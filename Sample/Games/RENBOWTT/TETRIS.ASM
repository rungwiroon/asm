;||||||***************************************************************||||||;
;||||*****                        TETRIS                           *****||||;
;||*****          Programed by  Chawalit Siwaborwornwattana          *****||;
;||||*****               Room: 1P   Code: 39013233                 *****||||;
;||||||***************************************************************||||||;

.model SMALL
.stack 300h

.data
  MainColor     db ?
  BoxColor      db ?
  x             db ?
  y             db ?
  yT            db ?
  x1            dw ?
  x2            dw ?
  y1            dw ?
  y2            dw ?
  Count         dw ?
  Check         dw ?
  Time          dw ?
  Lines         dw ?
  Level         dw ?
  Count_15      dw ?
  ForDelay      dw ?
  BrickScore    dw ?
  Key           db ?
  ControlS      db 0
  GameOver      db 1
  pBrick        db ?
  nBrick        db ?
  StateBrick    db ?
  TempState     db ?
  TableA        db 200 dup(0)
  TableB        db 200 dup(0)
  TableC        db 200 dup(0)
  NameHS        db "$$$$$$$$$$$$$"
  ScoreHS       dw ?
  PlayerName    db "Anonymous$$$$"
  Score         dw ?
  FileName      db "_hs.dat",0          ; String type ASCIIZ
  Word_Tetris   db "  TETRIS  $"
  Word_Score    db "Score :$"
  Word_Lines    db "Lines :$"
  Word_Level    db "Level :$"
  Word_Player   db "Player :$"
  Word_HS       db "High Scores:$"
  Word_New      db "New       F2$"
  Word_Pause    db "Pause     F3$"
  Word_Exit     db "Exit   Alt-X$"
  Word_GameOver db "GAME  OVER$"
  Word_Pause2   db "  PAUSE   $"

.code
  Main proc far
        push    ds              ; Begining
        push    @data           ;
        pop     ds              ; DS <- offset Data Segment
        push    es              ;

        call    GetPlayerName   ; Get player's name from command line

        mov     ax,0a000h       ;
        mov     es,ax           ; ES <- adress of Video Ram

        mov     ax,13h          ; 
        int     10h             ; set VIDEO mode (to mode 13h)

        call    GetHighScores   ; Get high scores from file
        call    Screen          ; Draw screen
        call    Controler       ; Control operating of game
        call    PutHighScores   ; Put high scores to file

        mov     ax,3h           ; 
        int     10h             ; set VIDEO mode (to mode 3h)

        pop     es              ; Ending
        pop     ds              ;
        mov     ax,4c00h        ;
        int     21h             ;
  Main endp
  


  Controler proc near           ;********************************************;
        push    ax              ;| This procedure is for control operting   |;
        push    bx              ;| of program by Control Signals (ControlS) |;
        push    cx              ;| that is generated by GenerateS procedure |;
        push    dx              ;********************************************;
    Again1_Controler:
        mov     ah,0bh          ;
        int     21h             ; Check pressing keyboard
        cmp     al,0ffh         ;
        jne     L1_controler    ; Jump if not press key
        call    PressKey        ; Key (variable) <- Keyboard input
        call    GenerateS       ; Generate Signal to control operating of game
        mov     ax,0c00h        ;
        int     21h             ; Clear Keyboard buffer
    L1_Controler:
        cmp     ControlS,1d
        jne     L2_controler    ;------------------------;
        mov     ControlS,0      ; Signal=1 is Turn brick ;
        call    TurnBrick       ;------------------------;
    L2_Controler:
        cmp     ControlS,2
        jne     L3_controler    ;-----------------------;
        mov     ControlS,0      ; Signal=2 is Move left ;
        call    MoveLeft        ;-----------------------;
    L3_Controler:
        cmp     ControlS,3
        jne     L4_controler    ;-----------------------;
        mov     ControlS,0      ; Signal=3 is Move down ;
        call    MoveDown        ;-----------------------;
    L4_Controler:
        cmp     ControlS,4
        jne     L5_controler    ;-----------------------;
        mov     ControlS,0      ; Signal=4 is Move right;
        call    MoveRight       ;-----------------------;
    L5_Controler:
        cmp     ControlS,5
        jne     L6_controler    ;-----------------------;
        mov     ControlS,0      ; Signal=5 is New       ;
        call    New             ;-----------------------;
    L6_Controler:
        cmp     ControlS,6
        jne     L7_controler    
        cmp     GameOver,1
        je      L7_controler            ; Jump if game is over
        mov     si,offset Word_Pause2   ;-----------------------;
        mov     X,15d                   ; Signal=6 is Pause     ;
        mov     Y,0d                    ;                       ;
        call    WriteStringXY           ;                       ;
        mov     ControlS,0d             ; Wait for pressing key ;
    Again2_Controler:                   ; F3 again to continue  ;
        call    PressKey                ;                       ;
        cmp     Key,61                  ;                       ;
        jne     Again2_controler        ;-----------------------;
        mov     si,offset Word_Tetris
        mov     MainColor,78d
        call    WriteStringXY
    L7_Controler:
        call    Delay           ; Delay around 1/18.2 second
        inc     Count
        mov     ax,ForDelay
        cmp     Count,ax        ; Check for auto calling MoveDown procedure.
        jl      L8_controler    ; MoveDown procedure will be called if
        mov     Count,0         ; Count(variable) is equal to ForDelay(variable)
        call    MoveDown        ; then Count (variable) will be cleared
        dec     BrickScore      ; and BrickScore <- ( BrickScore-1 )
    L8_Controler:
        cmp     Key,45          ; 45 is Alt-X Key (check for exit program)
        je      Exit_controler
        jmp     Again1_controler        ; Jump if not press Alt-X
    Exit_Controler:
        call    UpDateHighScores        ; Update high scores to variable
        pop     dx
        pop     cx
        pop     bx
        pop     ax
        ret
  Controler endp

  PutHighScores proc near       ; This function is for keep high scores
        mov     ah,03ch         ; from variable to file as name _hs.dat
        mov     dx,offset FileName
        mov     cx,02h
        int     21h             ; Creat file
        mov     dx,offset NameHS
        mov     cx,15d
        mov     bx,ax
        mov     ah,40h
        int     21h             ; Write file
        mov     ah,03eh
        int     21h             ; Close file
        ret
  PutHighScores endp

  GetHighScores proc near       ; This function is for read high scores 
        mov     ah,03dh         ; from file _hs.dat to variable
        mov     al,0h
        mov     dx,offset FileName
        int     21h             ; Open file
        jnc     L1_getHighScores
        mov     [NameHS],'$'
        mov     [ScoreHS],0h
        jmp     End_getHighScores
    L1_GetHighScores:
        mov     dx,offset NameHS
        mov     cx,15           ; read 15 bytes from file to variable
        mov     bx,ax           ; BX <- file handle
        mov     ah,03fh
        int     21h
        mov     ah,03eh         ;
        int     21h             ; Close file
    End_GetHighScores:
        ret
  GetHighScores endp

  GetPlayerName proc near               ; This function is for read argument
        mov     di,offset PlayerName    ; (player's name) from byte No.80h
        mov     si,80h                  ; of PSP
        mov     ch,0
        mov     cl,es:[si]      ; cl <- Lenght of argument from command line
        mov     si,82h          ; si point to first charecter of argument
        cmp     cx,0            ; if cx=0 that is without command line
        jg      L1_getPlayerName
        add     di,9d           ; Without argment
        jmp     End_getPlayerName
    L1_GetPlayerName:           ; Have argument
        cmp     cx,13d          ; Read string from PSP less than 13 charecter
        jl      Again_GetPlayerName
        mov     cx,12d
    Again_GetPlayerName:
        mov     dh,es:[si]
        cmp     dh,13d
        je      End_getPlayerName
        mov     [di],dh
        inc     di
        inc     si
        dec     cx
        jnz     Again_getPlayerName
    End_GetPlayerName:
        mov     dh,'$'          ; Put '$' to end of string
        mov     [di],dh         ;
        ret
  GetPlayerName endp

  Delay proc near               ; This function is for delay
    Loop_delay:                 ; around 1/18.2 second
        mov     ah,0h
        int     1ah
        cmp     dx,Time
        je      Loop_delay
        mov     Time,dx
        ret
  Delay endp

  GenerateS proc near           ; Generate signal by consider from ascii code
        cmp     Key,72          ; 72 is Up key (check for turning brick)
        jne     L1_generateS
        mov     ControlS,1      ; Generate signal 1
    L1_GenerateS:
        cmp     Key,75          ; 75 is Left key
        jne     L2_generateS
        mov     ControlS,2      ; Generate signal 2
    L2_GenerateS:
        cmp     Key,80          ; 80 is Down key
        jne     L3_generateS
        mov     ControlS,3      ; Generate signal 3
    L3_GenerateS:
        cmp     Key,77          ; 77 is Right key
        jne     L4_generateS
        mov     ControlS,4      ; Generate signal 4
    L4_GenerateS:
        cmp     Key,60          ; 60 is F2
        jne     L5_generateS
        mov     ControlS,5      ; Generate signal 5
    L5_GenerateS:
        cmp     Key,61          ; 61 is F3
        jne     L6_generateS
        mov     ControlS,6      ; Generate signal 6
    L6_GenerateS:
        ret
  GenerateS endp

  New proc near                         ; This function is for initialize
        mov     si,offset Word_Tetris   ; values before starting game
        mov     MainColor,78d           ; and also magnegment about screen
        mov     x,15d                   ; and score
        mov     y,0d
        call    WriteStringXY
        mov     MainColor,0d
        mov     x1,35d
        mov     x2,85d
        mov     y1,38d
        mov     y2,48d
        call    Bar
        mov     y1,78d
        mov     y2,88d
        call    Bar
        mov     y1,118d
        mov     y2,128d
        call    Bar
        mov     x1,114d
        mov     x2,203d
        mov     y1,14d
        mov     y2,193d
        call    Bar
        mov     GameOver,0d
        call    ClearTable
        call    Set_nBrick
        mov     Score,0h
        mov     Lines,0h
        mov     Level,1h
        mov     Count_15,0h
        mov     ForDelay,20d
        mov     MainColor,10d
        mov     ax,0h
        mov     x,5d
        mov     y,5d
        call    ShowNumXY
        mov     y,10d
        call    ShowNumXY
        mov     ax,01h
        mov     y,15d
        call    ShowNumXY
        call    Delay
        call    StartBrick
        ret
  New endp

  ClearTable proc near                  ; This function is for clear TableA
        mov     si,0d                   ; (variable)
    Again_ClearTable:
        mov     [TableA+si],0d
        inc     si
        cmp     si,400d
        jle     Again_clearTable
        ret
  ClearTable endp

  MoveA2B proc near             ; This function is for move brick from TableA
        push    di              ; to TableB
        push    bx
        push    ax
        mov     di,0d
    Again_MoveA2B:
        cmp     [TableA+di],0d
        je      L1_MoveA2B
        mov     bl,[TableA+di]
        mov     [TableB+di],bl
        mov     [TableA+di],0d
    L1_MoveA2B:
        inc     di
        cmp     di,200d
        jl      Again_MoveA2B
        mov     bx,BrickScore
        add     Score,bx
        mov     ax,Score
        mov     MainColor,10d
        mov     x,5d
        mov     y,5d
        call    ShowNumXY
        pop     ax
        pop     bx
        pop     di
        ret
  MoveA2B endp

  DelLineTable proc near        ; After any brick is can't continue to fall,
        push    di              ; this function will be check every lines
        push    ax              ; in table if found any lines is full
        mov     di,0d           ; that line will be deleted
        mov     y,0d
    Again1_DelLineTable:
        mov     Check,1d
        mov     x,0d
    Again2_DelLineTable:
        cmp     [TableB+di],0d
        jne     L1_delLineTable
        mov     Check,0d
    L1_DelLineTable:
        inc     di
        inc     x
        cmp     x,10d
        jl      Again2_delLineTable
        cmp     Check,1d
        jne     L2_delLineTable
        call    DelLine
        call    ShowTableB
    L2_DelLineTable:
        inc     y
        cmp     di,200d
        jl      Again1_delLineTable
        pop     ax
        pop     di
        ret
  DelLineTable endp

  DelLine proc near             ; Input is Y (row to delete)
        push    ax
        push    bx              ; This function is for delete line No.Y
        push    dx
        push    di
        mov     MainColor,59d
        mov     ax,9d
        mov     bh,0d
        mov     bl,y
        mul     bx
        add     ax,14d
        mov     y1,ax
        add     ax,8d
        mov     y2,ax
        mov     x1,114d
        mov     x2,203d
        call    Woop
        call    ClearOldTableB
        sub     di,11d
    Again1_DelLine:
        mov     dh,[TableB+di]
        mov     [TableB+di+10],dh
        dec     di
        cmp     di,0d
        jge     Again1_delLine
    Again2_DelLine:
        mov     [TableB+di],0d
        inc     di
        cmp     di,10d
        jl      Again2_DelLine
        pop     di
        pop     dx
        pop     bx
        pop     ax
        ret
  DelLine endp

  Woop proc near                ; This function is for generate colors
        push    ax              ; and sound
        push    bx
        push    cx
        push    dx
        mov     bh,y
        mov     yT,bh
        mov     bx,x1
        mov     cx,x2
        mov     dx,0d
    Again1_Woop:
        mov     MainColor,dl
        mov     ax,y1
    Again2_Woop:
        call    Line_H
        call    Sound
        inc     ax
        inc     ax
        cmp     ax,y2
        jle     Again2_woop
        inc     dx
        cmp     dx,0ffh
        jl      Again1_woop
        add     Score,100d
        mov     ax,Score
        mov     MainColor,10d
        mov     x,5d
        mov     y,5d
        call    ShowNumXY
        inc     Lines
        inc     Count_15
        mov     ax,Lines
        mov     MainColor,10d
        mov     x,5d
        mov     y,10d
        call    ShowNumXY
        cmp     Count_15,15d
        jl      L1_woop
        mov     Count_15,0d
        inc     Level
        cmp     Level,5d
        jg      L2_woop
        mov     ax,4d
        sub     ForDelay,ax
        jmp     L4_woop
    L2_Woop:
        cmp     Level,6d
        jg      L3_woop
        mov     ForDelay,2d
        jmp     L4_woop
    L3_Woop:
        mov     ForDelay,1d
    L4_Woop:
        mov     ax,Level
        mov     x,5d
        mov     y,15d
        call    ShowNumXY
    L1_Woop:
        mov     bh,yT
        mov     y,bh
        pop     dx
        pop     cx
        pop     bx
        pop     ax
        ret
  Woop endp

  ShowNumXY proc near           ; Input is AX (number for show)
        push    ax              ; (X,Y) is position to show number
        push    cx
        push    dx              ; This funtion is for show number in AX
        push    si              ; to screen at position (X,Y)
        call    GotoXY
        mov     si,10d
        mov     cx,0h
    Positive_ShowNumXY:
        mov     dx,0h
        div     si
        push    dx
        inc     cx
        or      ax,ax
        jne     Positive_showNumXY
    WriteLoop_ShowNumXY:
        pop     dx
        add     dl,'0'
        call    PrintChar
        loop    WriteLoop_showNumXY
        pop     si
        pop     dx
        pop     cx
        pop     ax
        ret
  ShowNumXY endp

  GotoXY proc near              ; Input is position (X,Y)
        push    dx
        push    bx              ; This function is for set cursor position
        push    ax
        mov     dh,y            ;
        mov     dl,x            ;
        mov     bh,0            ;
        mov     ah,02h          ;
        int     10h             ; Set position of cursor
        pop     ax
        pop     bx
        pop     dx
        ret
  GotoXY endp

  PrintChar proc near           ; Input is dl (Ascii for print)
        push    ax
        push    bx
        push    cx
        mov     al,dl           ; Ascii of character
        mov     bh,0h           ;
        mov     bl,MainColor    ; bl <- MainColor (vairable)
        mov     cx,1            ; Num to print
        mov     ah,09h
        int     10h             ; Write attribute and character at cursor
        mov     ah,03h
        int     10h             ; Get cursor position
        inc     dl              ; Increase column of cursor
        mov     ah,02d
        int     10h             ; Set cursor position
        pop     cx
        pop     bx
        pop     ax
        ret
  PrintChar endp

  TurnBrick proc near           ; The operating of this function is
        push    ax              ; check type of present brick (nBrick)
        call    TableA_2_C      ; to call TurnB(n) function,let (n) = 1,2,..,6
        mov     ah,StateBrick
        mov     TempState,ah    ; After already call TurnB(n), this function
        call    ClearOldBox     ; will check error of table
        cmp     pBrick,0d       ; if table is error it will restore old
        je      End_turnBrick   ; table that kept in TableC to TableA
        cmp     pBrick,1d       ; ( before call TurnB(n), TableC is uses to 
        jne     L1_turnBrick    ; keep old table )
        call    TurnB1
        jmp     End_turnBrick
    L1_TurnBrick:
        cmp     pBrick,2d
        jne     L2_turnBrick
        call    TurnB2
        jmp     End_turnBrick
    L2_TurnBrick:
        cmp     pBrick,3d
        jne     L3_turnBrick
        call    TurnB3
        jmp     End_turnBrick
    L3_TurnBrick:
        cmp     pBrick,4d
        jne     L4_turnBrick
        call    TurnB4
        jmp     End_turnBrick
    L4_TurnBrick:
        cmp     pBrick,5d
        jne     L5_turnBrick
        call    TurnB5
        jmp     End_turnBrick
    L5_TurnBrick:
        call    TurnB6
    End_TurnBrick:
        call    CheckErrorTable
        cmp     Check,0d
        je      L6_turnBrick
        call    TableC_2_A      ; Restore old table from TableC to TableA
        mov     ah,TempState
        mov     StateBrick,ah
    L6_TurnBrick:
        call    ShowTableA
        pop     ax
        ret
  TurnBrick endp

  ; The operating of function TurnB1 to TurnB6 is check present state of brick
  ; and change it to next state

  TurnB1 proc near
        push    di
        cmp     StateBrick,0
        jne     NowState1_turnB1
        call    checkTop
        cmp     Check,0
        je      L1_turnB1
        call    BrickMoveDown
    L1_TurnB1:                          ; turning
        mov     di,9
    Again1_turnB1:
        inc     di
        cmp     [TableA+di],0
        je      Again1_turnB1
        mov     [TableA+di-9],40
        mov     [TableA+di+10],40
        mov     [TableA+di+11],0
        mov     [TableA+di+12],0
        mov     StateBrick,1
        jmp     L3_turnB1
    NowState1_TurnB1:
        call    CheckRight
        cmp     Check,0
        je      L2_turnB1
        call    BrickMoveLeft
    L2_TurnB1:
        mov     di,0
    Again2_turnB1:
        cmp     [TableA+di],0
        jne     L4_turnB1
        inc     di
        jmp     Again2_turnB1
    L4_TurnB1:
        mov     [TableA+di],0
        mov     [TableA+di+19],0
        mov     [TableA+di+20],40
        mov     [TableA+di+21],40
        mov     StateBrick,0
    L3_TurnB1:
        pop     di
        ret
  TurnB1 endp

  TurnB2 proc near
        push    di
        cmp     StateBrick,0
        jne     NowState1_turnB2
        call    CheckTop
        cmp     Check,0
        je      L1_turnB2
        call    BrickMoveDown
    L1_turnB2:
        mov     di,9h
    Again1_TurnB2:
        inc     di
        cmp     [TableA+di],0h
        je      Again1_turnB2
        mov     [TableA+di-10],35
        mov     [TableA+di+9],0
        mov     [TableA+di+10],0
        mov     [TableA+di+11],35
        mov     StateBrick,1
        jmp     L2_turnB2
    NowState1_turnB2:
        call    CheckLeft
        cmp     Check,0
        je      L3_turnB2
        call    BrickMoveRight
    L3_TurnB2:
        mov     di,0
    Again2_TurnB2:
        cmp     [TableA+di],0
        jne     L4_turnB2
        inc     di
        jmp     Again2_turnB2
    L4_TurnB2:
        mov     [TableA+di],0h
        mov     [TableA+di+19],35
        mov     [TableA+di+20],35
        mov     [TableA+di+21],0
        mov     StateBrick,0
    L2_TurnB2:
        pop     di
        ret
  TurnB2 endp

  TurnB3 proc near
        push    di
        cmp     StateBrick,0
        jne     NowState1_turnB3
        call    CheckTop
        cmp     Check,0
        je      L1_turnB3
        call    BrickMoveDown
        call    BrickMoveDown
        jmp     L2_turnB3
    L1_TurnB3:
        mov     di,9
    Again1_TurnB3:
        inc     di
        cmp     [TableA+di],0
        je      L3_turnB3
        call    BrickMoveDown
        jmp     L2_turnB3
    L3_TurnB3:
        inc     di
        cmp     di,20
        jl      Again1_turnB3
    L2_TurnB3:
        call    CheckFloor
        cmp     Check,1
        jne     L9_turnB3
        call    BrickMoveUp
    L9_turnB3:
        mov     di,19
    Again2_TurnB3:
        inc     di
        cmp     [TableA+di],0
        je      Again2_turnB3
        mov     [TableA+di-19],37
        mov     [TableA+di-9],37
        mov     [TableA+di],0
        mov     [TableA+di+2],0
        mov     [TableA+di+3],0
        mov     [TableA+di+11],37
        mov     StateBrick,1
        jmp     L4_turnB3
    NowState1_TurnB3:
        call    CheckLeft
        cmp     Check,0
        je      L5_turnB3
        call    BrickMoveRight
        jmp     L6_turnB3
    L5_TurnB3:
        call    CheckRight
        cmp     Check,0
        je      L7_turnB3
        call    BrickMoveLeft
        call    BrickMoveLeft
        jmp     L6_turnB3
    L7_TurnB3:
        mov     di,8
        mov     Check,0
    Again3_TurnB3:
        cmp     [TableA+di],0
        je      L8_turnB3
        mov     Check,1
    L8_TurnB3:
        add     di,10
        cmp     di,200
        jl      Again3_turnB3
        cmp     Check,0
        je      L6_turnB3
        call    BrickMoveLeft
    L6_TurnB3:
        mov     di,0
    Again4_TurnB3:
        inc     di
        cmp     [TableA+di],0
        je      Again4_turnB3
        mov     [TableA+di],0
        mov     [TableA+di+10],0
        mov     [TableA+di+19],37
        mov     [TableA+di+21],37
        mov     [TableA+di+22],37
        mov     [TableA+di+30],0
        mov     StateBrick,0
    L4_TurnB3:
        pop     di
        ret
  TurnB3 endp

  TurnB4 proc near
        push    di
        cmp     StateBrick,1
        je      NowState1_3_turnB4
        cmp     StateBrick,3
        je      NowState1_3_turnB4
        call    CheckTop
        cmp     Check,0
        je      L1_turnB4
        call    BrickMoveDown
    L1_TurnB4:
        mov     di,9
    Again1_turnB4:
        inc     di
        cmp     [TableA+di],0
        je      Again1_turnB4
        cmp     StateBrick,0
        jne     NowState2_turnB4
        mov     [TableA+di-9],43
        mov     [TableA+di],0
        mov     [TableA+di+2],0
        mov     [TableA+di+10],0
        mov     [TableA+di+11],43
        mov     [TableA+di+12],43
        mov     StateBrick,1
        jmp     L3_turnB4
    NowState2_TurnB4:
        mov     [TableA+di-11],43
        mov     [TableA+di-10],43
        mov     [TableA+di+8],0
        mov     [TableA+di+9],0
        mov     StateBrick,3
        jmp     L3_turnB4
    NowState1_3_TurnB4:
        call    CheckLeft
        cmp     Check,0
        je      L2_turnB4
        call    BrickMoveRight
    L2_TurnB4:
        mov     di,0h
    Again2_turnB4:
        cmp     [TableA+di],0h
        jne     L4_turnB4
        inc     di
        jmp     Again2_turnB4
    L4_TurnB4:
        cmp     StateBrick,1
        jne     NowState3_turnB4
        mov     [TableA+di],0
        mov     [TableA+di+10],0
        mov     [TableA+di+11],43
        mov     [TableA+di+19],43
        mov     StateBrick,2
        jmp     L3_turnB4
    NowState3_TurnB4:
        mov     [TableA+di],0
        mov     [TableA+di+1],0
        mov     [TableA+di+9],43
        mov     [TableA+di+10],43
        mov     [TableA+di+19],43
        mov     [TableA+di+21],0
        mov     StateBrick,0
    L3_TurnB4:
        pop     di
        ret
  TurnB4 endp

  TurnB5 proc near
        push    di
        cmp     StateBrick,1
        je      NowState1_3_turnB5
        cmp     StateBrick,3
        je      NowState1_3_turnB5
        call    CheckTop
        cmp     Check,0
        je      L1_turnB5
        call    BrickMoveDown
    L1_TurnB5:
        mov     di,9
    Again1_turnB5:
        inc     di
        cmp     [TableA+di],0
        je      Again1_turnB5
        cmp     StateBrick,0
        jne     NowState2_turnB5
        mov     [TableA+di-9],53
        mov     [TableA+di-8],53
        mov     [TableA+di],0
        mov     [TableA+di+2],0
        mov     [TableA+di+11],53
        mov     [TableA+di+12],0
        mov     StateBrick,1
        jmp     L3_turnB5
    NowState2_TurnB5:
        mov     [TableA+di-8],53
        mov     [TableA+di],0
        mov     [TableA+di+2],53
        mov     [TableA+di+10],0
        mov     StateBrick,3
        jmp     L3_turnB5
    NowState1_3_TurnB5:
        call    CheckLeft
        cmp     Check,0
        je      L2_turnB5
        call    BrickMoveRight
    L2_TurnB5:
        mov     di,0h
    Again2_turnB5:
        cmp     [TableA+di],0h
        jne     L4_turnB5
        inc     di
        jmp     Again2_turnB5
    L4_TurnB5:
        cmp     StateBrick,1
        jne     NowState3_turnB5
        mov     [TableA+di],0
        mov     [TableA+di+1],0
        mov     [TableA+di+9],53
        mov     [TableA+di+10],0
        mov     [TableA+di+19],53
        mov     [TableA+di+21],53
        mov     StateBrick,2
        jmp     L3_turnB5
    NowState3_TurnB5:
        mov     [TableA+di],0
        mov     [TableA+di+8],53
        mov     [TableA+di+9],53
        mov     [TableA+di+19],0
        mov     StateBrick,0
    L3_TurnB5:
        pop     di
        ret
  TurnB5 endp

  TurnB6 proc near
        push    di
        cmp     StateBrick,1
        je      NowState1_turnB6
        cmp     StateBrick,2
        je      NowState2_turnB6
        cmp     StateBrick,3
        je      NowState3_turnB6
        call    CheckTop
        cmp     Check,0
        je      L1_turnB6
        call    BrickMoveDown
    L1_TurnB6:
        mov     di,9
    Again1_TurnB6:
        inc     di
        cmp     [TableA+di],0
        je      Again1_turnB6
        mov     [TableA+di-10],32
        mov     [TableA+di-1],32
        mov     [TableA+di+9],0
        mov     [TableA+di+11],0
        mov     StateBrick,1
        jmp     L2_turnB6
    NowState1_TurnB6:
        call    CheckRight
        cmp     Check,0
        je      L3_turnB6
        call    BrickMoveLeft
    L3_TurnB6:
        mov     di,0
    Again2_TurnB6:
        inc     di
        cmp     [TableA+di],0
        je      Again2_turnB6
        mov     [TableA+di],0
        mov     [TableA+di+11],32
        mov     StateBrick,2
        jmp     L2_turnB6
    NowState2_TurnB6:
        mov     di,9
    Again3_TurnB6:
        inc     di
        cmp     [TableA+di],0
        je      Again3_turnB6
        mov     [TableA+di-9],32
        mov     [TableA+di],0
        mov     StateBrick,3
        jmp     L2_turnB6
    NowState3_TurnB6:
        call    CheckLeft
        cmp     Check,0
        je      L4_turnB6
        call    BrickMoveRight
    L4_TurnB6:
        mov     di,0
    Again4_TurnB6:
        inc     di
        cmp     [TableA+di],0
        je      Again4_turnB6
        mov     [TableA+di],0
        mov     [TableA+di+11],0
        mov     [TableA+di+19],32
        mov     [TableA+di+21],32
        mov     StateBrick,0
    L2_TurnB6:
        pop     di
        ret
  TurnB6 endp

  TableA_2_C proc near          ; This function is for copy data from TableA
        push    ax              ; to TableC
        push    di
        mov     di,0d
    Again_TableA_2_C:
        mov     ah,[TableA+di]
        mov     [TableC+di],ah
        inc     di
        cmp     di,200d
        jl      Again_tableA_2_C
        pop     di
        pop     ax
        ret
  TableA_2_C endp

  TableC_2_A proc near          ; This function is for copy data from TableC
        push    ax              ; to TableA
        push    di
        mov     di,0d
    Again_TableC_2_A:
        mov     ah,[TableC+di]
        mov     [TableA+di],ah
        inc     di
        cmp     di,200d
        jl      Again_tableC_2_A
        pop     di
        pop     ax
        ret
  TableC_2_A endp

  StartBrick proc near                  ; This function is for put brick
        push    ax                      ; to the top of tableA
        cmp     GameOver,1d             ; type of brick to put is consider
        jne     L_startBrick            ; from nBrick.
        jmp     End_startBrick          ; After already put brick, nBrick
    L_StartBrick:                       ; will be set to next brick again
        mov     BrickScore,25d
        mov     StateBrick,0d
        cmp     nBrick,0d
        jne     L1_startBrick
        mov     [TableA+4],43           ; (5,0)
        mov     [TableA+5],43           ; (6,0)
        mov     [TableA+14],43          ; (15,1)
        mov     [TableA+15],43          ; (16,1)
        jmp     End_startBrick
    L1_StartBrick:
        cmp     nBrick,1d
        jne     L2_startBrick
        mov     [TableA+4],40           ; (5,0)
        mov     [TableA+5],40           ; (6,0)
        mov     [TableA+15],40          ; (6,1)
        mov     [TableA+16],40          ; (7,1)
        jmp     End_startBrick
    L2_StartBrick:
        cmp     nBrick,2d
        jne     L3_startBrick
        mov     [TableA+5],35           ; (6,0)
        mov     [TableA+6],35           ; (7,0)
        mov     [TableA+14],35          ; (5,1)
        mov     [TableA+15],35          ; (6,1)
        jmp     End_startBrick
    L3_StartBrick:
        cmp     nBrick,3d
        jne     L4_startBrick
        mov     [TableA+3],37           ; (4,0)
        mov     [TableA+4],37           ; (5,0)
        mov     [TableA+5],37           ; (6,0)
        mov     [TableA+6],37           ; (7,0)
        jmp     End_startBrick
    L4_StartBrick:
        cmp     nBrick,4d
        jne     L5_startBrick
        mov     [TableA+4],43           ; (5,0)
        mov     [TableA+5],43           ; (6,0)
        mov     [TableA+6],43           ; (7,0)
        mov     [TableA+14],43          ; (5,1)
        jmp     End_startBrick
    L5_StartBrick:
        cmp     nBrick,5d
        jne     L6_startBrick
        mov     [TableA+3],53           ; (4,0)
        mov     [TableA+4],53           ; (5,0)
        mov     [TableA+5],53           ; (6,0)
        mov     [TableA+15],53          ; (6,1)
        jmp     End_startBrick
    L6_StartBrick:
        mov     [TableA+13],32          ; (4,1)
        mov     [TableA+14],32          ; (5,1)
        mov     [TableA+15],32          ; (6,1)
        mov     [TableA+4],32           ; (5,0)
    End_StartBrick:
        call    ShowTableA
        mov     ah,nBrick
        mov     pBrick,ah
        call    Delay
        call    Delay
        call    Set_nBrick
        call    Show_nBrick
        pop     ax
        ret
  StartBrick endp

  Show_nBrick proc near         ; This function is for show next brick
        mov     x1,238
        mov     x2,288
        mov     y1,30
        mov     y2,55
        mov     MainColor,0
        call    Bar
        cmp     nBrick,0
        jg      L1_Show_nBrick
        mov     BoxColor,43
        mov     x,16
        mov     y,2
        call    ShowBox
        inc     y
        call    ShowBox
        inc     x
        call    ShowBox
        dec     y
        call    ShowBox
        jmp     End_Show_nBrick
    L1_Show_nBrick:
        cmp     nBrick,1
        jg      L2_Show_nBrick
        mov     BoxColor,40
        mov     x,15
        mov     y,2
        call    ShowBox
        inc     x
        call    ShowBox
        inc     y
        call    ShowBox
        inc     x
        call    ShowBox
        jmp     End_Show_nBrick
    L2_Show_nBrick:
        cmp     nBrick,2
        jg      L3_Show_nBrick
        mov     BoxColor,35
        mov     x,15
        mov     y,3
        call    ShowBox
        inc     x
        call    ShowBox
        dec     y
        call    ShowBox
        inc     x
        call    ShowBox
        jmp     End_Show_nBrick
    L3_Show_nBrick:
        cmp     nBrick,3
        jg      L4_Show_nBrick
        mov     BoxColor,37
        mov     x,15
        mov     y,3
        call    ShowBox
        inc     x
        call    ShowBox
        inc     x
        call    ShowBox
        inc     x
        call    ShowBox
        jmp     End_Show_nBrick
    L4_Show_nBrick:
        cmp     nBrick,4
        jg      L5_Show_nBrick
        mov     BoxColor,43
        mov     x,15
        mov     y,3
        call    ShowBox
        dec     y
        call    ShowBox
        inc     x
        call    ShowBox
        inc     x
        call    ShowBox
        jmp     End_Show_nBrick
    L5_Show_nBrick:
        cmp     nBrick,5
        jg      L6_Show_nBrick
        mov     BoxColor,53
        mov     x,15
        mov     y,2
        call    ShowBox
        inc     x
        call    ShowBox
        inc     x
        call    ShowBox
        inc     y
        call    ShowBox
        jmp     End_Show_nBrick
    L6_Show_nBrick:
        mov     BoxColor,32
        mov     x,15
        mov     y,3
        call    ShowBox
        inc     x
        call    ShowBox
        inc     x
        call    ShowBox
        dec     x
        dec     y
        call    ShowBox
    End_Show_nBrick:
        ret
  Show_nBrick endp

  Set_nBrick proc near          ; This function is for set next brick by
        push    ax              ; random (use time for random)
        push    cx              ; each brick have different percent for
        push    dx              ; set to next brick
        mov     ah,02ch
        int     21h             ; Get time uses for random brick
        cmp     dl,10
        jge     L1_set_nBrick
        mov     nBrick,0        ; Brick 0 have 10%
        jmp     End_set_nBrick
    L1_Set_nBrick:
        cmp     dl,30d
        jge     L2_set_nBrick
        mov     nBrick,1        ; Brick 1 have 20%
        jmp     End_set_nBrick
    L2_Set_nBrick:
        cmp     dl,50d
        jge     L3_set_nBrick
        mov     nBrick,2        ; Brick 2 have 20%
        jmp     End_set_nBrick
    L3_Set_nBrick:
        cmp     dl,60d
        jge     L4_set_nBrick
        mov     nBrick,3        ; Brick 3 have 10%
        jmp     End_set_nBrick
    L4_Set_nBrick:
        cmp     dl,75d
        jge     L5_set_nBrick
        mov     nBrick,4        ; Brick 4 have 15%
        jmp     End_set_nBrick
    L5_Set_nBrick:
        cmp     dl,85d
        jge     L6_set_nBrick
        mov     nBrick,5        ; Brick 5 have 10%
        jmp     End_set_nBrick
    L6_Set_nBrick:
        mov     nBrick,6        ; Brick 6 have 15%
    End_Set_nBrick:
        pop     dx
        pop     cx
        pop     ax
        ret
  Set_nBrick endp

  MoveRight proc near                   ; Operating of this function is
        call    ClearOldBox             ;   1. move brick to right side
        call    CheckRight              ;   2. check error of table
        cmp     Check,1d                ;   3. if table is error then
        je      L1_moveRight            ;      move brick to left side
        call    BrickMoveRight
        call    CheckErrorTable
        cmp     Check,1d
        jne     L1_moveRight
        call    BrickMoveLeft
    L1_MoveRight:
        call    ShowTableA
        ret
  MoveRight endp

  BrickMoveRight proc near              ; This function is for move brick
        push    ax                      ; to right side
        push    si
        mov     si,199d
    Again2_brickMoveRight:
        mov     x,9d
    Again1_brickMoveRight:
        mov     ah,[TableA+si-1]
        mov     [TableA+si],ah
        dec     si
        dec     x
        cmp     x,0d
        jg      Again1_brickMoveRight
        mov     [TableA+si],0d
        dec     si
        cmp     si,0d
        jg      Again2_brickMoveRight
        pop     si
        pop     ax
        ret
  BrickMoveRight endp        

  MoveLeft proc near                    ; Operating of this function is
        call    ClearOldBox             ;   1. move brick to left side
        call    CheckLeft               ;   2. check error of table
        cmp     Check,1d                ;   3. if table is error then
        je      L1_moveLeft             ;      move brick to right side
        call    BrickMoveLeft
        call    CheckErrorTable
        cmp     Check,1d
        jne     L1_moveLeft
        call    BrickMoveRight
    L1_MoveLeft:
        call    ShowTableA
        ret
  MoveLeft endp

  BrickMoveLeft proc near               ; This function is for move brick
        push    ax                      ; to left side
        push    si
        mov     si,0d
    Again2_brickMoveLeft:
        mov     x,0d
    Again1_brickMoveLeft:
        mov     ah,[TableA+si+1]
        mov     [TableA+si],ah
        inc     si
        inc     x
        cmp     x,9d
        jl      Again1_brickMoveLeft
        mov     [TableA+si],0d
        inc     si
        cmp     si,200d
        jl      Again2_brickMoveleft
        pop     si
        pop     ax
        ret
  BrickMoveLeft endp

  MoveDown proc near                    ; Operating of this function is
        call    ClearOldBox             ;   1. move brick down
        call    CheckFloor              ;   2. check error of table
        cmp     Check,1d                ;   3. if table is error then
        je      L1_moveDown             ;      move brick up
        call    BrickMoveDown
        call    CheckErrorTable
        cmp     Check,1d
        jne     L2_moveDown
        call    BrickMoveUp
    L1_MoveDown:
        call    MoveA2B
        call    DelLineTable
        call    CheckGameOver
        call    ShowTableB
        call    StartBrick
        mov     ax,0c00h                ; Clear Keyboard buffer
        int     21h
    L2_MoveDown:
        call    ShowTableA
        call    Sound
        call    Sound
        ret
  MoveDown endp

  BrickMoveUp proc near                 ; This function is for move brick up
        push    ax
        push    si
        mov     si,0d
    Again1_BrickMoveUp:
        mov     ah,[TableA+si+10d]
        mov     [TableA+si],ah
        inc     si
        cmp     si,190d
        jl      Again1_BrickMoveUp
    Again2_brickMoveUp:
        mov     [TableA+si],0d
        inc     si
        cmp     si,200d
        jl      Again2_BrickMoveUp
        pop     si
        pop     ax
        ret
  BrickMoveUp endp

  BrickMoveDown proc near               ; This function is for move brick down
        push    ax
        push    si
        mov     si,189d
    Again1_BrickMoveDown:
        mov     ah,[TableA+si]
        mov     [TableA+si+10d],ah
        dec     si
        cmp     si,0d
        jge     Again1_brickMoveDown
        mov     si,0d
    Again2_BrickMoveDown:
        mov     [TableA+si],0d
        inc     si
        cmp     si,10d
        jl      Again2_brickMoveDown
        pop     si
        pop     ax
        ret
  BrickMoveDown endp

  ClearOldBox proc near         ; This function is for delete old box on screen
        push    bx
        push    si
        mov     x,0d
        mov     y,0d
        mov     si,0d
    Again_ClearOldBox:
        mov     bl,[TableA+si]
        cmp     bl,0d
        je     Except1_ClearOldBox
        mov     BoxColor,0d
        call    ShowBox
    Except1_ClearOldBox:
        inc     si
        inc     x
        cmp     x,10d
        jne     Except2_ClearOldBox
        mov     x,0d
        inc     y
    Except2_ClearOldBox:
        cmp     si,200d
        jl      Again_ClearOldBox
        pop     si        
        pop     bx
        ret
  ClearOldBox endp

  ClearOldTableB proc near      ; This function is for delete tableB on screen
        push    bx
        push    si
        mov     bl,y
        mov     yT,bl
        mov     x,0d
        mov     y,0d
        mov     si,0d
    Again_ClearOldTableB:
        mov     bl,[TableB+si]
        cmp     bl,0d
        je      Except1_ClearOldTableB
        mov     BoxColor,0d
        call    ShowBox
    Except1_ClearOldTableB:
        inc     si
        inc     x
        cmp     x,10d
        jne     Except2_ClearOldTableB
        mov     x,0d
        inc     y
    Except2_ClearOldTableB:
        cmp     si,200d
        jl      Again_ClearOldTableB
        mov     bl,yT
        mov     y,bl
        pop     si        
        pop     bx
        ret
  ClearOldTableB endp

  ShowTableA proc near          ; This function is for show tableA to screen
        push    bx
        push    si
        mov     bl,y
        mov     yT,bl
        mov     x,0d
        mov     y,0d
        mov     si,0d
    Again_ShowTableA:
        mov     bl,[TableA+si]
        cmp     bl,0d
        je     Except1_ShowTableA
        mov     BoxColor,bl
        call    ShowBox
    Except1_ShowTableA:
        inc     si
        inc     x
        cmp     x,10d
        jne     Except2_ShowTableA
        mov     x,0d
        inc     y
    Except2_ShowTableA:
        cmp     si,200d
        jl      Again_ShowTableA
        mov     bl,yT
        mov     y,bl
        pop     si        
        pop     bx
        ret
  ShowTableA endp

  ShowTableB proc near          ; This function is for show TableB to screen
        push    bx
        push    si
        mov     bl,y
        mov     yT,bl
        mov     x,0d
        mov     y,0d
        mov     si,0d
    Again_ShowTableB:
        mov     bl,[TableB+si]
        cmp     bl,0d
        je     Except1_ShowTableB
        mov     BoxColor,bl
        call    ShowBox
    Except1_ShowTableB:
        inc     si
        inc     x
        cmp     x,10d
        jne     Except2_ShowTableB
        mov     x,0d
        inc     y
    Except2_ShowTableB:
        cmp     si,200d
        jl      Again_ShowTableB
        mov     bl,yT
        mov     y,bl
        pop     si        
        pop     bx
        ret
  ShowTableB endp

  ShowBox proc                  ; Input is position (X,Y)
        push    ax
        push    bx              ; This function is for show a box to table
        push    cx              ; on screen at position (X,Y)
        push    dx
        mov     dh,BoxColor
        mov     MainColor,dh
        mov     ax,9
        mov     bl,x
        cbw
        mul     bx
        add     ax,114
        mov     x1,ax
        add     ax,8
        mov     x2,ax
        mov     ax,9
        mov     bl,y
        cbw
        mul     bx
        add     ax,14
        mov     y1,ax
        add     ax,8
        mov     y2,ax
        call    rectangle
        cmp     MainColor,0d
        je      Except1_showBox
        add     MainColor,48d
    Except1_showBox:
        mov     ax,y1
        mov     bx,x1
        mov     cx,x2
        call    line_H
        mov     ax,x1
        mov     bx,y1
        mov     cx,y2
        call    line_V
        cmp     MainColor,0d
        je      Except2_showBox
        sub     MainColor,24d
    Except2_showBox:
        mov     ax,x1
        mov     bx,y2
        call    PutPixel
        mov     ax,x2
        mov     bx,y1
        call    PutPixel
        inc     x1
        inc     y1
        dec     x2
        dec     y2
        call    bar
        pop     dx
        pop     cx
        pop     bx
        pop     ax
        ret
  ShowBox endp

  Screen proc near              ; This function is for draw screen
        mov     cx,55d
        mov     x1,0d
        mov     x2,319d
        mov     y1,8d
        mov     y2,199d
    Again1_Screen:
        mov     MainColor,cl
        call    bar
        inc     cx
        add     x1,8d
        sub     x2,8d
        add     y1,5d
        sub     y2,5d
        mov     ax,y2
        cmp     y1,ax
        jl      Again1_Screen
        mov     MainColor,35d
        call    rectangle

        ;*****< Score,Level,Lines,Player >*****;
        mov     x1,20d
        mov     x2,95d
        mov     y1,20d
        mov     y2,133d
        call    BlackWin
        mov     x1,5d
        mov     x2,105d
        mov     y1,156d
        mov     y2,186d
        call    BlackWin
        mov     si,offset Word_Score
        mov     MainColor,11d
        mov     x,4d
        mov     y,3d
        call    WriteStringXY
        mov     si,offset Word_Lines
        mov     y,8d
        call    WriteStringXY
        mov     si,offset Word_Level
        mov     y,13d
        call    WriteStringXY
        mov     si,offset Word_Player
        mov     x,1d
        mov     y,20d
        call    WriteStringXY
        mov     si,offset PlayerName
        mov     MainColor,14d
        mov     y,22d
        call    WriteStringXY

        ;*****< For show next brick >*****;
        mov     x1,234d
        mov     x2,294d
        mov     y1,20d
        mov     y2,60d
        call    BlackWin

        ;*****< High Scores , Menu hot key >*****;
        mov     x1,210d
        mov     x2,315d
        mov     y1,68d
        mov     y2,114d
        call    BlackWin
        mov     y1,130d
        mov     y2,180d
        call    BlackWin
        mov     si,offset Word_HS
        mov     x,27d
        mov     y,9d
        mov     MainColor,11d
        call    WriteStringXY
        call    ShowHighScores
        mov     MainColor,35d
        mov     si,offset Word_New
        mov     y,17d
        call    WriteStringXY
        mov     si,offset Word_Pause
        mov     y,19d
        call    WriteStringXY
        mov     si,offset Word_Exit
        mov     y,21d
        call    WriteStringXY
        
        ;*****< Border of table >*****;
        mov     MainColor,15d
        mov     x1,111d
        mov     y1,11d
        mov     x2,206d
        mov     y2,196d
        call    rectangle
        mov     MainColor,7d
        mov     x1,112d
        mov     y1,12d
        mov     x2,205d
        mov     y2,195d
        call    rectangle
        mov     MainColor,8d
        mov     x1,113d
        mov     y1,13d
        mov     x2,204d
        mov     y2,194d
        call    rectangle
        ret
  Screen endp

  ShowHighScores proc near      ; This function is for show high scores
        push    ax
        push    si
        mov     MainColor,0d
        mov     x1,212d
        mov     x2,313d
        mov     y1,85d
        mov     y2,100d
        call    Bar
        mov     si,offset NameHS
        mov     x,27d
        mov     y,11d
        mov     MainColor,85d
        call    WriteStringXY
        mov     ax,ScoreHS
        mov     y,13d
        call    ShowNumXY
        pop     si
        pop     ax
        ret
  ShowHighScores endp

  BlackWin proc near                    ; Input is position (X1,Y1,X2,Y2)
        push    ax                      ; Output is black windows with border
        push    bx                      ; on screen at position (X1,Y1,X2,Y2)
        push    cx
        mov     MainColor,0d
        call    Bar
        mov     MainColor,15d
        call    Rectangle
        mov     MainColor,8d
        mov     ax,y2
        mov     bx,x1
        mov     cx,x2
        call    Line_H
        mov     ax,x2
        mov     bx,y1
        mov     cx,y2
        call    Line_V
        pop     cx
        pop     bx
        pop     ax
        ret
  BlackWin endp

  WriteStringXY proc near       ; Input is si (offset of string)
        push    si              ; (X,Y) is position to write string
        push    dx
        call    GotoXY          ; This function is for write string
    Again_WriteStringXY:        ; at position (X,Y)
        mov     dh,'$'
        cmp     [si],dh
        je      End_writeStringXY
        mov     dl,[si]
        call    PrintChar
        inc     si
        jmp     Again_writeStringXY
    End_WriteStringXY:
        pop     dx
        pop     si
        ret
  WriteStringXY endp

  Bar proc near                 ; Input:-
        push    ax              ;    x1,y1,x2,y2
        push    bx              ; Output:-
        push    cx              ;    screen <= Bar(x1,y1,x2,y2)
        mov     ax,y1
        mov     bx,x1
        mov     cx,x2
    again_bar:
        cmp     y2,ax
        jl      EndLoop_bar
        call    line_H
        inc     ax
        jmp     Again_bar
    EndLoop_bar:
        pop     cx
        pop     bx
        pop     ax
        ret
  Bar endp

  Rectangle proc near           ; Input:-
        push    ax              ;    x1,y1,x2,y2
        push    bx              ; Output:-
        push    cx              ;    screen <= rectangle(x1,y1,x2,y2)
        mov     ax,y1
        mov     bx,x1
        mov     cx,x2
        call    line_H
        mov     ax,y2
        call    line_H
        mov     ax,x1
        mov     bx,y1
        mov     cx,y2
        call    line_V
        mov     ax,x2
        call    line_V
        pop     cx
        pop     bx
        pop     ax
        ret
  Rectangle endp

  PutPixel proc near                    ; Input:-
        push    ax                      ;    AX => position of x
        push    dx                      ;    BX => position of y
        push    di                      ; Output:-
        push    cx                      ;    Screen <= putpixel(x,y)
        mov     dx,ax                   
        mov     ax,320
        push    dx
        mul     bx
        pop     dx
        add     ax,dx
        mov     di,ax
        mov     ch,MainColor
        mov byte ptr es:[di],ch
        pop     cx
        pop     di
        pop     dx
        pop     ax
        ret
  PutPixel endp

  Line_V proc near                      ; Input:-
        push    dx                      ;    AX => position of x
        push    cx                      ;    BX => position of y1
        push    bx
        mov     dx,cx                   ;    CX => position of y2
        mov     ch,MainColor            ; Output:-
    Again_line_V:                       ;    Screen <= line(x,y1,x,y2)
        cmp     dx,bx
        jl      EndLoop_line_V
        call    PutPixel
        inc     bx
        jmp     Again_line_V
    EndLoop_line_v:
        pop     bx
        pop     cx
        pop     dx
        ret
  Line_V endp

  Line_H proc near                      ; Input:-
        push    dx                      ;    AX => Position of y
        push    ax                      ;    BX => Position of x1
        push    bx                      ;    CX => Position of x2
        mov     dx,ax                   ; Output:-
        mov     ax,bx                   ;    Screen <= line(x1,y,x2,y)
        mov     bx,dx
    Again_line_H:
        cmp     cx,ax
        jl      EndLoop_line_H
        call    PutPixel
        inc     ax
        jmp     Again_line_H
    EndLoop_line_H:
        pop     bx
        pop     ax
        pop     dx
        ret
  Line_H endp

  PressKey proc near                    ; Operation:-
        push    ax                      ;    waiting util press anykey
        mov     ah,7h                   ;    (no input, no output)
        int     21h
        cmp     al,0h
        jne     L_pressKey
        mov     ah,7h
        int     21h
    L_PressKey:
        mov     Key,al
        pop     ax
        ret
  PressKey endp
  
  CheckGameOver proc near               ; This function is for check game over
        push    si
        mov     si,12d
    Again_CheckGameOver:
        inc     si
        cmp     [TableB+si],0d
        je      L_checkGameOver
        mov     GameOver,1d
        mov     si,offset Word_GameOver
        mov     MainColor,64d
        mov     X,15d
        mov     Y,0d
        call    WriteStringXY
        call    UpDateHighScores
        call    ShowHighScores
    L_CheckGameOver:
        cmp     si,16d
        jl      Again_checkGameOver
        pop     si
        ret
  CheckGameOver endp

  UpDateHighScores proc near            ; Operation:-
        push    ax                      ;    Update high scores to variable
        push    cx
        push    si
        mov     ax,ScoreHS
        cmp     Score,ax
        jle     L_upDateHighScores
        mov     cx,12d
        mov     si,0d
    Again_UpDateHighScores:
        mov     ah,[PlayerName+si]
        mov     [NameHS+si],ah
        inc     si
        dec     cx
        jnz     Again_upDateHighScores
        mov     ax,Score
        mov     ScoreHS,ax
    L_UpDateHighScores:
        pop     si
        pop     cx
        pop     ax
        ret
  UpDateHighScores endp

  Sound proc near               ; Operation:-
        push   ax               ;    Generate sound to pc-speaker
        push   cx
        mov    cx,35h
        in     al,61h
        and    al,0feh
        out    61h,al
    Again_Sound:
        or     al,2
        out    61h,al
        and    al,0fdh
        out    61h,al
        loop   Again_Sound
        pop    cx
        pop    ax
        ret
  Sound endp

  CheckTop proc near            ; Operation:-
        push    di              ;    if (first row in table is empty) then
        mov     Check,0         ;      Check <= 0
        mov     di,0            ;    else Check <=1
    Again_CheckTop:
        cmp     [TableA+di],0
        jne     L_checkTop
        inc     di
        cmp     di,10
        jl      Again_checkTop
        jmp     End_checkTop
    L_CheckTop:
        mov     Check,1
    End_checkTop:
        pop     di
        ret
  CheckTop endp

  CheckFloor proc near          ; Operation:-
        push    si              ;    if (last row in table is empty) then
        mov     Check,0         ;      Check <= 0
        mov     si,190          ;    else Check <= 1
    Again_CheckFloor:
        cmp     [TableA+si],0
        jne     L1_checkFloor
        inc     si
        cmp     si,200
        jl      Again_checkFloor
        jmp     L2_checkFloor
    L1_checkFloor:
        mov     Check,1
    L2_checkFloor:
        pop     si
        ret
  CheckFloor endp

  CheckLeft proc near           ; Operation:-
        push    si              ;    if (each row at first colomn is empty)
        mov     Check,0d        ;    then Check <= 0
        mov     si,0d           ;    else Check <= 1
    Again_checkLeft:
        cmp     [TableA+si],0d
        jne     L1_checkLeft
        add     si,10d
        cmp     si,200d
        jl      Again_checkLeft
        jmp     L2_checkLeft
    L1_CheckLeft:
        mov     Check,1d
    L2_CheckLeft:
        pop     si
        ret
  CheckLeft endp

  CheckRight proc near          ; Operation:-
        push    si              ;    if (each row at last colomn is empty)
        mov     Check,0         ;    then Check <= 0
        mov     si,9d           ;    else Check <= 1
    Again_checkRight:
        cmp     [TableA+si],0d
        jne     L1_checkRight
        add     si,10d
        cmp     si,200d
        jl      Again_checkRight
        jmp     L2_checkRight
    L1_CheckRight:
        mov     Check,1d
    L2_CheckRight:
        pop     si
        ret
  CheckRight endp

  CheckErrorTable proc near             ; Output:-
        push    si                      ;    Check <= 0 if table is not error
        mov     Check,0                 ;    Check <= 1 if table is error
        mov     si,0d
    Again_CheckErrorTable:
        cmp     [TableA+si],0d
        je      L1_checkErrorTable
        cmp     [TableB+si],0d
        je      L1_checkErrorTable
        mov     check,1d
        jmp     L2_checkErrorTable
    L1_CheckErrorTable:
        inc     si
        cmp     si,200d
        jl      Again_checkErrorTable
    L2_CheckErrorTable:
        pop     si
        ret
  CheckErrorTable endp
end
