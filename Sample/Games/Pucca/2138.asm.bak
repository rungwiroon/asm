.MODEL SMALL
.386
.STACK 100H
.DATA
;;;;;;;;;;;;;;COMMENT FOR DEBUGER;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;COMMENT FOR DEBUGER;;;;;;;;;;;;;;;;;;
;WAITKEY MACRO   					92
;	MACRO FOR WAIT AND GET KEY IN

;DSPL_MAIN						136
;	DISPLAY MAIN PAGE

;ACTV_MNU						144
;	SHOW MENU SELECT PICTURE

;LVL_MAIN						155
;	DISPLAY LVL MENU

;ACTLV_MNU						163
;	SHOW LV SELECT PICTURE

;LVL_MNU						173
;	LEVEL CHOICE DISPLAY
;	VAR HARD = 0 FOR EASY,1 FOR HARD MODE

;DET_MNU						227
;	SHOW AND CHOOSE CHOICE IN MAIN MENU

;HOWTOPLAY						305
;	SHOW HOWTOPLAY PAGE
			   
;STARTGAME						320
;	PLAY GAME
;	COMPLAY1
;	MANPLAY1
;	SHOW_ACT
;	MANPLAY2
;	COMPLAY2
;	ACTION - SHOW ATK

;GETNAME						461   
;	CLEAR OLD NAME
;	GET NEW NAME
;	SHOW NEW NAME IN TIME BAR

;LISTSCORE						509
;
;

;INITIAL						572
;SHOW_LIFE						599
;TIME_COUNTER						642

;MANPLAY1						674
;COMPLAY1						703
;SHOW_ACT						719
;MANPLAY2						742
;COMPLAY2						780
;ACTION							800
;SHOW_ATTACK						919

;CAL_SCORE						940
;UPDATESCORE						959


;;;;;;;;;;;;;;COMMENT FOR DEBUGER;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;COMMENT FOR DEBUGER;;;;;;;;;;;;;;;;;;

;DATA SET FOR READ PICTURE FROM .BMP FILE
BMP_WIDTH	DW 		?		;DON'T CARE
BMP_HEIGHT	DW 		?		;DON'T CARE
BMP_BUFFER	DB 		4 DUP(?)		;DON'T CARE
BMP_COUNT	DW 		?		;DON'T CARE
BMP_X		DW 		?		;X POSITION OF BMP 
BMP_Y		DW 		?		;Y POSITION OF BMP

;DATA SET FOR DELAY
TIME		DB		?

;DATA .BMP FILE
BMP_MAIN	DB 		'MAIN.BMP',0
BMP_MNU	DB		'C0.BMP',0,'$'
BMP_HOWTO	DB		'HOWTO.BMP',0
BMP_NAME	DB		'NAME.BMP',0
BMP_SCORE	DB		'REC.BMP',0
BMP_STAGE	DB		'STAGE.BMP',0
BMP_LIFE1	DB		'A1.BMP',0,'$'
BMP_LIFE2	DB		'B1.BMP',0,'$'
BMP_TIME	DB		'CT0.BMP',0,'$'
BMP_STATUS	DB		'S00.BMP',0,'$'
BMP_COMACT	DB		'G1.BMP',0,'$'
BMP_MANACT	DB		'P1.BMP',0,'$'
BMP_WIN	DB		'WIN.BMP',0
BMP_LOSE	DB		'LOSE.BMP',0
BMP_LEVEL	DB		'LEVEL.BMP',0
BMP_LV		DB		'L1.BMP',0
BMP_THX	DB		'THX.BMP',0
BMP_CHE	DB		'D1.BMP',0,'$'

;DATA FOR CONTACT FILE
F_SCORE	DB	'SCORE.TXT',0
HANDLE		DW	0
BUFFER		DB	18 DUP (0)

;DATA FOR GAME
HARD		DB	0
MSG		DB	'ESC : EXIT      HELLO!          '
TIME_BUF	DB	'00:00:00','$'			;time buffer hr:min:sec
TEMP		DB	0
TEMP2		DB	0
MNU_CUR	DB	'1'
LV_CUR		DB	'1'
COUNT		DW	0
LIFE_P1		DB	4
LIFE_P2		DB	4
TLIFE_P1 	DW	0
TLIFE_P2	DW	0
MAN_ACT1	DB	0
MAN_ACT2	DB	0
COM_ACT1	DB	0
COM_ACT2	DB	0
ESCG		DB	0
P_NAME		DB	10,0,'          $'
PT_NAME	DB	10,0,'          $'
MINUS		DW	0
SPACE		DB	'                    ',10,13,'                    ','$'
MINUS_MSG	DB	'MINUS : $'
YOUR		DB	'YOUR '
SCORE_MSG	DB	'SCORE : $'

;DATA FOR SCORE
SCR_Y		DB	0		;SCORE SCREEN Y-AXIS
SCR_P1		DW	0
SCR_CUR		DB	'          $      $'
SCR_LIST	DB	180 DUP (0)

WAITKEY MACRO
	LOCAL LOOP_PRESS
	LOCAL KEYPRESS
	LOOP_PRESS:
	mov	ah,11h			;Check press key
	int	16h
	jnz	Keypress			;JMP IF ZF == 0
	CALL	TIMER
	JMP	LOOP_PRESS
	KEYPRESS:
ENDM

.CODE
MAIN 		PROC
	MOV 	AX,@DATA		
	MOV 	DS,AX			
	MOV	ES,AX			

	MOV 	AH,0FH		;SAVE DISPLAY MODE
	INT 	10H
	PUSH 	AX


	MOV 	AH,0H		;CHANGE DISPLAY MODE
	MOV 	AL,13H
	INT	 10H

	CALL 	DET_MNU

	MOV 	BMP_X,0		;LOAD THANK PICTURE
	MOV 	BMP_Y,0
	LEA	SI,BMP_THX
	CALL 	LOADBMP

	MOV AH,00H		;WAIT KEY
	INT 16H
	
	POP AX			;LOAD OLD DISPLAY MODE
	MOV	AH,00H		;-----
	INT	10H		;-----
MOV AH,4CH
INT 21H
MAIN ENDP
;===================================
DSPL_MAIN       PROC    NEAR
	MOV 	BMP_X,0
	MOV 	BMP_Y,0
	LEA	SI,BMP_MAIN
	CALL 	LOADBMP
	RET
DSPL_MAIN       ENDP
;=================================
ACTV_MNU	PROC    NEAR
	MOV 	BMP_X,102
	MOV 	BMP_Y,96
	MOV 	AL,MNU_CUR
	MOV 	BMP_MNU[1],AL
	LEA 	SI,BMP_MNU
	CALL 	LOADBMP
	RET
ACTV_MNU	ENDP
;===================================
;===================================
LVL_MAIN       PROC    NEAR
	MOV 	BMP_X,0
	MOV 	BMP_Y,0
	LEA	SI,BMP_LEVEL
	CALL 	LOADBMP
	RET
LVL_MAIN       ENDP
;=================================
ACTLV_MNU	PROC    NEAR
	MOV 	BMP_X,0
	MOV 	BMP_Y,0
	MOV 	AL,LV_CUR
	MOV 	BMP_LV[1],AL
	LEA 	SI,BMP_LV
	CALL 	LOADBMP
	RET
ACTLV_MNU	ENDP
;===================================
LVL_MNU	PROC	NEAR

@DRW_BG: 
	MOV	HARD,0
	MOV	LV_CUR,'1'
	CALL	LVL_MAIN      	 ;DRW BG
	CALL	ACTLV_MNU	;TKE FRST MNU

@STRT_DET:
	
	WAITKEY

	MOV	AH,00H		;GET SCANNED KEY (UP-DOWN ARROW)	
	INT	16H		;-----
	CMP	AH,01H
	JE	@CHK_MNU2 
	CMP	AH,1CH		;CHK FOR ENTER
	JE	@GO_MNU		;JMP FOR GOTO MNU

	CMP	AH,48H		;CHK FOR UP ARRW KEY
	JE	@UP_MNU		;JMP FOR PRCSS KEYPRSS

	CMP	AH,50H		;CHK FOR DWN ARRW KEY
	JE	@DWN_MNU	;JMP FOR PRCSS KEYPRSS

	JMP	@STRT_DET	;LOOP FOR DET

@UP_MNU:
	CMP	LV_CUR,'1'	;CHK FOR LWWR BUND
	JE	@STRT_DET	;IF IT IS THEN SKP CHNG MNU

	DEC	LV_CUR		;DEC THE MNU
	CALL	ACTLV_MNU	;DSPL NEW MNU
	JMP	@STRT_DET	;RE DET

@DWN_MNU:
	CMP	LV_CUR,'2'	;CHK FOR UPPR BUND
	JE	@STRT_DET	;IF IT IS THEN SKP CHNG MNU

	INC	LV_CUR		;INC THE MNU
	CALL	ACTLV_MNU	;DSPL NEW MNU
	JMP	@STRT_DET	;RE DET

@GO_MNU:
@CHK_MNU1:
	CMP	LV_CUR,'2'	;CHK FOR MNU 1
	JNE	@CHK_MNU2	;JMP TO CHK MNU2 IF IT'S NOT
	MOV	HARD,1
@CHK_MNU2:

	RET			;RET TO END PROG

LVL_MNU		ENDP
;===================================
DET_MNU	PROC	NEAR

DRW_BG: 
	MOV	AH,0CH		;CLEAR BUFFER
	MOV	AL,00H
	INT	21H
	
	
	CALL	DSPL_MAIN      	 ;DRW BG
	CALL	ACTV_MNU	;TKE FRST MNU

STRT_DET:
	
	WAITKEY

	MOV	AH,00H		;GET SCANNED KEY (UP-DOWN ARROW)	
	INT	16H		;-----
	CMP	AH,01H
	JE	CHK_MNU4 
	CMP	AH,1CH		;CHK FOR ENTER
	JE	GO_MNU		;JMP FOR GOTO MNU

	CMP	AH,48H		;CHK FOR UP ARRW KEY
	JE	UP_MNU		;JMP FOR PRCSS KEYPRSS

	CMP	AH,50H		;CHK FOR DWN ARRW KEY
	JE	DWN_MNU	;JMP FOR PRCSS KEYPRSS

	JMP	STRT_DET	;LOOP FOR DET

UP_MNU:
	CMP	MNU_CUR,'1'	;CHK FOR LWWR BUND
	JE	STRT_DET	;IF IT IS THEN SKP CHNG MNU

	DEC	MNU_CUR	;DEC THE MNU
	CALL	ACTV_MNU	;DSPL NEW MNU
	JMP	STRT_DET	;RE DET

DWN_MNU:
	CMP	MNU_CUR,'4'	;CHK FOR UPPR BUND
	JE	STRT_DET	;IF IT IS THEN SKP CHNG MNU

	INC	MNU_CUR	;INC THE MNU
	CALL	ACTV_MNU	;DSPL NEW MNU
	JMP	STRT_DET	;RE DET

GO_MNU:
CHK_MNU1:
	CMP	MNU_CUR,'1'	;CHK FOR MNU 1
	JNE	CHK_MNU2	;JMP TO CHK MNU2 IF IT'S NOT
	CALL	STARTGAME	;ACCESS MNU
        CALL	LISTSCORE
	MOV	TIME,1
	CALL	DELAY
    	MOV	AH,01H
	INT	21H
	JMP	DRW_BG	;RETURN TO REDRAW MNU

CHK_MNU2:
	CMP	MNU_CUR,'2'	;CHK FOR MNU2
	JNE	CHK_MNU3	;JMP TO CHK MNU3 IF IT'S NOT

	CALL	LISTSCORE
	MOV	AH,01H
	INT	21H
	JMP	DRW_BG	;RE DET

CHK_MNU3:
	CMP	MNU_CUR,'3'	;CHK FOR MNU3
	JNE	CHK_MNU4	;JMP TO CHK MNU4 IF IT'S NOT
	CALL	HOWTOPLAY	;ACCESS MNU
	JMP	DRW_BG	;RETURN TO REDRAW MNU

CHK_MNU4:
	RET			;RET TO END PROG

DET_MNU		ENDP
;=============================================================
HOWTOPLAY       PROC    NEAR

	LEA SI,BMP_HOWTO	;POINT TO HOWTO PIC
	MOV BMP_X,0		;SET POS X
	MOV BMP_Y,0		;SET POS Y
	CALL LOADBMP		;LOAD BMP

	MOV AH,1		;WAIT KEY FOR RET TO MNU
	INT 21H			;-----

	RET
HOWTOPLAY       ENDP
;=============================================================

;============================================================
STARTGAME	PROC	NEAR

	CALL	GETNAME
	CALL	LVL_MNU
	CALL	INITIAL

	LEA SI,BMP_STAGE	;POINT TO STAGE PIC
	MOV BMP_X,0		;SET POS X
	MOV BMP_Y,0		;SET POS Y
	CALL LOADBMP		;LOAD BMP

PLAY:
	MOV	DH,22D
	MOV	DL,0D
	MOV	BH,00H
	MOV	AH,02H
	INT	10H
	MOV AH,09H		;CLEAR SPACE FOR MSG
	LEA DX,SPACE		;CLEAR SPACE FOR MSG
	INT 21H			;CLEAR SPACE FOR MSG



	MOV	DH,22D		;SET POS FOR SHOW LIFE POINT
	MOV	DL,0D		;--
	MOV	BH,00H		;--
	MOV	AH,02H		;--
	INT	10H		;--
	PUSH	AX		;--
	MOV	AH,09H		;CAL NOW MINUS
	LEA	DX,MINUS_MSG	;--
	INT	21H		;--
	XOR	AX,AX		;--
	MOV	AX,MINUS	;--
	CALL	OUTDEC		;SHOW NOW MINUS


	MOV	DH,23D
	MOV	DL,0D
	MOV	BH,00H
	MOV	AH,02H
	INT	10H		;SET POS FOR SHOW LIFE POINT
	MOV	AH,09H		;--
	LEA	DX,SCORE_MSG	;--
	INT	21H		;--

	XOR	AX,AX		;CAL NOW SCORE
	MOV	AL,LIFE_P1	;CAL NOW SCORE
	MOV	BL,50		;--
	MUL	BL		;--
	MOV 	TLIFE_P1,AX	;--
	MOV	AL,LIFE_P2	;--
	MOV	BL,50		;--
	MUL	BL		;--
	MOV 	TLIFE_P2,AX	;--
	MOV	AX,TLIFE_P1	;--
	SUB	AX,TLIFE_P2	;--
	SUB	AX,MINUS	;--
	CALL	OUTDEC		;SHOW NOW SCORE
	POP	AX

	MOV	BMP_STATUS[1],'0'
	MOV	BMP_STATUS[2],'0'	;SET STATUS(START WITH STANDING) PICTURE

       	LEA	 SI,BMP_STATUS	;POINT TO STAGE PIC
	MOV	 BMP_X,41		;SET POS X
	MOV	 BMP_Y,81		;SET POS Y
	CALL	 LOADBMP		;LOAD BMP     (START WITH STANDING)

	CALL	SHOW_LIFE	;SHOW LIFE
	CALL	TIME_COUNTER	;SHOW TIME COUNTER


	CALL	COMPLAY1

	LEA	SI,BMP_CHE		;CHECK COM ACT FOR DEBUG! (^^)
	MOV	 BMP_X,48		;SET POS X
	MOV	 BMP_Y,7		;SET POS Y
	CALL 	LOADBMP

	CALL	MANPLAY1

	CMP	ESCG,01H		;CHECK MAN ACT  KEY?  ESC?
	JE	END_G
	CALL	SHOW_ACT		;ACTIN PAO YIN CHUP


	MOV	AL,COM_ACT1
	CMP	AL,MAN_ACT1
	JE	_NEXT			;IF SAME SAME

	CALL	MANPLAY2

	CMP	ESCG,01H
	JE	END_G

	CALL	COMPLAY2
_NEXT:	
	CALL	ACTION			;CHECK WIN?LOSE? & GET KEY FOR PROTECT OR ATTACK
	CALL	SHOW_ATTACK		;FIGHT!!!! !!!

	CMP	LIFE_P1,0
	JE	LOSE

	CMP	LIFE_P2,0
	JE	WIN

	JMP	PLAY

WIN:
     	CALL	CAL_SCORE
	CALL	UPDATESCORE  
	LEA	SI,BMP_WIN
	JMP	CONCLUDE
LOSE:
     	CALL	CAL_SCORE
	CALL	UPDATESCORE
	LEA	SI,BMP_LOSE
CONCLUDE:
	MOV BMP_X,0		;SET POS X
	MOV BMP_Y,0		;SET POS Y
	CALL LOADBMP		;LOAD BMP
	MOV AH,09H
	LEA DX,YOUR
	INT 21H
	MOV AX,SCR_P1
	CALL OUTDEC
	MOV TIME,1
	CALL DELAY
	;CALL	CHKTIME

	MOV	AH,01H
	INT	21H
	
END_G:
	MOV	ESCG,00H
	RET
STARTGAME	ENDP
;=============================================================
GETNAME		PROC	NEAR
	GETN:
	LEA	SI,PT_NAME	;LOAD NAME OF PLAYER1
	ADD	SI,2		;SKIP STR INFO IN P_NAME
	LEA	DI,P_NAME	;LOAD TEMPLATE
	ADD	DI,2

	MOV	CX,10		;PREPARE TRANSFER DATA 10 TIMES
	CLD			;CLEAR DIRECTION FLAG
	REP	MOVSB		;TRANSFER DATA
				;CLEAR OLD NAME IN GAME!!!!!

	LEA	SI,BMP_NAME	;POINT TO MAIN PIC
	MOV	BMP_X,0		;SET POS X
	MOV	BMP_Y,0		;SET POS Y
	CALL	LOADBMP		;LOAD BMP


	MOV	DH,14		 ;ROW
	MOV	DL,15		 ;COLUME
	MOV	BH,00H		 ;PAGE
	MOV	AH,02H		 ;MOVE CURSOR
	INT	10H

	LEA	DX,P_NAME
	MOV	AH,0AH
	INT	21H

	XOR	BX,BX
	XOR	AX,AX

	MOV	AL,[P_NAME+1]
	ADD	BX,AX
	MOV	BYTE PTR [P_NAME+2+BX],255
	
	CMP BYTE PTR [P_NAME+1],0
	JE GETN			;DONT'PASS WITH NO NAME

	LEA	SI,P_NAME	;LOAD NAME OF PLAYER1
	ADD	SI,2		;SKIP STR INFO IN P_NAME
	LEA	DI,MSG		;LOAD TEMPLATE
	ADD	DI,22

	MOV	CX,10		;PREPARE TRANSFER DATA 10 TIMES
	CLD			;CLEAR DIRECTION FLAG
	REP	MOVSB		;TRANSFER DATA

	RET
GETNAME		ENDP
;=================================================================     
LISTSCORE	PROC	NEAR
	LEA	SI,BMP_SCORE	;POINT TO SCORE BACKGROUND PIC
	MOV	BMP_X,0		;SET POS X
	MOV	BMP_Y,0		;SET POS Y
	CALL	LOADBMP		;LOAD BMP

	LEA DX,F_SCORE		;LOAD SCORE
	MOV AX,3D00H
	INT 21H			;OPEN FILE
;	;JC  ERROR_BMP_1	;########
	MOV HANDLE,AX		;save handle

	MOV	CX,10		;SET FOR LOOP 10 TIMES
	MOV	SCR_Y,3		;SET FOR Y-AXIS

LP_DSPL:
	PUSH	CX		;KEEP LOOP COUNTER

	;READ DATA TO BUFFER
		MOV	BX,HANDLE
		MOV	AH,3FH
		MOV	CX,18
		LEA	DX,BUFFER
		INT	21H

	;MOVE CURSOR
		MOV	DH,SCR_Y	;Y AXIS
		MOV	DL,5		;X AXIS
		MOV	BH,00H
		MOV	AH,02H
		INT	10H

	;DISPLAY NAME
		MOV	AH,09H
		LEA	DX,BUFFER
		INT	21H

	;MOVE CURSOR
		MOV	DH,SCR_Y	;Y AXIS
		MOV	DL,30		;X AXIS
		MOV	BH,00H
		MOV	AH,02H
		INT	10H

	;DISPLAY SCORE
		MOV	AH,09H
		LEA	DX,BUFFER
		ADD	DX,11
		INT	21H

		POP	CX		;RESTORE COUNTER
		ADD	SCR_Y,2		;COUNT UP Y-AXIS

LOOP	LP_DSPL

;CLOSE FILE
	MOV	AH,3EH
	MOV	BX,HANDLE
	INT	21H

	RET
LISTSCORE	ENDP
;===============================================================
INITIAL		PROC	NEAR

;DATA SET FOR GAME


	MOV	LIFE_P1,4	    ;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	CMP	HARD,1
	JNE	@EASY
	MOV	LIFE_P2,8
	JMP 	@END_EASY	
	@EASY:
	MOV	LIFE_P2,4
	@END_EASY:
	MOV	MINUS,0
;-----------------------
	MOV	ESCG,0

;DATA SET FOR DELAY
	MOV	TIME,0
	MOV	COUNT,0
	MOV	SCR_Y,0		;SCORE SCREEN Y-AXIS
	MOV	SCR_P1,0

	RET
INITIAL		ENDP
;================================================================
SHOW_LIFE	PROC	NEAR
	MOV	AL,LIFE_P1
	ADD	AL,48D		;CONVERT LIFE POINT TO ASCII
	
	MOV	DH,03H
	MOV	DL,04H
	MOV	BH,00H
	MOV	AH,02H
	INT	10H		;SET POS FOR SHOW LIFE POINT

	MOV	DL,AL
	MOV	AH,02H
	INT	21H		;SHOW LIFE POINT

	MOV	BMP_LIFE1[1],AL
	LEA	SI,BMP_LIFE1	;POINT TO STAGE PIC
	MOV	BMP_X,56		;SET POS X
	MOV	BMP_Y,8		;SET POS Y
	CALL	LOADBMP		;LOAD BMP


	MOV	AL,LIFE_P2
	ADD	AL,48D		;CONVERT LIFE POINT TO ASCII

	MOV	DH,03H
	MOV	DL,75D
	MOV	BH,00H
	MOV	AH,02H
	INT	10H		;SET POS FOR SHOW LIFE POINT

	MOV	DL,AL
	MOV	AH,02H
	INT	21H		;SHOW LIFE POINT

	MOV BMP_LIFE2[1],AL
	LEA SI,BMP_LIFE2	;POINT TO STAGE PIC
	MOV BMP_X,192		;SET POS X
	MOV BMP_Y,8		;SET POS Y
	CALL LOADBMP		;LOAD BMP
	
	RET
SHOW_LIFE	ENDP
;===============================================================
TIME_COUNTER	PROC	NEAR
	MOV BMP_X,126		;SET POS X
	MOV BMP_Y,22		;SET POS Y

	MOV BMP_TIME[2],'1'	;SET TIME PICTURE
	LEA SI,BMP_TIME	;POINT TO STAGE PIC
	CALL LOADBMP		;LOAD BMP
	CALL TIMER
	MOV	TIME,0
	CALL	DELAY
	CALL TIMER
	MOV BMP_TIME[2],'2'	;SET TIME PICTURE
	LEA SI,BMP_TIME	;POINT TO STAGE PIC
	CALL LOADBMP		;LOAD BMP
	
	MOV	TIME,1
	CALL	DELAY
	CALL TIMER
	MOV BMP_TIME[2],'3'	;SET TIME PICTURE
 	LEA SI,BMP_TIME	;POINT TO STAGE PIC
	CALL LOADBMP		;LOAD BMP
	
	MOV	TIME,1
	CALL	DELAY
	CALL TIMER
	MOV BMP_TIME[2],'4'	;SET TIME PICTURE
	LEA SI,BMP_TIME	;POINT TO STAGE PIC
	CALL LOADBMP		;LOAD BMP

	RET
TIME_COUNTER	ENDP
;============================================================
MANPLAY1	PROC	NEAR

GET_MAN_ACT1:
	MOV	AH,0CH
	MOV	AL,00H
	INT	21H
	WAITKEY
	MOV AH,00H
	INT 16H			;GET SCANNED KEY (Z X C)

	CMP AH,01H
	JE EXIT_GET_MAN_ACT1

	CMP AH,2CH		;CHK FOR KEY IS LESS THAN Z
	JL GET_MAN_ACT1		;JMP FOR RE GET

	CMP AH,2EH		;CHK FOR KEY IS MORE THAN C
	JG GET_MAN_ACT1		;JMP FOR RE GET

	SUB AH,2BH
	MOV MAN_ACT1,AH		;SET ACTION CODE
	
	RET

EXIT_GET_MAN_ACT1:
	MOV ESCG,01H
	RET
MANPLAY1	ENDP
;============================================================
COMPLAY1	PROC	NEAR
	MOV	AH,2CH
	INT	21H		;GET RAND

	XOR	AX,AX
	MOV	AL,DL
	MOV	BL,03H	;SET DIVISER
	DIV	BL

	ADD	AH,01H
	MOV	COM_ACT1,AH
	ADD	AH,'0'
	MOV	BMP_CHE[1],AH
	RET
COMPLAY1	ENDP
;============================================================
SHOW_ACT	PROC	NEAR

	MOV AL,COM_ACT1
	ADD AL,48D		;CONVERT LIFE POINT TO ASCII

	MOV BMP_COMACT[1],AL
	LEA SI,BMP_COMACT	;POINT TO STAGE PIC
	MOV BMP_X,156		;SET POS X
	MOV BMP_Y,89		;SET POS Y
	CALL LOADBMP		;LOAD BMP

	MOV AL,MAN_ACT1
	ADD AL,48D		;CONVERT LIFE POINT TO ASCII

	MOV BMP_MANACT[1],AL
	LEA SI,BMP_MANACT	;POINT TO STAGE PIC
	MOV BMP_X,60		;SET POS X
	MOV BMP_Y,88		;SET POS Y
	CALL LOADBMP		;LOAD BMP
	
	RET
SHOW_ACT	ENDP
;============================================================
MANPLAY2	PROC	NEAR

GET_MAN_ACT2:
	CMP	HARD,1
	JNE	@EASY4
	MOV TIME,1
	CALL DELAY
	MOV 	MAN_ACT2,01H
	JMP	ACT2_PASS
	@EASY4:
	WAITKEY


	MOV	AH,00H
	INT	16H		;GET SCANNED KEY (Q A)

	CMP	AH,01H
	JE	EXIT_GET_MAN_ACT2

	MOV	MAN_ACT2,01H
	CMP	AH,10H		;CHK FOR KEY IS Q
	JE	ACT2_PASS	;JMP FOR RE GET
	
	MOV	MAN_ACT2,02H
	CMP	AH,1EH		;CHK FOR KEY IS A
	JE	ACT2_PASS	;JMP FOR RE GET

	JMP	GET_MAN_ACT2

ACT2_PASS:
	RET

EXIT_GET_MAN_ACT2:
	MOV ESCG,01H
	RET

MANPLAY2	ENDP
;===============================================================
COMPLAY2	PROC	NEAR
	MOV	AH,2CH
	INT	21H		;GET RAND

	XOR	AX,AX
	MOV	AL,DL
	MOV	BL,02H	;SET DIVISER
	DIV	BL

	ADD	AH,01H
	MOV	COM_ACT2,AH


	CMP	HARD,1
	JNE	@EASY2
	MOV	COM_ACT2,1
	@EASY2:
	RET
COMPLAY2	ENDP
;================================================================
ACTION	PROC	NEAR
	MOV	AL,COM_ACT1
	SUB	AL,MAN_ACT1

	CMP	AL,01H
	JE	ACT1_WIN
	CMP	AL,254D
	JE	ACT1_WIN

	CMP	AL,02H
	JE	ACT1_LOSE
	CMP	AL,255D
	JE	ACT1_LOSE
	
ACT1_DRAW:
	MOV	AH,00H
	JMP	STATUS_22

ACT1_WIN:
	MOV	AH,01H
	JMP	CHECK_ACT2

ACT1_LOSE:
	MOV	AH,255D

CHECK_ACT2:
CHK_CASE:
	CMP AH,255D
	JNE CHK_CASE0
	CMP COM_ACT2,01H
	JE STATUS_31
CHK_CASE0:
	CMP	AH,255D
	JNE	CHK_CASE1	
	CMP	MAN_ACT2,01H
	JE	STATUS_F

CHK_CASE1:
	CMP	MAN_ACT2,02H
	JNE	CHK_CASE2
	CMP	COM_ACT2,01H
	JE	STATUS_21

CHK_CASE2:
	CMP	MAN_ACT2,02H
	JNE	CHK_CASE3
	CMP	COM_ACT2,02H
	JE	STATUS_22

CHK_CASE3:
	CMP	MAN_ACT2,01H
	JNE	CHK_CASE4
	CMP	COM_ACT2,02H
	JE	STATUS_12

CHK_CASE4:
	CMP	AH,01H
	JNE	CHK_CASE5
	CMP	MAN_ACT2,01H
	JE	STATUS_13

CHK_CASE5:
	CMP	AH,255D
	JNE	STATUS_22	;BYPASS FOR PREVENT BUG
	CMP	COM_ACT2,01H
	JE	STATUS_31

STATUS_21:
	SUB	MINUS,5
	MOV	BMP_STATUS[1],'2'
	MOV	BMP_STATUS[2],'1'
	JMP	COMPLETE

STATUS_22:

	ADD	MINUS,10

	CMP	HARD,1
	JNE	@DRAW
	SUB	MINUS,25
	@DRAW:
	
	MOV	BMP_STATUS[1],'2'
	MOV	BMP_STATUS[2],'2'
	JMP	COMPLETE

STATUS_12:
	SUB	MINUS,25
	MOV	BMP_STATUS[1],'1'
	MOV	BMP_STATUS[2],'2'
	JMP	COMPLETE

STATUS_13:
	CMP	HARD,1
	JNE	@EASY3
	SUB	MINUS,50
	@EASY3:
	SUB	MINUS,5
	DEC	LIFE_P2
	MOV	BMP_STATUS[1],'1'
	MOV	BMP_STATUS[2],'3'
	JMP	COMPLETE

STATUS_31:
	ADD	MINUS,15
	DEC	LIFE_P1
	MOV	BMP_STATUS[1],'3'
	MOV	BMP_STATUS[2],'1'
	JMP	COMPLETE

STATUS_F:
	ADD	MINUS,50
	DEC	LIFE_P1
	MOV	BMP_STATUS[1],'3'
	MOV	BMP_STATUS[2],'1'
COMPLETE:
	RET
ACTION	ENDP
;======================================================
SHOW_ATTACK	PROC	NEAR

	CALL	SHOW_LIFE

	LEA	 SI,BMP_STATUS	;POINT TO STAGE PIC
	MOV	 BMP_X,41		;SET POS X
	MOV	 BMP_Y,81		;SET POS Y
	CALL	 LOADBMP		;LOAD BMP
	
	CALL	TIMER
	MOV	TIME,1
	CALL	DELAY
	CALL	TIMER
	MOV	TIME,1
	CALL	DELAY

	RET
SHOW_ATTACK	ENDP
;=====================================================
CAL_SCORE	PROC	NEAR
	XOR	AX,AX
	MOV	AL,LIFE_P1
	MOV	BL,50
	MUL	BL
	MOV 	TLIFE_P1,AX

	MOV	AL,LIFE_P2
	MOV	BL,50
	MUL	BL
	MOV 	TLIFE_P2,AX

	MOV	AX,TLIFE_P1
	SUB	AX,TLIFE_P2
	SUB	AX,MINUS
	MOV	SCR_P1,AX
	RET
CAL_SCORE	ENDP
;=====================================================
UPDATESCORE	PROC	NEAR
	LEA	SI,P_NAME	;LOAD NAME OF PLAYER1
	ADD	SI,2		;SKIP STR INFO IN P_NAME
	LEA	DI,SCR_CUR	;LOAD TEMPLATE

	MOV	CX,10		;PREPARE TRANSFER DATA 10 TIMES
	CLD			;CLEAR DIRECTION FLAG
	REP	MOVSB		;TRANSFER DATA

	INC	DI		;SKIP UP '$'
 				

	MOV	AX,SCR_P1	;LOAD SCORE

	CALL	AOUTDEC		;CONVERT TO STR IN [DI]
;SCR_CUR GET NAMEXXXXX$SCOREXXX
	LEA	DX,F_SCORE		;LOAD SCORE'S FILE NAME
	MOV	AX,3D00H
	INT	21H			;OPEN FILE APPEND
	MOV	HANDLE,AX		;save handle

	MOV	CX,10		;SET FOR LOOP 10 TIMES
	LEA	DI,SCR_LIST	;LOAD TARGETED LIST
	MOV	TEMP,0		;SET INSERTED FLAG (VALUE 1 FOR INSERTED NEW DATA)

LP_DATA:
	PUSH	CX		;KEEP LOOP COUNTER

	;READ DATA
	MOV	BX,HANDLE
	MOV	AH,3FH
	MOV	CX,18
	LEA	DX,BUFFER
	INT	21H

	LEA	SI,BUFFER	;LOAD 1 RECORD
	ADD	SI,11		;SKIP ADDRESS TO SCORE
	CALL	AINDEC		;CONVERT TO INTEGER IN AX

	CMP	AX,SCR_P1	;COMPARE TO CURRENT SCORE
	JGE	OLD_DATA	;IF NEW SCORE IS LESS THAN
	CMP	TEMP,1		;CHK FOR INSERTED NEW DATA
	JE	OLD_DATA	;IF INSERTED

NEW_DATA:
	MOV	TEMP,1
	LEA	SI,SCR_CUR	;LOAD CURRENT FIELD
	MOV	CX,18		;PREPARE TO TRANSFER DATA 10 TIMES
	REP	MOVSB		;TRANSFER

	;DEC NUM OF LAP
	POP	CX
	CMP	CX,0		;IF CX IS 0 THEN DO NOT DEC
	JE	SKIP_DEC	;JG	SKIP_DEC
	DEC	CX
SKIP_DEC:
	PUSH	CX

OLD_DATA:
	LEA	SI,BUFFER	;LOAD OLD DATA FIELD
	MOV	CX,18		;PREPARE TO TRANSFER DATA 10 TIMES
	REP	MOVSB		;TRANSFER
	
	POP	CX		;RESTORE COUNTER
LOOP	LP_DATA			;LOOP FOR 10 RECORD

	;CLOSE FILE
	MOV	AH,3EH
	MOV	BX,HANDLE
	INT	21H
;+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+
	LEA DX,F_SCORE		;LOAD SCORE'S FILE NAME
	MOV AX,3C00H
	MOV CL,0
	INT 21H			;OPEN FILE
	MOV HANDLE,AX		;save handle

;SAVE NEW LIST
	MOV	AH,40H
	MOV	BX,HANDLE
	MOV	CX,180
	LEA	DX,SCR_LIST
	INT	21H

;CLOSE FILE
	MOV	AH,3EH
	MOV	BX,HANDLE
	INT	21H

	RET
UPDATESCORE	ENDP
;======================================================================
AINDEC PROC
;reads a number in range -32768 to 32767 FROM FILE
;input: FILE [SI]
;output: AX = binary equivalent of number
	PUSH BX		;save registers used
	PUSH CX
	PUSH DX
	PUSH SI
	PUSH DI
;print prompt
@ABEGIN:
;total = 0
	 XOR BX,BX	;BX hold total
;negative = false	 
	 XOR CX,CX	;CX hold sign
	 MOV AL,[SI]
;case charecter of	 
	 CMP AL,'-'
	 JE @AMINUS
	 CMP AL,'+'
	 JE @APLUS
	 JMP @AREPEAT2
@AMINUS:
	 MOV CX,1
@APLUS:
	 INC SI
	 MOV AL,[SI]
;end case
@AREPEAT2:
;if charecter is between '0' and '9'
	CMP AL,'0'
	JNGE @AEXIT ;@ANOT_DIGIT
	CMP AL,'9'
	JNLE @AEXIT ;@ANOT_DIGIT
;then convert charecter to a digit	
	AND AX,000FH
	PUSH AX
;total = total * 10 + digit
	MOV AX,10
	MUL BX
	POP BX
	ADD BX,AX
;read a charecter	
 	 ;INC SI
	 INC SI
	 MOV AL,[SI]
	CMP AL,' '
	JNE @AREPEAT2

;until CR
	MOV AX,BX
@AEXIT2:
;if negative
	OR CX,CX
	JE @AEXIT
;then
	NEG AX
;end if	
@AEXIT:
	POP DI
	POP SI
	POP DX
	POP CX
	POP BX
	RET
;here if illegal charecter entered	
@ANOT_DIGIT:
	CMP AL,' '
	JNE @AREPEAT2
	JE @AEXIT2
	JMP @ABEGIN
AINDEC ENDP
;=======================================================================
AOUTDEC PROC
;SAVE AX as asigned decimal integer TO [DI]
;input : AX,[DI]
;output : COUNT AND [DI]
;NEED 
;	COUNT DW 0

	PUSH AX		;save register
	PUSH BX
	PUSH CX
	PUSH DX
	PUSH DI
	PUSH SI
	
	MOV COUNT,0	;INITTIALIZE COUNT
	;MOV AX,[SI]	;MOV ARRAY DATA TO AX
;if AX < 0
	OR AX,AX	;ax , 0?
	JGE @AEND_IF1	;NO, > 0
;then
	PUSH AX		;save number
	MOV DL,'-'	;get '-'
	MOV [DI],DL
	INC COUNT
	INC DI
	POP AX		;get AX back
	NEG AX		;AX = AX - 1	
@AEND_IF1:
;get decimal digits
	XOR CX,CX	;CX count digits
	MOV BX,10D	;BX has divisor
@AREPEAT1:
	XOR DX,DX	;prepare high word of dividend
	DIV BX		;AX = quotient, DX = remainder
	PUSH DX		;save remainder on stack
	INC CX		;count = count + 1
;until	
	OR AX,AX	;quotient = 0?
	JNE @AREPEAT1	;no, keep going
;convert digits to characters and print	
		;print char function
;for count time do	

@APRINT_LOOP:
	POP DX		;digit in DL
	OR DX,30H	;convert to charecter
	MOV [DI],DX	;SAVE digit
	INC COUNT	;COUNT DIGIT
	INC DI		;INC DI TO NEXT ELEMENT
	LOOP @APRINT_LOOP	;loop until done
	MOV AL,' '
	MOV [DI],AL
	POP SI
	POP DI
	POP DX		;restore register
	POP CX
	POP BX
	POP AX
	RET
	
AOUTDEC ENDP
;======================================================================
INCLUDE LOADBMP.ASM
INCLUDE OUTDEC.ASM
INCLUDE DELAY.ASM
INCLUDE TIME.ASM
END MAIN