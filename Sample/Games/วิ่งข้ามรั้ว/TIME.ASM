TIME_INT	PROC
	;PUSHA
;INTERRUPT PROCEDURE
;ACTIVATED BY THE TIMER
	;PUSH	DS		;SAVE CURRENT DS
	;OV	AX,SEG TIME_BUF	;SET IT TO DATA SEGMENT
	;MOV	DS,AX
;GET NEW TIME
	LEA	BX,TIME_BUF	;BX POINTS TIME BUFFER
	;CALL	GET_TIME	;STORE TIME IN BUFFER
	CALL	COUNT_TIME
;DISPLAY TIME
	GOTOXY	66,2
	LEA	DX,TIME_BUF	;DX POINTS TO TIME_BUF
	MOV	AH,09H		;DISPLAY STRING
	INT	21H
;RESTORE CURSOR POSITION
	;MOV	AH,2		;FUNCTION 2, MOVE CURSOR
	;MOV	BH,0		;PAGE 0
	;MOV	DX,CURSOR_POS	;CURSOR POSITION,DH=ROW,DL=COL
	;INT	10H		;
	;POP	DS		;RESTORE DS
	;POPA
	RET
TIME_INT	ENDP		;END OF INTERRUPT PROCEDURE

GET_TIME        PROC
;GET TIME OF DAY AND STORE ASCII DIGITS IN TIME BUFFER
;INPUT:  BX = ADDRESS OF TIME BUFFER
        MOV     AH,2CH          ;GETTIME
        INT     21H             ;CH = HR, CL =  MIN, DH = SEC, DL = MSEC
;CONVERT HOURS INTO ASCII AND STORE
        MOV     AL,CH           	;HOUR
        CALL    CONVERT         ;CONVERT TO ASCII
        MOV     [BX],AX         ;STORE
;CONVERT MINUTES INTO ASCII AND STORE
        MOV     AL,CL           ;MINUTE
        CALL    CONVERT         ;CONVERT TO ASCII
        MOV     [BX+3],AX       ;STORE
;CONVERT SECONDS INTO ASCII AND STORE
        MOV     AL,DH           ;SECOND
        CALL    CONVERT         ;CONVERT TO ASCII
        MOV     [BX+6],AX       ;STORE
        RET
GET_TIME        ENDP

COUNT_TIME	PROC
	MOV AH,2CH		;GETTIME
    INT	21H     	;DH = SEC, DL = 1/100 SEC

	CMP	START_COUNT,1
	JNE	CHECK_TIME
WAIT_0:
	INT	21H     	;DH = SEC, DL = 1/100 SEC
	CMP	DL,0
	JNE	WAIT_0		;WAIT 1/100 SEC = 20
	MOV	SEC,0
	MOV	SEC2,DH
	MOV	START_COUNT,0

CHECK_TIME:	
	CMP	DH,SEC2
	JE	SAVE_COUNT
	MOV	SEC2,DH
	INC	SEC
	CMP	SEC,100
	JNE	SAVE_COUNT
	MOV	SEC,0
	
SAVE_COUNT:
	MOV	AL,DL
	MOV	M_SEC,DL
	CALL	CONVERT
	MOV	[BX+6],AX

	MOV	AL,SEC
	CALL	CONVERT
	MOV	[BX+3],AX
		
CT_RET:	
	RET
COUNT_TIME	ENDP
;
CONVERT PROC
;CONVERTS BYTE NUMBER (0-59) INTO ASCII DIGITS
;INPUT: AL = NUMBER
;OUTPUT: AX = ASCII DIGITS, AL = HIGH DIGIT, AH = LOW DIGIT
        MOV     AH,0            ;CLEAR AH
        MOV     DL,10           ;DIVIDE AX BY 10
        DIV     DL              ;AH HAS REMAINDER, AL HAS QUOTIENT
        OR      AX,3030H        ;CONVERT TO ASCII, AH HAS LOW DIGIT
        RET                     ;AL HAS HIGH DIGIT
CONVERT ENDP

SETUP_INT	PROC
;SAVES OLD VECTOR AND SETS UP NEW VECTOR
;INPUT  AL = INTERRUPT TYPE
;	DI = ADDRESS OF BUFFER FOR OLD VECTOR
;	SI = ADDRESS OF BUFFER CONTAINING NEW VECTOR
;SAVE OLD INTERRUPT VECTOR
	PUSH	ES
 	MOV	AH,35H		;FUNCTION 35H, GET VECTOR
	INT	21H		;ES:BX = VECTOR
	MOV	[DI],BX		;SAVE OFFSET
	MOV	[DI+2],ES	;SAVE SEGMENT
;SETUP NEW VECTOR
	MOV	DX,[SI]		;DX HAS OFFSET
	PUSH	DS		;SAVE IT
	MOV	DS,[SI+2]	;DS HAS SEGMENT NUMBER
	MOV	AH,25H		;FUNCTION 25H, SET VECTOR
	INT	21H		
	POP	DS		;RESTORE DS
	POP	ES		;RESTORE ES
	RET
SETUP_INT	ENDP
