;==========================================================================================
;PROC FOR SHOW PICTURE(.BMP) 
;===================================================================================================================================
;MODIFIER CODE TO  VERSION 8 BY RUNG CSs13 KMITNB
;
;WHAT'S NEW
;1. ENHANCE SPEED FOR DISPLAY PICTURE
;2. ADD 4 MODE FOR USE TO DISPLAY PICTURE
;	BMP_MODE = 0	NORMAL MODE, SAME AS ORIGINAL LOADBMP
;	BMP_MODE = 1	ENHANCE DISPLAY SPEED BY NOT LOAD COLOR TABLE
;	BMP_MODE = 2	TRANSPARENT MODE, DISPLAY PICTURE BY USE TRANSPARENT COLOR
;	BMP_MODE = 3	SET COLOR REGISTER MODE, THIS MODE NOT DISPLAY PICTURE BUT IT LOAD COLOR TABLE TO COLOR REGISTER
;3. CHANGE DISPLAY MODE TO 640*480 256 COLOR (IT DOESN'T WORK ON SOME MACHINE)
;
;KNOW BUGS!!!!!!!
;1. SOME POSITION OF PICTURE DISPLAY INCORRECT <------PLEASE FIXED IT!
;2. DISPLAY PICTURE WITH INCORRECT COLOR TABLE ON SOME MACHINE
;===================================================================================================================================
;ïïïTHIS PROC IS FOR 640 *480  IN  256 COLORS ONLYïïï
;INPUT:	BMP_FILENAME(LEA SI,FILENAME)
;	BMP_WIDTH	DW 	?	DON'T CARE
;	BMP_HEIGHT	DW	?	DON'T CARE
;I'M MODIFIER FOLLOWING MEMORY
;	BMP_HANDLE	DW	?	DON'T CARE
;	BMP_BUFFER  	DB 	1024 DUP(?)	DON'T CARE
;	BMP_X1		DW	?	X POSITION OF BMP 
;	BMP_Y1		DW	?	Y POSITION OF BMP
;	BMP_BLANK	DW	0	DON'T CARE
;	BMP_X2		DW	?	DON'T CARE
;	BMP_Y2		DW	?	DON'T CARE
;	BMP_MODE	DB	0	IF YOU DON'T WANT TO USE MODE LEAVE IT ZERO
;	TRANSPARENT	DB	???	IF YOU WANT TO USE TRANSPARENT COLOR YOU CAN SET IT
;OUTPUT:	NONE
;=============================================================================================
LOADBMP PROC
	PUSHA				;PUSH ALL GENERAL REGISTER
	PUSH	ES
	
;OPEN BMP FILE
	MOV	AX,3D00H
	MOV	DX,SI
	INT	21H
	JC	ERROR1
;SAVE_HANDLE	
	MOV	BMP_HANDLE,AX

MODE_0:					;NORMAL MODE
	CMP	BMP_MODE,0
	JNE	MODE_1_2
	CALL	READBMP		;READ HIEGHT AND WIDTH
	CALL	SETCOLOR	;SET COLOR REGISTER
	CALL	SHOWBMP		;DISPLAY PICTURE
	JMP	EXIT_BMP

MODE_1_2:				;FAST OR TRANSPARENT MODE
	CMP	BMP_MODE,1
	JB	MODE_3
	CMP	BMP_MODE,2
	JA	MODE_3
	CALL	READBMP		;READ HIEGHT AND WIDTH
;SEEK TO COLOR
	MOV	AX,4200H
	;MOV	BX,FILE_HANDLE
	XOR	CX,CX
	MOV	DX,1078D		; start at byte 1078
	INT	21H
	CALL	SHOWBMP
	JMP	EXIT_BMP
	
MODE_3:					;SET COLOR REGISTER ONLY MODE
	CMP	BMP_MODE,3
	JNE	EXIT_BMP
	CALL	SETCOLOR
	
EXIT_BMP:
	POP	ES
	POPA				;POP ALL GENERAL REGISTER
	RET
	
;CAN'T LOAD PIC!
ERROR1:
	MOV DL,'E'
	MOV AH,2
	INT 21H	
	JMP	EXIT_BMP
	
LOADBMP	ENDP

;==================================================
;READ BMP READ WIDTH AND HEIGHT
;==================================================	
READBMP	PROC
	
;SEEK TO WIDTH
	MOV	AX,4200H
	MOV	BX,BMP_HANDLE
	XOR	CX,CX
	MOV	DX,18D			; start at byte 18
	INT	21H
;READ WIDTH TO BUFFER AND SAVE TO BMP_WIDTH
	MOV	AH,3FH
	;MOV	BX,BMP_HANDLE
	MOV	CX,2
	LEA	DX,BMP_BUFFER
	INT	21H
	MOV	AX,WORD PTR BMP_BUFFER
	MOV	BMP_WIDTH,AX
	
;SEEK TO HEIGHT
	MOV	AX,4200H
	;MOV	BX,BMP_HANDLE
	XOR	CX,CX
	MOV	DX,22D			; start at byte 22
	INT	21H
;READ HEIGHT TO BUFFER AND SAVE TO BMP_HEIGHT
	MOV	AH,3FH
	;MOV	BX,BMP_HANDLE
	MOV	CX,2
	LEA	DX,BMP_BUFFER
	INT	21H
	MOV	AX,WORD PTR BMP_BUFFER
	MOV	BMP_HEIGHT,AX
	
	RET

READBMP	ENDP
	
;===========================================================
; READING IN THE COLOR PALETTE
;THIS CODE USE EFFECTIVE METHOD TO SET COLOR REGISTER
;BY NOT USE BIOS INTERRUPT BECAUSE IS VERY SLOW
;CHANGE TO USE OUT PORT DIRECTLY
;AND CALCULATE COLOR VALUE BY SHIFT BIT
;===========================================================
SETCOLOR	PROC
;SEEK TO COLOR
	MOV	AX,4200H
	MOV	BX,BMP_HANDLE
	XOR	CX,CX
	MOV	DX,54D			; start at byte 54 
	INT	21H
				
;READ 4 BYTES FROM BMP FILE TO BUFFER
	MOV	AH,3FH
	;MOV	BX,BMP_HANDLE
	MOV	CX,1024
	LEA	DX,BMP_BUFFER
	INT	21H
		
	MOV	AL,0				
	MOV	DX,3C8H				;SAVE PORT NUMBER IN DX
	OUT	DX,AL				;SEND START COLOR CODE
	
	LEA	SI,BMP_BUFFER
	MOV	DX,3C9H
	MOV	CX,256
COLOR_LOOP:
	MOV	AL,[SI + 2]
	SHR	AL,2				;DIVIDE AL BY 2*2
	OUT	DX,AL
	MOV	AL,[SI + 1]
	SHR	AL,2				;DIVIDE AL BY 2*2
	OUT	DX,AL
	MOV	AL,[SI + 0]
	SHR	AL,2				;DIVIDE AL BY 2*2
	OUT	DX,AL
	ADD	SI,4
	LOOP	COLOR_LOOP		
; PALETTE READ END	
	RET
	
SETCOLOR	ENDP

;===========================================================================
;CALCULATE POSITION FOR POINT TO START DRAW PICTURE 
;AND CHECK FOR BLANK PIXEL FOR DISPLAY PICTURE CORRECTLY
;===========================================================================
SHOWBMP	PROC
	MOV	AX, 0A000h		;START ADDRESS OF VGA BUFFER MEMORY
	MOV	ES, AX			;ES PONIT TO SCREEN SEGMENT
	
	MOV	AX,BMP_Y1
	ADD AX,BMP_HEIGHT
	MOV	BMP_Y2,AX		;DRAW PIC FROM BOTTOM
	
;COMPUTE BLANK PIXEL
	MOV	AX,BMP_WIDTH
	AND	AX,03H			;AX MOD 4
	CMP	AX,0			;MOD 4 = 0?
	JNE	SET_BMP_BLANK	;NO
	MOV	BMP_BLANK,0		;YES, SKIP WIDTH = 0
	JMP	SHOW_LOOP
SET_BMP_BLANK:
	MOV	BMP_BLANK,AX	
	MOV AX,4			
	SUB AX,BMP_BLANK	;HOW MANY BYTES TO SKIP?
	MOV BMP_BLANK,AX	;SAVE IT

;===========================================================
;LOAD COLUMN OF PICTURE AND PUT TO SCREEN
;READ ALL PIXEL IN 1 LINE OF PIC FOR FAST DISPLAY
;===========================================================
SHOW_LOOP:
	
	MOV	AH,3FH
	MOV	BX,BMP_HANDLE
	LEA	DX,BMP_BUFFER
	MOV	CX,BMP_WIDTH	;READ 1 LINE OF PIC
	INT	21H
	
	LEA	SI,BMP_BUFFER	;SI POINT TO BMP_BUFFER
	
;CALCULATE SCREEN OFFSET
Y_OFFSET:
	XOR	DX,DX			;CLEAR FOR USE TO DEFINE BANK NUMBER
	MOV	AX,640			;CALCULATE ROW
	MUL	BMP_Y2			;MUL AX BY Y,RESULT HIGH WORD IN DX,LOW WORD IN AX
	ADD	AX,BMP_X1		;ADD X  CORDINATE
						;offset = (x*s)+(y*(640*s))
	MOV	DI,AX			;DI POINT TO SCREEN OFFSET
	
	CMP	BMP_MODE,1
	JG	BMP_TRANSPARENT		
BMP_NORM:
	CALL	PUTPIXEL_NORM

	JMP		NEXT_LINE
	
BMP_TRANSPARENT:	
	CMP	BMP_MODE,2
	JNE	BMP_CLOSE
	CALL	PUTPIXEL_TRAN	
	JMP	NEXT_LINE
	
NEXT_LINE:
	CMP	BMP_BLANK,0
	JE	NO_BLANK
	MOV AX,4201H
	XOR CX,CX
	MOV DX,BMP_BLANK
	INT	21H
NO_BLANK:	
	DEC	BMP_Y2			;DISPLAY UPPER LINE	
	MOV	AX,BMP_Y2
	CMP	AX,BMP_Y1		;TOP LINE?
	JA	SHOW_LOOP		;NO SHOW NEXT LINE
	
;====================================================
;DISPLAY PICTURE COMPLETE!
;====================================================
;CLOSE BMP FILE
BMP_CLOSE:
	MOV	AH,3EH
	MOV	BX,BMP_HANDLE
	INT	21H
	
	RET
	
SHOWBMP	ENDP

;==========================================================================================
;Normal putpixel to scrren by load 1 byte from BMP_BUFFER to VGA segment
;==========================================================================================
PUTPIXEL_NORM	PROC
X_OFFSET_N:	
	JNC	NO_INC_BANK_N	;CHECK FOR CARRY OUT FROM AX
	INC	DX				;INCREMENT BANK NUMBER
NO_INC_BANK_N:
	CMP	DL,BMP_BANK		;CHAECK CURENT BANK NUMBER WITH BMP_BANK
	JE	NO_CHANGE_BANK_N	;BANK NOT FULL NOT CHANGE BANK
	MOV	BMP_BANK,DL		;KEEP CURRENT BANK IN NBANK
	PUSH	AX
	MOV	AX,4F05H		;CALL FUNCTION BANK SELECT
	XOR	BX,BX			;RESEVRE MUST BE 0
	INT	10H				;SET BANK NUMBER
	POP	AX
	
NO_CHANGE_BANK_N:
	MOVSB				;MOV	ES:[DI],DS[SI] AND INC SI,DI
	
	ADD	AX,1
	LOOP	X_OFFSET_N
						;DISPLAY 1 LINE COMPLETE
	RET
	
PUTPIXEL_NORM	ENDP

;======================================================================================================
;Fast putpixel to scrren by load 1 Byte from BMP_BUFFER and check transparent for skip put to VGA segment
;======================================================================================================
PUTPIXEL_TRAN	PROC	
X_OFFSET_T:	
	JNC	NO_INC_BANK_T	;CHECK FOR CARRY OUT FROM AX
	INC	DX				;INCREMENT BANK NUMBER
NO_INC_BANK_T:
	CMP	DL,BMP_BANK		;CHAECK CURENT BANK NUMBER WITH BMP_BANK
	JE	NO_CHANGE_BANK_T	;BANK NOT FULL NOT CHANGE BANK
	MOV	BMP_BANK,DL		;KEEP CURRENT BANK IN NBANK
	PUSH	AX
	MOV	AX,4F05H		;CALL FUNCTION BANK SELECT
	XOR	BX,BX			;RESEVRE MUST BE 0
	INT	10H				;SET BANK NUMBER
	POP		AX
	
NO_CHANGE_BANK_T:
	MOV	BX,AX
	LODSB				;MOV	AL,DS:[SI] ,AND INC SI
	CMP	AL,TRANSPARENT
	JNE	PUT_PIXEL
	INC	DI				;MANUAL INC DI
	JMP	SKIP_PIXEL

PUT_PIXEL:	
	STOSB				;MOV ES:[DI],AL ,AND INC DI
	
SKIP_PIXEL:	
	MOV	AX,BX
	ADD	AX,1
	LOOP	X_OFFSET_T
						;DISPLAY 1 LINE COMPLETE
	RET
	
PUTPIXEL_TRAN	ENDP