;==============================================================================
;PROC FOR SHOW PICTURE(.BMP) 
;==================================================
;MODIFIER CODE TO NEW VERSION BY RUNG CSs13
;KNOW ISSUE!!!
;1. SOME SMALL PICTURE DISPLAY INCORRECT
;2. SOME POSITION OF PICTURE DISPLAY INCORRECT
;==================================================
;ÔÔÔTHIS PROC IS FOR 320 * 200(MODE 13H) IN 256 COLORS ONLYÔÔÔ
;INPUT:	BMP_FILENAME(LEA SI,FILENAME)
;	BMP_HANDLE	DW	?	DON'T CARE
;	BMP_WIDTH	DW 	?	DON'T CARE
;	BMP_HEIGHT	DW	?	DON'T CARE
;	BMP_BUFFER  	DB 	320 DUP(?)	DON'T CARE
;	BMP_X		DW	?	X POSITION OF BMP 
;	BMP_Y		DW	?	Y POSITION OF BMP
;	COUNTCOLOR	DB	?	DON'T CARE
;	x			DW	?	DON'T CARE
;	Y			DW	?	DON'T CARE
;	RGB			DB	?	DON'T CARE
;OUTPUT:NONE
;==============================================================================
LOADBMP PROC
	PUSHA				;PUSH ALL GENERAL REGISTER
	
;OPEN BMP FILE
	MOV	DX,SI
	MOV	AX,3D00H
	INT	21H
	JC	ERROR1
;SAVE_HANDLE	
	MOV	BMP_HANDLE,AX
	
	CALL	READBMP		;READ HIEGHT AND WIDTH
	CALL	SETCOLOR	;SET COLOR REGISTER
	CALL	SHOWBMP		;DISPLAY PICTURE

EXIT_BMP:
	POPA				;POP ALL GENERAL REGISTER
	RET
	
;CAN'T LOAD PIC!
ERROR1:
	MOV DL,'E'
	MOV AH,2
	INT 21H	
	JMP	EXIT_BMP
	
LOADBMP	ENDP

;===============================================================
;Fast load bmp by cut set register color for fast operation
;but msut normal loadbmp before and picture must use same color table
;===============================================================
FLOADBMP PROC
	PUSHA				;PUSH ALL GENERAL REGISTER
	
;OPEN BMP FILE
	MOV	DX,SI
	MOV	AX,3D00H
	INT	21H
	JC	FERROR1
;SAVE_HANDLE	
	MOV	BMP_HANDLE,AX
	
	CALL	READBMP		;READ HIEGHT AND WIDTH
	;CALL	SETCOLOR	;SET COLOR REGISTER
;SEEK TO COLOR
	MOV	AX,4200H
	;MOV	BX,FILE_HANDLE
	XOR	CX,CX
	MOV	DX,1078D			; start at byte 1078
	INT	21H
	CALL	SHOWBMP		;DISPLAY PICTURE

FEXIT_BMP:
	POPA				;POP ALL GENERAL REGISTER
	RET
	
;CAN'T LOAD PIC!
FERROR1:
	MOV DL,'E'
	MOV AH,2
	INT 21H	
	JMP	EXIT_BMP
	
FLOADBMP	ENDP

CLOADBMP	PROC
	PUSHA				;PUSH ALL GENERAL REGISTER
	
;OPEN BMP FILE
	MOV	AX,3D00H
	MOV	DX,SI
	INT	21H
	JC	CERROR1
;SAVE_HANDLE	
	MOV	BX,AX
	
	;CALL	READBMP		;READ HIEGHT AND WIDTH
	CALL	SETCOLOR	;SET COLOR REGISTER

CEXIT_BMP:
	POPA				;POP ALL GENERAL REGISTER
	RET
	
;CAN'T LOAD PIC!
CERROR1:
	MOV DL,'E'
	MOV AH,2
	INT 21H	
	JMP	CEXIT_BMP
	
CLOADBMP	ENDP

;==================================================
;READ BMP READ WIDTH AND HEIGHT
;==================================================	
READBMP	PROC
	
;SEEK TO WIDTH
	MOV	AX,4200H
	MOV	BX,BMP_HANDLE
	XOR	CX,CX
	MOV	DX,18D			; start at byte 18
	INT	21H
;READ WIDTH TO BUFFER AND SAVE TO BMP_WIDTH
	MOV	AH,3FH
	;MOV	BX,FILE_HANDLE
	MOV	CX,2
	LEA	DX,BMP_WIDTH
	INT	21H
	;MOV	AX,WORD PTR BMP_BUFFER
	;MOV	BMP_WIDTH,AX
	
;SEEK TO HEIGHT
	MOV	AX,4200H
	;MOV	BX,FILE_HANDLE
	XOR	CX,CX
	MOV	DX,22D			; start at byte 22
	INT	21H
;READ HEIGHT TO BUFFER AND SAVE TO BMP_HEIGHT
	MOV	AH,3FH
	;MOV	BX,FILE_HANDLE
	MOV	CX,2
	LEA	DX,BMP_HEIGHT
	INT	21H
	;MOV	AX,WORD PTR BMP_BUFFER
	;MOV	BMP_HEIGHT,AX
	
	RET

READBMP	ENDP
	
;===========================================================
; READING IN THE COLOR PALETTE
;THIS CODE USE EFFECTIVE METHOD TO SET COLOR REGISTER
;BY NOT USE BIOS INTERRUPT BECAUSE IS VERY SLOW
;CHANGE TO USE OUT PORT DIRECTLY
;AND CALCULATE COLOR VALUE BY SHIFT BIT
;===========================================================
SETCOLOR	PROC
;SEEK TO COLOR
	MOV	AX,4200H
	;MOV	BX,BMP_HANDLE
	XOR	CX,CX
	MOV	DX,54D			; start at byte 54 
	INT	21H
				
COLOR_LOOP:
;READ 4 BYTES FROM BMP FILE TO BUFFER
	MOV	AH,3FH
	;MOV	BX,BMP_HANDLE
	MOV	CX,4
	LEA	DX,BMP_BUFFER
	INT	21H
		
	MOV	AL,COUNTCOLOR
	MOV	DX,3C8H				;SAVE PORT NUMBER IN DX
	OUT	DX,AL
	MOV	AL,BYTE PTR [BMP_BUFFER + 2]
	SHR	AL,2				;DIVIDE AL BY 2*2
	MOV	DX,3C9H
	OUT	DX,AL
	MOV	AL,BYTE PTR [BMP_BUFFER + 1]
	SHR	AL,2				;DIVIDE AL BY 2*2
	OUT	DX,AL
	MOV	AL,BYTE PTR [BMP_BUFFER + 0]
	SHR	AL,2				;DIVIDE AL BY 2*2
	OUT	DX,AL
	CMP	COUNTCOLOR,255
	INC	COUNTCOLOR
	JB	COLOR_LOOP		        	
; PALETTE READ END	
	RET
	
SETCOLOR	ENDP

;============================================================
;CALCULATE POSITION FOR POINT TO START DRAW PICTURE 
;============================================================
SHOWBMP	PROC	
	
	MOV	AX, 0A000h		;START ADDRESS OF VGA BUFFER MEMORY
	MOV	ES, AX			;ES PONIT TO SCREEN SEGMENT
	
	MOV	AX,BMP_Y
	ADD AX,BMP_HEIGHT
	MOV	Y,AX			;DRAW PIC FROM BOTTOM
	
	;CMP	BMP_WIDTH,320	;CHECK PIC WIDTH MORE THAN 320
	;JLE	SHOW_LOOP1		;IF LOWER SHOW PIC
	;MOV	BMP_WIDTH2,320	;IF MORE THAN LOAD ONLY 320
	
;===========================================================
;LOAD COLUMN OF PICTURE AND PUT TO SCREEN
;READ ALL PIXEL IN 1 LINE OF PIC FOR FAST DISPLAY
;===========================================================	
SHOW_LOOP1:
	
	MOV	AH,3FH
	MOV	BX,BMP_HANDLE
	LEA	DX,BMP_BUFFER
	MOV	CX,BMP_WIDTH	;READ 1 LINE OF PIC
	INT	21H
	
	XOR	BX,BX		;CLEAR BX FOR COUNT BMP_BUFFER
	
;CALCULATE SCREEN OFFSET
	MOV	AX, 320		;CALCULATE ROW
	MUL	Y			;MUL AX BY Y,RESULT HIGH WORD IN DX,LOW WORD IN AX
	ADD	AX,BMP_X	;ADD X  CORDINATE
	MOV	DI,AX		;POINT DI TO SCREEN OFFSET
		
SHOW_LOOP2:
	MOV	AL,BYTE PTR [BMP_BUFFER + BX]
	CMP	AL,TRANSPARENT	;IT TRANSPARENT COLOR?
	JNE	PUTPIXEL		;YES,PUTPIXEL!
	INC	DI				;IF SKIP COLOR MUST INC DI
	JMP	SKIP_COLOR
	
PUTPIXEL:
	STOSB				;MOV ES:[DI],AL AND INC DI

SKIP_COLOR:
	;INC	X
	INC BX				;POINT TO NEXT PIXEL
	CMP	BX,BMP_WIDTH	;LAST PIXEL OF LINE?
	JB	SHOW_LOOP2		;NO SHOW NEXT PIXEL OF LINE
						;DISPLAY 1 LINE COMPLETE
	DEC	Y				;DISPLAY UPPER LINE	
	MOV	AX,Y
	CMP	AX,BMP_Y		;TOP LINE?
	JA	SHOW_LOOP1		;NO SHOW NEXT LINE
	
;====================================================
;DISPLAY PICTURE COMPLETE!
;====================================================
;CLOSE BMP FILE
	MOV	AH,3EH
	MOV	BX,BMP_HANDLE
	INT	21H
	
	RET
	
SHOWBMP	ENDP