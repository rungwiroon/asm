
SETUP_INT	PROC
;SAVES OLD VECTOR AND SETS UP NEW VECTOR
;INPUT  AL = INTERRUPT TYPE
;	DI = ADDRESS OF BUFFER FOR OLD VECTOR
;	SI = ADDRESS OF BUFFER CONTAINING NEW VECTOR
;SAVE OLD INTERRUPT VECTOR
	PUSH	ES
 	MOV	AH,35H		;FUNCTION 35H, GET VECTOR
	INT	21H		;ES:BX = VECTOR
	MOV	[DI],BX		;SAVE OFFSET
	MOV	[DI+2],ES	;SAVE SEGMENT
;SETUP NEW VECTOR
	MOV	DX,[SI]		;DX HAS OFFSET
	PUSH	DS		;SAVE IT
	MOV	DS,[SI+2]	;DS HAS SEGMENT NUMBER
	MOV	AH,25H		;FUNCTION 25H, SET VECTOR
	INT	21H		
	POP	DS		;RESTORE DS
	POP	ES		;RESTORE ES
	RET
SETUP_INT	ENDP

KEYBOARD_INT	PROC
	;PUSHF	;NOT NEED 
	PUSHA
	; PUSH	DS
	; MOV	AX,SEG DOKEYS
	; MOV	DS,AX
	
	; CMP	BYTE PTR DOKEYS, 1
	; JNE	ENDOFI
	
	LEA	SI, ONKEYS

	XOR	AX, AX
	IN	AL, 60H
	MOV	BL, AL
	AND	BL, 127
	CMP	BL, 60H      ; EXTENDED?
	JNE	NOEX
	IN	AL, 60H
	INC	SI	      ; SHIFT IN MAP TO EXTENDED BYTE
NOEX:
	MOV	BL, AL
	AND	AL, 127		; CLEAR ON/OFF
	MOV	FS:LASTKEY, AX	; KEEP AL
	SHL	AX, 1		; TWO BYTES PER INDEX (NORMAL/EXTENDED)
	ADD	SI, AX
	NOT	BL
	SHR	BL, 7	      ; SET TO 0/1
	MOV	FS:[SI], BL   ; WRITE ON/OFF
	
ENDOFI:
	CLI
	MOV	AX, 20H
	OUT	20H, AL	; SEND EOI
	STI

	;POP	DS
	POPA
	;POPF
	IRET	;RESTORE CS:IP AND FLAG
KEYBOARD_INT	ENDP

;==========================================================
;SHOW TIME HR:MIN:SEC
;==========================================================
TIME_INT	PROC
;INTERRUPT PROCEDURE
;ACTIVATED BY THE TIMER
	;PUSH	DS		;SAVE CURRENT DS
	;MOV	AX,@DATA	;SET IT TO DATA SEGMENT
	;MOV	DS,AX
;GET NEW TIME
	LEA	BX,TIME_BUF	;BX POINTS TIME BUFFER
	CALL	GET_TIME	;STORE TIME IN BUFFER
	;CALL	COUNT_TIME
;DISPLAY TIME
	GOTOXY	63,24
	LEA	DX,TIME_BUF	;DX POINTS TO TIME_BUF
	MOV	AH,09H		;DISPLAY STRING
	INT	21H
;RESTORE CURSOR POSITION
	;MOV	AH,2		;FUNCTION 2, MOVE CURSOR
	;MOV	BH,0		;PAGE 0
	;MOV	DX,CURSOR_POS	;CURSOR POSITION,DH=ROW,DL=COL
	;INT	10H		;
	;POP	DS		;RESTORE DS
	RET
TIME_INT	ENDP		;END OF INTERRUPT PROCEDURE

GET_TIME        PROC
;GET TIME OF DAY AND STORE ASCII DIGITS IN TIME BUFFER
;INPUT:  BX = ADDRESS OF TIME BUFFER
        MOV     AH,2CH          ;GETTIME
        INT     21H             ;CH = HR, CL =  MIN, DH = SEC, DL = MSEC
;CONVERT HOURS INTO ASCII AND STORE
        MOV     AL,CH           ;HOUR
        CALL    CONVERT         ;CONVERT TO ASCII
        MOV     [BX],AX         ;STORE
;CONVERT MINUTES INTO ASCII AND STORE
        MOV     AL,CL           ;MINUTE
        CALL    CONVERT         ;CONVERT TO ASCII
        MOV     [BX+3],AX       ;STORE
;CONVERT SECONDS INTO ASCII AND STORE
        MOV     AL,DH           ;SECOND
        CALL    CONVERT         ;CONVERT TO ASCII
        MOV     [BX+6],AX       ;STORE
        RET
GET_TIME        ENDP

CONVERT PROC
;CONVERTS BYTE NUMBER (0-59) INTO ASCII DIGITS
;INPUT: AL = NUMBER
;OUTPUT: AX = ASCII DIGITS, AL = HIGH DIGIT, AH = LOW DIGIT

        MOV     AH,0            ;CLEAR AH
        MOV     DL,10           ;DIVIDE AX BY 10
        DIV     DL              ;AH HAS REMAINDER, AL HAS QUOTIENT
        OR      AX,3030H        ;CONVERT TO ASCII, AH HAS LOW DIGIT
        RET                     ;AL HAS HIGH DIGIT
CONVERT ENDP
	
;===========================================
;PRINTS AX AS A UNSIGNED DECIMAL INTEGER
;INPUT: AX
;OUTPUT : NONE
;=========================================
OUTDEC PROC
	PUSHA

	;OR	AX,AX
	;JGE	@END_IF1

	;PUSH	AX
	;MOV	DL,'-'
	;MOV	AH,2
	;INT	21H
	;POP	AX
	;NEG	AX

@END_IF1:
	XOR	CX,CX
	MOV	BX,10D

@REPEAT1:
	XOR	DX,DX
	DIV	BX
	PUSH	DX
	INC	CX
	OR	AX,AX
	JNE	@REPEAT1

	;MOV	AH,2

@PRINT_LOOP:
	POP	DX
	OR	DL,30H
	;INT	21H
	PUT_CHR	DL,1
	LOOP	@PRINT_LOOP

	POPA
	
	RET
OUTDEC ENDP



WAIT_RETRACE	PROC
	MOV     DX,03DAH        ; DX = IS1 PORT, WAITING FOR RETRACE
V_1:
    IN      AL,DX           ; WAIT FOR BIT 3 TO GO OFF (ACTIVE PERIOD)
    TEST    AL,8
    JNZ     V_1
V_2:
    IN      AL,DX           ; WAIT FOR BIT 3 TO COME ON (RETRACE PERIOD)
    TEST    AL,8
    JZ      V_2
    RET                     ; RETURN
WAIT_RETRACE	ENDP

		