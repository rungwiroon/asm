COUNT_TIME	PROC
	MOV 	AH,2CH		;GETTIME
    INT	21H     	;CL = min, DH = SEC

	CMP	CT_RESET,1
	JNE	@CT_CHECK_TIME

@CT_RESET_TIME:
	MOV	CT_SEC,0
	MOV	CT_MIN,0
	MOV	CT_LAST_SEC,DH
	MOV	CT_RESET,0

@CT_CHECK_TIME:	
	CMP	DH,CT_LAST_SEC
	MOV	CT_LAST_SEC,DH
	JE	@CT_RET

@CT_INC_SEC:	
	INC	CT_SEC
	CMP	CT_SEC,60
	JNE	@CT_CHECK_SS
	MOV	CT_SEC,0

@CT_INC_MIN:
	INC	CT_MIN
	
@CT_CHECK_SS:
	MOV	AL,CT_SEC
	CMP	SS_SEC,AL
	JNE	@CT_RET
	
	MOV	AL,CT_MIN
	CMP	SS_MIN,AL
	JNE	@CT_RET
		
	MOV	SS_FLAG,1
		
@CT_RET:	
	RET
COUNT_TIME	ENDP

SHOW_TIME	PROC
	LEA	BX,TIME_STR
	
	MOV	AL,CT_SEC
	CALL	CONVERT
	MOV	[BX+3],AX

	MOV	AL,CT_MIN
	CALL	CONVERT
	MOV	[BX],AX
	
	GOTOXY	0,0
	MOV	AH,09
	LEA	DX,TIME_STR
	INT	21H
	
	RET
SHOW_TIME	ENDP

SCR_SAVER	PROC
	MOV	DL,07
	MOV	AH,02
	INT	21H

@SS_LOOP:
	CBUF	BUFFER1,BUFFER2
	;LOAD WHAT YOU WANT HERE!
	;MOVOBJ2	OBJ3_X,OBJ3_Y,0,0,90,0,6,OBJ3_D,GAUGE
	LBTS	BUFFER2
	;CALL	OBJ_SCREEN
	CALL	WAIT_RETRACE
	
@SS_CHECK_KEY:
	MOV	AH,01
	INT	16H
	JZ	@SS_LOOP	
	
	MOV	SS_FLAG,0
	RET

SCR_SAVER	ENDP

;
CONVERT PROC
;CONVERTS BYTE NUMBER (0-59) INTO ASCII DIGITS
;INPUT: AL = NUMBER
;OUTPUT: AX = ASCII DIGITS, AL = HIGH DIGIT, AH = LOW DIGIT
        MOV     AH,0            ;CLEAR AH
        MOV     DL,10           ;DIVIDE AX BY 10
        DIV     DL              ;AH HAS REMAINDER, AL HAS QUOTIENT
        OR      AX,3030H        ;CONVERT TO ASCII, AH HAS LOW DIGIT
        RET                     ;AL HAS HIGH DIGIT
CONVERT ENDP
