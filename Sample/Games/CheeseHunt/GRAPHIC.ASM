
	PUBLIC	BTB,CBMP,BTA,ATB
	PUBLIC	BUFFER_TO_SCREEN,COPY_BUFFER,CLEAR_BUFFER
	PUBLIC	OBJECT_BOUND_INTERSECT
	PUBLIC	BMP_X,BMP_Y
	PUBLIC	COLLISION_FLAG

.MODEL	SMALL
.586
.STACK 100H

;====================================================
;		TYPEDEF
;====================================================
PBYTE	TYPEDEF	FAR PTR BYTE
LPBYTE	TYPEDEF	FAR PTR BYTE
PWORD	TYPEDEF	FAR PTR WORD
LPWORD	TYPEDEF	FAR PTR WORD
PNEAR	TYPEDEF	NEAR PTR
PFAR	TYPEDEF	FAR PTR
PSTR	TYPEDEF	NEAR PTR SBYTE
LPSTR	TYPEDEF	FAR PTR SBYTE
PVOID	TYPEDEF	NEAR PTR
LPVOID	TYPEDEF	FAR PTR 


;====================================================
;		CONSTANT
;====================================================
INCLUDE	CONSTANT.ASM	

;====================================================
;		STRUCTURE
;====================================================
_POINT	STRUC
	X	DW	?
	Y	DW	?
_POINT	ENDS

_SIZE	STRUC
	W	DW	?
	H	DW	?
_SIZE	ENDS

_SPEED	STRUC
	X	DW	?
	Y	DW	?
_SPEED	ENDS


BITMAP	STRUC
	B_SIZE	_SIZE	{}
	B_BYTE	DB	?
BITMAP	ENDS

SPRITE	STRUC
	S_POINT		_POINT	{}
	S_SPEED		_SPEED	{}
	S_FLAG		DB	?
	S_PBITMAP	LPVOID	?
SPRITE	ENDS

PLANE	STRUC
	P_POINT	_POINT	{}
	LEN	DW	?
PLANE	ENDS

;================================================
;		MACRO
;================================================
;OPEN FILE
F_OPEN	MACRO	FILENAME
	MOV	AX,3D00H
	LEA	DX,FILENAME
	INT	21H
ENDM


;CLOSE FILE
F_CLOSE	MACRO	HANDLE
	MOV	AX,3E00H
	MOV	BX,HANDLE
	INT	21H
ENDM


;SEEK FILE
F_SEEK	MACRO	@OFFSET,HANDLE
	MOV	AX,4200H
	MOV	BX,HANDLE
	XOR	CX,CX
	MOV	DX,@OFFSET
	INT	21H
ENDM

;READ FILE
F_READ	MACRO	BUFFER,COUNT,HANDLE
	MOV	AH,3FH
	MOV	BX,HANDLE
	MOV	CX,COUNT
	LEA	DX,BUFFER
	INT	21H
ENDM

;CALCULATE SCREEN OFFSET 
;INPUT X,Y
;OUTPUT OFFSET IN DI
SCR_OFFSET	MACRO	X,Y
	MOV	AX,Y
	MOV	DI,AX
	SHL	DI,8   	;DI:=DI*256 
	SHL	AX,6	;AX:=AX*64 
	ADD	DI,AX	;DI := (Y*256)+(Y*64) := Y*320
	ADD	DI,X
ENDM

;FIND NUMBER OF BLANK PIXEL PER LINE
BMP_BLANK	MACRO WIDTH1, WIDTH2, BLANK
	LOCAL	ADD_BLANK, NO_BLANK

	MOV	AX,WIDTH1
	TEST	AX,03H		;AX MOD 4
	JNZ	ADD_BLANK	;MOD 4 = 0?
	MOV	WIDTH2,AX	;YES, SKIP WIDTH = 0
	MOV	BLANK,0
	JMP	NO_BLANK

ADD_BLANK:
	SHR	AX,2		;DIVIDE BY 4 FOR CHANGE WORD
	INC	AX		;INC WORD
	SHL	AX,2		;MUL BY 4 TO BYTE
	MOV	WIDTH2,AX	
	SUB	AX,WIDTH1
	MOV	BLANK,AX
NO_BLANK:
ENDM

SEEK_BITMAP	MACRO	HANDLE
	LOCAL	START
	JMP	START
	
	TEMP	DW	?
	
START:	
	;FOR SEEK TO START OFFSET OF BITMAP DATA
	F_SEEK 10D,BMP_HANDLE	
	;READ OFFSET OF BITMAP DATA 
	PUSH	DS
	PUSH	CS
	POP	DS
	F_READ	TEMP,2,BMP_HANDLE
	POP	DS
	MOV	DX,TEMP	
	;SEEK TO BITMAP DATA
	F_SEEK DX,BMP_HANDLE
ENDM

;LOAD SEGMENT TO DS ES
LD_DS	MACRO	@SEGMENT
	PUSH	@SEGMENT
	POP	DS
ENDM

LD_ES	MACRO	@SEGMENT
	PUSH	@SEGMENT
	POP	ES
ENDM

;ADD 2 MEM 
ADD_MEM	MACRO	VALUE1,VALUE2
	MOV	AX,VALUE1
	ADD	AX,VALUE2
ENDM

;FIND MAX MIN VALUE
;	INPUT 	2 VALUE
;	OUTPUT 	AX
MAX	MACRO	VALUE1,VALUE2
	LOCAL	EXIT
	MOV	AX,VALUE1
	CMP	AX,VALUE2
	JG	EXIT
	MOV	AX,VALUE2	
EXIT:
	
ENDM

MIN	MACRO	VALUE1,VALUE2
	LOCAL	EXIT
	MOV	AX,VALUE1
	CMP	AX,VALUE2
	JL	EXIT
	MOV	AX,VALUE2	
EXIT:	
ENDM

BEEP	MACRO
	PUSH	AX
	PUSH	DX
	
	MOV	AH,02H
	MOV	DL,07H
	INT	21H
	
	POP	DX
	POP	AX
ENDM


.DATA
;======================================================
;		GLOBAL VARIABLE
;======================================================
COLLISION_FLAG	DB	0

BMP_X		DW	?	;X POSITION OF BMP (0-319)
BMP_Y		DW	?	;Y POSITION OF BMP (0-199)
BMP_WIDTH	DW 	?	;PICTURE WIDTH	
BMP_HEIGHT	DW	?	;PICTURE HEIGHT

BMP_X2		DW	?
BMP_Y2		DW	?
BMP_WIDTH2	DW	?
BMP_HEIGHT2	DW	?

BMP_HANDLE	DW	?	;SAVE BMP FILE HANDLE
BMP_BLK		DW	0	;BLANK PIXEL
BMP_BUFFER	DB 	1024 DUP(?)	;BUFFER PIXEL

.CODE

;========================================================
;		PROCEDURE
;	PASSING DATA BY GLOBAL VAR
;========================================================
;LOAD BITMAP FROM BMP FILE TO BUFFER
;INPUT 
;	BMP_X	X POS
;	BMP_Y	Y POS
;	SI	OFFSET OF FILE LOCATION STRING
;	ES	SEGMENT
;OUTPUT
;	DRAW BITMAP TO SEGMNET
BTB	PROC	;BMP TO BUFFER

	CALL	OPEN_BMP_FILE
	JC	@BTB_EXIT
	CALL	READ_BMP_FILE	;READ HEIGHT AND WIDTH
	CALL	FILE_TO_BUFFER	;LOAD TO BUFFER SEGMENT
		
@BTB_EXIT:
	RET
	
BTB	ENDP


;LOAD COLOR TABLE FROM BMP FILE TO VGA DAC
;INTPUT
;	SI	OFFSET OF FILE LOCATION STRING 
;OUTPUT
;	COLOR REGISTER 
CBMP	PROC	;LOAD COLOR TO DAC
	CALL	OPEN_BMP_FILE
	JC	@C_EXIT
	CALL	SETCOLOR
@C_EXIT:
	RET
CBMP	ENDP



;LOAD BITMAP DATA FROM FILE TO ARRAY
;INPUT
;	SI	OFFSET OF FILE LOCATION STRING 
;	DI	OFFSET OF ARRAY
;OUTPUT
;	BITMAP DATA ARRAY
BTA	PROC	;BMP TO ARRAY
	;PUSH	0A000H	;TEST LOAD BMP ARRAY
	
	PUSH	DS
	POP	ES
	
	CALL	OPEN_BMP_FILE
	JC	@BTA_EXIT
	CALL	READ_BMP_FILE	;READ HIEGHT AND WIDTH
	CALL	FILE_TO_ARRAY	;LOAD TO BUFFER SEGMENT

@BTA_EXIT:
	RET
	
BTA	ENDP


;LOAD BITMAP DATA FROM ARRAY TO SPECIFIC SEGMENT
;INPUT
;	SI	OFFSET OF ARRAY
;	ES	DESTINATION SEGMENT
;OUTPUT
;	DATA IN DESTINATION SEGMENT
ATB	PROC	;ARRAY TO BUFFER
	TEST	[SI + FLAG_OFFSET], V_MASK
	JZ	@ATB_EXIT
	CALL	READ_OBJECT	;READ HIEGHT AND WIDTH	
	CALL	ARRAY_TO_BUFFER	;LOAD TO BUFFER SEGMENT

@ATB_EXIT:
	RET
	
ATB	ENDP


;OPEN BMP FILE
;INPUT
;	SI	OFFSET OF FILE LOCATION STRING 
;OUTPUT
;	AX	FILE HANDLE
;	BMP_HANDLE	FILE HANDLE
OPEN_BMP_FILE PROC
	F_OPEN	[SI]
	JNC	SAVE_HANDLE
	
	MOV	DL,'E'
	MOV	AH,2
	INT	21H	
	
SAVE_HANDLE:	
	MOV	BMP_HANDLE,AX
	
	RET
OPEN_BMP_FILE	ENDP



;READ BIMAP FILE HAEDER WIDTH AND HEIGHT
;INPUT
;	BMP_HADLE	FILE HANDLE
;OUTPUT
;	BMP_WIDTH	WIDTH
;	BMP_HEIGHT	HEIGHT			
READ_BMP_FILE	PROC
	
	F_SEEK	18D,BMP_HANDLE		;SEEK TO WIDTH
	F_READ	BMP_BUFFER,6,BMP_HANDLE	;READ WIDTH TO BUFFER
	MOV	AX,WORD PTR BMP_BUFFER[0]
	MOV	BMP_WIDTH,AX		;SAVE TO BMP_WIDTH
	MOV	AX,WORD PTR BMP_BUFFER[4]
	MOV	BMP_HEIGHT,AX		;SAVE TO BMP_HEIGHT

	; MOV	BMP_WIDTH,320
	; MOV	BMP_HEIGHT,200
	
	RET

READ_BMP_FILE	ENDP


;READ X, Y ,WIDTH, HEIGHT FROM SPRITE OBJECT
;INPUT
;	SI	OFFSET OF OBJECT
;OUTPUT	
;	BMP_X		X
;	BMP_Y		Y
;	BMP_WIDTH	WIDTH
;	BMP_HEIGHT	HEIGHT
READ_OBJECT	PROC	

	LODSD
	MOV	DWORD PTR [BMP_X],EAX	;SAVE X,Y BY OVERIDE 
	
	MOV	SI,[SI+PTR_OFFSET-4]

	LODSD
	MOV	DWORD PTR [BMP_WIDTH],EAX ;SAVE W, H BY OVERIDE
	
	RET

READ_OBJECT	ENDP

;READ BMP READ WIDTH AND HEIGHT
;READ BIMAP FILE HAEDER WIDTH AND HEIGHT
;INPUT
;	OBJECT	OBJECT ADDRESS
;OUTPUT
;	AX	WIDTH
;	BX	HEIGHT		

	

;READING IN THE COLOR PALETTE
;THIS CODE USE EFFECTIVE METHOD TO SET COLOR REGISTER
;BY NOT USE BIOS INTERRUPT BECAUSE IS VERY SLOW
;CHANGE TO USE OUT PORT DIRECTLY
;AND CALCULATE COLOR VALUE BY SHIFT BIT
SETCOLOR	PROC FAR
;FIND NUMBER OF COLOR
	;FOR SEEK TO START OFFSET OF BITMAP DATA
	F_SEEK	10D,BMP_HANDLE
	
	;READ OFFSET OF BITMAP DATA 
	F_READ	BMP_BUFFER,2H,BMP_HANDLE
	MOV	DX,WORD PTR BMP_BUFFER[0]
	
	SUB	DX,54D
	PUSH	DX	;SAVE COLOR PALETTE SIZE
	
	;SEEK TO BITMAP DATA
	F_SEEK	54D,BMP_HANDLE
	
	POP	CX
	
	F_READ	BMP_BUFFER,CX,BMP_HANDLE
	
	F_CLOSE	BMP_HANDLE
		
	MOV	AL,0				
	MOV	DX,3C8H		;SAVE PORT NUMBER IN DX
	OUT	DX,AL		;SEND START COLOR CODE
	
	LEA	SI,BMP_BUFFER
	MOV	DX,3C9H
	SHR	CX,2
COLOR_LOOP:
	MOV	AL,[SI+2]
	SHR	AL,2		;DIVIDE AL BY 2*2
	OUT	DX,AL
	MOV	AL,[SI+1]
	SHR	AL,2		;DIVIDE AL BY 2*2
	OUT	DX,AL
	MOV	AL,[SI+0]
	SHR	AL,2		;DIVIDE AL BY 2*2
	OUT	DX,AL
	ADD	SI,4
	LOOP	COLOR_LOOP
	
	
	
	RET
	
SETCOLOR	ENDP


SEEK_TO_BITMAP PROC FAR
	;FOR SEEK TO START OFFSET OF BITMAP DATA
	F_SEEK 10D,BMP_HANDLE
	
	;READ OFFSET OF BITMAP DATA 
	F_READ	BMP_BUFFER,2,BMP_HANDLE
	MOV	DX,WORD PTR BMP_BUFFER[0]
	
	;SEEK TO BITMAP DATA
	F_SEEK DX,BMP_HANDLE
	
	RET
SEEK_TO_BITMAP ENDP



;CALCULATE POSITION FOR POINT TO START DRAW PICTURE 
;AND CHECK FOR BLANK PIXEL FOR DISPLAY PICTURE CORRECTLY
;
;LOAD COLUMN OF PICTURE AND PUT TO SCREEN
;READ ALL PIXEL IN 1 LINE OF PIC FOR FAST DISPLAY
;INPUT :	BX	FILE HANDLE
;	BMP_X	START POSITION X
;	BMP_Y	START POSITION Y
;
;OUTPUT:	SCREEN
FILE_TO_BUFFER	PROC

@FTB_Y1:	
	MOV	AX,BMP_Y
	CMP	AX,0		;CHECK NEGATIVE VALUE 
	JGE	@FTB_Y2
	MOV	BMP_Y,0
	XOR	AX,AX		;IF BMP_Y NEGATIVE, BMP_Y MUST NOT LOWER THAN 0
	
@FTB_Y2:
	ADD	AX,BMP_HEIGHT
	DEC	AX
	MOV	BMP_Y2,AX		;DRAW PIC FROM BOTTOM
	
	BMP_BLANK BMP_WIDTH, BMP_WIDTH2, BMP_BLK
	CALL	SEEK_TO_BITMAP
	
	;CALCULATE SCREEN OFFSET OFFSET = (Y*320) + X
	SCR_OFFSET	BMP_X,BMP_Y2
	
	;MOV	BX,BMP_HANDLE
@FTB_LOOP:

	CMP	BMP_Y,SCREEN_HEIGHT - 1	;CHECK BMP_Y OVER SCREEN ROW
	JG	@FTB_NEXT	;SKIP THIS LINE
	CMP	BMP_Y,0		;CHECK BMP_Y LOWER THAN 0
	JL	@FTB_CLOSE_FILE	;RETURN IF BELOW ZERO
	
	MOV	AX,3F00H
	MOV	CX,BMP_WIDTH	;READ 1 LINE OF PIC
	MOV	DX,DI
	PUSH	DS
	PUSH	ES	
	POP	DS		;DS SWITCH TO SCREEN SEGMENT
	INT	21H
	POP	DS		;RESTORE DS
	
	MOV	AX,4201H	;SEEK TO SKIP BLANK BYTES
	XOR	CX,CX
	MOV	DX,BMP_BLK
	INT	21H
	
				;DISPLAY 1 LINE COMPLETE
@FTB_NEXT:
	SUB	DI,SCREEN_WIDTH	;DI POINT TO UPPER LINE
	
	DEC	BMP_Y2		;DEC TO UPPER LINE
	MOV	AX,BMP_Y2
	CMP	AX,BMP_Y	;CHECK WITH BMP_Y
	JGE	@FTB_LOOP	;LAST LINE ?
	
				;DISPLAY PICTURE COMPLETE!
@FTB_CLOSE_FILE:
	F_CLOSE	BMP_HANDLE
	RET	
	
FILE_TO_BUFFER	ENDP


;LOAD COLUMN OF PICTURE AND PUT TO SCREEN
;READ ALL PIXEL IN 1 LINE OF PIC FOR FAST DISPLAY
;INPUT :	BX		FILE HANDLE
;	BMP_Y2		FROM BOTTOM
;	BMP_WIDTH	BITMAP WIDTH
;	BMP_HEIGHT	BITMAP HEIGHT
;
;OUTPUT:	SCREEN
FILE_TO_ARRAY	PROC

	MOV	AX,BMP_WIDTH
	STOSW	;SAVE WIDTH
	MOV	AX,BMP_HEIGHT
	STOSW	;SAVE HEIGHT
	
	BMP_BLANK BMP_WIDTH, BMP_WIDTH2, BMP_BLK
	CALL	SEEK_TO_BITMAP

	MOV	AX,BMP_HEIGHT
	MOV	SI,BMP_WIDTH
	DEC	AX
	MUL	SI
	ADD	DI,AX		;DI = (HEIGHT*WIDTH)
	
	MOV	BX,BMP_HANDLE
	MOV	CX,BMP_WIDTH	;READ 1 LINE IN FILE 
	
	TEST	SI,03H
	JNZ	@LFA_LOOP_BLANK
	
@LFA_LOOP_NO_BLANK:
	MOV	AH,3FH
	;MOV	CX,BMP_WIDTH
	MOV	DX,DI
	INT	21H
	
	SUB	DI,SI
	DEC	BMP_HEIGHT	;DEC TO UPPER LINE
	JNZ	@LFA_LOOP_NO_BLANK
	JMP	@LFA_CLOSE_FILE
	
@LFA_LOOP_BLANK:
	MOV	AH,3FH
	MOV	CX,BMP_WIDTH
	MOV	DX,DI
	INT	21H
	
	MOV	AX,4201H	;SEEK TO SKIP BLANK BYTES
	XOR	CX,CX
	MOV	DX,BMP_BLK
	INT	21H
	
	SUB	DI,SI
	DEC	BMP_HEIGHT	;DEC TO UPPER LINE
	JNZ	@LFA_LOOP_BLANK
	
@LFA_CLOSE_FILE:
	F_CLOSE	BMP_HANDLE
	RET
	
FILE_TO_ARRAY	ENDP


;CALCULATE POSITION FOR POINT TO START DRAW PICTURE 
;
;LOAD COLUMN OF PICTURE AND PUT TO SCREEN
;READ ALL PIXEL IN 1 LINE OF PIC FOR FAST DISPLAY
;INPUT :	SI	SOURCE ARRAY MEM
;	DI	DESTINATION IS BUFFER
;
;OUTPUT:	SCREEN
ARRAY_TO_BUFFER	PROC

	LOCAL	SKIP_L:WORD,SKIP_R:WORD

	;CALCULATE SCREEN OFFSET	OFFSET = (Y*320) + X
	SCR_OFFSET	BMP_X,BMP_Y
	
	PUSH	BMP_WIDTH
	POP	BMP_WIDTH2
	
@LAB_CHK_R:		;SKIP OVER RIGTH X POSITION
	MOV	SKIP_R,0
	MOV	AX,BMP_X	
	ADD	AX,BMP_WIDTH
	CMP	AX,SCREEN_WIDTH
	JL	@LAB_CHK_L
	SUB	AX,SCREEN_WIDTH
	CMP	AX,BMP_WIDTH
	JG	@LAB_RET
	SUB	BMP_WIDTH2,AX
	MOV	SKIP_R,AX
	
@LAB_CHK_L:		;SKIP OVER LEFT X POSITION
	MOV	SKIP_L,0
	MOV	AX,BMP_X	
	CMP	AX,0
	JGE	@LAB_CHK_D
	NEG	AX
	CMP	AX,BMP_WIDTH
	JGE	@LAB_RET
	SUB	BMP_WIDTH2,AX
	ADD	DI,AX
	MOV	SKIP_L,AX

@LAB_CHK_D:		;SKIP OVER DOWN Y POSITION
	MOV	AX,BMP_Y	
	ADD	AX,BMP_HEIGHT
	CMP	AX,SCREEN_HEIGHT
	JL	@LAB_LOOP
	SUB	AX,SCREEN_HEIGHT
	CMP	AX,BMP_HEIGHT
	JGE	@LAB_RET
	SUB	BMP_HEIGHT,AX

@LAB_LOOP:
	PUSH	DI
	
	CMP	BMP_Y,SCREEN_HEIGHT-1	;CHECK BMP_Y OVER SCREEN ROW
	JG	@LAB_RET		;IF OVER DON'T MOVE DATA TO SCREEN
	CMP	BMP_Y,0			;CHECK BMP_Y LOWER THAN 0
	JGE	@LAB_PUTPIXEL		;
	ADD	SI,BMP_WIDTH		;SKIP THIS LINE
	JMP	@LAB_NEXT_LINE
	
; @LAB_DWORD:
@LAB_PUTPIXEL:
	ADD	SI,SKIP_L	;SKIP LEFT SCREEN OFFSET
	
	CALL	PUTPIXEL_TRAN	
	
	ADD	SI,SKIP_R	;SKIP RIGHT SCREEN OFFSET
				;DISPLAY 1 LINE COMPLETE					
						
@LAB_NEXT_LINE:
	POP	DI
	ADD	DI,SCREEN_WIDTH
	INC	BMP_Y		;DEC TO UPPER LINE
	DEC	BMP_HEIGHT
	
	JNZ	@LAB_LOOP

@LAB_RET:
	RET	
				;DISPLAY PICTURE COMPLETE!
ARRAY_TO_BUFFER	ENDP


;putpixel to scrren by load 1 Byte from BMP_BUFFER and check transparent for skip put to VGA segment
PUTPIXEL_TRAN	PROC
		
	MOV	CX,BMP_WIDTH2	;SET CX FOR LOOP BMP_BUFFER

PT_LOOP:
	LODSB			;MOV AL,BYTE PTR DS:[SI] AND INC SI
	CMP	AL,TRANSPARENT	;IT TRANSPARENT COLOR?
	JNE	PT_STORE	;NO,PUTPIXEL!
	INC	DI		;IF SKIP COLOR MANUAL INC DI
	JMP	PT_SKIP
	
PT_STORE:
	STOSB			;MOV ES:[DI],AL AND INC DI

PT_SKIP:
	LOOP	PT_LOOP		;NO SHOW NEXT PIXEL OF LINE
				;DISPLAY 1 LINE COMPLETE
PT_RET:	
	RET
	
PUTPIXEL_TRAN	ENDP



;CALCULATE POSITION FOR POINT TO START DRAW PICTURE 
BUFFER_TO_SCREEN	PROC
	PUSHA

	XOR	SI,SI
	XOR	DI,DI
	
	MOV	AX,0A000H
	MOV	ES,AX
	
	CLD
	MOV	ECX,SCREEN_WIDTH * SCREEN_HEIGHT / 4
	REP	MOVSD	;move data from DS:[SI] to ES:[DI] AND INC SI,DI
	
	POPA
	RET
BUFFER_TO_SCREEN	ENDP

COPY_BUFFER	PROC
	PUSHA
		
	XOR	SI,SI
	XOR	DI,DI	
	CLD
	MOV	ECX,SCREEN_WIDTH * SCREEN_HEIGHT / 4
	REP	MOVSD	;move data from DS:[SI] to ES:[DI] AND SI,DI BY 4

	POPA
	RET
COPY_BUFFER	ENDP	

CLEAR_BUFFER	PROC
	PUSHA
	
	XOR	DI,DI
	
	MOV	ECX,4
CB_SET_BYTE:
	MOV	EAX,TRANSPARENT
	ROL	EAX,8	;NEXT BYTE
	LOOP	CB_SET_BYTE
	
	CLD
	MOV	ECX,SCREEN_WIDTH * SCREEN_HEIGHT / 4
	REP	STOSD
	
	POPA
	RET
CLEAR_BUFFER	ENDP



;INPUT:	DI HAS OBJ OFFSET
;OUTPUT	BMP_X2		X_POS
;	BMP_Y2		Y_POS
;	BMP_WIDTH2	WIDTH
;	BMP_HEIGHT2	HEIGHT
READ_OBJECT2	PROC
	PUSH	SI
	
	MOV	SI,DI
	
	LODSD
	MOV	DWORD PTR [BMP_X2],EAX
	
	MOV	SI,[SI+PTR_OFFSET-(Y_OFFSET+2)]

	LODSD
	MOV	DWORD PTR [BMP_WIDTH2],EAX
	
	MOV	DI,SI
	
	POP	SI
	RET
READ_OBJECT2	ENDP


;CHECK 2 OBJECT BOUND INTERSECT
;FAST BUT NOT ACCURATE 
;
;INPUT:		SI,DI POINT TO OBJECT
;
;OUTPUT:	COLLISION_FLAG = 0 NOT COLLIDE
;		COLLISION_FLAG = 1 COLLIDE	
OBJECT_BOUND_INTERSECT	PROC
	PUSHA
	
	CALL	READ_OBJECT		
	CALL	READ_OBJECT2
		
OI_CHECK1:
	MOV	AX,BMP_X2
	ADD	AX,BMP_WIDTH2
	CMP	BMP_X,AX
	JL	OI_CHECK2
	JMP	OI_NOT_COLLIDE
	
OI_CHECK2:
	MOV	AX,BMP_X
	ADD	AX,BMP_WIDTH
	CMP	BMP_X2,AX
	JL	OI_CHECK3
	JMP	OI_NOT_COLLIDE

OI_CHECK3:
	MOV	AX,BMP_Y2	
	ADD	AX,BMP_HEIGHT2
	CMP	BMP_Y,AX
	JL	OI_CHECK4
	JMP	OI_NOT_COLLIDE
	
OI_CHECK4:
	MOV	AX,BMP_Y
	ADD	AX,BMP_HEIGHT
	CMP	BMP_Y2,AX
	JNL	OI_NOT_COLLIDE
	
OI_COLLIDE:
	MOV	COLLISION_FLAG,1
	OR	AX,0FFFFH
	JMP	OI_RET

OI_NOT_COLLIDE:
	MOV	COLLISION_FLAG,0
	AND	AX,0
	
OI_RET:
	POPA	
	RET
OBJECT_BOUND_INTERSECT	ENDP



END


