
SETUP_INT	PROC
;SAVES OLD VECTOR AND SETS UP NEW VECTOR
;INPUT  AL = INTERRUPT TYPE
;	DI = ADDRESS OF BUFFER FOR OLD VECTOR
;	SI = ADDRESS OF BUFFER CONTAINING NEW VECTOR
;SAVE OLD INTERRUPT VECTOR
	PUSH	ES
 	MOV	AH,35H		;FUNCTION 35H, GET VECTOR
	INT	21H		;ES:BX = VECTOR
	MOV	[DI],BX		;SAVE OFFSET
	MOV	[DI+2],ES	;SAVE SEGMENT
;SETUP NEW VECTOR
	MOV	DX,[SI]		;DX HAS OFFSET
	PUSH	DS		;SAVE IT
	MOV	DS,[SI+2]	;DS HAS SEGMENT NUMBER
	MOV	AH,25H		;FUNCTION 25H, SET VECTOR
	INT	21H		
	POP	DS		;RESTORE DS
	POP	ES		;RESTORE ES
	RET
SETUP_INT	ENDP

KEYBOARD_INT	PROC
	;PUSHF	;NOT NEED 
	PUSHA
	; PUSH	DS
	; MOV	AX,SEG DOKEYS
	; MOV	DS,AX
	
	; CMP	BYTE PTR DOKEYS, 1
	; JNE	ENDOFI
	
	LEA	SI, ONKEYS

	XOR	AX, AX
	IN	AL, 60H
	MOV	BL, AL
	AND	BL, 127
	CMP	BL, 60H      ; EXTENDED?
	JNE	NOEX
	IN	AL, 60H
	INC	SI	      ; SHIFT IN MAP TO EXTENDED BYTE
NOEX:
	MOV	BL, AL
	AND	AL, 127		; CLEAR ON/OFF
	MOV	FS:LASTKEY, AX	; KEEP AL
	SHL	AX, 1		; TWO BYTES PER INDEX (NORMAL/EXTENDED)
	ADD	SI, AX
	NOT	BL
	SHR	BL, 7	      ; SET TO 0/1
	MOV	FS:[SI], BL   ; WRITE ON/OFF
	
ENDOFI:
	CLI
	MOV	AX, 20H
	OUT	20H, AL	; SEND EOI
	STI

	;POP	DS
	POPA
	;POPF
	IRET	;RESTORE CS:IP AND FLAG
KEYBOARD_INT	ENDP
	
;===========================================
;PRINTS AX AS A UNSIGNED DECIMAL INTEGER
;INPUT: AX
;OUTPUT : NONE
;=========================================
OUTDEC PROC
	PUSHA

	;OR	AX,AX
	;JGE	@END_IF1

	;PUSH	AX
	;MOV	DL,'-'
	;MOV	AH,2
	;INT	21H
	;POP	AX
	;NEG	AX

@END_IF1:
	XOR	CX,CX
	MOV	BX,10D

@REPEAT1:
	XOR	DX,DX
	DIV	BX
	PUSH	DX
	INC	CX
	OR	AX,AX
	JNE	@REPEAT1

	;MOV	AH,2

@PRINT_LOOP:
	POP	DX
	OR	DL,30H
	;INT	21H
	PUT_CHR	DL,253
	LOOP	@PRINT_LOOP

	POPA
	
	RET
OUTDEC ENDP



WAIT_RETRACE	PROC
	MOV     DX,03DAH        ; DX = IS1 PORT, WAITING FOR RETRACE
V_1:
	IN      AL,DX           ; WAIT FOR BIT 3 TO GO OFF (ACTIVE PERIOD)
	TEST    AL,8
	JNZ     V_1
V_2:
	IN      AL,DX           ; WAIT FOR BIT 3 TO COME ON (RETRACE PERIOD)
	TEST    AL,8
	JZ      V_2
	RET                     ; RETURN
WAIT_RETRACE	ENDP

		