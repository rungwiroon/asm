
INCLUDE GRAPHIC.INC
TRANSPARENT	EQU	255

.MODEL	SMALL
.486
.STACK 406H

;================================================
;		MACRO
;================================================
;OPEN FILE
F_OPEN	MACRO	FILENAME
	MOV	AX,3D00H
	LEA	DX,FILENAME
	INT	21H
ENDM


;CLOSE FILE
F_CLOSE	MACRO	HANDLE
	MOV	AX,3E00H
	MOV	BX,HANDLE
	INT	21H
ENDM


;SEEK FILE
F_SEEK	MACRO	@OFFSET,HANDLE
	MOV	AX,4200H
	MOV	BX,HANDLE
	XOR	CX,CX
	MOV	DX,@OFFSET
	INT	21H
ENDM

;READ FILE
F_READ	MACRO	BUFFER,COUNT,HANDLE
	MOV	AH,3FH
	MOV	BX,HANDLE
	MOV	CX,COUNT
	LEA	DX,BUFFER
	INT	21H
ENDM

;CALCULATE SCREEN OFFSET 
;INPUT X,Y
;OUTPUT OFFSET IN DI
SCR_OFFSET	MACRO	X,Y,DEST
	MOV	AX,Y
	MOV	DEST,AX
	SHL	DEST,8  ;DI:=DI*256 
	SHL	AX,6	;AX:=AX*64 
	ADD	DEST,AX	;DI := (Y*256)+(Y*64) := Y*320
	ADD	DEST,X
ENDM

;FIND NUMBER OF BLANK PIXEL PER LINE
BMP_BLANK	MACRO WIDTH1, WIDTH2, BLANK
	LOCAL	ADD_BLANK, NO_BLANK

	MOV	AX,WIDTH1
	TEST	AX,03H		;AX MOD 4
	JNZ	ADD_BLANK	;MOD 4 = 0?
	MOV	WIDTH2,AX	;YES, SKIP WIDTH = 0
	MOV	BLANK,0
	JMP	NO_BLANK

ADD_BLANK:
	SHR	AX,2		;DIVIDE BY 4 FOR CHANGE WORD
	INC	AX		;INC WORD
	SHL	AX,2		;MUL BY 4 TO BYTE
	MOV	WIDTH2,AX	
	SUB	AX,WIDTH1
	MOV	BLANK,AX
NO_BLANK:
ENDM

GET_OBJ_DATA	MACRO	IDX_R, POINT_, SIZE_
	MOV	EAX,[IDX_R].S_POINT
	MOV	POINT_,EAX
	LDS	IDX_R, [IDX_R].S_PBITMAP
	LDS	IDX_R, [IDX_R]
	MOV	EAX,[IDX_R].B_SIZE
	MOV	SIZE_,EAX
	ADD	IDX_R, SIZEOF _SIZE
ENDM

SEEK_BITMAP	MACRO	HANDLE
	LOCAL	START
	JMP	START
	
	TEMP	DW	?
	
START:	
	;FOR SEEK TO START OFFSET OF BITMAP DATA
	F_SEEK 10D,BMP_HANDLE	
	;READ OFFSET OF BITMAP DATA 
	PUSH	DS
	PUSH	CS
	POP	DS
	F_READ	TEMP,2,BMP_HANDLE
	POP	DS
	MOV	DX,TEMP	
	;SEEK TO BITMAP DATA
	F_SEEK DX,BMP_HANDLE
ENDM

;LOAD SEGMENT TO DS ES
LD_DS	MACRO	@SEGMENT
	PUSH	@SEGMENT
	POP	DS
ENDM

LD_ES	MACRO	@SEGMENT
	PUSH	@SEGMENT
	POP	ES
ENDM

;ADD 2 MEM 
ADD_MEM	MACRO	VALUE1,VALUE2
	MOV	AX,VALUE1
	ADD	AX,VALUE2
ENDM

;FIND MAX MIN VALUE
;	INPUT 	2 VALUE
;	OUTPUT 	AX
MAX	MACRO	VALUE1,VALUE2
	LOCAL	EXIT
	MOV	AX,VALUE1
	CMP	AX,VALUE2
	JG	EXIT
	MOV	AX,VALUE2	
EXIT:
	
ENDM

MIN	MACRO	VALUE1,VALUE2
	LOCAL	EXIT
	MOV	AX,VALUE1
	CMP	AX,VALUE2
	JL	EXIT
	MOV	AX,VALUE2	
EXIT:	
ENDM

BEEP	MACRO
	PUSH	AX
	PUSH	DX
	
	MOV	AH,02H
	MOV	DL,07H
	INT	21H
	
	POP	DX
	POP	AX
ENDM

;.DATA
;======================
;NO USE GLOBAL VAR :D
;======================

.CODE
;=============================================================================
;		PROCEDURE
;	 PASSING DATA BY STACK
;	MAIN FUNCTION
;=============================================================================
DRAW_BITMAP PROC FAR C USES DS ES,
	X1:WORD, Y1:WORD, SOURCE:LPVOID, DEST:LPVOID
	
	LOCAL	SIZE1:_SIZE
	LOCAL	W2:WORD
	LOCAL	SKIP_L:WORD,SKIP_R:WORD
	
	PUSHA		;SAVE ALL REGISTER
	
	LDS	SI, SOURCE
	;LDS	SI,[SI]	;POINTER TO POINTER
	MOV	EAX,[SI].B_SIZE
	MOV	SIZE1,EAX
	ADD	SI,SIZEOF _SIZE
	
	LES	DI, DEST
	SCR_OFFSET X1, Y1, DI
	
	PUSH	SIZE1.W
	POP	W2

DB_CHK_R:		;SKIP OVER RIGTH X POSITION
	MOV	SKIP_R,0
	MOV	AX,X1	
	ADD	AX,SIZE1.W
	CMP	AX,SCREEN_WIDTH
	JL	DB_CHK_L
	SUB	AX,SCREEN_WIDTH
	CMP	AX,SIZE1.W
	JG	DB_RET
	SUB	W2,AX
	MOV	SKIP_R,AX
	
DB_CHK_L:		;SKIP OVER LEFT X POSITION
	MOV	SKIP_L,0
	MOV	AX,X1	
	CMP	AX,0
	JGE	DB_CHK_D
	NEG	AX
	CMP	AX,SIZE1.W
	JGE	DB_RET
	SUB	W2,AX
	ADD	DI,AX
	MOV	SKIP_L,AX

DB_CHK_D:		;SKIP OVER DOWN Y POSITION
	MOV	AX,Y1	
	ADD	AX,SIZE1.H
	CMP	AX,SCREEN_HEIGHT
	JL	DB_LOOP
	SUB	AX,SCREEN_HEIGHT
	CMP	AX,SIZE1.H
	JGE	DB_RET
	SUB	SIZE1.H,AX

DB_LOOP:
	PUSH	DI
	
	CMP	Y1,SCREEN_HEIGHT-1	;CHECK BMP_Y OVER SCREEN ROW
	JG	DB_RET			;IF OVER DON'T MOVE DATA TO SCREEN
	CMP	Y1,0			;CHECK BMP_Y LOWER THAN 0
	JGE	DB_PUT_LINE		;
	ADD	SI,SIZE1.W		;SKIP THIS LINE
	JMP	DB_NEXT_LINE
	
; @LAB_DWORD:
DB_PUT_LINE:
	ADD	SI,SKIP_L	;SKIP LEFT SCREEN OFFSET
	
	MOV	CX,W2		;SET CX FOR LOOP BMP_BUFFER

DB_LOOP_PIXEL:
	LODSB			;MOV AL,BYTE PTR DS:[SI] AND INC SI
	CMP	AL,TRANSPARENT	;IT TRANSPARENT COLOR?
	JNE	DB_STORE	;NO,PUTPIXEL!
	INC	DI		;IF SKIP COLOR MANUAL INC DI
	JMP	DB_SKIP
	
DB_STORE:
	STOSB			;MOV ES:[DI],AL AND INC DI

DB_SKIP:
	LOOP	DB_LOOP_PIXEL	;NO SHOW NEXT PIXEL OF LINE
				;DISPLAY 1 LINE COMPLETE
		
	ADD	SI,SKIP_R	;SKIP RIGHT SCREEN OFFSET
				;DISPLAY 1 LINE COMPLETE					
						
DB_NEXT_LINE:
	POP	DI
	ADD	DI,SCREEN_WIDTH
	INC	Y1		
	DEC	SIZE1.H		;DEC TO UPPER LINE
	JNZ	DB_LOOP	
	
DB_RET:
	POPA	
	RET
DRAW_BITMAP ENDP


;LOAD BITMAP FROM FILE AND STORE IN BUFFER
;INPUT 
;	X	X POS
;	Y	Y POS
;	FILENAME	FILENAME STRING ADDRESS
;	DEST	DESTINATION ADDRESS
;OUTPUT
;	DRAW BITMAP TO SEGMNET
BTBB	PROC FAR C USES DS ES,
	X1:WORD, Y1:WORD, FILENAME:LPSTR, DEST:LPVOID
	LOCAL	Y2:WORD, W1:WORD, H1:WORD, W2:WORD, BLK:WORD
	LOCAL	HANDLE:WORD
	
	PUSHA

	MOV	AX,3D00H
	LDS	DX,FILENAME
	INT	21H		;OPEN FILE FNC.
	JNC	@F
	
	MOV	DL,'E'
	MOV	AH,2
	INT	21H	
	JMP	BTBB_EXIT
@@:
	MOV	HANDLE,AX
	
	INVOKE	READ_BMP_FILEE, HANDLE, ADDR W1, ADDR H1	;READ HEIGHT AND WIDTH
	; MOV	W1,38
	; MOV	H1,58
	; MOV	X1,0
	; MOV	Y1,0
		
	MOV	AX,Y1
	CMP	AX,0		;CHECK NEGATIVE VALUE 
	JGE	@F
	MOV	Y1,0
	XOR	AX,AX		;IF BMP_Y NEGATIVE, BMP_Y MUST NOT LOWER THAN 0
	
@@:
	ADD	AX,H1
	DEC	AX
	MOV	Y2,AX		;DRAW PIC FROM BOTTOM
	
	BMP_BLANK W1,W2, BLK		;CALCULATE BLANK PIXEL PER LINE	
	INVOKE	SEEK_TO_BITMAPP, HANDLE ;SEEL TO FIRST BITMAP DATA		
	;F_SEEK	432H, HANDLE
	
	LES	DI,DEST
	SCR_OFFSET X1,Y2,DI	;CALCULATE SCREEN OFFSET OFFSET = (Y*320) + X
	
	MOV	BX,HANDLE
BTBB_LOOP:

	CMP	Y1,SCREEN_HEIGHT - 1	;CHECK BMP_Y OVER SCREEN ROW
	JG	BTBB_NEXT	;SKIP THIS LINE
	CMP	Y1,0		;CHECK BMP_Y LOWER THAN 0
	JL	BTBB_CLOSE_FILE	;RETURN IF BELOW ZERO
	
	MOV	AX,3F00H
	MOV	CX,W1		;READ 1 LINE OF PIC
	MOV	DX,DI
	PUSH	DS
	PUSH	ES	
	POP	DS		;DS SWITCH TO SCREEN SEGMENT
	INT	21H
	POP	DS		;RESTORE DS
	
	MOV	AX,4201H	;SEEK TO SKIP BLANK BYTES
	XOR	CX,CX
	MOV	DX,BLK
	INT	21H
	
				;DISPLAY 1 LINE COMPLETE
BTBB_NEXT:
	SUB	DI,SCREEN_WIDTH	;DI POINT TO UPPER LINE	
	DEC	Y2		;DEC TO UPPER LINE
	MOV	AX,Y2
	CMP	AX,Y1		;CHECK WITH BMP_Y
	JGE	BTBB_LOOP	;LAST LINE ?
	
				;DISPLAY PICTURE COMPLETE!
BTBB_CLOSE_FILE:
	F_CLOSE	HANDLE
	
BTBB_EXIT:
	POPA	
	RET
BTBB	ENDP

;WARNING!!! REQUIRE STACK SIZE MORE THAN 406H 
CBMP2	PROC FAR C USES DS ES,
	FILENAME:LPSTR
	LOCAL	HANDLE:WORD, BUFFER[1024]:BYTE
	
	PUSHA
	
	MOV	AX,3D00H
	LDS	DX,FILENAME
	INT	21H		;OPEN FILE FNC.
	JNC	@F
	
	MOV	DL,'E'		;ERROR TO OPEN FILE
	MOV	AH,2
	INT	21H		;DISPLAY CHAR FNC.
	JMP	CBMP2_RET
@@:
	MOV	HANDLE,AX	;SAVE FILE HANDLE
	
	PUSH	SS
	POP	DS
	;FOR SEEK TO START OFFSET OF BITMAP DATA
	F_SEEK	10D,HANDLE
	
	;READ OFFSET OF BITMAP DATA 
	F_READ	BUFFER,02H,HANDLE
	MOV	DX,WORD PTR BUFFER[0]
	
	SUB	DX,54D
	PUSH	DX	;SAVE COLOR PALETTE SIZE
	
	;SEEK TO COLOR TABLE DATA
	F_SEEK	54D,HANDLE
	
	POP	CX
	
	F_READ	BUFFER,CX,HANDLE
	
	MOV	AL,0				
	MOV	DX,3C8H		;SAVE PORT NUMBER IN DX
	OUT	DX,AL		;SEND START COLOR CODE
	
	LEA	SI,BUFFER
	MOV	DX,3C9H
	SHR	CX,2
	
CBMP2_LOOP:
	MOV	AL,[SI+2]
	SHR	AL,2		;DIVIDE AL BY 2*2
	OUT	DX,AL
	MOV	AL,[SI+1]
	SHR	AL,2		;DIVIDE AL BY 2*2
	OUT	DX,AL
	MOV	AL,[SI+0]
	SHR	AL,2		;DIVIDE AL BY 2*2
	OUT	DX,AL
	ADD	SI,4
	LOOP	CBMP2_LOOP
CBMP2_RET:	
	POPA
	RET
CBMP2	ENDP


BTA3	PROC FAR C USES DS ES,
	FILENAME:LPSTR, DEST:LPVOID
	LOCAL	Y2:WORD, W1:WORD, H1:WORD, W2:WORD, BLK:WORD
	LOCAL	HANDLE:WORD
	
	PUSHA
	
	MOV	AX,3D00H
	LDS	DX,FILENAME
	INT	21H		;OPEN FILE FNC.
	JNC	@F
	
	MOV	DL,'E'
	MOV	AH,2
	INT	21H	
	JMP	BTA3_RET
@@:
	MOV	HANDLE,AX
	
	INVOKE	READ_BMP_FILEE, HANDLE, ADDR W1, ADDR H1	;READ HEIGHT AND WIDTH
	
	MOV	AX,W1
	MUL	H1
	ADD	AX,SIZEOF _SIZE
	INVOKE	MALLOC, DEST, AX
	JNZ	@F
	JMP	BTA3_CLOSE_FILE
@@:
	BMP_BLANK W1, W2, BLK
	INVOKE	SEEK_TO_BITMAPP, HANDLE ;SEEK TO FIRST BITMAP DATA
	
	LES	DI,DEST
	LES	DI,[DI]	;POINTER TO POINTER
	PUSH	ES
	POP	DS
	
	MOV	AX,W1
	STOSW	;SAVE WIDTH
	MOV	AX,H1
	STOSW	;SAVE HEIGHT

	MOV	AX,H1
	DEC	AX	;START AT LAST LINE
	MOV	SI,W1
	MUL	SI
	ADD	DI,AX
	
	MOV	BX,HANDLE
	
	TEST	SI,03H
	JNZ	BTA3_LOOP_BLANK
	
	MOV	CX,W1
BTA3_LOOP_NO_BLANK:
	; MOV	CX,W1
	; MOV	AL,0FEH
	; REP	STOSB
	
	MOV	AH,3FH
	MOV	DX,DI
	INT	21H
	
	SUB	DI,SI
	DEC	H1		;DEC TO UPPER LINE
	JNZ	BTA3_LOOP_NO_BLANK
	JMP	BTA3_CLOSE_FILE
	
BTA3_LOOP_BLANK:
	; MOV	CX,W1
	; MOV	AL,0FEH
	; REP	STOSB
	
	MOV	AH,3FH
	MOV	CX,W1
	MOV	DX,DI
	INT	21H
	
	MOV	AX,4201H	;SEEK TO SKIP BLANK BYTES
	XOR	CX,CX
	MOV	DX,BLK
	INT	21H
	
	SUB	DI,SI
	DEC	H1		;DEC TO UPPER LINE
	JNZ	BTA3_LOOP_BLANK
	
BTA3_CLOSE_FILE:
	F_CLOSE	HANDLE
BTA3_RET:	
	POPA
	RET
BTA3	ENDP

;LOAD BITMAP DATA FROM ARRAY TO SPECIFIC SEGMENT
;INPUT
;	SI	OFFSET OF ARRAY
;	ES	DESTINATION SEGMENT
;OUTPUT
;	DATA IN DESTINATION SEGMENT
ATB2	PROC FAR C USES DS ES,
	OBJECT:LPVOID, DEST:LPVOID
	LOCAL	POINT_:_POINT, SIZE_:_SIZE
	LOCAL	W2:WORD
	LOCAL	SKIP_L:WORD,SKIP_R:WORD

	PUSHA	
	
	LDS	SI, OBJECT
	MOV	EAX,[SI].S_POINT
	MOV	POINT_,EAX
	LDS	SI, [SI].S_PBITMAP
	
	INVOKE	DRAW_BITMAP, POINT_.X, POINT_.Y, [SI], DEST	

ATB2_RET:
	POPA
	RET
	
ATB2	ENDP

;CALCULATE POSITION FOR POINT TO START DRAW PICTURE 
BUFFER_TO_SCREEN2	PROC FAR C USES DS ES,
	SOURCE:LPVOID
	PUSHA

	LDS	SI,SOURCE
	XOR	DI,DI
	
	MOV	AX,0A000H
	MOV	ES,AX
	
	CLD
	MOV	ECX,SCREEN_WIDTH * SCREEN_HEIGHT / 4
	REP	MOVSD	;move data from DS:[SI] to ES:[DI] AND INC SI,DI
	
	POPA
	RET
BUFFER_TO_SCREEN2	ENDP

COPY_BUFFER2	PROC FAR C USES DS ES,
	SOURCE:LPVOID, DEST:LPVOID
	PUSHA
		
	LDS	SI,SOURCE
	LES	DI,DEST	
	CLD
	MOV	ECX,SCREEN_WIDTH * SCREEN_HEIGHT / 4
	REP	MOVSD	;move data from DS:[SI] to ES:[DI] AND SI,DI BY 4

	POPA
	RET
COPY_BUFFER2	ENDP

CLEAR_BUFFER2	PROC FAR C USES DS ES,
	DEST:LPVOID, COLOR:BYTE
	PUSHA
	
	LES	DI,DEST
	
	MOV	ECX,4
CB2_SET_BYTE:
	MOV	EAX,TRANSPARENT
	ROL	EAX,8	;NEXT BYTE
	LOOP	CB2_SET_BYTE
	
	CLD
	MOV	ECX,SCREEN_WIDTH * SCREEN_HEIGHT / 4
	REP	STOSD
	
	POPA
	RET
CLEAR_BUFFER2	ENDP	

;CHECK 2 OBJECT BOUND INTERSECT
;FAST BUT NOT ACCURATE 
;
;INPUT:		SI,DI POINT TO OBJECT
;
;OUTPUT:	COLLISION_FLAG = 0 NOT COLLIDE
;		COLLISION_FLAG = 1 COLLIDE	
OBJECT_BOUND_INTERSECT2	PROC FAR C USES DS ES,
	OBJ1:LPVOID, OBJ2:LPVOID
	LOCAL	POINT1:_POINT, POINT2:_POINT
	LOCAL	SIZE1:_SIZE, SIZE2:_SIZE
	PUSHA
	
	LDS	SI,OBJ1
	GET_OBJ_DATA	SI, POINT1, SIZE1		
	LES	DI,OBJ2
	GET_OBJ_DATA	DI, POINT2, SIZE2
		
OI2_CHECK1:
	MOV	AX,POINT2.X
	ADD	AX,SIZE2.W
	CMP	POINT1.X,AX
	JL	OI2_CHECK2
	JMP	OI2_RET
	
OI2_CHECK2:
	MOV	AX,POINT1.X
	ADD	AX,SIZE1.W
	CMP	POINT2.X,AX
	JL	OI2_CHECK3
	JMP	OI2_RET

OI2_CHECK3:
	MOV	AX,POINT2.Y	
	ADD	AX,SIZE2.H
	CMP	POINT1.Y,AX
	JL	OI2_CHECK4
	JMP	OI2_RET
	
OI2_CHECK4:
	MOV	AX,POINT1.Y
	ADD	AX,SIZE1.H
	CMP	POINT2.Y,AX
	JNL	OI2_NOT_COLLIDE

OI2_COLLIDE:
	;MOV	COLLISION_FLAG,1
	OR	AX,0FFFFH
	JMP	OI2_RET
	
OI2_NOT_COLLIDE:
	;MOV	COLLISION_FLAG,0
	XOR	AX,AX
	
OI2_RET:
	POPA	
	RET
OBJECT_BOUND_INTERSECT2	ENDP

;=========================================================
;	SUB PROCEDURE
;	FOR MAIN PROC USE
;=========================================================
OPEN_BMP_FILEE PROC FAR C USES DS,
	FILENAME:LPSTR, HANDLE:PWORD
	
	MOV	AX,3D00H
	LDS	DX,FILENAME
	;LEA	DX,FILENAME
	INT	21H
	JNC	@F
	
	MOV	DL,'E'
	MOV	AH,2
	INT	21H	
	
@@:
	LDS	SI,HANDLE
	MOV	[SI],AX
	
	RET
OPEN_BMP_FILEE	ENDP

OPEN_BMPFILE PROC FAR C USES DS,
	FILENAME:LPSTR, PHANDLE:LPWORD,
	WIDTH_:LPWORD, HEIGHT:LPWORD
	LOCAL	TEMP[3]:WORD, HANDLE:WORD
	
	MOV	AX,3D00H
	LDS	DX,FILENAME
	;LEA	DX,FILENAME
	INT	21H
	JNC	@F
	
	MOV	DL,'E'
	MOV	AH,2
	INT	21H	
	
@@:
	LDS	SI,PHANDLE
	MOV	[SI],AX
	MOV	HANDLE,AX
	
	F_SEEK	18D,HANDLE	;SEEK TO WIDTH
	F_READ	TEMP,6,HANDLE	;READ WIDTH TO BUFFER
	
	LDS	SI,WIDTH_
	MOV	AX,TEMP[0]
	MOV	[SI],AX
	
	LDS	SI,HEIGHT
	MOV	AX,TEMP[4]
	MOV	[SI],AX
	
	RET
OPEN_BMPFILE	ENDP

READ_BMP_FILEE	PROC FAR C USES DS,
	HANDLE:WORD, WIDTH_:LPWORD, HEIGHT:LPWORD
	LOCAL	TEMP[3]:WORD
		
	PUSH	SS
	POP	DS
	
	F_SEEK	18D,HANDLE	;SEEK TO WIDTH
	F_READ	TEMP,6,HANDLE	;READ WIDTH TO BUFFER
	
	LDS	SI,WIDTH_
	MOV	AX,TEMP[0]
	MOV	[SI],AX
	
	LDS	SI,HEIGHT
	MOV	AX,TEMP[4]
	MOV	[SI],AX
	
	RET

READ_BMP_FILEE	ENDP

SEEK_TO_BITMAPP PROC FAR C USES DS,
	HANDLE:WORD
	LOCAL	TEMP:WORD
	
	;FOR SEEK TO START OFFSET OF BITMAP DATA
	F_SEEK 10D,HANDLE
	
	PUSH	SS
	POP	DS
	;READ OFFSET OF BITMAP DATA 
	F_READ	TEMP, 2, HANDLE
	;SEEK TO BITMAP DATA
	F_SEEK	TEMP, HANDLE
	
	RET
SEEK_TO_BITMAPP ENDP

;========================================================
;	MEMORY	PROCEDURE
;========================================================
MALLOC	PROC	FAR C USES DS ES,
	MEM:LPVOID, SIZE_:WORD
	
	PUSHA
	
	MOV     AH,48H		;ALLOCATE       VIDBUF
	MOV 	BX,SIZE_	;FIND NUMBER OF PARAGRAPH 1 PARAGRAPH = 16 BYTES
	DEC 	BX
	SHR 	BX,4
	INC 	BX	
	INT     21H
	
	JC	MALLOC_ERR

	LDS	SI,MEM
	MOV	WORD PTR [SI+0],0
	MOV	[SI+2],AX
	OR	BX,0FFFFH
	JMP	MALLOC_RET
	
MALLOC_ERR:
	AND	BX,0
	
MALLOC_RET:
	POPA
	RET

MALLOC	ENDP	

REALLOC	PROC	FAR C USES ax bx dx ds,
	MEM:PFAR, SIZE_:WORD
	RET
REALLOC	ENDP

DEALLOC	PROC	FAR C USES ax bx dx ds,
	MEM:PFAR	
	RET
DEALLOC	ENDP

END
