<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_6/CH06-4.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:28 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER SIX: THE 80x86 INSTRUCTION SET (Part 4)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING4"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH06-3.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH06-3.html">Chapter Six</a> (Part 3)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH06-5.html">Chapter Six</a> (Part 5) </strong></font><a href="CH06-5.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10" colspan="2"><a NAME="HEADING4-0"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0" colspan="2"><font face="Arial" size="4"><strong>CHAPTER
    SIX:<br>
    THE 80x86 INSTRUCTION SET (Part 4)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10" colspan="2"></td>
  </tr>
  <tr>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING4-1"><b>6.6.4 </b>-
    The Bit Operations</a><br>
    <a HREF="#HEADING4-39"><b>6.6.4.1 </b>- TEST</a><br>
    <a HREF="#HEADING4-55"><b>6.6.4.2 </b>- The Bit Test Instructions: BT, BTS, BTR, and BTC</a>
    <br>
    <a HREF="#HEADING4-67"><b>6.6.4.3 </b>- Bit Scanning: BSF and BSR</a> <br>
    </font></td>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING4-74"><b>6.6.5 </b>-
    The &quot;Set on Condition&quot; Instructions</a> <br>
    <a HREF="#HEADING4-144"><b>6.7 </b>- I/O Instructions</a> <br>
    <a HREF="#HEADING4-162"><b>6.8 </b>- String Instructions</a></font></td>
  </tr>
  <tr>
    <td width="100%" valign="top" colspan="2" nowrap height="20"></td>
  </tr>
</table>
</center></div>

<p><strong><font face="Arial" size="3"><a NAME="HEADING4-1"></a>6.6.4 The Bit Operations</font></strong></p>

<p><font face="Arial" size="2">Bit twiddling is one of those operations easier done in
assembly language than other languages. And no wonder. Most high-level languages shield
you from the machine representation of the underlying data types. Instructions like <code>and,
or, xor, not, </code>and the shifts and rotates make it possible to test, set, clear,
invert, and align bit fields within strings of bits. Even the C++ programming language,
famous for its bit manipulation operators, doesn't provide the bit manipulation
capabilities of assembly language.</font></p>

<p><font face="Arial" size="2">The 80x86 family, particularly the 80386 and later
processors, go much farther, though. Besides the standard logical, shift, and rotate
instructions, there are instructions to test bits within an operand, to test and set,
clear, or invert specific bits in an operand, and to search for set bits. These
instructions are </font></p>

<pre><font face="Courier New" size="2">        test    dest, source
        bt      source, index
        btc     source, index
        btr     source, index
        bts     source, index
        bsf     dest, source
        bsr     dest, source</font></pre>

<p><font face="Arial" size="2">The specific forms are </font></p>

<pre><font face="Courier New" size="2">        test    reg, reg
        test    reg, mem
        test    mem, reg                (*)
        test    reg, imm
        test    mem, imm
        test    eax/ax/al, imm

        bt      reg, reg                (3)
        bt      mem, reg                (3)
        bt      reg, imm                (3)
        bt      mem, imm                (3)

        btc uses the same formats as bt. (3)
        btr uses the same formats as bt. (3)
        bts uses the same formats as bt. (3)

        bsf     reg, reg                (3)
        bsr     reg, mem                (3)

        bsr uses the same formats as bsf. (3)

3- This instruction is only available on 80386 and later processors.
*- This is the same instruction as test reg,mem</font></pre>

<p><font face="Arial" size="2">Note that the<code> bt, btc, btr, bts, bsf, </code>and <code>bsr</code>
require 16 or 32 bit operands.</font></p>

<p><font face="Arial" size="2">The bit operations are useful when implementing
(monochrome) bit mapped graphic primitive functions and when implementing a set data type
using bit maps.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING4-39"></a>6.6.4.1 TEST</font></strong></p>

<p><font face="Arial" size="2">The <code>test</code> instruction logically ands its two
operands and sets the flags but does not save the result. <code>Test</code> and <code>and</code>
share the same relationship as <code>cmp</code> and <code>sub</code>. Typically, you would
use this instruction to see if a bit contains one. Consider the following instruction: </font></p>

<pre><font face="Courier New" size="2">		test	al, 1</font></pre>

<p><font face="Arial" size="2">This instruction logically ands <code>al </code>with the
value one. If bit zero of <code>al</code> contains a one, the result is non-zero and the
80x86 clears the zero flag. If bit zero of <code>al</code> contains zero, then the result
is zero and the <code>test</code> operation sets the zero flag. You can test the zero flag
after this instruction to decide whether <code>al</code> contained zero or one in bit
zero.</font></p>

<p><font face="Arial" size="2">The <code>test</code> instruction can also check to see if
one or more bits in a register or memory location are non-zero. Consider the following
instruction: </font></p>

<pre><font face="Courier New" size="2">		test	dx, 105h</font></pre>

<p><font face="Arial" size="2">This instruction logically ands <code>dx</code> with the
value 105h. This will produce a non-zero result (and, therefore, clear the zero flag) if
at least one of bits zero, two, or eight contain a one. They must all be zero to set the
zero flag.</font></p>

<p><font face="Arial" size="2">The <code>test</code> instruction sets the flags
identically to the <code>and</code> instruction: </font>

<ul>
  <li><font face="Arial" size="2">It clears the carry flag. </font></li>
  <li><font face="Arial" size="2">It clears the overflow flag. </font></li>
  <li><font face="Arial" size="2">It sets the zero flag if the result is zero, they clear it
    otherwise. </font></li>
  <li><font face="Arial" size="2">It copies the H.O. bit of the result into the sign flag. </font></li>
  <li><font face="Arial" size="2">It sets the parity flag according to the parity (number of
    one bits) in the L.O. byte of the result. </font></li>
  <li><font face="Arial" size="2">It scrambles the auxiliary carry flag. </font></li>
</ul>

<p><strong><font face="Arial" size="3"><a NAME="HEADING4-55"></a>6.6.4.2 The Bit Test
Instructions: BT, BTS, BTR, and BTC</font></strong></p>

<p><font face="Arial" size="2">On an 80386 or later processor, you can use the <code>bt</code>
instruction (bit test) to test a single bit. Its second operand specifies the bit index
into the first operand. <code>Bt</code> copies the addressed bit into the carry flag. For
example, the instruction </font></p>

<pre><font face="Courier New" size="2">		bt	ax, 12</font></pre>

<p><font face="Arial" size="2">copies bit twelve of <code>ax</code> into the carry flag. </font></p>

<p><font face="Arial" size="2">The <code>bt/bts/btr/btc</code> instructions only deal with
16 or 32 bit operands. This is not a limitation of the instruction. After all, if you want
to test bit three of the <code>al</code> register, you can just as easily test bit three
of the <code>ax</code> register. On the other hand, if the index is larger than the size
of a register operand, the result is undefined.</font></p>

<p><font face="Arial" size="2">If the first operand is a memory location, the <code>bt</code>
instruction tests the bit at the given offset in memory, regardless the value of the
index. For example, if <code>bx</code> contains 65 then </font></p>

<pre><font face="Courier New" size="2">		bt	TestMe, bx</font></pre>

<p><font face="Arial" size="2">will copy bit one of location <code>TestMe+8</code> into
the carry flag. Once again, the size of the operand does not matter. For all intents and
purposes, the memory operand is a byte and you can test any bit after that byte with an
appropriate index. The actual bit <code>bt</code> tests is at bit position index mod 8 and
at memory offset effective address + index/8.</font></p>

<p><font face="Arial" size="2">The <code>bts</code>, <code>btr</code>, and <code>btc</code>
instructions also copy the addressed bit into the carry flag. However, these instructions
also set, reset (clear), or complement (invert) the bit in the first operand after copying
it to the carry flag. This provides test and set, test and clear, and test and invert
operations necessary for some concurrent algorithms.</font></p>

<p><font face="Arial" size="2">The bt, bts, btr, and btc instructions do not affect any
flags other than the carry flag.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING4-67"></a>6.6.4.3 Bit Scanning: BSF
and BSR</font></strong></p>

<p><font face="Arial" size="2">The <code>bsf</code> (Bit Scan Forward) and <code>bsr</code>
(Bit Scan Reverse) instructions search for the first or last set bit in a 16 or 32 bit
quantity. The general form of these instructions is</font> </p>

<pre><font face="Courier New" size="2">		bsf	dest, source
		bsr	dest, source</font></pre>

<p><font face="Arial" size="2"><code>Bsf</code> locates the first set bit in the source
operand, searching from bit zero though the H.O. bit. <code>Bsr</code> locates the first
set bit searching from the H.O. bit down to the L.O. bit. If these instructions locate a
one, they clear the zero flag and store the bit index (0..31) into the destination
operand. If the source operand is zero, these instructions set the zero flag and store an
indeterminate value into the destination operand.</font></p>

<p><font face="Arial" size="2">To scan for the first bit containing zero (rather than
one), make a copy of the source operand and invert it (using <code>not</code>), then
execute <code>bsf</code> or <code>bsr</code> on the inverted value. The zero flag would be
set after this operation if there were no zero bits in the original source value,
otherwise the destination operation will contain the position of the first bit containing
zero.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING4-74"></a>6.6.5 The &quot;Set on
Condition&quot; Instructions</font></strong></p>

<p><font face="Arial" size="2">The set on condition (or <code>setcc</code>) instructions
set a single byte operand (register or memory location) to zero or one depending on the
values in the flags register. The general formats for the <code>setcc</code> instructions
are </font></p>

<pre><font face="Courier New" size="2">                setcc   reg8
                setcc   mem8</font></pre>

<p><font face="Arial" size="2"><code>Setcc</code> represents a mnemonic appearing in the
following tables. These instructions store a zero into the corresponding operand if the
condition is false, they store a one into the eight bit operand if the condition is true. </font></p>
<div align="center"><center>

<table BORDER="1" cellspacing="0" cellpadding="0" bordercolor="#C0C0C0" width="50%">
  <caption><strong><font face="Arial" size="2">SETcc Instructions That Test Flags</font></strong></caption>
  <tr>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">Instruction</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">Description</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">Condition</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">Comments</font></th>
  </tr>
  <tr>
    <td><font face="Arial" size="2">SETC</font></td>
    <td><font face="Arial" size="2">Set if carry</font></td>
    <td><font face="Arial" size="2">Carry = 1</font></td>
    <td><font face="Arial" size="2">Same as SETB, SETNAE</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">SETNC</font></td>
    <td><font face="Arial" size="2">Set if no carry</font></td>
    <td><font face="Arial" size="2">Carry = 0</font></td>
    <td><font face="Arial" size="2">Same as SETNB, SETAE</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">SETZ</font></td>
    <td><font face="Arial" size="2">Set if zero</font></td>
    <td><font face="Arial" size="2">Zero = 1</font></td>
    <td><font face="Arial" size="2">Same as SETE</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">SETNZ</font></td>
    <td><font face="Arial" size="2">Set if not zero</font></td>
    <td><font face="Arial" size="2">Zero = 0</font></td>
    <td><font face="Arial" size="2">Same as SETNE</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">SETS</font></td>
    <td><font face="Arial" size="2">Set if sign</font></td>
    <td><font face="Arial" size="2">Sign = 1</font></td>
    <td><font face="Arial" size="2">-</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">SETNS</font></td>
    <td><font face="Arial" size="2">Set if no sign</font></td>
    <td><font face="Arial" size="2">Sign = 0</font></td>
    <td><font face="Arial" size="2">-</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">SETO</font></td>
    <td><font face="Arial" size="2">Set if overflow</font></td>
    <td><font face="Arial" size="2">Ovrflw=1</font></td>
    <td><font face="Arial" size="2">-</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">SETNO</font></td>
    <td><font face="Arial" size="2">Set if no overflow</font></td>
    <td><font face="Arial" size="2">Ovrflw=0</font></td>
    <td><font face="Arial" size="2">-</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">SETP</font></td>
    <td><font face="Arial" size="2">Set if parity</font></td>
    <td><font face="Arial" size="2">Parity = 1</font></td>
    <td><font face="Arial" size="2">Same as SETPE</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">SETPE</font></td>
    <td><font face="Arial" size="2">Set if parity even</font></td>
    <td><font face="Arial" size="2">Parity = 1</font></td>
    <td><font face="Arial" size="2">Same as SETP</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">SETNP</font></td>
    <td><font face="Arial" size="2">Set if no parity</font></td>
    <td><font face="Arial" size="2">Parity = 0</font></td>
    <td><font face="Arial" size="2">Same as SETPO</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">SETPO</font></td>
    <td><font face="Arial" size="2">Set if parity odd</font></td>
    <td><font face="Arial" size="2">Parity = 0</font></td>
    <td><font face="Arial" size="2">Same as SETNP</font></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">The <code>setcc</code> instructions above simply test the
flags without any other meaning attached to the operation. You could, for example, use <code>setc</code>
to check the carry flag after a shift, rotate, bit test, or arithmetic operation.
Likewise, you could use <code>setnz</code> instruction after a <code>test</code>
instruction to check the result.</font></p>

<p><font face="Arial" size="2">The <code>cmp</code> instruction works synergistically with
the <code>setcc</code> instructions. Immediately after a <code>cmp</code> operation the
processor flags provide information concerning the relative values of those operands. They
allow you to see if one operand is less than, equal to, greater than, or any combination
of these.</font></p>

<p><font face="Arial" size="2">There are two groups of <code>setcc</code> instructions
that are very useful after a <code>cmp</code> operation. The first group deals with the
result of an unsigned comparison, the second group deals with the result of a signed
comparison.</font></p>
<div align="center"><center>

<table BORDER="1" cellspacing="0" cellpadding="0" bordercolor="#C0C0C0" width="60%">
  <caption><strong><font face="Arial" size="2">SETcc Instructions for Unsigned Comparisons</font></strong></caption>
  <tr>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">Instruction</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">Description</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">Condition</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">Comments</font></th>
  </tr>
  <tr>
    <td><font face="Arial" size="2">SETA</font></td>
    <td><font face="Arial" size="2">Set if above (&gt;)</font></td>
    <td><font face="Arial" size="2">Carry=0, Zero=0</font></td>
    <td><font face="Arial" size="2">Same as SETNBE</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">SETNBE</font></td>
    <td><font face="Arial" size="2">Set if not below or equal (not &lt;=)</font></td>
    <td><font face="Arial" size="2">Carry=0, Zero=0</font></td>
    <td><font face="Arial" size="2">Same as SETA</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">SETAE</font></td>
    <td><font face="Arial" size="2">Set if above or equal (&gt;=)</font></td>
    <td><font face="Arial" size="2">Carry = 0</font></td>
    <td><font face="Arial" size="2">Same as SETNC, SETNB</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">SETNB</font></td>
    <td><font face="Arial" size="2">Set if not below (not &lt;)</font></td>
    <td><font face="Arial" size="2">Carry = 0</font></td>
    <td><font face="Arial" size="2">Same as SETNC, SETAE</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">SETB</font></td>
    <td><font face="Arial" size="2">Set if below (&lt;)</font></td>
    <td><font face="Arial" size="2">Carry = 1</font></td>
    <td><font face="Arial" size="2">Same as SETC, SETNAE</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">SETNAE</font></td>
    <td><font face="Arial" size="2">Set if not above or equal (not &gt;=)</font></td>
    <td><font face="Arial" size="2">Carry = 1</font></td>
    <td><font face="Arial" size="2">Same as SETC, SETB</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">SETBE</font></td>
    <td><font face="Arial" size="2">Set if below or equal (&lt;=)</font></td>
    <td><font face="Arial" size="2">Carry = 1 or Zero = 1</font></td>
    <td><font face="Arial" size="2">Same as SETNA</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">SETNA</font></td>
    <td><font face="Arial" size="2">Set if not above (not &gt;)</font></td>
    <td><font face="Arial" size="2">Carry = 1 or Zero = 1</font></td>
    <td><font face="Arial" size="2">Same as SETBE</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">SETE</font></td>
    <td><font face="Arial" size="2">Set if equal (=)</font></td>
    <td><font face="Arial" size="2">Zero = 1</font></td>
    <td><font face="Arial" size="2">Same as SETZ</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">SETNE</font></td>
    <td><font face="Arial" size="2">Set if not equal ()</font></td>
    <td><font face="Arial" size="2">Zero = 0</font></td>
    <td><font face="Arial" size="2">Same as SETNZ</font></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">The corresponding table for signed comparisons is </font></p>
<div align="center"><center>

<table BORDER="1" width="60%" cellspacing="0" cellpadding="0">
  <caption><strong><font face="Arial" size="2">SETcc Instructions for Signed Comparisons</font></strong></caption>
  <tr>
    <th bgcolor="#F0F0F0"><font face="Arial" size="2">Instruction</font></th>
    <th bgcolor="#F0F0F0"><font face="Arial" size="2">Description</font></th>
    <th bgcolor="#F0F0F0"><font face="Arial" size="2">Condition</font></th>
    <th bgcolor="#F0F0F0"><font face="Arial" size="2">Comments</font></th>
  </tr>
  <tr>
    <td><font face="Arial" size="2">SETG</font></td>
    <td><font face="Arial" size="2">Set if greater (&gt;)</font></td>
    <td><font face="Arial" size="2">Sign = Ovrflw or Zero=0</font></td>
    <td><font face="Arial" size="2">Same as SETNLE</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">SETNLE</font></td>
    <td><font face="Arial" size="2">Set if not less than or equal (not &lt;=)</font></td>
    <td><font face="Arial" size="2">Sign = Ovrflw or Zero=0 &nbsp;</font></td>
    <td><font face="Arial" size="2">Same as SETG</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">SETGE</font></td>
    <td><font face="Arial" size="2">Set if greater than or equal (&gt;=)</font></td>
    <td><font face="Arial" size="2">Sign = Ovrflw</font></td>
    <td><font face="Arial" size="2">Same as SETNL</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">SETNL</font></td>
    <td><font face="Arial" size="2">Set if not less than (not &lt;)</font></td>
    <td><font face="Arial" size="2">Sign = Ovrflw</font></td>
    <td><font face="Arial" size="2">Same as SETGE</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">SETL</font></td>
    <td><font face="Arial" size="2">Set if less than (&lt;)</font></td>
    <td><font face="Arial" size="2">Sign Ovrflw</font></td>
    <td><font face="Arial" size="2">Same as SETNGE</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">SETNGE</font></td>
    <td><font face="Arial" size="2">Set if not greater or equal (not &gt;=)</font></td>
    <td><font face="Arial" size="2">Sign Ovrflw &nbsp;</font></td>
    <td><font face="Arial" size="2">Same as SETL</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">SETLE</font></td>
    <td><font face="Arial" size="2">Set if less than or equal (&lt;=)</font></td>
    <td><font face="Arial" size="2">Sign Ovrflw or Zero = 1</font></td>
    <td><font face="Arial" size="2">Same as SETNG</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">SETNG</font></td>
    <td><font face="Arial" size="2">Set if not greater than (not &gt;)</font></td>
    <td><font face="Arial" size="2">Sign Ovrflw or Zero = 1</font></td>
    <td><font face="Arial" size="2">Same as SETLE</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">SETE</font></td>
    <td><font face="Arial" size="2">Set if equal (=)</font></td>
    <td><font face="Arial" size="2">Zero = 1</font></td>
    <td><font face="Arial" size="2">Same as SETZ</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">SETNE</font></td>
    <td><font face="Arial" size="2">Set if not equal ()</font></td>
    <td><font face="Arial" size="2">Zero = 0</font></td>
    <td><font face="Arial" size="2">Same as SETNZ</font></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">The <code>setcc</code> instructions are particularly
valuable because they can convert the result of a comparison to a boolean value
(true/false or 0/1). This is especially important when translating statements from a high
level language like Pascal or C++ into assembly language. The following example shows how
to use these instructions in this manner: </font></p>

<pre><font face="Courier New" size="2">; Bool := A &lt;= B

                mov     ax, A   ;Assume A and B are signed integers.
                cmp     ax, B
                setle   Bool    ;Bool needs to be a byte variable.</font></pre>

<p><font face="Arial" size="2">Since the <code>setcc</code> instructions always produce
zero or one, you can use the results with the logical <code>and</code> and <code>or</code>
instructions to compute complex boolean values: </font></p>

<pre><font face="Courier New" size="2">; Bool := ((A &lt;= B) and (D = E)) or (F &lt;&gt; G)

                mov     ax, A
                cmp     ax, B
                setle   bl
                mov     ax, D
                cmp     ax, E
                sete    bh
                and     bl, bh
                mov     ax, F
                cmp     ax, G
                setne   bh
                or      bl, bh
                mov     Bool, bh</font></pre>

<p><font face="Arial" size="2">For more examples, see Chapter Nine.</font></p>

<p><font face="Arial" size="2">The <code>setcc</code> instructions always produce an eight
bit result since a byte is the smallest operand the 80x86 will operate on. However, you
can easily use the shift and rotate instructions to pack eight boolean values in a single
byte. The following instructions compare eight different values with zero and copy the
&quot;zero flag&quot; from each comparison into corresponding bits of <code>al</code>: </font></p>

<pre><font face="Courier New" size="2">                cmp     Val7, 0
                setne   al              ;Put first value in bit #0
                cmp     Val6, 0         ;Test the value for bit #6
                setne   ah              ;Copy zero flag into ah register.
                shr     ah, 1           ;Copy zero flag into carry.
                rcl     al, 1           ;Shift carry into result byte.
                cmp     Val5, 0         ;Test the value for bit #5
                setne   ah
                shr     ah, 1
                rcl     al, 1
                cmp     Val4, 0         ;Test the value for bit #4
                setne   ah
                shr     ah, 1
                rcl     al, 1
                cmp     Val3, 0         ;Test the value for bit #3
                setne   ah
                shr     ah, 1
                rcl     al, 1
                cmp     Val2, 0         ;Test the value for bit #2
                setne   ah
                shr     ah, 1
                rcl     al, 1
                cmp     Val1, 0         ;Test the value for bit #1
                setne   ah
                shr     ah, 1
                rcl     al, 1
                cmp     Val0, 0         ;Test the value for bit #0
                setne   ah
                shr     ah, 1
                rcl     al, 1

; Now AL contains the zero flags from the eight comparisons.</font></pre>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a name="#HEADING4-144"></a>6.7 I/O
    Instructions</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">The 80x86 supports two I/O instructions: <code>in</code>
and <code>out</code>. They take the forms: </font></p>

<pre><font face="Courier New" size="2">                in      eax/ax/al, port
                in      eax/ax/al, dx
                out     port, eax/ax/al
                out     dx, eax/ax/al</font></pre>

<p><font face="Arial" size="2"><code>port</code> is a value between 0 and 255.</font></p>

<p><font face="Arial" size="2">The 80x86 supports up to 65,536 different I/O ports
(requiring a 16 bit I/O address). The <code>port</code> value above, however, is a single
byte value. Therefore, you can only directly address the first 256 I/O ports in the
80x86's I/O address space. To address all 65,536 different I/O ports, you must load the
address of the desired port (assuming it's above 255) into the <code>dx</code> register
and access the port indirectly. The <code>in</code> instruction reads the data at the
specified I/O port and copies it into the accumulator. The <code>out</code> instruction
writes the value in the accumulator to the specified I/O port. </font></p>

<p><font face="Arial" size="2">Please realize that there is nothing magical about the
80x86's <code>in</code> and <code>out</code> instructions. They're simply another form of
the <code>mov</code> instruction that accesses a different memory space (the I/O address
space) rather than the 80x86's normal 1 Mbyte memory address space.</font></p>

<p><font face="Arial" size="2">The <code>in</code> and <code>out</code> instructions do
not affect any 80x86 flags.</font></p>

<p><font face="Arial" size="2">Examples of the 80x86 I/O instructions: </font></p>

<pre><font face="Courier New" size="2">                in      al, 60h         ;Read keyboard port

                mov     dx, 378h        ;Point at LPT1: data port
                in      al, dx          ;Read data from printer port.
                inc     ax              ;Bump the ASCII code by one.
                out     dx, al          ;Write data in AL to printer port.</font></pre>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a name="#HEADING4-162"></a>6.8
    String Instructions </font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">The 80x86 supports twelve string instructions: </font>

<ul>
  <li><font face="Arial" size="2"><code>movs</code> (move string) </font></li>
  <li><font face="Arial" size="2"><code>lods</code> (load string element into the accumulator)
    </font></li>
  <li><font face="Arial" size="2"><code>stos</code> (store accumulator into string element) </font></li>
  <li><font face="Arial" size="2"><code>scas</code> (Scan string and check for match against
    the value in the accumulator) </font></li>
  <li><font face="Arial" size="2"><code>cmps</code> (compare two strings). </font></li>
  <li><font face="Arial" size="2"><code>ins</code> (input a string from an I/O port) </font></li>
  <li><font face="Arial" size="2"><code>outs</code> (output a string to an I/O port </font></li>
  <li><font face="Arial" size="2"><code>rep</code> (repeat a string operation) </font></li>
  <li><font face="Arial" size="2"><code>repz</code> (repeat while zero) </font></li>
  <li><font face="Arial" size="2"><code>repe</code> (repeat while equal) </font></li>
  <li><font face="Arial" size="2"><code>repnz</code> (repeat while not zero) </font></li>
  <li><font face="Arial" size="2"><code>repne</code> (repeat while not equal) </font></li>
</ul>

<p><font face="Arial" size="2">You can use the <code>movs, stos, scas, cmps, ins</code>
and <code>outs</code> instructions to manipulate a single element (byte, word, or double
word) in a string, or to process an entire string. Generally, you would only use the <code>lods</code>
instruction to manipulate a single item at a time.</font></p>

<p><font face="Arial" size="2">These instructions can operate on strings of bytes, words,
or double words. To specify the object size, simply append a b, w, or d to the end of the
instruction's mnemonic, i.e., <code>lodsb, movsw, cmpsd, </code>etc. Of course, the double
word forms are only available on 80386 and later processors.</font></p>

<p><font face="Arial" size="2">The <code>movs</code> and <code>cmps</code> instructions
assume that <code>ds:si</code> contains the segmented address of a source string and that <code>es:di</code>
contains the segmented address of a destination string. The <code>lods</code> instruction
assumes that <code>ds:si </code>points at a source string, the accumulator (<code>al/ax/eax</code>)
is the destination location. The <code>scas</code> and <code>stos</code> instructions
assume that <code>es:di </code>points at a destination string and the accumulator contains
the source value. </font></p>

<p><font face="Arial" size="2">The <code>movs</code> instruction moves one string element
(byte, word, or dword) from memory location <code>ds:si</code> to<code> es:di</code>.
After moving the data, the instruction increments or decrements <code>si</code> and <code>di</code>
by one, two, or four if processing bytes, words, or dwords, respectively. The CPU
increments these registers if the direction flag is clear, the CPU decrements them if the
direction flag is set. </font></p>

<p><font face="Arial" size="2">The <code>movs</code> instruction can move blocks of data
around in memory. You can use it to move strings, arrays, and other multi-byte data
structures. </font></p>

<pre><font face="Courier New" size="2">movs{b,w,d}:    es:[di] := ds:[si]
                if direction_flag = 0 then
                        si := si + size;
                        di := di + size;
                else
                        si := si - size;
                        di := di - size;
                endif;</font></pre>

<p><font face="Arial" size="2">Note: <code>size</code> is one for bytes, two for words,
and four for dwords.</font></p>

<p><font face="Arial" size="2">The <code>cmps</code> instruction compares the byte, word,
or dword at location <code>ds:si</code> to <code>es:di </code>and sets the processor flags
accordingly. After the comparison, <code>cmps </code>increments or decrements <code>si</code>
and <code>di</code> by one, two, or four depending on the size of the instruction and the
status of the direction flag in the flags register. </font></p>

<pre><font face="Courier New" size="2">cmps{b,w,d}:    cmp ds:[si], es:[di]
                if direction_flag = 0 then
                        si := si + size;
                        di := di + size;
                else
                        si := si - size;
                        di := di - size;
                endif;</font></pre>

<p><font face="Arial" size="2">The <code>lods</code> instruction moves the byte, word, or
dword at <code>ds:si</code> into the <code>al</code>, <code>ax</code>, or <code>eax</code>
register. It then increments or decrements the <code>si</code> register by one, two, or
four depending on the instruction size and the value of the direction flag. The <code>lods</code>
instruction is useful for fetching a sequence of bytes, words, or double words from an
array, performing some operation(s) on those values and then processing the next element
from the string. </font></p>

<pre><font face="Courier New" size="2">lods{b,w,d}:    eax/ax/al := ds:[si]
                if direction_flag = 0 then
                        si := si + size;
                else
                        si := si - size;
                endif;</font></pre>

<p><font face="Arial" size="2">The <code>stos</code> instruction stores <code>al</code>, <code>ax</code>,
or <code>eax</code> at the address specified by <code>es:di</code>. Again, <code>di</code>
is incremented or decremented according to the size of the instruction and the value of
the direction flag. The <code>stos</code> instruction has several uses. Paired with the <code>lods</code>
instruction above, you can load (via <code>lods</code>), manipulate, and store string
elements. By itself, the <code>stos</code> instruction can quickly store a single value
throughout a multi-byte data structure. </font></p>

<pre><font face="Courier New" size="2">stos{b,w,d}:    es:[di] := eax/ax/al
                if direction_flag = 0 then
                        di := di + size;
                else
                        di := di - size;
                endif;</font></pre>

<p><font face="Arial" size="2">The <code>scas</code> instruction compares <code>al, ax </code>or
<code>eax</code> against the value at location <code>es:di</code> and then adjusts <code>di</code>
accordingly. This instruction sets the flags in the processor status register just like
the <code>cmp</code> and <code>cmps</code> instructions. The <code>scas</code> instruction
is great for searching for a particular value throughout some multi-byte data structure. </font></p>

<pre><font face="Courier New" size="2">scas{b,w,d}:    cmp eax/ax/al, es:[di]
                if direction_flag = 0 then
                        di := di + size;
                else
                        di := di - size;
                endif;</font></pre>

<p><font face="Arial" size="2">The <code>ins </code>instruction inputs a byte, word, or
double word from the I/O port specified in the <code>dx</code> register. It then stores
the input value at memory location <code>es:di </code>and increments or decrements <code>di</code>
appropriately. This instruction is available only on 80286 and later processors. </font></p>

<pre><font face="Courier New" size="2">ins{b,w,d}:     es:[di] := port(dx)
                if direction_flag = 0 then
                        di := di + size;
                else
                        di := di - size;
                endif;</font></pre>

<p><font face="Arial" size="2">The <code>outs</code> instruction fetches the byte, word,
or double word at address <code>ds:si</code>, increments or decrements <code>si</code>
accordingly, and then outputs the value to the port specified in the <code>dx</code>
register. </font></p>

<pre><font face="Courier New" size="2">outs{b,w,d}:    port(dx) := ds:[si]
                if direction_flag = 0 then
                        si := si + size;
                else
                        si := si - size;
                endif;</font></pre>

<p><font face="Arial" size="2">As explained here, the string instructions are useful, but
it gets even better! When combined with the <code>rep, repz, repe, repnz,</code> and <code>repne</code>
prefixes, a single string instruction can process an entire string. For more information
on these prefixes see the chapter on strings.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH06-3.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH06-3.html">Chapter Six</a> (Part 3)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH06-5.html">Chapter Six</a> (Part 5) </strong></font><a href="CH06-5.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Six: The 80x86 Instruction
Set (Part 4)<br>
26 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_6/CH06-4.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:28 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
