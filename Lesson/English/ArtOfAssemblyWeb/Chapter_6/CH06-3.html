<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_6/CH06-3.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:16 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER SIX: THE 80x86 INSTRUCTION SET (Part 3)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING3"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH06-2.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH06-2.html">Chapter Six</a> (Part 2)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH06-4.html">Chapter Six</a> (Part 4) </strong></font><a href="CH06-4.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10" colspan="2"><a NAME="HEADING3-0"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0" colspan="2"><font face="Arial" size="4"><strong>CHAPTER
    SIX:<br>
    THE 80x86 INSTRUCTION SET (Part 3)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10" colspan="2"></td>
  </tr>
  <tr>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING3-1"><b>6.6 </b>-
    Logical, Shift, Rotate and Bit Instructions</a> <br>
    <a HREF="#HEADING3-4"><b>6.6.1 </b>- The Logical Instructions: AND, OR, XOR, and NOT</a> <br>
    <a HREF="#HEADING3-42"><b>6.6.2 </b>- The Shift Instructions: SHL/SAL, SHR, SAR, SHLD, and
    SHRD</a> <br>
    <a HREF="#HEADING3-82"><b>6.6.2.1 </b>- SHL/SAL</a> <br>
    <a HREF="#HEADING3-120"><b>6.6.2.2 </b>- SAR</a> <br>
    <a HREF="#HEADING3-174"><b>6.6.2.3 </b>- SHR</a> </font></td>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING3-208"><b>6.6.2.4
    </b>- The SHLD and SHRD Instructions</a> <br>
    <a HREF="#HEADING3-253"><b>6.6.3 </b>- The Rotate Instructions: RCL, RCR, ROL, and ROR</a>
    <br>
    <a HREF="#HEADING3-273"><b>6.6.3.1 </b>- RCL</a> <br>
    <a HREF="#HEADING3-284"><b>6.6.3.2 </b>- RCR</a> <br>
    <a HREF="#HEADING3-294"><b>6.6.3.3 </b>- ROL</a> <br>
    <a HREF="#HEADING3-306"><b>6.6.3.4 </b>- ROR</a> </font></td>
  </tr>
  <tr>
    <td width="100%" valign="top" colspan="2" nowrap height="20"></td>
  </tr>
  <tr>
    <td width="100%" valign="top" colspan="2"><strong><font face="Arial" size="3"><a NAME="HEADING3-1"></a>6.6 Logical, Shift, Rotate and Bit Instructions </font></strong></td>
  </tr>
  <tr>
    <td width="100%" valign="top" colspan="2" nowrap height="1" bgcolor="#000000"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">The 80x86 family provides five logical instructions, four
rotate instructions, and three shift instructions. The logical instructions are <code>and,
or, xor, test, </code>and <code>not</code>; the rotates are <code>ror, rol, rcr,</code>
and <code>rcl</code>; the shift instructions are <code>shl/sal, shr, </code>and <code>sar</code>.
The 80386 and later processors provide an even richer set of operations. These are <code>bt,
bts, btr, btc</code>, <code>bsf, bsr</code>, <code>shld, shrd</code>, and the conditional
set instructions (<code>setcc</code>).</font></p>

<p><font face="Arial" size="2">These instructions can manipulate bits, convert values, do
logical operations, pack and unpack data, and do arithmetic operations. The following
sections describe each of these instructions in detail.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-4"></a>6.6.1 The Logical
Instructions: AND, OR, XOR, and NOT</font></strong></p>

<p><font face="Arial" size="2">The 80x86 logical instructions operate on a bit-by-bit
basis. Both eight, sixteen, and thirty-two bit versions of each instruction exist. The <code>and,
not, or, </code>and <code>xor</code> instructions do the following: </font></p>

<pre><font face="Courier New" size="2">        and     dest, source            ;dest := dest and source
        or      dest, source            ;dest := dest or source
        xor     dest, source            ;dest := dest xor source
        not     dest                    ;dest := not dest

The specific variations are

        and     reg, reg
        and     mem, reg
        and     reg, mem
        and     reg, immediate data
        and     mem, immediate data
        and     eax/ax/al, immediate data

        or uses the same formats as AND
        xor uses the same formats as AND

        not     register
        not     mem</font></pre>

<p><font face="Arial" size="2">Except <code>not</code>, these instructions affect the
flags as follows: </font>

<ul>
  <li><font face="Arial" size="2">They clear the carry flag. </font></li>
  <li><font face="Arial" size="2">They clear the overflow flag. </font></li>
  <li><font face="Arial" size="2">They set the zero flag if the result is zero, they clear it
    otherwise. </font></li>
  <li><font face="Arial" size="2">They copy the H.O. bit of the result into the sign flag. </font></li>
  <li><font face="Arial" size="2">They set the parity flag according to the parity (number of
    one bits) in the result. </font></li>
  <li><font face="Arial" size="2">They scramble the auxiliary carry flag. </font></li>
</ul>

<p><font face="Arial" size="2">The <code>not</code> instruction does not affect any flags.</font></p>

<p><font face="Arial" size="2">Testing the zero flag after these instructions is
particularly useful. The <code>and</code> instruction sets the zero flag if the two
operands do not have any ones in corresponding bit positions (since this would produce a
zero result); for example, if the source operand contained a single one bit, then the zero
flag will be set if the corresponding destination bit is zero, it will be one otherwise.
The <code>or</code> instruction will only set the zero flag if both operands contain zero.
The <code>xor</code> instruction will set the zero flag only if both operands are equal.
Notice that the <code>xor </code>operation will produce a zero result if and only if the
two operands are equal. Many programmers commonly use this fact to clear a sixteen bit
register to zero since an instruction of the form </font></p>

<pre><font face="Courier New" size="2">		xor	reg16, reg16</font></pre>

<p><font face="Arial" size="2">is shorter than the comparable <code>mov reg,0</code>
instruction.</font></p>

<p><font face="Arial" size="2">Like the addition and subtraction instructions, the <code>and</code>,
<code>or</code>, and <code>xor</code> instructions provide special forms involving the
accumulator register and immediate data. These forms are shorter and sometimes faster than
the general &quot;register, immediate&quot; forms. Although one does not normally think of
operating on signed data with these instructions, the 80x86 does provide a special form of
the &quot;reg/mem, immediate&quot; instructions that sign extend a value in the range
-128..+127 to sixteen or thirty-two bits, as necessary.</font></p>

<p><font face="Arial" size="2">The instruction's operands must all be the same size. On
pre-80386 processors they can be eight or sixteen bits. On 80386 and later processors,
they may be 32 bits long as well. These instructions compute the obvious bitwise logical
operation on their operands, see Chapter One for details on these operations.</font></p>

<p><font face="Arial" size="2">You can use the <code>and</code> instruction to set
selected bits to zero in the destination operand. This is known as masking out data; see
for more details. Likewise, you can use the <code>or</code> instruction to force certain
bits to one in the destination operand; see Chapter Nine for the details. You can use
these instructions, along with the shift and rotate instructions described next, to pack
and unpack data. </font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-42"></a>6.6.2 The Shift
Instructions: SHL/SAL, SHR, SAR, SHLD, and SHRD</font></strong></p>

<p><font face="Arial" size="2">The 80x86 supports three different shift instructions (<code>shl</code>
and <code>sal</code> are the same instruction): <code>shl</code> (shift left), <code>sal</code>
(shift arithmetic left), <code>shr</code> (shift right), and <code>sar</code> (shift
arithmetic right). The 80386 and later processors provide two additional shifts: <code>shld</code>
and <code>shrd</code>. </font></p>

<p><font face="Arial" size="2">The shift instructions move bits around in a register or
memory location. The general format for a shift instruction is </font></p>

<pre><font face="Courier New" size="2">        shl     dest, count
        sal     dest, count
        shr     dest, count
        sar     dest, count</font></pre>

<p><font face="Arial" size="2"><code>Dest</code> is the value to shift and <code>count</code>
specifies the number of bit positions to shift. For example, the <code>shl</code>
instruction shifts the bits in the destination operand to the left the number of bit
positions specified by the <code>count</code> operand. The <code>shld</code> and <code>shrd</code>
instructions use the format: </font></p>

<pre><font face="Courier New" size="2">        shld    dest, source, count
        shrd    dest, source, count</font></pre>

<p><font face="Arial" size="2">The specific forms for these instructions are </font></p>

<pre><font face="Courier New" size="2">        shl     reg, 1
        shl     mem, 1
        shl     reg, imm        (2)
        shl     mem, imm        (2)
        shl     reg, cl
        shl     mem, cl

        sal is a synonym for shl and uses the same formats.
        shr uses the same formats as shl.
        sar uses the same formats as shl.

        shld    reg, reg, imm   (3)
        shld    mem, reg, imm   (3)
        shld    reg, reg, cl    (3)
        shld    mem, reg, cl    (3)

        shrd uses the same formats as shld.

2- This form is available on 80286 and later processors only.
3- This form is available on 80386 and later processors only.</font></pre>

<p><font face="Arial" size="2">For 8088 and 8086 CPUs, the number of bits to shift is
either &quot;1&quot; or the value in <code>cl</code>. On 80286 and later processors you
can use an eight bit immediate constant. Of course, the value in <code>cl</code> or the
immediate constant should be less than or equal to the number of bits in the destination
operand. It would be a waste of time to shift left <code>al</code> by nine bits (eight
would produce the same result, as you will soon see). Algorithmically, you can think of
the shift operations with a count other than one as follows: </font></p>

<pre><font face="Courier New" size="2">	for temp := 1 to count do
		shift dest, 1</font></pre>

<p><font face="Arial" size="2">There are minor differences in the way the shift
instructions treat the overflow flag when the count is not one, but you can ignore this
most of the time.</font></p>

<p><font face="Arial" size="2">The <code>shl, sal, shr, </code>and <code>sar</code>
instructions work on eight, sixteen, and thirty-two bit operands. The <code>shld</code>
and <code>shrd</code> instructions work on 16 and 32 bit destination operands only.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-82"></a>6.6.2.1 SHL/SAL</font></strong></p>

<p><font face="Arial" size="2">The <code>shl</code> and <code>sal</code> mnemonics are
synonyms. They represent the same instruction and use identical binary encodings. These
instructions move each bit in the destination operand one bit position to the left the
number of times specified by the count operand. Zeros fill vacated positions at the L.O.
bit; the H.O. bit shifts into the carry flag:</font></p>

<p align="center"><img SRC="images/ch06a1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH06/ch06a1.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="250" HEIGHT="39"> </p>

<p><font face="Arial" size="2">The <code>shl/sal</code> instruction sets the condition
code bits as follows: </font>

<ul>
  <li><font face="Arial" size="2">If the shift count is zero, the <code>shl </code>instruction
    doesn't affect any flags. </font></li>
  <li><font face="Arial" size="2">The carry flag contains the last bit shifted out of the H.O.
    bit of the operand. </font></li>
  <li><font face="Arial" size="2">The overflow flag will contain one if the two H.O. bits were
    different prior to a single bit shift. The overflow flag is undefined if the shift count
    is not one. </font></li>
  <li><font face="Arial" size="2">The zero flag will be one if the shift produces a zero
    result. </font></li>
  <li><font face="Arial" size="2">The sign flag will contain the H.O. bit of the result. </font></li>
  <li><font face="Arial" size="2">The parity flag will contain one if there are an even number
    of one bits in the L.O. byte of the result. </font></li>
  <li><font face="Arial" size="2">The A flag is always undefined after the <code>shl/sal</code>
    instruction. </font></li>
</ul>

<p><font face="Arial" size="2">The shift left instruction is especially useful for packing
data. For example, suppose you have two nibbles in <code>al</code> and <code>ah</code>
that you want to combine. You could use the following code to do this: </font></p>

<pre><font face="Courier New" size="2">                shl     ah, 4   ;This form requires an 80286 or later
                or      al, ah  ;Merge in H.O. four bits.</font></pre>

<p><font face="Arial" size="2">Of course, <code>al</code> must contain a value in the
range 0..F for this code to work properly (the shift left operation automatically clears
the L.O. four bits of <code>ah</code> before the <code>or</code> instruction). If the H.O.
four bits of <code>al</code> are not zero before this operation, you can easily clear them
with an <code>and</code> instruction: </font></p>

<pre><font face="Courier New" size="2">                shl     ah, 4           ;Move L.O. bits to H.O. position.
                and     al, 0Fh         ;Clear H.O. four bits.
                or      al, ah          ;Merge the bits.</font></pre>

<p><font face="Arial" size="2">Since shifting an integer value to the left one position is
equivalent to multiplying that value by two, you can also use the shift left instruction
for multiplication by powers of two: </font></p>

<pre><font face="Courier New" size="2">                shl     ax, 1   ;Equivalent to AX*2
                shl     ax, 2   ;Equivalent to AX*4
                shl     ax, 3   ;Equivalent to AX*8
                shl     ax, 4   ;Equivalent to AX*16
                shl     ax, 5   ;Equivlaent to AX*32
                shl     ax, 6   ;Equivalent to AX*64
                shl     ax, 7   ;Equivalent to AX*128
                shl     ax, 8   ;Equivalent to AX*256
                etc.</font></pre>

<p><font face="Arial" size="2">Note that <code>shl ax, 8</code> is equivalent to the
following two instructions: </font></p>

<pre><font face="Courier New" size="2">                mov     ah, al
                mov     al, 0</font></pre>

<p><font face="Arial" size="2">The <code>shl/sal</code> instruction multiplies both signed
and unsigned values by two for each shift. This instruction sets the carry flag if the
result does not fit in the destination operand (i.e., unsigned overflow occurs). Likewise,
this instruction sets the overflow flag if the signed result does not fit in the
destination operation. This occurs when you shift a zero into the H.O. bit of a negative
number or you shift a one into the H.O. bit of a non-negative number.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-120"></a>6.6.2.2 SAR</font></strong></p>

<p><font face="Arial" size="2">The <code>sar</code> instruction shifts all the bits in the
destination operand to the right one bit, replicating the H.O. bit:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch06a2.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH06/ch06a2.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="274" HEIGHT="53"> </font></p>

<p><font face="Arial" size="2">The <code>sar</code> instruction sets the flag bits as
follows: </font>

<ul>
  <li><font face="Arial" size="2">If the shift count is zero, the <code>sar </code>instruction
    doesn't affect any flags. </font></li>
  <li><font face="Arial" size="2">The carry flag contains the last bit shifted out of the L.O.
    bit of the operand. </font></li>
  <li><font face="Arial" size="2">The overflow flag will contain zero if the shift count is
    one. Overflow can never occur with this instruction. However, if the count is not one, the
    value of the overflow flag is undefined. </font></li>
  <li><font face="Arial" size="2">The zero flag will be one if the shift produces a zero
    result. </font></li>
  <li><font face="Arial" size="2">The sign flag will contain the H.O. bit of the result. </font></li>
  <li><font face="Arial" size="2">The parity flag will contain one if there are an even number
    of one bits in the L.O. byte of the result. </font></li>
  <li><font face="Arial" size="2">The auxiliary carry flag is always undefined after the <code>sar</code>
    instruction. </font></li>
</ul>

<p><font face="Arial" size="2">The <code>sar</code> instruction's main purpose is to
perform a signed division by some power of two. Each shift to the right divides the value
by two. Multiple right shifts divide the previous shifted result by two, so multiple
shifts produce the following results: </font></p>

<pre><font face="Courier New" size="2">                sar     ax, 1   ;Signed division by 2
                sar     ax, 2   ;Signed division by 4
                sar     ax, 3   ;Signed division by 8
                sar     ax, 4   ;Signed division by 16
                sar     ax, 5   ;Signed division by 32
                sar     ax, 6   ;Signed division by 64
                sar     ax, 7   ;Signed division by 128
                sar     ax, 8   ;Signed division by 256</font></pre>

<p><font face="Arial" size="2">There is a very important difference between the <code>sar</code>
and <code>idiv</code> instructions. The idiv instruction always truncates towards zero
while <code>sar</code> truncates results toward the smaller result. For positive results,
an arithmetic shift right by one position produces the same result as an integer division
by two. However, if the quotient is negative, <code>idiv</code> truncates towards zero
while <code>sar</code> truncates towards negative infinity. The following examples
demonstrate the difference: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, -15
                cwd
                mov     bx, 2
                idiv                    ;Produces -7

                mov     ax, -15
                sar     ax, 1           ;Produces -8</font></pre>

<p><font face="Arial" size="2">Keep this in mind if you use <code>sar</code> for integer
division operations.</font></p>

<p><font face="Arial" size="2">The <code>sar ax, 8</code> instruction effectively copies <code>ah</code>
into <code>al</code> and then sign extends <code>al</code> into <code>ax</code>. This is
because <code>sar ax, 8</code> will shift <code>ah</code> down into <code>al</code> but
leave a copy of <code>ah</code>'s H.O. bit in all the bit positions of <code>ah</code>.
Indeed, you can use the sar instruction on 80286 and later processors to sign extend one
register into another. The following code sequences provide examples of this usage: </font></p>

<pre><font face="Courier New" size="2">; Equivalent to CBW:

                mov     ah, al
                sar     ah, 7

; Equivalent to CWD:

                mov     dx, ax
                sar     dx, 15

; Equivalent to CDQ:

                mov     edx, eax
                sar     edx, 31</font></pre>

<p><font face="Arial" size="2">Of course it may seem silly to use two instructions where a
single instruction might suffice; however, the <code>cbw, cwd, </code>and <code>cdq</code>
instructions only sign extend <code>al</code> into <code>ax, ax </code>into <code>dx:ax,</code>
and <code>eax</code> into <code>edx:eax</code>. Likewise, the movsx instruction copies its
sign extended operand into a destination operand twice the size of the source operand. The
<code>sar</code> instruction lets you sign extend one register into another register of
the same size, with the second register containing the sign extension bits: </font></p>

<pre><font face="Courier New" size="2">; Sign extend bx into cx:bx

                mov     cx, bx
                sar     cx, 15</font></pre>

<h3><strong><font face="Arial" size="3"><a name="#HEADING3-174"></a>6.6.2.3 SHR</font></strong></h3>

<p><font face="Arial" size="2">The <code>shr</code> instruction shifts all the bits in the
destination operand to the right one bit shifting a zero into the H.O. bit:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch06a3.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH06/ch06a3.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="284" HEIGHT="39"> </font></p>

<p><font face="Arial" size="2">The <code>shr</code> instruction sets the flag bits as
follows: </font>

<ul>
  <li><font face="Arial" size="2">If the shift count is zero, the <code>shr </code>instruction
    doesn't affect any flags. </font></li>
  <li><font face="Arial" size="2">The carry flag contains the last bit shifted out of the L.O.
    bit of the operand. </font></li>
  <li><font face="Arial" size="2">If the shift count is one, the overflow flag will contain
    the value of the H.O. bit of the operand prior to the shift (i.e., this instruction sets
    the overflow flag if the sign changes). However, if the count is not one, the value of the
    overflow flag is undefined. </font></li>
  <li><font face="Arial" size="2">The zero flag will be one if the shift produces a zero
    result. </font></li>
  <li><font face="Arial" size="2">The sign flag will contain the H.O. bit of the result, which
    is always zero. </font></li>
  <li><font face="Arial" size="2">The parity flag will contain one if there are an even number
    of one bits in the L.O. byte of the result. </font></li>
  <li><font face="Arial" size="2">The auxiliary carry flag is always undefined after the <code>shr</code>
    instruction. </font></li>
</ul>

<p><font face="Arial" size="2">The shift right instruction is especially useful for
unpacking data. For example, suppose you want to extract the two nibbles in the <code>al</code>
register, leaving the H.O. nibble in <code>ah</code> and the L.O. nibble in <code>al</code>.
You could use the following code to do this: </font></p>

<pre><font face="Courier New" size="2">                mov     ah, al  ;Get a copy of the H.O. nibble
                shr     ah, 4   ;Move H.O. to L.O. and clear H.O. nibble
                and     al, 0Fh ;Remove H.O. nibble from al</font></pre>

<p><font face="Arial" size="2">Since shifting an unsigned integer value to the right one
position is equivalent to dividing that value by two, you can also use the shift right
instruction for division by powers of two:</font> </p>

<pre><font face="Courier New" size="2">                shr     ax, 1           ;Equivalent to AX/2
                shr     ax, 2           ;Equivalent to AX/4
                shr     ax, 3           ;Equivalent to AX/8
                shr     ax, 4           ;Equivalent to AX/16
                shr     ax, 5           ;Equivlaent to AX/32
                shr     ax, 6           ;Equivalent to AX/64
                shr     ax, 7           ;Equivalent to AX/128
                shr     ax, 8           ;Equivalent to AX/256
                etc.</font></pre>

<p><font face="Arial" size="2">Note that <code>shr ax, 8</code> is equivalent to the
following two instructions: </font></p>

<pre><font face="Courier New" size="2">		mov	al, ah
		mov	ah, 0</font></pre>

<p><font face="Arial" size="2">Remember that division by two using <code>shr</code> only
works for unsigned operands. If <code>ax</code> contains -1 and you execute <code>shr ax,
1 </code>the result in <code>ax</code> will be 32767 (7FFFh), not -1 or zero as you would
expect. Use the <code>sar</code> instruction if you need to divide a signed integer by
some power of two.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-208"></a>6.6.2.4 The SHLD and
SHRD Instructions</font></strong></p>

<p><font face="Arial" size="2">The <code>shld</code> and <code>shrd</code> instructions
provide double precision shift left and right operations, respectively. These instructions
are available only on 80386 and later processors. Their generic forms are </font></p>

<pre><font face="Courier New" size="2">                shld    operand1, operand2, immediate
                shld    operand1, operand2, cl
                shrd    operand1, operand2, immediate
                shrd    operand1, operand2, cl</font></pre>

<p><font face="Arial" size="2"><code>Operand</code>2 must be a sixteen or thirty-two bit
register. <code>Operand</code>1 can be a register or a memory location. Both operands must
be the same size. The immediate operand can be a value in the range zero through n-1,
where n is the number of bits in the two operands; it specifies the number of bits to
shift.</font></p>

<p><font face="Arial" size="2">The <code>shld</code> instruction shifts bits in operand1
to the left. The H.O. bit shifts into the carry flag and the H.O. bit of <code>operand</code>2
shifts into the L.O. bit of <code>operand</code>1. Note that this instruction does not
modify the value of operand2, it uses a temporary copy of operand2 during the shift. The
immediate operand specifies the number of bits to shift. If the count is n, then <code>shld</code>
shifts bit n-1 into the carry flag. It also shifts the H.O. n bits of operand2 into the
L.O. n bits of operand1. Pictorially, the <code>shld</code> instruction is: </font></p>

<p align="center"><img SRC="images/ch06a4.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH06/ch06a4.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="380" HEIGHT="115"> </p>

<p><font face="Arial" size="2">The <code>shld</code> instruction sets the flag bits as
follows: </font>

<ul>
  <li><font face="Arial" size="2">If the shift count is zero, the shld instruction doesn't
    affect any flags. </font></li>
  <li><font face="Arial" size="2">The carry flag contains the last bit shifted out of the H.O.
    bit of the operand1. </font></li>
  <li><font face="Arial" size="2">If the shift count is one, the overflow flag will contain
    one if the sign bit of operand1 changes during the shift. If the count is not one, the
    overflow flag is undefined. </font></li>
  <li><font face="Arial" size="2">The zero flag will be one if the shift produces a zero
    result. </font></li>
  <li><font face="Arial" size="2">The sign flag will contain the H.O. bit of the result. </font></li>
</ul>

<p><font face="Arial" size="2">The shld instruction is useful for packing data from many
different sources. For example, suppose you want to create a word by merging the H.O.
nibbles of four other words. You could do this with the following code: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, Value4      ;Get H.O. nibble
                shld    bx, ax, 4       ;Copy H.O. bits of AX to BX.
                mov     ax, Value3      ;Get nibble #2.
                shld    bx, ax, 4       ;Merge into bx.
                mov     ax, Value2      ;Get nibble #1.
                shld    bx, ax, 4       ;Merge into bx.
                mov     ax, Value1      ;Get L.O. nibble
                shld    bx, ax, 4       ;BX now contains all four nibbles.</font></pre>

<p><font face="Arial" size="2">The <code>shrd</code> instruction is similar to <code>shld</code>
except, of course, it shifts its bits right rather than left. To get a clear picture of
the <code>shrd</code> instruction, consider:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch06a5.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH06/ch06a5.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="378" HEIGHT="133"> </font></p>

<p><font face="Arial" size="2">The <code>shrd</code> instruction sets the flag bits as
follows: </font>

<ul>
  <li><font face="Arial" size="2">If the shift count is zero, the <code>shrd</code>
    instruction doesn't affect any flags. </font></li>
  <li><font face="Arial" size="2">The carry flag contains the last bit shifted out of the L.O.
    bit of the operand1. </font></li>
  <li><font face="Arial" size="2">If the shift count is one, the overflow flag will contain
    one if the H.O. bit of operand1 changes. If the count is not one, the overflow flag is
    undefined. </font></li>
  <li><font face="Arial" size="2">The zero flag will be one if the shift produces a zero
    result. </font></li>
  <li><font face="Arial" size="2">The sign flag will contain the H.O. bit of the result. </font></li>
</ul>

<p><font face="Arial" size="2">Quite frankly, these two instructions would probably be
slightly more useful if <code>Operan</code>d2 could be a memory location. Intel designed
these instructions to allow fast multiprecision (64 bits, or more) shifts.</font></p>

<p><font face="Arial" size="2">The <code>shrd</code> instruction is marginally more useful
than <code>shld</code> for packing data. For example, suppose that <code>ax</code>
contains a value in the range 0..99 representing a year (1900..1999), <code>bx</code>
contains a value in the range 1..31 representing a day, and <code>cx</code> contains a
value in the range 1..12 representing a month (see Chapter One). You can easily use the
shrd instruction to pack this data into <code>dx</code> as follows: </font></p>

<pre><font face="Courier New" size="2">                shrd    dx, ax, 7
                shrd    dx, bx, 5
                shrd    dx, cx, 4</font></pre>
<div align="center"><center>

<pre><font face="Courier New" size="2"><img SRC="images/ch06a6.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH06/ch06a6.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="368" HEIGHT="243"></font></pre>
</center></div>

<h3><strong><font face="Arial" size="3"><a name="#HEADING3-253"></a>6.6.3 The Rotate
Instructions: RCL, RCR, ROL, and ROR</font></strong></h3>

<p><font face="Arial" size="2">The rotate instructions shift the bits around, just like
the shift instructions, except the bits shifted out of the operand by the rotate
instructions recirculate through the operand. They include <code>rcl</code> (rotate
through carry left), <code>rcr</code> (rotate through carry right), <code>rol</code>
(rotate left), and <code>ror</code> (rotate right). These instructions all take the forms:</font>
</p>

<pre><font face="Courier New" size="2">        rcl     dest, count
        rol     dest, count
        rcr     dest, count
        ror     dest, count</font></pre>

<p><font face="Arial" size="2">The specific forms are </font></p>

<pre><font face="Courier New" size="2">        rcl     reg, 1
        rcl     mem, 1
        rcl     reg, imm        (2)
        rcl     mem, imm        (2)
        rcl     reg, cl
        rcl     mem, cl

        rol uses the same formats as rcl.
        rcr uses the same formats as rcl.
        ror uses the same formats as rcl.

2- This form is avialable on 80286 and later processors only.</font></pre>

<h3><strong><font face="Arial" size="3"><a name="#HEADING3-273"></a>6.6.3.1 RCL</font></strong></h3>

<p><font face="Arial" size="2">The <code>rcl</code> (rotate through carry left), as its
name implies, rotates bits to the left, through the carry flag, and back into bit zero on
the right:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch06a7.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH06/ch06a7.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="260" HEIGHT="74"> </font></p>

<p><font face="Arial" size="2">Note that if you rotate through carry an object n+1 times,
where n is the number of bits in the object, you wind up with your original value. Keep in
mind, however, that some flags may contain different values after n+1 <code>rcl</code>
operations.</font></p>

<p><font face="Arial" size="2">The <code>rcl</code> instruction sets the flag bits as
follows: </font>

<ul>
  <li><font face="Arial" size="2">The carry flag contains the last bit shifted out of the H.O.
    bit of the operand. </font></li>
  <li><font face="Arial" size="2">If the shift count is one, <code>rcl</code> sets the
    overflow flag if the sign changes as a result of the rotate. If the count is not one, the
    overflow flag is undefined. </font></li>
  <li><font face="Arial" size="2">The <code>rcl</code> instruction does not modify the zero,
    sign, parity, or auxiliary carry flags. </font></li>
</ul>

<p><font face="Arial" size="2">Important warning: unlike the shift instructions, the
rotate instructions do not affect the sign, zero, parity, or auxiliary carry flags. This
lack of orthogonality can cause you lots of grief if you forget it and attempt to test
these flags after an <code>rcl</code> operation. If you need to test one of these flags
after an <code>rcl</code> operation, test the carry and overflow flags first (if
necessary) then compare the result to zero to set the other flags.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-284"></a>6.6.3.2 RCR</font></strong></p>

<p><font face="Arial" size="2">The <code>rcr</code> (rotate through carry right)
instruction is the complement to the <code>rcl</code> instruction. It shifts its bits
right through the carry flag and back into the H.O. bit:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch06a8.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH06/ch06a8.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="248" HEIGHT="87"> </font></p>

<p><font face="Arial" size="2">This instruction sets the flags in a manner analogous to <code>rcl</code>:
</font>

<ul>
  <li><font face="Arial" size="2">The carry flag contains the last bit shifted out of the L.O.
    bit of the operand. </font></li>
  <li><font face="Arial" size="2">If the shift count is one, then <code>rcr</code> sets the
    overflow flag if the sign changes (meaning the values of the H.O. bit and carry flag were
    not the same before the execution of the instruction). However, if the count is not one,
    the value of the overflow flag is undefined. </font></li>
  <li><font face="Arial" size="2">The <code>rcr</code> instruction does not affect the zero,
    sign, parity, or auxiliary carry flags. </font></li>
</ul>

<p><font face="Arial" size="2">Keep in mind the warning given for <b>rcl</b> above.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-294"></a>6.6.3.3 ROL</font></strong></p>

<p><font face="Arial" size="2">The <code>rol</code> instruction is similar to the <code>rcl</code>
instruction in that it rotates its operand to the left the specified number of bits. The
major difference is that <code>rol</code> shifts its operand's H.O. bit, rather than the
carry, into bit zero. <code>Rol</code> also copies the output of the H.O. bit into the
carry flag:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch06a9.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH06/ch06a9.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="258" HEIGHT="74"> </font></p>

<p><font face="Arial" size="2">The <code>rol</code> instruction sets the flags identically
to <code>rcl</code>. Other than the source of the value shifted into bit zero, this
instruction behaves exactly like the <code>rcl</code> instruction. Don't forget the
warning about the flags!</font></p>

<p><font face="Arial" size="2">Like <code>shl</code>, the <code>rol</code> instruction is
often useful for packing and unpacking data. For example, suppose you want to extract bits
10..14 in <code>ax</code> and leave these bits in bits 0..4. The following code sequences
will both accomplish this: </font></p>

<pre><font face="Courier New" size="2">                shr     ax, 10
                and     ax, 1Fh

                rol     ax, 6
                and     ax, 1Fh</font></pre>

<h3><strong><font face="Arial" size="3"><a name="#HEADING3-306"></a>6.6.3.4 ROR</font></strong></h3>

<p><font face="Arial" size="2">The <code>ror</code> instruction relates to the <code>rcr</code>
instruction in much the same way that the <code>rol</code> instruction relates to <code>rcl</code>.
That is, it is almost the same operation other than the source of the input bit to the
operand. Rather than shifting the previous carry flag into the H.O. bit of the destination
operation, <code>ror</code> shifts bit zero into the H.O. bit:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch06a10.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH06/ch06a10.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="248" HEIGHT="87"> </font></p>

<p><font face="Arial" size="2">The <code>ror</code> instruction sets the flags identically
to <code>rcr</code>. Other than the source of the bit shifted into the H.O. bit, this
instruction behaves exactly like the <code>rcr</code> instruction. Don't forget the
warning about the flags! </font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH06-2.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH06-2.html">Chapter Six</a> (Part 2)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH06-4.html">Chapter Six</a> (Part 4) </strong></font><a href="CH06-4.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Six: The 80x86 Instruction
Set (Part 3)<br>
26 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_6/CH06-3.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:27 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
