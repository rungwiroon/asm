<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_6/CH06-2.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:16 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER SIX: THE 80x86 INSTRUCTION SET (Part 2)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING2"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH06-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH06-1.html">Chapter Six</a> (Part 1)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH06-3.html">Chapter Six</a> (Part 3) </strong></font><a href="CH06-3.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10" colspan="2"><a NAME="HEADING2-0"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0" colspan="2"><font face="Arial" size="4"><strong>CHAPTER
    SIX:<br>
    THE 80x86 INSTRUCTION SET (Part 2)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10" colspan="2"></td>
  </tr>
  <tr>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING2-1"><b>6.5 </b>-
    Arithmetic Instructions</a> <br>
    <a HREF="#HEADING2-28"><b>6.5.1 </b>- The Addition Instructions: ADD, ADC, INC, XADD, AAA,
    and DAA</a> <br>
    <a HREF="#HEADING2-48"><b>6.5.1.1 </b>- The ADD and ADC Instructions</a> <br>
    <a HREF="#HEADING2-117"><b>6.5.1.2 </b>- The INC Instruction</a> <br>
    <a HREF="#HEADING2-123"><b>6.5.1.3 </b>- The XADD Instruction</a> <br>
    <a HREF="#HEADING2-133"><b>6.5.1.4 </b>- The AAA and DAA Instructions</a> </font></td>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING2-171"><b>6.5.2 </b>-
    The Subtraction Instructions: SUB, SBB, DEC, AAS, and DAS</a> <br>
    <a HREF="#HEADING2-244"><b>6.5.3 </b>- The CMP Instruction</a> <br>
    <a HREF="#HEADING2-286"><b>6.5.4 </b>- The CMPXCHG, and CMPXCHG8B Instructions</a> <br>
    <a HREF="#HEADING2-313"><b>6.5.5 </b>- The NEG Instruction </a><br>
    <a HREF="#HEADING2-337"><b>6.5.6 </b>- The Multiplication Instructions: MUL, IMUL, and AAM</a>
    <br>
    <a HREF="#HEADING2-451"><b>6.5.7 </b>- The Division Instructions: DIV, IDIV, and AAD</a> </font></td>
  </tr>
  <tr>
    <td width="100%" valign="top" colspan="2" nowrap height="20"></td>
  </tr>
  <tr>
    <td width="100%" valign="top" colspan="2"><strong><font face="Arial" size="3"><a NAME="HEADING2-1"></a>6.5 Arithmetic Instructions</font></strong></td>
  </tr>
  <tr>
    <td width="100%" valign="top" colspan="2" nowrap height="1" bgcolor="#000000"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">The 80x86 provides many arithmetic operations: addition,
subtraction, negation, multiplication, division/modulo (remainder), and comparing two
values. The instructions that handle these operations <code>are add, adc, sub, sbb, mul,
imul, div, idiv, cmp, neg, inc, dec, xadd, cmpxchg,</code> and some miscellaneous
conversion instructions: <code>aaa, aad, aam, aas, daa,</code> and <code>das</code>. The
following sections describe these instructions in detail. </font></p>

<p><font face="Arial" size="2">The generic forms for these instructions are </font></p>

<pre><font face="Courier New" size="2">add     dest, src               dest := dest + src
adc     dest, src               dest := dest + src + C
SUB     dest, src               dest := dest - src
sbb     dest, src               dest := dest - src - C
mul     src                     acc := acc * src
imul    src                     acc := acc * src
imul    dest, src1, imm_src     dest := src1 * imm_src
imul    dest, imm_src           dest := dest * imm_src
imul    dest, src               dest := dest * src
div     src                     acc := xacc /-mod src
idiv    src                     acc := xacc /-mod src
cmp     dest, src               dest - src (and set flags)
neg     dest                    dest := - dest
inc     dest                    dest := dest + 1
dec     dest                    dest := dest - 1
xadd    dest, src               (see text)
cmpxchg  operand1, operand2     (see text)
cmpxchg8 ax, operand            (see text)
aaa                             (see text)
aad                             (see text)
aam                             (see text)
aas                             (see text)
daa                             (see text)
das                             (see text)</font></pre>

<pre><a name="#HEADING2-28"></a><strong><font face="Arial" size="3">6.5.1 The Addition Instructions: ADD, ADC, INC, XADD, AAA, and DAA</font></strong></pre>

<p><font face="Arial" size="2">These instructions take the forms: </font></p>

<pre><font face="Courier New" size="2">                add     reg, reg
                add     reg, mem
                add     mem, reg
                add     reg, immediate data
                add     mem, immediate data
                add     eax/ax/al, immediate data

                adc forms are identical to ADD.

                inc     reg
                inc     mem
                inc     reg16
                xadd    mem, reg
                xadd    reg, reg
                aaa
                daa</font></pre>

<p><font face="Arial" size="2">Note that the <code>aaa</code> and <code>daa</code>
instructions use the implied addressing mode and allow no operands.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-48"></a>6.5.1.1 The ADD and ADC
Instructions</font></strong></p>

<p><font face="Arial" size="2">The syntax of <code>add</code> and <code>adc</code> (add
with carry) is similar to <code>mov</code>. Like <code>mov</code>, there are special forms
for the <code>ax/eax</code> register that are more efficient. Unlike <code>mov</code>, you
cannot add a value to a segment register with these instructions.</font></p>

<p><font face="Arial" size="2">The <code>add</code> instruction adds the contents of the
source operand to the destination operand. For example, <code>add</code> <code>ax, bx </code>adds<code>
bx</code> to <code>ax</code> leaving the sum in the <code>ax</code> register. <code>Add</code>
computes <code>dest :=dest+source </code>while <code>adc</code> computes <code>dest
:=dest+source+C</code> where <code>C</code> represents the value in the carry flag.
Therefore, if the carry flag is clear before execution, <code>adc</code> behaves exactly
like the <code>add</code> instruction. </font></p>

<p><font face="Arial" size="2">Both instructions affect the flags identically. They set
the flags as follows: </font>

<ul>
  <li><font face="Arial" size="2">The overflow flag denotes a signed arithmetic overflow. </font></li>
  <li><font face="Arial" size="2">The carry flag denotes an unsigned arithmetic overflow. </font></li>
  <li><font face="Arial" size="2">The sign flag denotes a negative result (i.e., the H.O. bit
    of the result is one). </font></li>
  <li><font face="Arial" size="2">The zero flag is set if the result of the addition is zero. </font></li>
  <li><font face="Arial" size="2">The auxiliary carry flag contains one if a BCD overflow out
    of the L.O. nibble occurs. </font></li>
  <li><font face="Arial" size="2">The parity flag is set or cleared depending on the parity of
    the L.O. eight bits of the result. If there are an even number of one bits in the result,
    the ADD instructions will set the parity flag to one (to denote even parity). If there are
    an odd number of one bits in the result, the ADD instructions clear the parity flag (to
    denote odd parity). </font></li>
</ul>

<p><font face="Arial" size="2">The <code>add</code> and <code>adc</code> instructions do
not affect any other flags.</font></p>

<p><font face="Arial" size="2">The <code>add</code> and <code>adc</code> instructions
allow eight, sixteen, and (on the 80386 and later) thirty-two bit operands. Both source
and destination operands must be the same size. See Chapter Nine if you want to add
operands whose size is different.</font></p>

<p><font face="Arial" size="2">Since there are no memory to memory additions, you must
load memory operands into registers if you want to add two variables together. The
following code examples demonstrate possible forms for the <code>add</code> instruction: </font></p>

<pre><font face="Courier New" size="2">; J:= K + M

                mov     ax, K
                add     ax, M
                mov     J, ax</font></pre>

<p><font face="Arial" size="2">If you want to add several values together, you can easily
compute the sum in a single register: </font></p>

<pre><font face="Courier New" size="2">; J := K + M + N + P

                mov     ax, K
                add     ax, M
                add     ax, N
                add     ax, P
                mov     J, ax</font></pre>

<p><font face="Arial" size="2">If you want to reduce the number of hazards on an 80486 or
Pentium processor, you can use code like the following: </font></p>

<pre><font face="Courier New" size="2">                mov     bx, K
                mov     ax, M
                add     bx, N
                add     ax, P
                add     ax, bx
                mov     J, ax</font></pre>

<p><font face="Arial" size="2">One thing that beginning assembly language programmers
often forget is that you can add a register to a memory location. Sometimes beginning
programmers even believe that both operands have to be in registers, completely forgetting
the lessons from Chapter Four. The 80x86 is a CISC processor that allows you to use memory
addressing modes with various instructions like <code>add</code>. It is often more
efficient to take advantages of the 80x86's memory addressing capabilities </font></p>

<pre><font face="Courier New" size="2">; J := K + J

                mov     ax, K           ;This works because addition is
                add     J, ax           ; commutative!

; Often, beginners will code the above as one of the following two sequences.
; This is unnecessary!

                mov     ax, J           ;Really BAD way to compute 
                mov     bx, K           ; J := J + K.
                add     ax, bx
                mov     J, ax

                mov     ax, J           ;Better, but still not a good way to
                add     ax, K           ; compute J := J + K
                mov     J, ax</font></pre>

<p><font face="Arial" size="2">Of course, if you want to add a constant to a memory
location, you only need a single instruction. The 80x86 lets you directly add a constant
to memory: </font></p>

<pre><font face="Courier New" size="2">; J := J + 2

                add     J, 2</font></pre>

<p><font face="Arial" size="2">There are special forms of the <code>add</code> and <code>adc</code>
instructions that add an immediate constant to the <code>al</code>, <code>ax</code>, or <code>eax</code>
register. These forms are shorter than the standard <code>add reg, immediate</code>
instruction. Other instructions also provide shorter forms when using these registers;
therefore, you should try to keep computations in the accumulator registers (al, ax, and
eax) as much as possible. </font></p>

<pre><font face="Courier New" size="2">                add     bl, 2           ;Three bytes long
                add     al, 2           ;Two bytes long
                add     bx, 2           ;Four bytes long
                add     ax, 2           ;Three bytes long
                etc.</font></pre>

<p><font face="Arial" size="2">Another optimization concerns the use of small signed
constants with the <code>add</code> and <code>adc</code> instructions. If a value is in
the range -128,,+127, the <code>add</code> and <code>adc</code> instructions will sign
extend an eight bit immediate constant to the necessary destination size (eight, sixteen,
or thirty-two bits). Therefore, you should try to use small constants, if possible, with
the <code>add</code> and <code>adc</code> instructions.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-117"></a>6.5.1.2 The INC
Instruction</font></strong></p>

<p><font face="Arial" size="2">The <code>inc</code> (increment) instruction adds one to
its operand. Except for the carry flag, <code>inc</code> sets the flags the same way as <code>add
operand, 1</code> would.</font></p>

<p><font face="Arial" size="2">Note that there are two forms of <code>inc</code> for 16 or
32 bit registers. They are the <code>inc reg </code>and <code>inc reg16 </code>instructions.
The <code>inc reg</code> and <code>inc mem</code> instructions are the same. This
instruction consists of an opcode byte followed by a mod-reg-r/m byte (see Appendix D for
details). The<code> inc reg16</code> instruction has a single byte opcode. Therefore, it
is shorter and usually faster.</font></p>

<p><font face="Arial" size="2">The <code>inc</code> operand may be an eight bit, sixteen
bit, or (on the 80386 and later) thirty-two bit register or memory location.</font></p>

<p><font face="Arial" size="2">The <code>inc</code> instruction is more compact and often
faster than the comparable <code>add reg, 1</code> or <code>add mem, 1</code> instruction.
Indeed, the <code>inc reg16</code> instruction is one byte long, so it turns out that two
such instructions are shorter than the comparable <code>add reg, 1</code> instruction;
however, the two increment instructions will run slower on most modern members of the
80x86 family. </font></p>

<p><font face="Arial" size="2">The <code>inc</code> instruction is very important because
adding one to a register is a very common operation. Incrementing loop control variables
or indices into an array is a very common operation, perfect for the <code>inc</code>
instruction. The fact that inc does not affect the carry flag is very important. This
allows you to increment array indices without affecting the result of a multiprecision
arithmetic operation ( see Chapter Nine for more details about multiprecision arithmetic).</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-123"></a>6.5.1.3 The XADD
Instruction</font></strong></p>
<code>

<p><font face="Arial" size="2">Xadd</code> (Exchange and Add) is another 80486 (and later)
instruction. It does not appear on the 80386 and earlier processors. This instruction adds
the source operand to the destination operand and stores the sum in the destination
operand. However, just before storing the sum, it copies the original value of the
destination operand into the source operand. The following algorithm describes this
operation:</font> </p>

<pre><font face="Courier New" size="2">                xadd dest, source

                temp := dest
                dest := dest + source
                source := temp</font></pre>

<p><font face="Arial" size="2">The<code> xadd</code> sets the flags just as the <code>add</code>
instruction would. The <code>xadd</code> instruction allows eight, sixteen, and thirty-two
bit operands. Both source and destination operands must be the same size.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-133"></a>6.5.1.4 The AAA and DAA
Instructions</font></strong></p>

<p><font face="Arial" size="2">The <code>aaa</code> (ASCII adjust after addition) and <code>daa</code>
(decimal adjust for addition) instructions support BCD arithmetic. Beyond this chapter,
this text will not cover BCD or ASCII arithmetic since it is mainly for controller
applications, not general purpose programming applications. BCD values are decimal integer
coded in binary form with one decimal digit (0..9) per nibble. ASCII (numeric) values
contain a single decimal digit per byte, the H.O. nibble of the byte should contain zero. </font></p>

<p><font face="Arial" size="2">The <code>aaa</code> and <code>daa</code> instructions
modify the result of a binary addition to correct it for ASCII or decimal arithmetic. For
example, to add two BCD values, you would add them as though they were binary numbers and
then execute the <code>daa</code> instruction afterwards to correct the results. Likewise,
you can use the <code>aaa</code> instruction to adjust the result of an ASCII addition
after executing an <code>add</code> instruction. Please note that these two instructions
assume that the add operands were proper decimal or ASCII values. If you add binary
(non-decimal or non-ASCII) values together and try to adjust them with these instructions,
you will not produce correct results.</font></p>

<p><font face="Arial" size="2">The choice of the name &quot;ASCII arithmetic&quot; is
unfortunate, since these values are not true ASCII characters. A name like &quot;unpacked
BCD&quot; would be more appropriate. However, Intel uses the name ASCII, so this text will
do so as well to avoid confusion. However, you will often hear the term &quot;unpacked
BCD&quot; to describe this data type.</font></p>

<p><font face="Arial" size="2"><code>Aaa</code> (which you generally execute after an <code>add,
adc, </code>or<code> xadd</code> instruction) checks the value in <code>al for </code>BCD
overflow. It works according to the following basic algorithm: </font></p>

<pre><font face="Courier New" size="2">if ( (al and 0Fh) &gt; 9 or (AuxC =1) ) then

        if (8088 or 8086) then 
                al := al + 6
        else 
                ax := ax + 6
        endif

        ah := ah + 1
        AuxC := 1               ;Set auxilliary carry
        Carry := 1              ; and carry flags.

else

        AuxC := 0               ;Clear auxilliary carry
        Carry := 0              ; and carry flags.
endif
al := al and 0Fh</font></pre>

<p><font face="Arial" size="2">The <code>aaa</code> instruction is mainly useful for
adding strings of digits where there is exactly one decimal digit per byte in a string of
numbers. This text will not deal with BCD or ASCII numeric strings, so you can safely
ignore this instruction for now. Of course, you can use the <code>aaa</code> instruction
any time you need to use the algorithm above, but that would probably be a rare situation.</font></p>

<p><font face="Arial" size="2">The <code>daa</code> instruction functions like <code>aaa</code>
except it handles packed BCD (binary code decimal) values rather than the one digit per
byte unpacked values <code>aaa</code> handles. As for <code>aaa</code>, <code>daa</code>'s
main purpose is to add strings of BCD digits (with two digits per byte). The algorithm <code>for
daa</code> is </font></p>

<pre><font face="Courier New" size="2">if ( (AL and 0Fh) &gt; 9 or (AuxC = 1)) then

        al := al + 6
        AuxC := 1               ;Set Auxilliary carry.

endif
if ( (al &gt; 9Fh) or (Carry = 1)) then

        al := al + 60h
        Carry := 1;             ;Set carry flag.

endif</font></pre>

<pre><a name="#HEADING2-171"></a><strong><font face="Arial" size="3">6.5.2 The Subtraction Instructions: SUB, SBB, DEC, AAS, and DAS</font></strong></pre>

<p><font face="Arial" size="2">The <code>sub</code> (subtract), <code>sbb</code> (subtract
with borrow), dec (decrement), aas (ASCII adjust for subtraction), and <code>das</code>
(decimal adjust for subtraction) instructions work as you expect. Their syntax is very
similar to that of the <code>add</code> instructions:</font> </p>

<pre><font face="Courier New" size="2">                sub     reg, reg
                sub     reg, mem
                sub     mem, reg
                sub     reg, immediate data
                sub     mem, immediate data
                sub     eax/ax/al, immediate data

                sbb forms are identical to sub.

                dec     reg
                dec     mem
                dec     reg16
                aas
                das</font></pre>

<p><font face="Arial" size="2">The <code>sub</code> instruction computes the value <code>dest
:= dest - src</code>. The <code>sbb</code> instruction computes <code>dest := dest - src -
C</code>. Note that subtraction is not commutative. If you want to compute the result for <code>dest
:= src - dest </code>you will need to use several instructions, assuming you need to
preserve the source operand).</font></p>

<p><font face="Arial" size="2">One last subject worth discussing is how the <code>sub</code>
instruction affects the 80x86 flags register. The <code>sub, sbb,</code> and <code>dec</code>
instructions affect the flags as follows: </font>

<ul>
  <li><font face="Arial" size="2">They set the zero flag if the result is zero. This occurs
    only if the operands are equal for <code>sub</code> and <code>sbb</code>. The <code>dec</code>
    instruction sets the zero flag only when it decrements the value one. </font></li>
  <li><font face="Arial" size="2">These instructions set the sign flag if the result is
    negative. </font></li>
  <li><font face="Arial" size="2">These instructions set the overflow flag if signed
    overflow/underflow occurs. </font></li>
  <li><font face="Arial" size="2">They set the auxiliary carry flag as necessary for BCD/ASCII
    arithmetic. </font></li>
  <li><font face="Arial" size="2">They set the parity flag according to the number of one bits
    appearing in the result value. </font></li>
  <li><font face="Arial" size="2">The <code>sub</code> and <code>sbb</code> instructions set
    the carry flag if an unsigned overflow occurs. Note that the <code>dec</code> instruction
    does not affect the carry flag. </font></li>
</ul>

<p><font face="Arial" size="2">The <code>aas</code> instruction, like its <code>aaa</code>
counterpart, lets you operate on strings of ASCII numbers with one decimal digit (in the
range 0..9) per byte. You would use this instruction after a <code>sub</code> or <code>sbb</code>
instruction on the ASCII value. This instruction uses the following algorithm:</font> </p>

<pre><font face="Courier New" size="2">if ( (al and 0Fh) &gt; 9 or AuxC = 1) then
        al := al - 6
        ah := ah - 1
        AuxC := 1       ;Set auxilliary carry
        Carry := 1      ; and carry flags.
else
        AuxC := 0       ;Clear Auxilliary carry
        Carry := 0      ; and carry flags.
endif
al := al and 0Fh</font></pre>

<p><font face="Arial" size="2">The <code>das</code> instruction handles the same operation
for BCD values, it uses the following algorithm: </font></p>

<pre><font face="Courier New" size="2">if ( (al and 0Fh) &gt; 9 or (AuxC = 1)) then
        al := al -6
        AuxC = 1
endif
if (al &gt; 9Fh or Carry = 1) then
        al := al - 60h
        Carry := 1              ;Set the Carry flag.
endif</font></pre>

<p><font face="Arial" size="2">Since subtraction is not commutative, you cannot use the <code>sub</code>
instruction as freely as the <code>add</code> instruction. The following examples
demonstrate some of the problems you may encounter. </font></p>

<pre><font face="Courier New" size="2">; J := K - J

                mov     ax, K           ;This is a nice try, but it computes
                sub     J, ax           ; J := J - K, subtraction isn't
                                        ; commutative!

                mov     ax, K           ;Correct solution.
                sub     ax, J
                mov     J, ax

; J := J - (K + M) -- Don't forget this is equivalent to J := J - K - M

                mov     ax, K           ;Computes AX := K + M
                add     ax, M
                sub     J, ax           ;Computes J := J - (K + M)

                mov     ax, J           ;Another solution, though less
                sub     ax, K           ;Efficient
                sub     ax, M
                mov     J, ax</font></pre>

<p><font face="Arial" size="2">Note that the <code>sub</code> and <code>sbb</code>
instructions, like <code>add</code> and <code>adc</code>, provide short forms to subtract
a constant from an accumulator register (<code>al, ax,</code> or <code>eax</code>). For
this reason, you should try to keep arithmetic operations in the accumulator registers as
much as possible. The <code>sub</code> and <code>sbb</code> instructions also provide a
shorter form when subtracting constants in the range -128..+127 from a memory location or
register. The instruction will automatically sign extend an eight bit signed value to the
necessary size before the subtraction occurs. See Appendix D for the details.</font></p>

<p><font face="Arial" size="2">In practice, there really isn't a need for an instruction
that subtracts a constant from a register or memory location - adding a negative value
achieves the same result. Nevertheless, Intel provides a subtract immediate instruction.</font></p>

<p><font face="Arial" size="2">After the execution of a <code>sub</code> instruction, the
condition code bits (carry, sign, overflow, and zero) in the flags register contain values
you can test to see if one of <code>sub</code>'s operands is equal, not equal, less than,
less than or equal, greater than, or greater than or equal to the other operand. See the <code>cmp</code>
instruction for more details.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-244"></a>6.5.3 The CMP
Instruction</font></strong></p>

<p><font face="Arial" size="2">The <code>cmp</code> (compare) instruction is identical to
the <code>sub</code> instruction with one crucial difference - it does not store the
difference back into the destination operand. The syntax for the <code>cmp</code>
instruction is very similar to <code>sub</code>, the generic form is </font></p>

<pre><font face="Courier New" size="2">                cmp     dest, src</font></pre>

<p><font face="Arial" size="2">The specific forms are </font></p>

<pre><font face="Courier New" size="2">                cmp     reg, reg
                cmp     reg, mem
                cmp     mem, reg
                cmp     reg, immediate data
                cmp     mem, immediate data
                cmp     eax/ax/al, immediate data</font></pre>

<p><font face="Arial" size="2">The <code>cmp</code> instruction updates the 80x86's flags
according to the result of the subtraction operation (dest - src). You can test the result
of the comparison by checking the appropriate flags in the flags register. For details on
how this is done, see &quot;The &quot;Set on Condition&quot; Instructions&quot; and
&quot;The Conditional Jump Instructions&quot;.</font></p>

<p><font face="Arial" size="2">Usually you'll want to execute a conditional jump
instruction after a <code>cmp </code>instruction. This two step process, comparing two
values and setting the flag bits then testing the flag bits with the conditional jump
instructions, is a very efficient mechanism for making decisions in a program. </font></p>

<p><font face="Arial" size="2">Probably the first place to start when exploring the <code>cmp
</code>instruction is to take a look at exactly how the <code>cmp </code>instruction
affects the flags. Consider the following <code>cmp </code>instruction: </font></p>

<pre><font face="Courier New" size="2">		cmp	ax, bx</font></pre>

<p><font face="Arial" size="2">This instruction performs the computation <code>ax-bx </code>and
sets the flags depending upon the result of the computation. The flags are set as follows:</font></p>

<p><font face="Arial" size="2">Z: The zero flag is set if and only if <code>ax = bx</code>.
This is the only time <code>ax-bx </code>produces a zero result. Hence, you can use the
zero flag to test for equality or inequality. </font></p>

<p><font face="Arial" size="2">S: The sign flag is set to one if the result is negative.
At first glance, you might think that this flag would be set if <code>ax </code>is less
than <code>bx </code>but this isn't always the case. If <code>ax</code>=7FFFh and <code>bx</code>=-1
(0FFFFh) subtracting <code>ax </code>from <code>bx </code>produces 8000h, which is
negative (and so the sign flag will be set). So, for signed comparisons anyway, the sign
flag doesn't contain the proper status. For unsigned operands, consider <code>ax</code>=0FFFFh
and <code>bx</code>=1. <code>Ax </code>is greater than <code>bx </code>but their
difference is 0FFFEh which is still negative. As it turns out, the sign flag and the
overflow flag, taken together, can be used for comparing two signed values. </font></p>

<p><font face="Arial" size="2">O: The overflow flag is set after a <code>cmp </code>operation
if the difference of <code>ax </code>and <code>bx </code>produced an overflow or
underflow. As mentioned above, the sign flag and the overflow flag are both used when
performing signed comparisons. </font></p>

<p><font face="Arial" size="2">C: The carry flag is set after a <code>cmp </code>operation
if subtracting <code>bx </code>from <code>ax </code>requires a borrow. This occurs only
when <code>ax </code>is less than <code>bx </code>where <code>ax </code>and <code>bx </code>are
both unsigned values. </font></p>

<p><font face="Arial" size="2">The <code>cmp </code>instruction also affects the parity
and auxiliary carry flags, but you'll rarely test these two flags after a compare
operation. Given that the <b>cmp </b>instruction sets the flags in this fashion, you can
test the comparison of the two operands with the following flags: </font></p>

<pre><font face="Courier New" size="2">		cmp Oprnd1, Oprnd2</font></pre>
<div align="center"><center>

<table BORDER="1" bordercolor="#C0C0C0" cellspacing="0" cellpadding="0">
  <caption><strong><font face="Arial" size="2">Condition Code Settings After CMP</font></strong></caption>
  <tr>
    <th bgcolor="#F0F0F0"><font face="Arial" size="2">Unsigned operands:</font></th>
    <th bgcolor="#F0F0F0"><font face="Arial" size="2">Signed operands:</font></th>
  </tr>
  <tr>
    <td><font face="Arial" size="2">Z: equality/inequality</font></td>
    <td><font face="Arial" size="2">Z: equality/inequality</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">C: Oprnd1 &lt; Oprnd2 (C=1) Oprnd1 &gt;= Oprnd2 (C=0)</font></td>
    <td><font face="Arial" size="2">C: no meaning </font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">S: no meaning</font></td>
    <td><font face="Arial" size="2">S: see below</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">O: no meaning</font></td>
    <td><font face="Arial" size="2">O: see below</font></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">For signed comparisons, the S (sign) and O (overflow)
flags, taken together, have the following meaning:</font></p>

<p><font face="Arial" size="2">If ((S=0) and (O=1)) or ((S=1) and (O=0)) then Oprnd1 &lt;
Oprnd2 when using a signed comparison.</font></p>

<p><font face="Arial" size="2">If ((S=0) and (O=0)) or ((S=1) and (O=1)) then Oprnd1 &gt;=
Oprnd2 when using a signed comparison.</font></p>

<p><font face="Arial" size="2">To understand why these flags are set in this manner,
consider the following examples: </font></p>

<pre><font face="Courier New" size="2">        Oprnd1        minus     Oprnd2          S       O
        ------                  ------          -       -

        0FFFF (-1)      -       0FFFE (-2)      0       0
        08000           -       00001           0       1
        0FFFE (-2)      -       0FFFF (-1)      1       0
        07FFF (32767)   -       0FFFF (-1)      1       1</font></pre>

<p><font face="Arial" size="2">Remember, the <code>cmp </code>operation is really a
subtraction, therefore, the first example above computes (-1)-(-2) which is (+1). The
result is positive and an overflow did not occur so both the S and O flags are zero. Since
(S xor O) is zero, Oprnd1 is greater than or equal to Oprnd2.</font></p>

<p><font face="Arial" size="2">In the second example, the <code>cmp </code>instruction
would compute (-32768)-(+1) which is (-32769). Since a 16-bit signed integer cannot
represent this value, the value wraps around to 7FFFh (+32767) and sets the overflow flag.
Since the result is positive (at least within the confines of 16 bits) the sign flag is
cleared. Since (S xor O) is one here, Oprnd1 is less than Oprnd2. </font></p>

<p><font face="Arial" size="2">In the third example above, <code>cmp </code>computes
(-2)-(-1) which produces (-1). No overflow occurred so the O flag is zero, the result is
negative so the sign flag is one. Since (S xor O) is one, Oprnd1 is less than Oprnd2. </font></p>

<p><font face="Arial" size="2">In the fourth (and final) example, <code>cmp </code>computes
(+32767)-(-1). This produces (+32768), setting the overflow flag. Furthermore, the value
wraps around to 8000h (-32768) so the sign flag is set as well. Since (S xor O) is zero,
Oprnd1 is greater than or equal to Oprnd2. </font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-286"></a>6.5.4 The CMPXCHG, and
CMPXCHG8B Instructions</font></strong></p>

<p><font face="Arial" size="2">The <code>cmpxchg</code> (compare and exchange) instruction
is available only on the 80486 and later processors. It supports the following syntax: </font></p>

<pre><font face="Courier New" size="2">                cmpxchg reg, reg
                cmpxchg mem, reg</font></pre>

<p><font face="Arial" size="2">The operands must be the same size (eight, sixteen, or
thirty-two bits). This instruction also uses the accumulator register; it automatically
chooses al, ax, or eax to match the size of the operands.</font></p>

<p><font face="Arial" size="2">This instruction compares <code>al</code>, <code>ax</code>,
or <code>eax</code> with the first operand and sets the zero flag if they are equal. If
so, then <code>cmpxchg</code> copies the second operand into the first. If they are not
equal, <code>cmpxchg</code> copies the first operand into the accumulator. The following
algorithm describes this operation: </font></p>

<pre><font face="Courier New" size="2">        cmpxchg         operand1, operand2

        if ({al/ax/eax} = operand1) then

                zero := 1               ;Set the zero flag
                operand1 := operand2

        else

                zero := 0               ;Clear the zero flag
                {al/ax/eax} := operand1

        endif</font></pre>

<p><font face="Arial" size="2"><code>Cmpxchg</code> supports certain operating system data
structures requiring atomic operations and semaphores. Of course, if you can fit the above
algorithm into your code, you can use the <code>cmpxchg</code> instruction as appropriate.</font></p>

<p><font face="Arial" size="2">Note: unlike the <code>cmp</code> instruction, the <code>cmpxchg</code>
instruction only affects the 80x86 zero flag. You cannot test other flags after <code>cmpxchg</code>
as you could with the <code>cmp</code> instruction.</font></p>

<p><font face="Arial" size="2">The Pentium processor supports a 64 bit compare and
exchange instruction - <code>cmpxchg8b</code>. It uses the syntax: </font></p>

<pre><font face="Courier New" size="2">                cmpxchg8b ax, mem64</font></pre>

<p><font face="Arial" size="2">This instruction compares the 64 bit value in <code>edx:eax</code>
with the memory value. If they are equal, the Pentium stores ecx:ebx into the memory
location, otherwise it loads edx:eax with the memory location. This instruction sets the
zero flag according to the result. It does not affect any other flags.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-313"></a>6.5.5 The NEG
Instruction </font></strong></p>

<p><font face="Arial" size="2">The <code>neg</code> (negate) instruction takes the two's
complement of a byte or word. It takes a single (destination) operation and negates it.
The syntax for this instruction is </font></p>

<pre><font face="Courier New" size="2">		neg	dest</font></pre>

<p><font face="Arial" size="2">It computes the following: </font></p>

<pre><font face="Courier New" size="2">		dest := 0 - dest</font></pre>

<p><font face="Arial" size="2">This effectively reverses the sign of the destination
operand. </font></p>

<p><font face="Arial" size="2">If the operand is zero, its sign does not change, although
this clears the carry flag. Negating any other value sets the carry flag. Negating a byte
containing -128, a word containing -32,768, or a double word containing -2,147,483,648
does not change the operand, but will set the overflow flag. <code>Neg</code> always
updates the A, S, P, and Z flags as though you were using the <code>sub</code>
instruction.</font></p>

<p><font face="Arial" size="2">The allowable forms are: </font></p>

<pre><font face="Courier New" size="2">                neg     reg
                neg     mem</font></pre>

<p><font face="Arial" size="2">The operands may be eight, sixteen, or (on the 80386 and
later) thirty-two bit values.</font></p>

<p><font face="Arial" size="2">Some examples: </font></p>

<pre><font face="Courier New" size="2">; J := - J

                neg     J

; J := -K
                mov     ax, K
                neg     ax
                mov     J, ax</font></pre>

<h3><strong><font face="Arial" size="3"><a name="#HEADING2-337"></a>6.5.6 The
Multiplication Instructions: MUL, IMUL, and AAM</font></strong></h3>

<p><font face="Arial" size="2">The multiplication instructions provide you with your first
taste of irregularity in the 8086's instruction set. Instructions like <code>add</code>, <code>adc</code>,
<code>sub</code>, <code>sbb</code>, and many others in the 8086 instruction set use a
mod-reg-r/m byte to support two operands. Unfortunately, there aren't enough bits in the
8086's opcode byte to support all instructions, so the 8086 uses the reg bits in the
mod-reg-r/m byte as an opcode extension. For example, <code>inc</code>, <code>dec</code>,
and <code>neg</code> do not require two operands, so the 80x86 CPUs use the reg bits as an
extension to the eight bit opcode. This works great for single operand instructions,
allowing Intel's designers to encode several instructions (eight, in fact) with a single
opcode.</font></p>

<p><font face="Arial" size="2">Unfortunately, the multiply instructions require special
treatment and Intel's designers were still short on opcodes, so they designed the multiply
instructions to use a single operand. The reg field contains an opcode extension rather
than a register value. Of course, multiplication is a two operand function. The 8086
always assumes the accumulator (<code>al</code>, <code>ax</code>, or <code>eax</code>) is
the destination operand. This irregularity makes using multiplication on the 8086 a little
more difficult than other instructions because one operand has to be in the accumulator.
Intel adopted this unorthogonal approach because they felt that programmers would use
multiplication far less often than instructions like <code>add</code> and <code>sub</code>.
</font></p>

<p><font face="Arial" size="2">One problem with providing only a mod-reg-r/m form of the
instruction is that you cannot multiply the accumulator by a constant; the mod-reg-r/m
byte does not support the immediate addressing mode. Intel quickly discovered the need to
support multiplication by a constant and provide some support for this in the 80286
processor. This was especially important for multidimensional array access. By the time
the 80386 rolled around, Intel generalized one form of the multiplication operation
allowing standard mod-reg-r/m operands.</font></p>

<p><font face="Arial" size="2">There are two forms of the multiply instruction: an
unsigned multiplication (<code>mul</code>) and a signed multiplication (<code>imul</code>).
Unlike addition and subtraction, you need separate instructions for these two operations.</font></p>

<p><font face="Arial" size="2">The multiply instructions take the following forms:</font></p>

<p><font face="Arial" size="2">Unsigned Multiplication: </font></p>

<pre><font face="Courier New" size="2">                mul     reg
                mul     mem</font></pre>

<p><font face="Arial" size="2">Signed (Integer) Multiplication: </font></p>

<pre><font face="Courier New" size="2">                imul    reg
                imul    mem
                imul    reg, reg, immediate     (2)
                imul    reg, mem, immediate     (2)
                imul    reg, immediate          (2)
                imul    reg, reg                (3)
                imul    reg, mem                (3)</font></pre>

<p><font face="Arial" size="2">BCD Multiplication Operations: </font></p>

<pre><font face="Courier New" size="2">                aam

2- Available on the 80286 and later, only.
3- Available on the 80386 and later, only.</font></pre>

<p><font face="Arial" size="2">As you can see, the multiply instructions are a real mess.
Worse yet, you have to use an 80386 or later processor to get near full functionality.
Finally, there are some restrictions on these instructions not obvious above. Alas, the
only way to deal with these instructions is to memorize their operation.</font></p>

<p><font face="Arial" size="2"><code>Mul</code>, available on all processors, multiplies
unsigned eight, sixteen, or thirty-two bit operands. Note that when multiplying two n-bit
values, the result may require as many as 2*n bits. Therefore, if the operand is an eight
bit quantity, the result will require sixteen bits. Likewise, a 16 bit operand produces a
32 bit result and a 32 bit operand requires 64 bits for the result.</font></p>

<p><font face="Arial" size="2">The <code>mul</code> instruction, with an eight bit
operand, multiplies the <code>al</code> register by the operand and stores the 16 bit
result in <code>ax</code>. So </font></p>

<pre><font face="Courier New" size="2">		mul	operand8
or		imul	operand8</font></pre>

<p><font face="Arial" size="2">computes: </font></p>

<pre><font face="Courier New" size="2">		ax := al * operand8</font></pre>

<p><font face="Arial" size="2">&quot;*&quot; represents an unsigned multiplication for <code>mul</code>
and a signed multiplication for <code>imul</code>.</font></p>

<p><font face="Arial" size="2">If you specify a 16 bit operand, then <code>mul</code> and <code>imul</code>
compute: </font></p>

<pre><font face="Courier New" size="2">		dx:ax := ax * operand16</font></pre>

<p><font face="Arial" size="2">&quot;*&quot; has the same meanings as above and <code>dx:ax</code>
means that <code>dx</code> contains the H.O. word of the 32 bit result and <code>ax</code>
contains the L.O. word of the 32 bit result. </font></p>

<p><font face="Arial" size="2">If you specify a 32 bit operand, then <code>mul</code> and <code>imul</code>
compute the following: </font></p>

<pre><font face="Courier New" size="2">		edx:eax := eax * operand32</font></pre>

<p><font face="Arial" size="2">&quot;*&quot; has the same meanings as above and <code>edx:eax</code>
means that <code>edx</code> contains the H.O. double word of the 64 bit result and <code>eax</code>
contains the L.O. double word of the 64 bit result. </font></p>

<p><font face="Arial" size="2">If an 8x8, 16x16, or 32x32 bit product requires more than
eight, sixteen, or thirty-two bits (respectively), the <code>mul</code> and <code>imul</code>
instructions set the carry and overflow flags. </font></p>

<p><font face="Arial" size="2"><code>Mul</code> and <code>imul</code> scramble the A, P,
S, and Z flags. Especially note that the sign and zero flags do not contain meaningful
values after the execution of these two instructions.</font></p>

<p><font face="Arial" size="2"><code>Imul</code> (integer multiplication) operates on
signed operands. There are many different forms of this instruction as Intel attempted to
generalize this instruction with successive processors. The previous paragraphs describe
the first form of the imul instruction, with a single operand. The next three forms of the
<code>imul</code> instruction are available only on the 80286 and later processors. They
provide the ability to multiply a register by an immediate value. The last two forms,
available only on 80386 and later processors, provide the ability to multiply an arbitrary
register by another register or memory location. Expanded to show allowable operand sizes,
they are </font></p>

<pre><font face="Courier New" size="2">        imul    operand1, operand2, immediate   ;General form

        imul    reg16, reg16, immediate8
        imul    reg16, reg16, immediate16
        imul    reg16, mem16, immediate8
        imul    reg16, mem16, immediate16
        imul    reg16, immediate8 
        imul    reg16, immediate16
        imul    reg32, reg32, immediate8        (3)
        imul    reg32, reg32, immediate32       (3)
        imul    reg32, mem32, immediate8        (3)
        imul    reg32, mem32, immediate32       (3)
        imul    reg32, immediate8               (3)
        imul    reg32, immediate32              (3)

3- Available on the 80386 and later, only.</font></pre>

<p><font face="Arial" size="2">The <code>imul reg, immediate </code>instructions are a
special syntax the assembler provides. The encodings for these instructions are the same
as<code> imul reg, reg, immediate.</code> The assembler simply supplies the same register
value for both operands.</font></p>

<p><font face="Arial" size="2">These instructions compute: </font></p>

<pre><font face="Courier New" size="2">	operand1 := operand2 * immediate
	operand1 := operand1 * immediate</font></pre>

<p><font face="Arial" size="2">Besides the number of operands, there are several
differences between these forms and the single operand <code>mul/imul </code>instructions:
</font>

<ul>
  <li><font face="Arial" size="2">There isn't an 8x8 bit multiplication available (the
    immediate8 operands simply provide a shorter form of the instruction. Internally, the CPU
    sign extends the operand to 16 or 32 bits as necessary). </font></li>
  <li><font face="Arial" size="2">These instructions do not produce a 2*n bit result. That is,
    a 16x16 multiply produces a 16 bit result. Likewise, a 32x32 bit multiply produces a 32
    bit result. These instructions set the carry and overflow flags if the result does not fit
    into the destination register. </font></li>
  <li><font face="Arial" size="2">The 80286 version of <code>imul</code> allows an immediate
    operand, the standard <code>mul/imul</code> instructions do not. </font></li>
</ul>

<p><font face="Arial" size="2">The last two forms of the <code>imul</code> instruction are
available only on 80386 and later processors. With the addition of these formats, the <code>imul</code>
instruction is almost as general as the <code>add</code> instruction: </font></p>

<pre><font face="Courier New" size="2">		imul	reg, reg
		imul	reg, mem</font></pre>

<p><font face="Arial" size="2">These instructions compute </font></p>

<pre><font face="Courier New" size="2">		reg := reg * reg
and		reg := reg * mem</font></pre>

<p><font face="Arial" size="2">Both operands must be the same size. Therefore, like the
80286 form of the <code>imul</code> instruction, you must test the carry or overflow flag
to detect overflow. If overflow does occur, the CPU loses the H.O. bits of the result.</font></p>

<p><font face="Arial" size="2">Important Note: Keep in mind that the zero flag contains an
indeterminate result after executing a multiply instruction. You cannot test the zero flag
to see if the result is zero after a multiplication. Likewise, these instructions scramble
the sign flag. If you need to check these flags, compare the result to zero after testing
the carry or overflow flags.</font></p>

<p><font face="Arial" size="2">The <code>aam</code> (ASCII Adjust after Multiplication)
instruction, like <code>aaa</code> and <code>aas</code>, lets you adjust an unpacked
decimal value after multiplication. This instruction operates directly on the <code>ax</code>
register. It assumes that you've multiplied two eight bit values in the range 0..9
together and the result is sitting in <code>ax</code> (actually, the result will be
sitting in <code>al</code> since 9*9 is 81, the largest possible value; <code>ah</code>
must contain zero). This instruction divides <code>ax</code> by 10 and leaves the quotient
in <code>ah</code> and the remainder in <code>al</code>: </font></p>

<pre><font face="Courier New" size="2">		ah := ax div 10
		al := ax mod 10</font></pre>

<p><font face="Arial" size="2">Unlike the other decimal/ASCII adjust instructions,
assembly language programs regularly use <code>aam</code> since conversion between number
bases uses this algorithm.</font></p>

<p><font face="Arial" size="2">Note: the <code>aam</code> instruction consists of a two
byte opcode, the second byte of which is the immediate constant 10. Assembly language
programmers have discovered that if you substitute another immediate value for this
constant, you can change the divisor in the above algorithm. This, however, is an
undocumented feature. It works in all varieties of the processor Intel has produced to
date, but there is no guarantee that Intel will support this in future processors. Of
course, the 80286 and later processors let you multiply by a constant, so this trick is
hardly necessary on modern systems.</font></p>

<p><font face="Arial" size="2">There is no <code>dam</code> (decimal adjust for
multiplication) instruction on the 80x86 processor.</font></p>

<p><font face="Arial" size="2">Perhaps the most common use of the <code>imul</code>
instruction is to compute offsets into multidimensional arrays. Indeed, this is probably
the main reason Intel added the ability to multiply a register by a constant on the 80286
processor. In Chapter Four, this text used the standard 8086 <code>mul</code> instruction
for array index computations. However, the extended syntax of the <code>imul</code>
instruction makes it a much better choice as the following examples demonstrate: </font></p>

<pre><font face="Courier New" size="2">MyArray         word    8 dup ( 7 dup ( 6 dup (?)))                             ;8x7x6 array.
J               word    ?
K               word    ?
M               word    ?
                 .
                 .
                 .
; MyArray [J, K, M] := J + K - M

                mov     ax, J
                add     ax, K
                sub     ax, M

                mov     bx, J           ;Array index :=
                imul    bx, 7           ;       ((J*7 + K) * 6 + M) * 2
                add     bx, K
                imul    bx, 6
                add     bx, M
                add     bx, bx          ;BX := BX * 2

                mov     MyArray[bx], ax</font></pre>

<p><font face="Arial" size="2">Don't forget that the multiplication instructions are very
slow; often an order of magnitude slower than an addition instruction. There are faster
ways to multiply a value by a constant. See Chapter Nine for all the details.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-451"></a>6.5.7 The Division
Instructions: DIV, IDIV, and AAD</font></strong></p>

<p><font face="Arial" size="2">The 80x86 divide instructions perform a 64/32 division
(80386 and later only), a 32/16 division or a 16/8 division. These instructions take the
form: </font></p>

<pre><font face="Courier New" size="2">                div     reg     For unsigned division
                div     mem

                idiv    reg     For signed division
                idiv    mem

                aad             ASCII adjust for division</font></pre>

<p><font face="Arial" size="2">The <code>div</code> instruction computes an unsigned
division. If the operand is an eight bit operand, <code>div</code> divides the <code>ax</code>
register by the operand leaving the quotient in <code>al</code> and the remainder (modulo)
in <code>ah</code>. If the operand is a 16 bit quantity, then the <code>div</code>
instruction divides the 32 bit quantity in <code>dx:ax </code>by the operand leaving the
quotient in <code>ax</code> and the remainder in . With 32 bit operands (on the 80386 and
later) <code>div</code> divides the 64 bit value in <code>edx:eax</code> by the operand
leaving the quotient in <code>eax</code> and the remainder in <code>edx</code>.</font></p>

<p><font face="Arial" size="2">You cannot, on the 80x86, simply divide one eight bit value
by another. If the denominator is an eight bit value, the numerator must be a sixteen bit
value. If you need to divide one unsigned eight bit value by another, you must zero extend
the numerator to sixteen bits. You can accomplish this by loading the numerator into the <code>al</code>
register and then moving zero into the <code>ah</code> register. Then you can divide <code>ax</code>
by the denominator operand to produce the correct result. Failing to zero extend al before
executing div may cause the 80x86 to produce incorrect results! </font></p>

<p><font face="Arial" size="2">When you need to divide two 16 bit unsigned values, you
must zero extend the <code>ax</code> register (which contains the numerator) into the <code>dx</code>
register. Just load the immediate value zero into the <code>dx</code> register. If you
need to divide one 32 bit value by another, you must zero extend the <code>eax</code>
register into <code>edx</code> (by loading a zero into <code>edx</code>) before the
division.</font></p>

<p><font face="Arial" size="2">When dealing with signed integer values, you will need to
sign extend <code>al</code> to <code>ax</code>, <code>ax</code> to <code>dx</code> or <code>eax</code>
into <code>edx</code> before executing <code>idiv</code>. To do so, use the <code>cbw</code>,
<code>cwd</code>, <code>cdq</code>, or <code>movsx</code> instructions. If the H.O. byte
or word does not already contain significant bits, then you must sign extend the value in
the accumulator (<code>al</code>/<code>ax</code>/<code>eax</code>) before doing the <code>idiv</code>
operation. Failure to do so may produce incorrect results. </font></p>

<p><font face="Arial" size="2">There is one other catch to the 80x86's divide
instructions: you can get a fatal error when using this instruction. First, of course, you
can attempt to divide a value by zero. Furthermore, the quotient may be too large to fit
into the <code>eax</code>, <code>ax</code>, or <code>al</code> register. For example, the
16/8 division &quot;8000h / 2&quot; produces the quotient 4000h with a remainder of zero.
4000h will not fit into eight bits. If this happens, or you attempt to divide by zero, the
80x86 will generate an int 0 trap. This usually means BIOS will print &quot;division by
zero&quot; or &quot;divide error&quot; and abort your program. If this happens to you,
chances are you didn't sign or zero extend your numerator before executing the division
operation. Since this error will cause your program to crash, you should be very careful
about the values you select when using division. </font></p>

<p><font face="Arial" size="2">The auxiliary carry, carry, overflow, parity, sign, and
zero flags are undefined after a division operation. If an overflow occurs (or you attempt
a division by zero) then the 80x86 executes an INT 0 (interrupt zero).</font></p>

<p><font face="Arial" size="2">Note that the 80286 and later processors do not provide
special forms for <code>idiv</code> as they do for <code>imul</code>. Most programs use
division far less often than they use multiplication, so Intel's designers did not bother
creating special instructions for the divide operation. Note that there is no way to
divide by an immediate value. You must load the immediate value into a register or a
memory location and do the division through that register or memory location.</font></p>

<p><font face="Arial" size="2">The <code>aad</code> (ASCII Adjust before Division)
instruction is another unpacked decimal operation. It splits apart unpacked binary coded
decimal values before an ASCII division operation. Although this text will not cover BCD
arithmetic, the <code>aad</code> instruction is useful for other operations. The algorithm
that describes this instruction is </font></p>

<pre><font face="Courier New" size="2">	al := ah*10 + al
	ah := 0</font></pre>

<p><font face="Arial" size="2">This instruction is quite useful for converting strings of
digits into integer values (see the questions at the end of this chapter).</font></p>

<p><font face="Arial" size="2">The following examples show how to divide one sixteen bit
value by another. </font></p>

<pre><font face="Courier New" size="2">; J := K / M (unsigned)

                mov     ax, K   ;Get dividend
                mov     dx, 0   ;Zero extend unsigned value in AX to DX.

        &lt; In practice, we should verify that M does not contain zero here &gt;

                div     M
                mov     J, ax

; J := K / M (signed)

                mov     ax, K   ;Get dividend
                cwd             ;Sign extend signed value in AX to DX.

        &lt; In practice, we should verify that M does not contain zero here &gt;

                idiv    M
                mov     J, ax

; J := (K*M)/P

                mov     ax, K   ;Note that the imul instruction produces
                imul    M       ; a 32 bit result in DX:AX, so we don't
                idiv    P       ; need to sign extend AX here.
                mov     J, ax   ;Hope and pray result fits in 16 bits!</font></pre>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH06-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH06-1.html">Chapter Six</a> (Part 1)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH06-3.html">Chapter Six</a> (Part 3) </strong></font><a href="CH06-3.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Six: The 80x86 Instruction
Set (Part 2)<br>
26 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_6/CH06-2.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:16 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
