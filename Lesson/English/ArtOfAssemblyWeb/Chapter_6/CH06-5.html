<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_6/CH06-5.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:28 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER SIX: THE 80x86 INSTRUCTION SET (Part 5)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING5"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH06-4.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH06-4.html">Chapter Six</a> (Part 4)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH06-6.html">Chapter Six</a> (Part 6) </strong></font><a href="CH06-6.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10" colspan="2"><a NAME="HEADING5-0"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0" colspan="2"><font face="Arial" size="4"><strong>CHAPTER
    SIX:<br>
    THE 80x86 INSTRUCTION SET (Part 5)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10" colspan="2"></td>
  </tr>
  <tr>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING5-1"><b>6.9 </b>-
    Program Flow Control Instructions</a> <br>
    <a HREF="#HEADING5-3"><b>6.9.1 </b>- Unconditional Jumps</a> <br>
    <a HREF="#HEADING5-98"><b>6.9.2 </b>- The CALL and RET Instructions</a> <br>
    <a HREF="#HEADING5-171"><b>6.9.3 </b>- The INT, INTO, BOUND, and IRET Instructions</a> <br>
    <a HREF="#HEADING5-226"><b>6.9.4 </b>- The Conditional Jump Instructions</a> </font></td>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING5-282"><b>6.9.5 </b>-
    The JCXZ/JECXZ Instructions</a> <br>
    <a HREF="#HEADING5-294"><b>6.9.6 </b>- The LOOP Instruction</a> <br>
    <a HREF="#HEADING5-312"><b>6.9.7 </b>- The LOOPE/LOOPZ Instruction</a> <br>
    <a HREF="#HEADING5-335"><b>6.9.8 </b>- The LOOPNE/LOOPNZ Instruction</a> <br>
    <a HREF="#HEADING5-372"><b>6.10 </b>- Miscellaneous Instructions</a> </font></td>
  </tr>
  <tr>
    <td width="100%" valign="top" colspan="2" nowrap height="20"></td>
  </tr>
  <tr>
    <td width="100%" valign="top" colspan="2"><strong><font face="Arial" size="3"><a NAME="HEADING5-1"></a>6.9 Program Flow Control Instructions</font></strong></td>
  </tr>
  <tr>
    <td width="100%" valign="top" colspan="2" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">The instructions discussed thus far execute sequentially;
that is, the CPU executes each instruction in the sequence it appears in your program. To
write real programs requires several control structures, not just the sequence. Examples
include the <code>if</code> statement, loops, and subroutine invocation (a call). Since
compilers reduce all other languages to assembly language, it should come as no surprise
that assembly language supports the instructions necessary to implement these control
structures. 80x86 program control instructions belong to three groups: unconditional
transfers, conditional transfers, and subroutine call and return instructions. The
following sections describe these instructions:</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-3"></a>6.9.1 Unconditional Jumps</font></strong></p>

<p><font face="Arial" size="2">The <code>jmp</code> (jump) instruction unconditionally
transfers control to another point in the program. There are six forms of this
instruction: an intersegment/direct jump, two intrasegment/direct jumps, an
intersegment/indirect jump, and two intrasegment/indirect jumps. Intrasegment jumps are
always between statements in the same code segment. Intersegment jumps can transfer
control to a statement in a different code segment.</font></p>

<p><font face="Arial" size="2">These instructions generally use the same syntax, it is </font></p>

<pre><font face="Courier New" size="2">	jmp	target</font></pre>

<p><font face="Arial" size="2">The assembler differentiates them by their operands: </font></p>

<pre><font face="Courier New" size="2">        jmp     disp8   ;direct intrasegment, 8 bit displacement.
        jmp     disp16  ;direct intrasegment, 16 bit displacement.
        jmp     adrs32  ;direct intersegment, 32 bit segmented address.
        jmp     mem16   ;indirect intrasegment, 16 bit memory operand.
        jmp     reg16   ;register indirect intrasegment.
        jmp     mem32   ;indirect intersegment, 32 bit memory operand.</font></pre>

<p><font face="Arial" size="2">Intersegment is a synonym for far, intrasegment is a
synonym for near.</font></p>

<p><font face="Arial" size="2">The two direct intrasegment jumps differ only in their
length. The first form consists of an opcode and a single byte displacement. The CPU sign
extends this displacement to 16 bits and adds it to the <code>ip</code> register. This
instruction can branch to a location -128..+127 from the beginning of the next instruction
following it (i.e., -126..+129 bytes around the current instruction). </font></p>

<p><font face="Arial" size="2">The second form of the intrasegment jump is three bytes
long with a two byte displacement. This instruction allows an effective range of
-32,768..+32,767 bytes and can transfer control to anywhere in the current code segment.
The CPU simply adds the two byte displacement to the <code>ip</code> register.</font></p>

<p><font face="Arial" size="2">These first two jumps use a relative addressing scheme. The
offset encoded as part of the opcode byte is not the target address in the current code
segment, but the distance to the target address. Fortunately, MASM will compute the
distance for you automatically, so you do not have to compute this displacement value
yourself. In many respects, these instructions are really nothing more than <code>add ip,
disp </code>instructions.</font></p>

<p><font face="Arial" size="2">The direct intersegment jump is five bytes long, the last
four bytes containing a segmented address (the offset in the second and third bytes, the
segment in the fourth and fifth bytes). This instruction copies the offset into the <code>ip</code>
register and the segment into the <code>cs</code> register. Execution of the next
instruction continues at the new address in <code>cs:ip</code>. Unlike the previous two
jumps, the address following the opcode is the absolute memory address of the target
instruction; this version does not use relative addressing. This instruction loads cs:ip
with a 32 bit immediate value.</font></p>

<p><font face="Arial" size="2">For the three direct jumps described above, you normally
specify the target address using a statement label. A statement label is usually an
identifier followed by a colon, usually on the same line as an executable machine
instruction. The assembler determines the offset of the statement after the label and
automatically computes the distance from the jump instruction to the statement label.
Therefore, you do not have to worry about computing displacements manually. For example,
the following short little loop continuously reads the parallel printer data port and
inverts the L.O. bit. This produces a square wave electrical signal on one of the printer
port output lines: </font></p>

<pre><font face="Courier New" size="2">                mov     dx, 378h        ;Parallel printer port address.
LoopForever:    in      al, dx          ;Read character from input port.
                xor     al, 1           ;Invert the L.O. bit.
                out     dx, al          ;Output data back to port.
                jmp     LoopForever     ;Repeat forever.</font></pre>

<p><font face="Arial" size="2">The fourth form of the unconditional jump instruction is
the indirect intrasegment jump instruction. It requires a 16 bit memory operand. This form
transfers control to the address within the offset given by the two bytes of the memory
operand. For example, </font></p>

<pre><font face="Courier New" size="2">WordVar         word    TargetAddress
                 .
                 .
                 .
                jmp     WordVar</font></pre>

<p><font face="Arial" size="2">transfers control to the address specified by the value in
the 16 bit memory location <code>WordVar</code>. This does not jump to the statement at
address <code>WordVar</code>, it jumps to the statement at the address held in the <code>WordVar</code>
variable. Note that this form of the jmp instruction is roughly equivalent to: </font></p>

<pre><font face="Courier New" size="2">		mov	ip, WordVar</font></pre>

<p><font face="Arial" size="2">Although the example above uses a single word variable
containing the indirect address, you can use any valid memory address mode, not just the
displacement only addressing mode. You can use memory indirect addressing modes like the
following: </font></p>

<pre><font face="Courier New" size="2">                jmp     DispOnly        ;Word variable
                jmp     Disp[bx]        ;Disp is an array of words
                jmp     Disp[bx][si]
                jmp     [bx]
                etc.</font></pre>

<p><font face="Arial" size="2">Consider the indexed addressing mode above for a moment (<code>disp[bx]</code>).
This addressing mode fetches the word from location <code>disp+bx</code> and copies this
value to the <code>ip</code> register; this lets you create an array of pointers and jump
to a specified pointer using an array index. Consider the following example: </font></p>

<pre><font face="Courier New" size="2">AdrsArray       word    stmt1, stmt2, stmt3, stmt4
                 .
                 .
                 .
                mov     bx, I           ;I is in the range 0..3
                add     bx, bx          ;Index into an array of words.
                jmp     AdrsArray[bx]   ;Jump to stmt1, stmt2, etc., depending
                                        ; on the value of I.</font></pre>

<p><font face="Arial" size="2">The important thing to remember is that the near indirect
jump fetches a word from memory and copies it into the <code>ip</code> register; it does
not jump to the memory location specified, it jumps indirectly through the 16 bit pointer
at the specified memory location.</font></p>

<p><font face="Arial" size="2">The fifth <code>jmp</code> instruction transfers control to
the offset given in a 16 bit general purpose register. Note that you can use any general
purpose register, not just <code>bx</code>, <code>si</code>, <code>di</code>, or <code>bp</code>.
An instruction of the form </font></p>

<pre><font face="Courier New" size="2">		jmp	ax</font></pre>

<p><font face="Arial" size="2">is roughly equivalent to </font></p>

<pre><font face="Courier New" size="2">		mov	ip, ax</font></pre>

<p><font face="Arial" size="2">Note that the previous two forms (register or memory
indirect) are really the same instruction. The mod and r/m fields of a mod-reg-r/m byte
specify a register or memory indirect address. See Appendix D for the details.</font></p>

<p><font face="Arial" size="2">The sixth form of the <code>jmp</code> instruction, the
indirect intersegment jump, has a memory operand that contains a double word pointer. The
CPU copies the double word at that address into the <code>cs:ip</code> register pair. For
example, </font></p>

<pre><font face="Courier New" size="2">FarPointer      dword   TargetAddress
                 .
                 .
                 .
                jmp     FarPointer</font></pre>

<p><font face="Arial" size="2">transfers control to the segmented address specified by the
four bytes at address <code>FarPointer</code>. This instruction is semantically identical
to the (mythical) instruction </font></p>

<pre><font face="Courier New" size="2">		lcs ip, FarPointer			;load cs, ip from FarPointer</font></pre>

<p><font face="Arial" size="2">As for the near indirect jump described earlier, this far
indirect jump lets you specify any arbitrary (valid) memory addressing mode. You are not
limited to the displacement only addressing mode the example above uses.</font></p>

<p><font face="Arial" size="2">MASM uses a near indirect or far indirect addressing mode
depending upon the type of the memory location you specify. If the variable you specify is
a word variable, MASM will automatically generate a near indirect jump; if the variable is
a dword, MASM emits the opcode for a far indirect jump. Some forms of memory addressing,
unfortunately, do not intrinsically specify a size. For example, <code>[bx] </code>is
definitely a memory operand, but does <code>bx</code> point at a word variable or a double
word variable? It could point at either. Therefore, MASM will reject a statement of the
form: </font></p>

<pre><font face="Courier New" size="2">		jmp	[bx]</font></pre>

<p><font face="Arial" size="2">MASM cannot tell whether this should be a near indirect or
far indirect jump. To resolve the ambiguity, you will need to use a type coercion
operator. Chapter Eight will fully describe type coercion operators, for now, just use one
of the following two instructions for a near or far jump, respectively: </font></p>

<pre><font face="Courier New" size="2">		jmp	word ptr [bx]
		jmp	dword ptr [bx]</font></pre>

<p><font face="Arial" size="2">The register indirect addressing modes are not the only
ones that could be type ambiguous. You could also run into this problem with indexed and
base plus index addressing modes: </font></p>

<pre><font face="Courier New" size="2">		jmp	word ptr 5[bx]
		jmp	dword ptr 9[bx][si]</font></pre>

<p><font face="Arial" size="2">For more information on the type coercion operators, see
Chapter Eight.</font></p>

<p><font face="Arial" size="2">In theory, you could use the indirect jump instructions and
the<code> setcc</code> instructions to conditionally transfer control to some given
location. For example, the following code transfers control to <code>iftrue</code> if word
variable <code>X</code> is equal to word variable <code>Y</code>. It transfers control to <code>iffalse</code>,
otherwise. </font></p>

<pre><font face="Courier New" size="2">JmpTbl          word    iffalse, iftrue
                 .
                 .
                 .
                mov     ax, X
                cmp     ax, Y
                sete    bl
                movzx   ebx, bl
                jmp     JmpTbl[ebx*2]</font></pre>

<p><font face="Arial" size="2">As you will soon see, there is a much better way to do this
using the conditional jump instructions.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-98"></a>6.9.2 The CALL and RET
Instructions</font></strong></p>

<p><font face="Arial" size="2">The <code>call</code> and <code>ret</code> instructions
handle subroutine calls and returns. There are five different call instructions and six
different forms of the return instruction: </font></p>

<pre><font face="Courier New" size="2">        call    disp16  ;direct intrasegment, 16 bit relative.
        call    adrs32  ;direct intersegment, 32 bit segmented address.
        call    mem16   ;indirect intrasegment, 16 bit memory pointer.
        call    reg16   ;indirect intrasegment, 16 bit register pointer.
        call    mem32   ;indirect intersegment, 32 bit memory pointer.

        ret             ;near or far return
        retn            ;near return
        retf            ;far return
        ret     disp    ;near or far return and pop
        retn    disp    ;near return and pop
        retf    disp    ;far return and pop</font></pre>

<p><font face="Arial" size="2">The <code>call</code> instructions take the same forms as
the <code>jmp</code> instructions except there is no short (two byte) intrasegment call.</font></p>

<p><font face="Arial" size="2">The far <code>call</code> instruction does the following: </font>

<ul>
  <li><font face="Arial" size="2">It pushes the <code>cs</code> register onto the stack. </font></li>
  <li><font face="Arial" size="2">It pushes the 16 bit offset of the next instruction
    following the call onto the stack. </font></li>
  <li><font face="Arial" size="2">It copies the 32 bit effective address into the <code>cs:ip</code>
    registers. Since the <code>call</code> instruction allows the same addressing modes as <code>jmp</code>,
    <code>call</code> can obtain the target address using a relative, memory, or register
    addressing mode. </font></li>
  <li><font face="Arial" size="2">Execution continues at the first instruction of the
    subroutine. This first instruction is the opcode at the target address computed in the
    previous step. </font></li>
</ul>

<p><font face="Arial" size="2">The near <code>call</code> instruction does the following: </font>

<ul>
  <li><font face="Arial" size="2">It pushes the 16 bit offset of the next instruction
    following the call onto the stack. </font></li>
  <li><font face="Arial" size="2">It copies the 16 bit effective address into the <code>ip</code>
    register. Since the <code>call</code> instruction allows the same addressing modes as <code>jmp</code>,
    <code>call</code> can obtain the target address using a relative, memory, or register
    addressing mode. </font></li>
  <li><font face="Arial" size="2">Execution continues at the first instruction of the
    subroutine. This first instruction is the opcode at the target address computed in the
    previous step. </font></li>
</ul>

<p><font face="Arial" size="2">The <code>call disp16</code> instruction uses relative
addressing. You can compute the effective address of the target by adding this 16 bit
displacement with the return address (like the relative jmp instructions, the displacement
is the distance from the instruction following the call to the target address).</font></p>

<p><font face="Arial" size="2">The <code>call adrs32 </code>instruction uses the direct
addressing mode. A 32 bit segmented address immediately follows the <code>call</code>
opcode. This form of the call instruction copies that value directly into the <code>cs:ip</code>
register pair. In many respects, this is equivalent to the immediate addressing mode since
the value this instruction copies into the <code>cs:ip </code>register pair immediately
follows the instruction.</font></p>

<p><font face="Arial" size="2"><code>Call mem16 </code>uses the memory indirect addressing
mode. Like the <code>jmp</code> instruction, this form of the <code>call</code>
instruction fetches the word at the specified memory location and uses that word's value
as the target address. Remember, you can use any memory addressing mode with this
instruction. The displacement-only addressing mode is the most common form, but the others
are just as valid: </font></p>

<pre><font face="Courier New" size="2">	call	CallTbl[bx]	;Index into an array of pointers.
	call	word ptr [bx]	;BX points at word to use.
	call	WordTbl[bx][si]	; etc.</font></pre>

<p><font face="Arial" size="2">Note that the selection of addressing mode only affects the
effective address computation for the target subroutine. These call instructions still
push the offset of the next instruction following the call onto the stack. Since these are
near calls (they obtain their target address from a 16 bit memory location), they all push
a 16 bit return address onto the stack.</font></p>

<p><font face="Arial" size="2"><code>Call reg16</code> works just like the memory indirect
call above, except it uses the 16 bit value in a register for the target address. This
instruction is really the same instruction as the <code>call mem16</code> instruction.
Both forms specify their effective address using a mod-reg-r/m byte. For the <code>call
reg16</code> form, the mod bits contain 11b so the r/m field specifies a register rather
than a memory addressing mode. Of course, this instruction also pushes the 16 bit offset
of the next instruction onto the stack as the return address.</font></p>

<p><font face="Arial" size="2">The <code>call mem32 </code>instruction is a far indirect
call. The memory address specified by this instruction must be a double word value. This
form of the call instruction fetches the 32 bit segmented address at the computed
effective address and copies this double word value into the <code>cs:ip</code> register
pair. This instruction also copies the 32 bit segmented address of the next instruction
onto the stack (it pushes the segment value first and the offset portion second). Like the
<code>call mem16</code> instruction, you can use any valid memory addressing mode with
this instruction: </font></p>

<pre><font face="Courier New" size="2">                call    DWordVar
                call    DwordTbl[bx]
                call    dword ptr [bx]
                etc.</font></pre>

<p><font face="Arial" size="2">It is relatively easy to synthesize the <code>call</code>
instruction using two or three other 80x86 instructions. You could create the equivalent
of a near <code>call</code> using a <code>push</code> and a <code>jmp</code> instruction: </font></p>

<pre><font face="Courier New" size="2">		push	&lt;offset of instruction after jmp&gt;
		jmp	subroutine</font></pre>

<p><font face="Arial" size="2">A far <code>call</code> would be similar, you'd need to add
a <code>push cs</code> instruction before the two instructions above to push a far return
address on the stack.</font></p>

<p><font face="Arial" size="2">The <code>ret</code> (return) instruction returns control
to the caller of a subroutine. It does so by popping the return address off the stack and
transferring control to the instruction at this return address. Intrasegment (near)
returns pop a 16 bit return address off the stack into the <code>ip</code> register. An
intersegment (far) return pops a 16 bit offset into the ip register and then a 16 bit
segment value into the <code>cs</code> register. These instructions are effectively equal
to the following: </font></p>

<pre><font face="Courier New" size="2">retn:		pop	ip
retf:		popd	cs:ip</font></pre>

<p><font face="Arial" size="2">Clearly, you must match a near subroutine call with a near
return and a far subroutine call with a corresponding far return. If you mix near calls
with far returns or vice versa, you will leave the stack in an inconsistent state and you
probably will not return to the proper instruction after the call. Of course, another
important issue when using the <code>call</code> and <code>ret</code> instructions is that
you must make sure your subroutine doesn't push something onto the stack and then fail to
pop it off before trying to return to the caller. Stack problems are a major cause of
errors in assembly language subroutines. Consider the following code: </font></p>

<pre><font face="Courier New" size="2">Subroutine:     push    ax
                push    bx
                 .
                 .
                 .
                pop     bx
                ret
                 .
                 .
                 .
                call    Subroutine</font></pre>

<p><font face="Arial" size="2">The <code>call</code> instruction pushes the return address
onto the stack and then transfers control to the first instruction of <code>subroutine</code>.
The first two push instructions push the <code>ax</code> and <code>bx</code> registers
onto the stack, presumably in order to preserve their value because <code>subroutine</code>
modifies them. Unfortunately, a programming error exists in the code above, subroutine
only pops <code>bx</code> from the stack, it fails to pop <code>ax</code> as well. This
means that when subroutine tries to return to the caller, the value of <code>ax</code>
rather than the return address is sitting on the top of the stack. Therefore, this
subroutine returns control to the address specified by the initial value of the <code>ax</code>
register rather than to the true return address. Since there are 65,536 different values <code>ax</code>
can have, there is a 1/65,536th of a chance that your code will return to the real return
address. The odds are not in your favor! Most likely, code like this will hang up the
machine. Moral of the story - always make sure the return address is sitting on the stack
before executing the return instruction.</font></p>

<p><font face="Arial" size="2">Like the <code>call</code> instruction, it is very easy to
simulate the ret instruction using two 80x86 instructions. All you need to do is pop the
return address off the stack and then copy it into the <code>ip</code> register. For near
returns, this is a very simple operation, just pop the near return address off the stack
and then jump indirectly through that register: </font></p>

<pre><font face="Courier New" size="2">		pop	ax
		jmp	ax</font></pre>

<p><font face="Arial" size="2">Simulating a far return is a little more difficult because
you must load <code>cs:ip</code> in a single operation. The only instruction that does
this (other than a far return) is the <code>jmp mem32</code> instruction. See the
exercises at the end of this chapter for more details.</font></p>

<p><font face="Arial" size="2">There are two other forms of the <code>ret</code>
instruction. They are identical to those above except a 16 bit displacement follows their
opcodes. The CPU adds this value to the stack pointer immediately after popping the return
address from the stack. This mechanism removes parameters pushed onto the stack before
returning to the caller. See Chapter Eleven for more details.</font></p>

<p><font face="Arial" size="2">The assembler allows you to type <code>ret</code> without
the &quot;f&quot; or &quot;n&quot; suffix. If you do so, the assembler will figure out
whether it should generate a near return or a far return. See the chapter on procedures
and functions for details on this.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-171"></a>6.9.3 The INT, INTO,
BOUND, and IRET Instructions</font></strong></p>

<p><font face="Arial" size="2">The <code>int</code> (for software interrupt) instruction
is a very special form of a <code>call</code> instruction. Whereas the <code>call</code>
instruction calls subroutines within your program, the <code>int</code> instruction calls
system routines and other special subroutines. The major difference between interrupt
service routines and standard procedures is that you can have any number of different
procedures in an assembly language program, while the system supports a maximum of 256
different interrupt service routines. A program calls a subroutine by specifying the
address of that subroutine; it calls an interrupt service routine by specifying the
interrupt number for that particular interrupt service routine. This chapter will only
describe how to call an interrupt service routine using the <code>int, into, </code>and <code>bound</code>
instructions, and how to return from an interrupt service routine using the <code>iret</code>
instruction.</font></p>

<p><font face="Arial" size="2">There are four different forms of the <code>int</code>
instruction. The first form is </font></p>

<pre><font face="Courier New" size="2">		int	nn </font></pre>

<p><font face="Arial" size="2">(where &quot;nn&quot; is a value between 0 and 255). It
allows you to call one of 256 different interrupt routines. This form of the <code>int</code>
instruction is two bytes long. The first byte is the <code>int</code> opcode. The second
byte is immediate data containing the interrupt number. </font></p>

<p><font face="Arial" size="2">Although you can use the <code>int</code> instruction to
call procedures (interrupt service routines) you've written, the primary purpose of this
instruction is to make a system call. A system call is a subroutine call to a procedure
provided by the system, such as a DOS , PC-BIOS, mouse, or some other piece of software
resident in the machine before your program began execution. Since you always refer to a
specific system call by its interrupt number, rather than its address, your program does
not need to know the actual address of the subroutine in memory. The int instruction
provides dynamic linking to your program. The CPU determines the actual address of an
interrupt service routine at run time by looking up the address in an interrupt vector
table. This allows the authors of such system routines to change their code (including the
entry point) without fear of breaking any older programs that call their interrupt service
routines. As long as the system call uses the same interrupt number, the CPU will
automatically call the interrupt service routine at its new address.</font></p>

<p><font face="Arial" size="2">The only problem with the <code>int</code> instruction is
that it supports only 256 different interrupt service routines. MS-DOS alone supports well
over 100 different calls. BIOS and other system utilities provide thousands more. This is
above and beyond all the interrupts reserved by Intel for hardware interrupts and traps.
The common solution most of the system calls use is to employ a single interrupt number
for a given class of calls and then pass a function number in one of the 80x86 registers
(typically the <code>ah</code> register). For example, MS-DOS uses only a single interrupt
number, 21h. To choose a particular DOS function, you load a DOS function code into the <code>ah</code>
register before executing the <code>int 21h </code>instruction. For example, to terminate
a program and return control to MS-DOS, you would normally load ah with 4Ch and call DOS
with the <code>int 21h</code> instruction: </font></p>

<pre><font face="Courier New" size="2">		mov   ah, 4ch  ;DOS terminate opcode.
		int   21h      ;DOS call</font></pre>

<p><font face="Arial" size="2">The BIOS keyboard interrupt is another good example.
Interrupt 16h is responsible for testing the keyboard and reading data from the keyboard.
This BIOS routine provides several calls to read a character and scan code from the
keyboard, see if any keys are available in the system type ahead buffer, check the status
of the keyboard modifier flags, and so on. To choose a particular operation, you load the
function number into the ah register before executing <code>int 16h</code>. The following
table lists the possible functions: </font></p>
<div align="center"><center>

<table BORDER="1" width="100%" cellspacing="0" cellpadding="0">
  <caption><font face="Arial" size="2"><strong>BIOS Keyboard Support Functions</strong></font></caption>
  <tr>
    <th bgcolor="#F0F0F0" align="center"><font face="Arial" size="2">Function # (AH)</font></th>
    <th bgcolor="#F0F0F0" align="center"><font face="Arial" size="2">Input Parameters</font></th>
    <th bgcolor="#F0F0F0" align="center"><font face="Arial" size="2">Output Parameters</font></th>
    <th bgcolor="#F0F0F0"><font face="Arial" size="2">Description</font></th>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">0</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2"><code>al</code>- ASCII character <code>ah</code>-
    scan code</font></td>
    <td><font face="Arial" size="2">Read character. Reads next available character from the
    system's type ahead buffer. Wait for a keystroke if the buffer is empty.</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">1</font></td>
    <td align="center"><font face="Arial" size="2">- </font></td>
    <td align="center"><font face="Arial" size="2">ZF- Set if no key. ZF- Clear if key
    available. <code>al</code>- ASCII code <code>ah</code>- scan code</font></td>
    <td><font face="Arial" size="2">Checks to see if a character is available in the type
    ahead buffer. Sets the zero flag if not key is available, clears the zero flag if a key is
    available. If there is an available key, this function returns the ASCII and scan code
    value in <code>ax</code>. The value in <code>ax</code> is undefined if no key is
    available.</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">2</font></td>
    <td align="center"><font face="Arial" size="2">- </font></td>
    <td align="center"><font face="Arial" size="2">al- shift flags</font></td>
    <td><font face="Arial" size="2">Returns the current status of the shift flags in al. The
    shift flags are defined as follows: &nbsp; bit 7: Insert toggle bit 6: Capslock toggle bit
    5: Numlock toggle bit 4: Scroll lock toggle bit 3: Alt key is down bit 2: Ctrl key is down
    bit 1: Left shift key is down bit 0: Right shift key is down</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">3</font></td>
    <td align="center"><font face="Arial" size="2"><code>al</code> = 5 <code>bh</code> = 0, 1,
    2, 3 for 1/4, 1/2, 3/4, or 1 second delay <code>bl</code>= 0..1Fh for 30/sec to 2/sec.</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td><font face="Arial" size="2">Set auto repeat rate. The <code>bh</code> register
    contains the amount of time to wait before starting the autorepeat operation, the <code>bl</code>
    register contains the autorepeat rate.</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">5</font></td>
    <td align="center"><font face="Arial" size="2"><code>ch</code> = scan code <code>cl</code>
    = ASCII code</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td><font face="Arial" size="2">Store keycode in buffer. This function stores the value in
    the <code>cx</code> register at the end of the type ahead buffer. Note that the scan code
    in <code>ch</code> doesn't have to correspond to the ASCII code appearing in <code>cl</code>.
    This routine will simply insert the data you provide into the system type ahead buffer.</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">10h</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2"><code>al</code>- ASCII character <code>ah</code>-
    scan code</font></td>
    <td><font face="Arial" size="2">Read extended character. Like <code>ah</code>=0 call,
    except this one passes all key codes, the <code>ah</code>=0 call throws away codes that
    are not PC/XT compatible.</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">11h</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">ZF- Set if no key. ZF- Clear if key
    available. <code>al</code>- ASCII code <code>ah</code>- scan code</font></td>
    <td><font face="Arial" size="2">Like the ah=01h call except this one does not throw away
    keycodes that are not PC/XT compatible (i.e., the extra keys found on the 101 key
    keyboard).</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">12h</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">al- shift flags ah- extended shift flags</font></td>
    <td><font face="Arial" size="2">Returns the current status of the shift flags in ax. The
    shift flags are defined as follows: &nbsp; bit 15: SysReq key pressed bit 14: Capslock key
    currently down bit 13: Numlock key currently down bit 12: Scroll lock key currently down
    bit 11: Right alt key is down bit 10:Right ctrl key is down bit 9: Left alt key is down
    bit 8: Left ctrl key is down bit 7: Insert toggle bit 6: Capslock toggle bit 5: Numlock
    toggle bit 4: Scroll lock toggle bit 3: Either alt key is down (some machines, left only)
    bit 2: Either ctrl key is down bit 1: Left shift key is down bit 0: Right shift key is
    down</font></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">For example, to read a character from the system type ahead
buffer, leaving the ASCII code in <code>al</code>, you could use the following code: </font></p>

<pre><font face="Courier New" size="2">        mov     ah, 0           ;Wait for key available, and then
        int     16h             ; read that key.
        mov     character, al   ;Save character read.</font></pre>

<p><font face="Arial" size="2">Likewise, if you wanted to test the type ahead buffer to
see if a key is available, without reading that keystroke, you could use the following
code: </font></p>

<pre><font face="Courier New" size="2">        mov     ah, 1   ;Test to see if key is available.
        int     16h     ;Sets the zero flag if a key is not
                        ; available.</font></pre>

<p><font face="Arial" size="2">The second form of the int instruction is a special case: </font></p>

<pre><font face="Courier New" size="2">	int	 3</font></pre>

<p><font face="Arial" size="2"><code>Int</code> 3 is a special form of the interrupt
instruction that is only one byte long. CodeView and other debuggers use it as a software
breakpoint instruction. Whenever you set a breakpoint on an instruction in your program,
the debugger will typically replace the first byte of the instruction's opcode with an <code>int
3</code> instruction. When your program executes the <code>int 3</code> instruction, this
makes a &quot;system call&quot; to the debugger so the debugger can regain control of the
CPU. When this happens, the debugger will replace the<code> int 3</code> instruction with
the original opcode.</font></p>

<p><font face="Arial" size="2">While operating inside a debugger, you can explicitly use
the <code>int 3 </code>instruction to stop program executing and return control to the
debugger. This is not, however, the normal way to terminate a program. If you attempt to
execute an <code>int 3</code> instruction while running under DOS, rather than under the
control of a debugger program, you will likely crash the system.</font></p>

<p><font face="Arial" size="2">The third form of the <code>int</code> instruction is <code>into</code>.
<code>Into</code> will cause a software breakpoint if the 80x86 overflow flag is set. You
can use this instruction to quickly test for arithmetic overflow after executing an
arithmetic instruction. Semantically, this instruction is equivalent to </font></p>

<pre><font face="Courier New" size="2">	if overflow = 1 then int 4</font></pre>

<p><font face="Arial" size="2">You should not use this instruction unless you've supplied
a corresponding trap handler (interrupt service routine). Doing so would probably crash
the system.</font></p>

<p><font face="Arial" size="2">The fourth software interrupt, provided by 80286 and later
processors, is the <code>bound</code> instruction. This instruction takes the form </font></p>

<pre><font face="Courier New" size="2">		bound	reg, mem</font></pre>

<p><font face="Arial" size="2">and executes the following algorithm: </font></p>

<pre><font face="Courier New" size="2">	if (reg &lt; [mem]) or (reg &gt; [mem+sizeof(reg)]) then int 5</font></pre>

<p><font face="Arial" size="2"><code>[mem]</code> denotes the contents of the memory
location <code>mem</code> and<code> sizeof(reg)</code> is two or four depending on whether
the register is 16 or 32 bits wide. The memory operand must be twice the size of the
register operand. The <code>bound</code> instruction compares the values using a signed
integer comparison.</font></p>

<p><font face="Arial" size="2">Intel's designers added the bound instruction to allow a
quick check of the range of a value in a register. This is useful in Pascal, for example,
which checking array bounds validity and when checking to see if a subrange integer is
within an allowable range. There are two problems with this instruction, however. On 80486
and Pentium/586 processors, the bound instruction is generally slower than the sequence of
instructions it would replace: </font></p>

<pre><font face="Courier New" size="2">                cmp     reg, LowerBound
                jl      OutOfBounds
                cmp     reg, UpperBound
                jg      OutOfBounds</font></pre>

<p><font face="Arial" size="2">On the 80486 and Pentium/586 chips, the sequence above only
requires four clock cycles assuming you can use the immediate addressing mode and the
branches are not taken; the <code>bound</code> instruction requires 7-8 clock cycles under
similar circumstances and also assuming the memory operands are in the cache.</font></p>

<p><font face="Arial" size="2">A second problem with the <code>bound</code> instruction is
that it executes an <code>int 5</code> if the specified register is out of range. IBM, in
their infinite wisdom, decided to use the <code>int 5</code> interrupt handler routine to
print the screen. Therefore, if you execute a <code>bound</code> instruction and the value
is out of range, the system will, by default, print a copy of the screen to the printer.
If you replace the default <code>int 5</code> handler with one of your own, pressing the
PrtSc key will transfer control to your <code>bound</code> instruction handler. Although
there are ways around this problem, most people don't bother since the <code>bound</code>
instruction is so slow.</font></p>

<p><font face="Arial" size="2">Whatever <code>int</code> instruction you execute, the
following sequence of events follows: </font>

<ul>
  <li><font face="Arial" size="2">The 80x86 pushes the flags register onto the stack; </font></li>
  <li><font face="Arial" size="2">The 80x86 pushes <code>cs</code> and then <code>ip</code>
    onto the stack; </font></li>
  <li><font face="Arial" size="2">The 80x86 uses the interrupt number (<code>into</code> is
    interrupt #4, <code>bound</code> is interrupt #5) times four as an index into the
    interrupt vector table and copies the double word at that point in the table into <code>cs:ip</code>.
    </font></li>
</ul>

<p><font face="Arial" size="2">The <code>int</code> instructions vary from a <code>call</code>
in two major ways. First, <code>call</code> instructions vary in length from two to six
bytes long, whereas <code>int</code> instructions are generally two bytes long (<code>int
3, into</code>, and <code>bound</code> are the exceptions). Second, and most important,
the <code>int</code> instruction pushes the flags and the return address onto the stack
while the <code>call</code> instruction pushes only the return address. Note also that the
<code>int</code> instructions always push a far return address (i.e., a <code>cs</code>
value and an offset within the code segment), only the far <em>call</em> pushes this
double word return address. </font></p>

<p><font face="Arial" size="2">Since <code>int</code> pushes the flags onto the stack you
must use a special return instruction, <code>iret</code> (interrupt return), to return
from a routine called via the <code>int</code> instructions. If you return from an
interrupt procedure using the <code>ret</code> instruction, the flags will be left on the
stack upon returning to the caller. The <code>iret</code> instruction is equivalent to the
two instruction sequence: <code>ret</code>, popf (assuming, of course, that you execute <code>popf</code>
before returning control to the address pointed at by the double word on the top of the
stack).</font></p>

<p><font face="Arial" size="2">The <code>int</code> instructions clear the trace (T) flag
in the flags register. They do not affect any other flags. The <code>iret</code>
instruction, by its very nature, can affect all the flags since it pops the flags from the
stack.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-226"></a>6.9.4 The Conditional
Jump Instructions</font></strong></p>

<p><font face="Arial" size="2">Although the <code>jmp</code>, <code>call</code>, and <code>ret</code>
instructions provide transfer of control, they do not allow you to make any serious
decisions. The 80x86's conditional jump instructions handle this task. The conditional
jump instructions are the basic tool for creating loops and other conditionally executable
statements like the <code>if..then </code>statement.</font></p>

<p><font face="Arial" size="2">The conditional jumps test one or more flags in the flags
register to see if they match some particular pattern (just like the <code>setcc</code>
instructions). If the pattern matches, control transfers to the target location. If the
match fails, the CPU ignores the conditional jump and execution continues with the next
instruction. Some instructions, for example, test the conditions of the sign, carry,
overflow, and zero flags. For example, after the execution of a shift left instruction,
you could test the carry flag to determine if it shifted a one out of the H.O. bit of its
operand. Likewise, you could test the condition of the zero flag after a <code>test</code>
instruction to see if any specified bits were one. Most of the time, however, you will
probably execute a conditional jump after a <code>cmp</code> instruction. The cmp
instruction sets the flags so that you can test for less than, greater than, equality,
etc.</font></p>

<p><font face="Arial" size="2">Note: Intel's documentation defines various synonyms or
instruction aliases for many conditional jump instructions. The following tables list all
the aliases for a particular instruction. These tables also list out the opposite
branches. You'll soon see the purpose of the opposite branches. </font></p>
<div align="center"><center>

<table BORDER="1" bordercolor="#C0C0C0" cellspacing="0" cellpadding="0" width="60%">
  <caption><strong><font face="Arial" size="3">Jcc Instructions That Test Flags</font></strong></caption>
  <tr>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">Instruction</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">Description</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">Condition</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">Aliases</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">Opposite</font></th>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">JC</font></td>
    <td><font face="Arial" size="2">Jump if carry</font></td>
    <td align="center"><font face="Arial" size="2">Carry = 1</font></td>
    <td align="center"><font face="Arial" size="2">JB, JNAE</font></td>
    <td align="center"><font face="Arial" size="2">JNC</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">JNC</font></td>
    <td><font face="Arial" size="2">Jump if no carry</font></td>
    <td align="center"><font face="Arial" size="2">Carry = 0</font></td>
    <td align="center"><font face="Arial" size="2">JNB, JAE</font></td>
    <td align="center"><font face="Arial" size="2">JC</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">JZ</font></td>
    <td><font face="Arial" size="2">Jump if zero</font></td>
    <td align="center"><font face="Arial" size="2">Zero = 1</font></td>
    <td align="center"><font face="Arial" size="2">JE</font></td>
    <td align="center"><font face="Arial" size="2">JNZ</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">JNZ</font></td>
    <td><font face="Arial" size="2">Jump if not zero</font></td>
    <td align="center"><font face="Arial" size="2">Zero = 0</font></td>
    <td align="center"><font face="Arial" size="2">JNE</font></td>
    <td align="center"><font face="Arial" size="2">JZ</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">JS</font></td>
    <td><font face="Arial" size="2">Jump if sign</font></td>
    <td align="center"><font face="Arial" size="2">Sign = 1</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">JNS</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">JNS</font></td>
    <td><font face="Arial" size="2">Jump if no sign</font></td>
    <td align="center"><font face="Arial" size="2">Sign = 0</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">JS</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">JO</font></td>
    <td><font face="Arial" size="2">Jump if overflow</font></td>
    <td align="center"><font face="Arial" size="2">Ovrflw=1</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">JNO</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">JNO</font></td>
    <td><font face="Arial" size="2">Jump if no Ovrflw</font></td>
    <td align="center"><font face="Arial" size="2">Ovrflw=0</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">JO</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">JP</font></td>
    <td><font face="Arial" size="2">Jump if parity</font></td>
    <td align="center"><font face="Arial" size="2">Parity = 1</font></td>
    <td align="center"><font face="Arial" size="2">JPE</font></td>
    <td align="center"><font face="Arial" size="2">JNP</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">JPE</font></td>
    <td><font face="Arial" size="2">Jump if parity even</font></td>
    <td align="center"><font face="Arial" size="2">Parity = 1</font></td>
    <td align="center"><font face="Arial" size="2">JP</font></td>
    <td align="center"><font face="Arial" size="2">JPO</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">JNP</font></td>
    <td><font face="Arial" size="2">Jump if no parity</font></td>
    <td align="center"><font face="Arial" size="2">Parity = 0</font></td>
    <td align="center"><font face="Arial" size="2">JPO</font></td>
    <td align="center"><font face="Arial" size="2">JP</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">JPO</font></td>
    <td><font face="Arial" size="2">Jump if parity odd</font></td>
    <td align="center"><font face="Arial" size="2">Parity = 0</font></td>
    <td align="center"><font face="Arial" size="2">JNP</font></td>
    <td align="center"><font face="Arial" size="2">JPE</font></td>
  </tr>
</table>
</center></div>

<p>&nbsp;</p>
<div align="center"><center>

<table BORDER="1" bordercolor="#C0C0C0" width="70%" cellspacing="0" cellpadding="0">
  <caption><font face="Arial" size="2"><strong>Jcc Instructions for Unsigned Comparisons</strong></font></caption>
  <tr>
    <th align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">Instruction</font></strong></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">Description</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">Condition</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">Aliases</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">Opposite</font></th>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">JA</font></strong></td>
    <td><font face="Arial" size="2">Jump if above (&gt;)</font></td>
    <td><font face="Arial" size="2">Carry=0, Zero=0</font></td>
    <td align="center"><font face="Arial" size="2">JNBE</font></td>
    <td align="center"><font face="Arial" size="2">JNA</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">JNBE</font></strong></td>
    <td><font face="Arial" size="2">Jump if not below or equal (not &lt;=)</font></td>
    <td><font face="Arial" size="2">Carry=0, Zero=0</font></td>
    <td align="center"><font face="Arial" size="2">JA</font></td>
    <td align="center"><font face="Arial" size="2">JBE</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">JAE</font></strong></td>
    <td><font face="Arial" size="2">Jump if above or equal (&gt;=)</font></td>
    <td><font face="Arial" size="2">Carry = 0</font></td>
    <td align="center"><font face="Arial" size="2">JNC, JNB</font></td>
    <td align="center"><font face="Arial" size="2">JNAE</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">JNB</font></strong></td>
    <td><font face="Arial" size="2">Jump if not below (not &lt;)</font></td>
    <td><font face="Arial" size="2">Carry = 0</font></td>
    <td align="center"><font face="Arial" size="2">JNC, JAE</font></td>
    <td align="center"><font face="Arial" size="2">JB</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">JB</font></strong></td>
    <td><font face="Arial" size="2">Jump if below (&lt;)</font></td>
    <td><font face="Arial" size="2">Carry = 1</font></td>
    <td align="center"><font face="Arial" size="2">JC, JNAE</font></td>
    <td align="center"><font face="Arial" size="2">JNB</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">JNAE</font></strong></td>
    <td><font face="Arial" size="2">Jump if not above or equal (not &gt;=)</font></td>
    <td><font face="Arial" size="2">Carry = 1</font></td>
    <td align="center"><font face="Arial" size="2">JC, JB</font></td>
    <td align="center"><font face="Arial" size="2">JAE</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">JBE</font></strong></td>
    <td><font face="Arial" size="2">Jump if below or equal (&lt;=)</font></td>
    <td><font face="Arial" size="2">Carry = 1 or Zero = 1</font></td>
    <td align="center"><font face="Arial" size="2">JNA</font></td>
    <td align="center"><font face="Arial" size="2">JNBE</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">JNA</font></strong></td>
    <td><font face="Arial" size="2">Jump if not above (not &gt;)</font></td>
    <td><font face="Arial" size="2">Carry = 1 or Zero = 1</font></td>
    <td align="center"><font face="Arial" size="2">JBE</font></td>
    <td align="center"><font face="Arial" size="2">JA</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">JE</font></strong></td>
    <td><font face="Arial" size="2">Jump if equal (=)</font></td>
    <td><font face="Arial" size="2">Zero = 1</font></td>
    <td align="center"><font face="Arial" size="2">JZ</font></td>
    <td align="center"><font face="Arial" size="2">JNE</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">JNE</font></strong></td>
    <td><font face="Arial" size="2">Jump if not equal ()</font></td>
    <td><font face="Arial" size="2">Zero = 0</font></td>
    <td align="center"><font face="Arial" size="2">JNZ</font></td>
    <td align="center"><font face="Arial" size="2">JE</font></td>
  </tr>
</table>
</center></div>

<p>&nbsp;</p>
<div align="center"><center>

<table BORDER="1" bordercolor="#C0C0C0" width="70%" cellspacing="0" cellpadding="0">
  <caption><font face="Arial" size="2"><strong>Jcc Instructions for Signed Comparisons</strong></font></caption>
  <tr>
    <th align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">Instruction</font></strong></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">Description</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">Condition</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">Aliases</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">Opposite</font></th>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">JG</font></strong></td>
    <td><font face="Arial" size="2">Jump if greater (&gt;)</font></td>
    <td><font face="Arial" size="2">Sign = Ovrflw or Zero=0</font></td>
    <td align="center"><font face="Arial" size="2">JNLE</font></td>
    <td align="center"><font face="Arial" size="2">JNG</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">JNLE</font></strong></td>
    <td><font face="Arial" size="2">Jump if not less than or equal (not &lt;=)</font></td>
    <td><font face="Arial" size="2">Sign = Ovrflw or Zero=0 &nbsp;</font></td>
    <td align="center"><font face="Arial" size="2">JG</font></td>
    <td align="center"><font face="Arial" size="2">JLE</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">JGE</font></strong></td>
    <td><font face="Arial" size="2">Jump if greater than or equal (&gt;=)</font></td>
    <td><font face="Arial" size="2">Sign = Ovrflw</font></td>
    <td align="center"><font face="Arial" size="2">JNL</font></td>
    <td align="center"><font face="Arial" size="2">JGE</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">JNL</font></strong></td>
    <td><font face="Arial" size="2">Jump if not less than (not &lt;)</font></td>
    <td><font face="Arial" size="2">Sign = Ovrflw</font></td>
    <td align="center"><font face="Arial" size="2">JGE</font></td>
    <td align="center"><font face="Arial" size="2">JL</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">JL</font></strong></td>
    <td><font face="Arial" size="2">Jump if less than (&lt;)</font></td>
    <td><font face="Arial" size="2">Sign Ovrflw</font></td>
    <td align="center"><font face="Arial" size="2">JNGE</font></td>
    <td align="center"><font face="Arial" size="2">JNL</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">JNGE</font></strong></td>
    <td><font face="Arial" size="2">Jump if not greater or equal (not &gt;=)</font></td>
    <td><font face="Arial" size="2">Sign Ovrflw &nbsp;</font></td>
    <td align="center"><font face="Arial" size="2">JL</font></td>
    <td align="center"><font face="Arial" size="2">JGE</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">JLE</font></strong></td>
    <td><font face="Arial" size="2">Jump if less than or equal (&lt;=)</font></td>
    <td><font face="Arial" size="2">Sign Ovrflw or Zero = 1</font></td>
    <td align="center"><font face="Arial" size="2">JNG</font></td>
    <td align="center"><font face="Arial" size="2">JNLE</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">JNG</font></strong></td>
    <td><font face="Arial" size="2">Jump if not greater than (not &gt;)</font></td>
    <td><font face="Arial" size="2">Sign Ovrflw or Zero = 1</font></td>
    <td align="center"><font face="Arial" size="2">JLE</font></td>
    <td align="center"><font face="Arial" size="2">JG</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">JE</font></strong></td>
    <td><font face="Arial" size="2">Jump if equal (=)</font></td>
    <td><font face="Arial" size="2">Zero = 1</font></td>
    <td align="center"><font face="Arial" size="2">JZ</font></td>
    <td align="center"><font face="Arial" size="2">JNE</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">JNE</font></strong></td>
    <td><font face="Arial" size="2">Jump if not equal ()</font></td>
    <td><font face="Arial" size="2">Zero = 0</font></td>
    <td align="center"><font face="Arial" size="2">JNZ</font></td>
    <td align="center"><font face="Arial" size="2">JE</font></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">On the 80286 and earlier, these instructions are all two
bytes long. The first byte is a one byte opcode followed by a one byte displacement.
Although this leads to very compact instructions, a single byte displacement only allows a
range of <em></em>128 bytes. There is a simple trick you can use to overcome this
limitation on these earlier processors: </font>

<ul>
  <li><font face="Arial" size="2">Whatever jump you're using, switch to its opposite form.
    (given in the tables above). </font></li>
  <li><font face="Arial" size="2">Once you've selected the opposite branch, use it to jump
    over a <code>jmp</code> instruction whose target address is the original target address. </font></li>
</ul>

<p><font face="Arial" size="2">For example, to convert: </font></p>

<pre><font face="Courier New" size="2">		jc	Target</font></pre>

<p><font face="Arial" size="2">to the long form, use the following sequence of
instructions: </font></p>

<pre><font face="Courier New" size="2">		jnc	SkipJmp
 		jmp	Target
SkipJmp:</font></pre>

<p><font face="Arial" size="2">If the carry flag is clear (NC=no carry), then control
transfers to label <code>SkipJmp</code>, at the same point you'd be if you were using the <code>jc</code>
instruction above. If the carry flag is set when encountering this sequence, control will
fall through the <code>jnc</code> instruction to the <code>jmp</code> instruction that
will transfer control to <code>Target</code>. Since the <code>jmp</code> instruction
allows 16 bit displacement and far operands, you can jump anywhere in the memory using
this trick. </font></p>

<p><font face="Arial" size="2">One brief comment about the &quot;opposites&quot; column is
in order. As mentioned above, when you need to manually extend a branch from <em></em>128
you should choose the opposite branch to branch around a jump to the target location. As
you can see in the &quot;aliases&quot; column above, many conditional jump instructions
have aliases. This means that there will be aliases for the opposite jumps as well. Do not
use any aliases when extending branches that are out of range. With only two exceptions, a
very simple rule completely describes how to generate an opposite branch: </font>

<ul>
  <li><font face="Arial" size="2">If the second letter of the <code>jcc</code> instruction is
    not an &quot;n&quot;, insert an &quot;n&quot; after the &quot;j&quot;. E.g., <code>je</code>
    becomes <code>jne</code> and <code>jl</code> becomes <code>jnl</code>. </font></li>
  <li><font face="Arial" size="2">If the second letter of the <code>jcc</code> instruction is
    an &quot;n&quot;, then remove that &quot;n&quot; from the instruction. E.g., <code>jng</code>
    becomes <code>jg</code>, <code>jne</code> becomes <code>je</code>. </font></li>
</ul>

<p><font face="Arial" size="2">The two exceptions to this rule are <code>jpe</code> (jump
parity even) and <code>jpo</code> (jump parity odd). These exceptions cause few problems
because (a) you'll hardly ever need to test the parity flag, and (b) you can use the
aliases <code>jp</code> and <code>jnp</code> synonyms<code> </code>for <code>jpe</code>
and <code>jpo</code>. The &quot;N/No N&quot; rule applies to <code>jp</code> and <code>jnp</code>.</font></p>

<p><font face="Arial" size="2">Though you know that <code>jge</code> is the opposite of <code>jl</code>,
get in the habit of using <code>jnl</code> rather than <code>jge</code>. It's too easy in
an important situation to start thinking &quot;greater is the opposite of less&quot; and
substitute <code>jg</code> instead. You can avoid this confusion by always using the
&quot;N/No N&quot; rule.</font></p>

<p><font face="Arial" size="2">MASM 6.x and many other modern 80x86 assemblers will
automatically convert out of range branches to this sequence for you. There is an option
that will allow you to disable this feature. For performance critical code that runs on
80286 and earlier processors, you may want to disable this feature so you can fix the
branches yourself. The reason is quite simple, this simple fix always wipes out the
pipeline no matter which condition is true since the CPU jumps in either case. One thing
nice about conditional jumps is that you do not flush the pipeline or the prefetch queue
if you do not take the branch. If one condition is true far more often than the other, you
might want to use the conditional jump to transfer control to a <code>jmp</code> nearby,
so you can continue to fall through as before. For example, if you have a <code>je target </code>instruction
and <code>target</code> is out of range, you could convert it to the following code: </font></p>

<pre><font face="Courier New" size="2">                je      GotoTarget
                 .
                 .
                 .
GotoTarget:     jmp     Target</font></pre>

<p><font face="Arial" size="2">Although a branch to target now requires executing two
jumps, this is much more efficient than the standard conversion if the zero flag is
normally clear when executing the <code>je</code> instruction.</font></p>

<p><font face="Arial" size="2">The 80386 and later processor provide an extended form of
the conditional jump that is four bytes long, with the last two bytes containing a 16 bit
displacement. These conditional jumps can transfer control anywhere within the current
code segment. Therefore, there is no need to worry about manually extending the range of
the jump. If you've told MASM you're using an 80386 or later processor, it will
automatically choose the two byte or four byte form, as necessary. See Chapter Eight to
learn how to tell MASM you're using an 80386 or later processor.</font></p>

<p><font face="Arial" size="2">The 80x86 conditional jump instruction give you the ability
to split program flow into one of two paths depending upon some logical condition. Suppose
you want to increment the <code>ax</code> register if <code>bx</code> is or equal to <code>cx</code>.
You can accomplish this with the following code: </font></p>

<pre><font face="Courier New" size="2">                cmp     bx, cx
                jne     SkipStmts
                inc     ax
SkipStmts:</font></pre>

<p><font face="Arial" size="2">The trick is to use the opposite branch to skip over the
instructions you want to execute if the condition is true. Always use the &quot;opposite
branch (N/no N)&quot; rule given earlier to select the opposite branch. You can make the
same mistake choosing an opposite branch here as you could when extending out of range
jumps.</font></p>

<p><font face="Arial" size="2">You can also use the conditional jump instructions to
synthesize loops. For example, the following code sequence reads a sequence of characters
from the user and stores each character in successive elements of an array until the user
presses the Enter key (carriage return): </font></p>

<pre><font face="Courier New" size="2">                mov     di, 0
ReadLnLoop:     mov     ah, 0           ;INT 16h read key opcode.
                int     16h
                mov     Input[di], al
                inc     di
                cmp     al, 0dh         ;Carriage return ASCII code.
                jne     ReadLnLoop
                mov     Input[di-1],0   ;Replace carriage return with zero.</font></pre>

<p><font face="Arial" size="2">For more information concerning the use of the conditional
jumps to synthesize IF statements, loops, and other control structures, see Chapter Ten.</font></p>

<p><font face="Arial" size="2">Like the <code>setcc</code> instructions, the conditional
jump instructions come in two basic categories - those that test specific process flag
values (e.g., <code>jz, jc, jno</code>) and those that test some condition ( less than,
greater than, etc.). When testing a condition, the conditional jump instructions almost
always follow a <code>cmp</code> instruction. The <code>cmp</code> instruction sets the
flags so you can use a <code>ja, jae, jb, jbe, je,</code> or <code>jne</code> instruction
to test for unsigned less than, less than or equal, equality, inequality, greater than, or
greater than or equal. Simultaneously, the cmp instruction sets the flags so you can also
do a signed comparison using the<code> jl, jle, je, jne, jg,</code> and <code>jge</code>
instructions.</font></p>

<p><font face="Arial" size="2">The conditional jump instructions only test flags, they do
not affect any of the 80x86 flags.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-282"></a>6.9.5 The JCXZ/JECXZ
Instructions</font></strong></p>

<p><font face="Arial" size="2">The <code>jcxz</code> (jump if <code>cx</code> is zero)
instruction branches to the target address if <code>cx</code> contains zero. Although you
can use it anytime you need to see if cx contains zero, you would normally use it before a
loop you've constructed with the <code>loop</code> instructions. The <code>loop</code>
instruction can repeat a sequence of operations <code>cx</code> times. If <code>cx</code>
equals zero, <code>loop</code> will repeat the operation 65,536 times. You can use <code>jcxz</code>
to skip over such a loop when <code>cx</code> is zero. </font></p>

<p><font face="Arial" size="2">The <code>jecxz</code> instruction, available only on 80386
and later processors, does essentially the same job as <code>jcxz</code> except it tests
the full <code>ecx</code> register. Note that the <code>jcxz</code> instruction only
checks <code>cx</code>, even on an 80386 in 32 bit mode.</font></p>

<p><font face="Arial" size="2">There are no &quot;opposite&quot; <code>jcxz</code> or <code>jecxz</code>
instructions. Therefore, you cannot use &quot;N/No N&quot; rule to extend the <code>jcxz</code>
and <code>jecxz</code> instructions. The easiest way to solve this problem is to break the
instruction up into two instructions that accomplish the same task: </font></p>

<pre><font face="Courier New" size="2">		jcxz	Target</font></pre>

<p><font face="Arial" size="2">becomes </font></p>

<pre><font face="Courier New" size="2">		test	cx, cx		;Sets the zero flag if cx=0
		je	Target</font></pre>

<p><font face="Arial" size="2">Now you can easily extend the <code>je</code> instruction
using the techniques from the previous section.</font></p>

<p><font face="Arial" size="2">The <code>test</code> instruction above will set the zero
flag if and only if <code>cx</code> contains zero. After all, if there are any non-zero
bits in <code>cx</code>, logically anding them with themselves will produce a non-zero
result. This is an efficient way to see if a 16 or 32 bit register contains zero. In fact,
this two instruction sequence is faster than the <code>jcxz</code> instruction on the
80486 and later processors. Indeed, Intel recommends the use of this sequence rather than
the <code>jcxz</code> instruction if you are concerned with speed. Of course, the <code>jcxz</code>
instruction is shorter than the two instruction sequence, but it is not faster. This is a
good example of an exception to the rule &quot;shorter is usually faster.&quot;</font></p>

<p><font face="Arial" size="2">The <code>jcxz</code> instruction does not affect any
flags.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-294"></a>6.9.6 The LOOP
Instruction</font></strong></p>

<p><font face="Arial" size="2">This instruction decrements the <code>cx</code> register
and then branches to the target location if the <code>cx</code> register does not contain
zero. Since this instruction decrements <code>cx</code> then checks for zero, if <code>cx</code>
originally contained zero, any loop you create using the <code>loop</code> instruction
will repeat 65,536 times. If you do not want to execute the loop when <code>cx</code>
contains zero, use <code>jcxz</code> to skip over the loop. </font></p>

<p><font face="Arial" size="2">There is no &quot;opposite&quot; form of the loop
instruction, and like the <code>jcxz/jecxz</code> instructions the range is limited to <em></em>128
bytes on all processors. If you want to extend the range of this instruction, you will
need to break it down into discrete components: </font></p>

<pre><font face="Courier New" size="2">; &quot;loop lbl&quot; becomes:

		dec	cx
		jne	lbl</font></pre>

<p><font face="Arial" size="2">You can easily extend this <code>jne</code> to any
distance.</font></p>

<p><font face="Arial" size="2">There is no <code>eloop</code> instruction that decrements <code>ecx</code>
and branches if not zero (there is a <code>loope</code> instruction, but it does something
else entirely). The reason is quite simple. As of the 80386, Intel's designers stopped
wholeheartedly supporting the <code>loop</code> instruction. Oh, it's there to ensure
compatibility with older code, but it turns out that the <code>dec/jne</code> instructions
are actually faster on the 32 bit processors. Problems in the decoding of the instruction
and the operation of the pipeline are responsible for this strange turn of events.</font></p>

<p><font face="Arial" size="2">Although the <code>loop</code> instruction's name suggests
that you would normally create loops with it, keep in mind that all it is really doing is
decrementing <code>cx</code> and branching to the target address if <code>cx</code> does
not contain zero after the decrement. You can use this instruction anywhere you want to
decrement <code>cx</code> and then check for a zero result, not just when creating loops.
Nonetheless, it is a very convenient instruction to use if you simply want to repeat a
sequence of instructions some number of times. For example, the following loop initializes
a 256 element array of bytes to the values 1, 2, 3, ... </font></p>

<pre><font face="Courier New" size="2">                mov     ecx, 255
ArrayLp:        mov     Array[ecx], cl
                loop    ArrayLp
                mov     Array[0], 0</font></pre>

<p><font face="Arial" size="2">The last instruction is necessary because the loop does not
repeat when <code>cx</code> is zero. Therefore, the last element of the array that this
loop processes is <code>Array[1]</code>, hence the last instruction.</font></p>

<p><font face="Arial" size="2">The <code>loop</code> instruction does not affect any
flags.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-312"></a>6.9.7 The LOOPE/LOOPZ
Instruction</font></strong></p>
<code>

<p><font face="Arial" size="2">Loope/loopz</code> (loop while equal/zero, they are
synonyms for one another) will branch to the target address if <code>cx</code> is not zero
and the zero flag is set. This instruction is quite useful after <code>cmp</code> or <code>cmps</code>
instruction, and is marginally faster than the comparable 80386/486 instructions if you
use all the features of this instruction. However, this instruction plays havoc with the
pipeline and superscalar operation of the Pentium so you're probably better off sticking
with discrete instructions rather than using this instruction. This instruction does the
following: </font></p>

<pre><font face="Courier New" size="2">	cx := cx - 1
	if ZeroFlag = 1 and cx  0, goto target</font></pre>

<p><font face="Arial" size="2">The <code>loope</code> instruction falls through on one of
two conditions. Either the zero flag is clear or the instruction decremented <code>cx</code>
to zero. By testing the zero flag after the loop instruction (with a <code>je</code> or <code>jne</code>
instruction, for example), you can determine the cause of termination.</font></p>

<p><font face="Arial" size="2">This instruction is useful if you need to repeat a loop
while some value is equal to another, but there is a maximum number of iterations you want
to allow. For example, the following loop scans through an array looking for the first
non-zero byte, but it does not scan beyond the end of the array: </font></p>

<pre><font face="Courier New" size="2">                mov     cx, 16          ;Max 16 array elements.
                mov     bx, -1          ;Index into the array (note next inc).
SearchLp:       inc     bx              ;Move on to next array element.
                cmp     Array[bx], 0    ;See if this element is zero.
                loope   SearchLp        ;Repeat if it is.
                je      AllZero         ;Jump if all elements were zero.</font></pre>

<p><font face="Arial" size="2">Note that this instruction is not the opposite of <code>loopnz/loopne</code>.
If you need to extend this jump beyond <em></em>128 bytes, you will need to synthesize
this instruction using discrete instructions. For example, if <code>loope</code> target is
out of range, you would need to use an instruction sequence like the following: </font></p>

<pre><font face="Courier New" size="2">                jne     quit
                dec     cx
                je      Quit2
                jmp     Target
quit:           dec     cx      ;loope decrements cx, even if ZF=0.
quit2:</font></pre>

<p><font face="Arial" size="2">The <code>loope/loopz</code> instruction does not affect
any flags.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-335"></a>6.9.8 The LOOPNE/LOOPNZ
Instruction</font></strong></p>

<p><font face="Arial" size="2">This instruction is just like <code>the loope</code>/<code>loopz</code>
instruction<code> </code>in the previous section except <code>loopne/loopnz </code>(loop
while not equal/not zero) repeats while <code>cx</code> is not zero and the zero flag is
clear. The algorithm is </font></p>

<pre><font face="Courier New" size="2">	cx := cx - 1
	if ZeroFlag = 0 and cx  0, goto target</font></pre>

<p><font face="Arial" size="2">You can determine if the <code>loopne</code> instruction
terminated because <code>cx</code> was zero or if the zero flag was set by testing the
zero flag immediately after the <code>loopne</code> instruction. If the zero flag is clear
at that point, the <code>loopne</code> instruction fell through because it decremented <code>cx</code>
to zero. Otherwise it fell through because the zero flag was set.</font></p>

<p><font face="Arial" size="2">This instruction is not the opposite of <code>loope/loopz</code>.
If the target address is out of range, you will need to use an instruction sequence like
the following: </font></p>

<pre><font face="Courier New" size="2">                je      quit
                dec     cx
                je      Quit2
                jmp     Target
quit:           dec     cx      ;loopne decrements cx, even if ZF=1.
quit2:</font></pre>

<p><font face="Arial" size="2">You can use the <code>loopne</code> instruction to repeat
some maximum number of times while waiting for some other condition to be true. For
example, you could scan through an array until you exhaust the number of array elements or
until you find a certain byte using a loop like the following: </font></p>

<pre><font face="Courier New" size="2">                mov     cx, 16          ;Maximum # of array elements.
                mov     bx, -1          ;Index into array.
LoopWhlNot0:    inc     bx              ;Move on to next array element.
                cmp     Array[bx],0     ;Does this element contain zero?
                loopne  LoopWhlNot0     ;Quit if it does, or more than 16 bytes.</font></pre>

<p><font face="Arial" size="2">Although the <code>loope/loopz </code>and <code>loopne/loopnz</code>
instructions are slower than the individual instruction from which they could be
synthesized, there is one main use for these instruction forms where speed is rarely
important; indeed, being faster would make them less useful - timeout loops during I/O
operations. Suppose bit #7 of input port 379h contains a one if the device is busy and
contains a zero if the device is not busy. If you want to output data to the port, you
could use code like the following: </font></p>

<pre><font face="Courier New" size="2">                mov     dx, 379h
WaitNotBusy:    in      al, dx          ;Get port
                test    al, 80h         ;See if bit #7 is one
                jne     WaitNotBusy     ;Wait for &quot;not busy&quot;</font></pre>

<p><font face="Arial" size="2">The only problem with this loop is that it is conceivable
that it would loop forever. In a real system, a cable could come unplugged, someone could
shut off the peripheral device, and any number of other things could go wrong that would
hang up the system. Robust programs usually apply a timeout to a loop like this. If the
device fails to become busy within some specified amount of time, then the loop exits and
raises an error condition. The following code will accomplish this: </font></p>

<pre><font face="Courier New" size="2">                mov     dx, 379h        ;Input port address
                mov     cx, 0           ;Loop 65,536 times and then quit.
WaitNotBusy:    in      al, dx          ;Get data at port.
                test    al, 80h         ;See if busy
                loopne  WaitNotBusy     ;Repeat if busy and no time out.
                jne     TimedOut        ;Branch if CX=0 because we timed out.</font></pre>

<p><font face="Arial" size="2">You could use the<code> loope/loopz </code>instruction if
the bit were zero rather than one.</font></p>

<p><font face="Arial" size="2">The <code>loopne/loopnz</code> instruction does not affect
any flags.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING5-372"></a>6.10
    Miscellaneous Instructions</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">There are various miscellaneous instructions on the 80x86
that don't fall into any category above. Generally these are instructions that manipulate
individual flags, provide special processor services, or handle privileged mode
operations.</font></p>

<p><font face="Arial" size="2">There are several instructions that directly manipulate
flags in the 80x86 flags register. They are </font>

<ul>
  <li><font face="Arial" size="2"><code>clc</code> Clears the carry flag </font></li>
  <li><font face="Arial" size="2"><code>stc</code> Sets the carry flag </font></li>
  <li><font face="Arial" size="2"><code>cmc</code> Complements the carry flag </font></li>
  <li><font face="Arial" size="2"><code>cld</code> Clears the direction flag </font></li>
  <li><font face="Arial" size="2"><code>std</code> Sets the direction flag </font></li>
  <li><font face="Arial" size="2"><code>cli</code> Clears the interrupt enable/disable flag </font></li>
  <li><font face="Arial" size="2"><code>sti</code> Sets the interrupt enable/disable flag </font></li>
</ul>

<p><font face="Arial" size="2">Note: you should be careful when using the <code>cli</code>
instruction in your programs. Improper use could lock up your machine until you cycle the
power. </font></p>

<p><font face="Arial" size="2">The <code>nop</code> instruction doesn't do anything except
waste a few processor cycles and take up a byte of memory. Programmers often use it as a
place holder or a debugging aid. As it turns out, this isn't a unique instruction, it's
just a synonym for the <code>xchg ax, ax </code>instruction.</font></p>

<p><font face="Arial" size="2">The <code>hlt</code> instruction halts the processor until
a reset, non-maskable interrupt, or other interrupt (assuming interrupts are enabled)
comes along. Generally, you shouldn't use this instruction on the IBM PC unless you really
know what you are doing. This instruction is not equivalent to the x86 halt instruction.
Do not use it to stop your programs.</font></p>

<p><font face="Arial" size="2">The 80x86 provides another prefix instruction, <code>lock</code>,
that, like the <code>rep</code> instruction, affects the following instruction. However,
this instruction has little meaning on most PC systems. Its purpose is to coordinate
systems that have multiple CPUs. As systems become available with multiple processors,
this prefix may finally become valuable. You need not be too concerned about this here.</font></p>

<p><font face="Arial" size="2">The Pentium provides two additional instructions of
interest to real-mode DOS programmers. These instructions are <code>cpuid</code> and <code>rdtsc</code>.
If you load <code>eax</code> with zero and execute the <code>cpuid</code> instruction, the
Pentium (and later processors) will return the maximum value <code>cpuid</code> allows as
a parameter in <code>eax</code>. For the Pentium, this value is one. If you load the <code>eax</code>
register with one and execute the <code>cpuid</code> instruction, the Pentium will return
CPU identification information in <code>eax</code>. Since this instruction is of little
value until Intel produces several additional chips in the family, there is no need to
consider it further, here.</font></p>

<p><font face="Arial" size="2">The second Pentium instruction of interest is the <code>rdtsc</code>
(read time stamp counter) instruction. The Pentium maintains a 64 bit counter that counts
clock cycles starting at reset. The <code>rdtsc</code> instruction copies the current
counter value into the <code>edx:eax</code> register pair. You can use this instruction to
accurately time sequences of code.</font></p>

<p><font face="Arial" size="2">Besides the instructions presented thus far, the 80286 and
later processors provide a set of protected mode instructions. This text will not consider
those protected most instructions that are useful only to those who are writing operating
systems. You would not even use these instructions in your applications when running under
a protected mode operating system like Windows, UNIX, or OS/2. These instructions are
reserved for the individuals who write such operating systems and drivers for them.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH06-4.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH06-4.html">Chapter Six</a> (Part 4)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH06-6.html">Chapter Six</a> (Part 6) </strong></font><a href="CH06-6.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Six: The 80x86 Instruction
Set (Part 5)<br>
26 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_6/CH06-5.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:28 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
