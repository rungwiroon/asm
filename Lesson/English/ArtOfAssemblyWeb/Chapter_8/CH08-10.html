<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_8/CH08-10.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:37 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER EIGHT: MASM: DIRECTIVES &amp; PSEUDO-OPCODES (Part 10)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING10"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH08-8.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH08-8.html">Chapter Eight</a> (Part 9)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH08-11.html">Chapter Eight</a> (Part 11) </strong></font><a href="CH08-11.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10" colspan="2"><a NAME="HEADING10-1"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0" colspan="2"><font face="Arial" size="4"><strong>CHAPTER
    EIGHT:<br>
    MASM: DIRECTIVES &amp; PSEUDO-OPCODES (Part 10)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10" colspan="2"></td>
  </tr>
  <tr>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING10-1"><b>8.19 </b>-
    Controlling the Listing</a> <br>
    <a HREF="#HEADING10-3"><b>8.19.1 </b>- The ECHO and %OUT Directives</a> <br>
    <a HREF="#HEADING10-5"><b>8.19.2 </b>- The TITLE Directive</a> <br>
    <a HREF="#HEADING10-10"><b>8.19.3 </b>- The SUBTTL Directive</a> <br>
    <a HREF="#HEADING10-15"><b>8.19.4 </b>- The PAGE Directive</a> <br>
    <a HREF="#HEADING10-26"><b>8.19.5 </b>- The .LIST, .NOLIST, and .XLIST Directives</a> </font></td>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING10-32"><b>8.19.6
    </b>- Other Listing Directives</a> <br>
    <a HREF="#HEADING10-34"><b>8.20 </b>- Managing Large Programs</a> <br>
    <a HREF="#HEADING10-41"><b>8.20.1 </b>- The INCLUDE Directive</a> <br>
    <a HREF="#HEADING10-56"><b>8.20.2 </b>- The PUBLIC, EXTERN, and EXTRN Directives</a> <br>
    <a HREF="#HEADING10-109"><b>8.20.3 </b>- The EXTERNDEF Directive</a> <br>
    <a HREF="#HEADING10-131"><b>8.21 </b>- Make Files</a> </font></td>
  </tr>
  <tr>
    <td width="100%" valign="top" nowrap height="20" colspan="2"></td>
  </tr>
  <tr>
    <td width="100%" valign="top" colspan="2"><font face="Arial" size="3"><strong>8.19
    Controlling The Listing</strong></font></td>
  </tr>
  <tr>
    <td width="100%" valign="top" nowrap height="1" bgcolor="#000000" colspan="2"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">MASM provides several assembler directives that are useful
for controlling the output of the assembler. These directives include <code>echo, %out,
title, subttl, page, .list, .nolist, </code>and<code> .xlist.</code> There are several
others, but these are the most important.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING10-3"></a>8.19.1 The ECHO and %OUT
Directives</font></strong></p>

<p><font face="Arial" size="2">The <code>echo </code>and <code>%out </code>directives
simply print whatever appears in its operand field to the video display during assembly.
Some examples of <code>echo </code>and <code>%out </code>appeared in the sections on
conditional assembly and macros. Note that <code>%out </code>is an older form of <code>echo
</code>provided for compatibility with old source code.. You should use <code>echo </code>in
all your new code.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING10-5"></a>8.19.2 The TITLE
Directive</font></strong></p>

<p><font face="Arial" size="2">The <code>title </code>assembler directive assigns a title
to your source file. Only one <code>title </code>directive may appear in your program. The
syntax for this directive is </font></p>

<pre><font face="Courier New" size="2">                title   text </font></pre>

<p><font face="Arial" size="2">MASM will print the specified text at the top of each page
of the assembled listing. </font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING10-10"></a>8.19.3 The SUBTTL
Directive</font></strong></p>

<p><font face="Arial" size="2">The <code>subttl </code>(subtitle) directive is similar to
the <code>title </code>directive, except multiple subtitles may appear within your source
file. Subtitles appear immediately below the title at the top of each page in the
assembled listing. The syntax for the <code>subttl </code>directive is </font></p>

<pre><font face="Courier New" size="2">                subttl  text </font></pre>

<p><font face="Arial" size="2">The specified text will become the new subtitle. Note that
MASM will not print the new subtitle until the next page eject. If you wish to place the
subtitle on the same page as the code immediately following the directive, use the <code>page
</code>directive (described next) to force a page ejection.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING10-15"></a>8.19.4 The PAGE
Directive</font></strong></p>

<p><font face="Arial" size="2">The <code>page </code>directive performs two functions- it
can force a page eject in the assembly listing and it can set the width and length of the
output device. To force a page eject, the following form of the <code>page </code>directive
is used:</font> </p>

<pre><font face="Courier New" size="2">                page</font></pre>

<p><font face="Arial" size="2">If you place a plus sign, &quot;+&quot;, in the operand
field, then MASM performs a page break, increments the section number, and resets the page
number to one. MASM prints page numbers using the format </font></p>

<p><font face="Arial" size="2">section-page</font></p>

<p><font face="Arial" size="2">If you want to take advantage of the section number
facility, you will have to manually insert page breaks (with a &quot;+&quot; operand) in
front of each new section. </font></p>

<p><font face="Arial" size="2">The second form of the <code>page </code>command lets you
set the printer page width and length values. It takes the form: </font></p>

<pre><font face="Courier New" size="2">                page    length, width</font></pre>

<p><font face="Arial" size="2">where length is the number of lines per page (defaults to
50, but 56-60 is a better choice for most printers) and width is the number of characters
per line. The default page width is 80 characters. If your printer is capable of printing
132 columns, you should change this value to 132 so your listings will be easier to read.
Note that some printers, even if their carriage is only 8-1/2&quot; wide, will print at
least 132 columns across in a condensed mode. Typically some control character must be
sent to the printer to place it in condensed mode. You can insert such a control character
in a comment at the beginning of your source listing.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING10-26"></a>8.19.5 The .LIST,
.NOLIST, and .XLIST Directives</font></strong></p>

<p><font face="Arial" size="2">The .<code>list</code>, .<code>nolist</code>, and .<code>xlist
</code>directives can be used to selectively list portions of your source file during
assembly. .<code>List </code>turns the listing on, .<code>Nolist </code>turns the listing
off. .<code>Xlist </code>is an obsolete form of .<code>Nolist </code>for older code.</font></p>

<p><font face="Arial" size="2">By sprinkling these three directives throughout your source
file, you can list only those sections of code that interest you. None of these directives
accept any operands. They take the following forms: </font></p>

<pre><font face="Courier New" size="2">                .list 
                .nolist
                .xlist</font></pre>

<pre><strong><font face="Arial" size="3">8.19.6 Other Listing Directives</font></strong></pre>

<p><font face="Arial" size="2">MASM provides several other listing control directives that
this chapter will not cover. These let you control the output of macros, conditional
assembly segments, and so on to the listing file. Please see the appendices for details on
these directives.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING10-34"></a>8.20
    Managing Large Programs</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">Most assembly language programs are not totally stand alone
programs. In general, you will call various standard library or other routines which are
not defined in your main program. For example, you've probably noticed by now that the
80x86 doesn't provide any instructions like &quot;read&quot;, &quot;write&quot;, or
&quot;printf&quot; for doing I/O operations. In fact, the only instructions you've seen
that do I/O include the 80x86 <code>in </code>and <code>out </code>instructions, which are
really just special <code>mov </code>instructions, and the <code>echo</code>/<code>%out </code>directives
that perform assembly-time output, not the run-time output you want. Is there no way to do
I/O from assembly language? Of course there is. You can write procedures that perform the
I/O operations like &quot;read&quot; and &quot;write&quot;. Unfortunately, writing such
routines is a complex task, and beginning assembly language programmers are not ready for
such tasks. That's where the UCR Standard Library for 80x86 Assembly Language Programmers
comes in. This is a package of procedures you can call to perform simple I/O operations
like &quot;printf&quot;.</font></p>

<p><font face="Arial" size="2">The UCR Standard Library contains thousands of lines of
source code. Imagine how difficult programming would be if you had to merge these
thousands of lines of code into your simple programs. Fortunately, you don't have to.</font></p>

<p><font face="Arial" size="2">For small programs, working with a single source file is
fine. For large programs this gets very cumbersome (consider the example above of having
to include the entire UCR Standard Library into each of your programs). Furthermore, once
you've debugged and tested a large section of your code, continuing to assemble that same
code when you make a small change to some other part of your program is a waste of time.
The UCR Standard Library, for example, takes several minutes to assemble, even on a fast
machine. Imagine having to wait five or ten minutes on a fast Pentium machine to assemble
a program to which you've made a one line change!</font></p>

<p><font face="Arial" size="2">As with HLLs, the solution is separate compilation (or
separate assembly in MASM's case). First, you break up your large source files into
manageable chunks. Then you assemble the separate files into object code modules. Finally,
you link the object modules together to form a complete program. If you need to make a
small change to one of the modules, you only need to reassemble that one module, you do
not need to reassemble the entire program.</font></p>

<p><font face="Arial" size="2">The UCR Standard Library works in precisely this way. The
Standard Library is already assembled and ready to use. You simply call routines in the
Standard Library and link your code with the Standard Library using a linker program. This
saves a tremendous amount of time when developing a program that uses the Standard Library
code. Of course, you can easily create your own object modules and link them together with
your code. You could even add new routines to the Standard Library so they will be
available for use in future programs you write.</font></p>

<p><font face="Arial" size="2">&quot;Programming in the large&quot; is a term software
engineers have coined to describe the processes, methodologies, and tools for handling the
development of large software projects. While everyone has their own idea of what
&quot;large&quot; is, separate compilation, and some conventions for using separate
compilation, are one of the big techniques for &quot;programming in the large.&quot; The
following sections describe the tools MASM provides for separate compilation and how to
effectively employ these tools in your programs.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING10-41"></a>8.20.1 The INCLUDE
Directive</font></strong></p>

<p><font face="Arial" size="2">The <code>include </code>directive, when encountered in a
source file, switches program input from the current file to the file specified in the
parameter list of the <code>include</code>. This allows you to construct text files
containing common equates, macros, source code, and other assembler items, and include
such a file into the assembly of several separate programs. The syntax for the <code>include
</code>directive is </font></p>

<pre><font face="Courier New" size="2">                include filename</font></pre>
<code>

<p><font face="Arial" size="2">Filename</code> must be a valid DOS filename. MASM merges
the specified file into the assembly at the point of the <code>include </code>directive.
Note that you can nest <code>include </code>statements inside files you include. That is,
a file being included into another file during assembly may itself include a third file.</font></p>

<p><font face="Arial" size="2">Using the <code>include </code>directive by itself does not
provide separate compilation. You could use the <code>include </code>directive to break up
a large source file into separate modules and join these modules together when you
assemble your file. The following example would <code>include </code>the PRINTF.ASM and
PUTC.ASM files during the assembly of your program: </font></p>

<pre><font face="Courier New" size="2">                include printf.asm
                include putc.asm

        &lt;Code for your program goes here&gt;

                end</font></pre>

<p><font face="Arial" size="2">Now your program will benefit from the modularity gained by
this approach. Alas, you will not save any development time. The <code>include </code>directive
inserts the source file at the point of the <code>include </code>during assembly, exactly
as though you had typed that code in yourself. MASM still has to assemble the code and
that takes time. Were you to include all the files for the Standard Library routines, your
assemblies would take forever.</font></p>

<p><font face="Arial" size="2">In general, you should not use the <code>include </code>directive
to include source code as shown above. Instead, you should use the <code>include </code>directive
to insert a common set of constants (equates), macros, external procedure declarations,
and other such items into a program. Typically an assembly language include file does not
contain any machine code (outside of a macro). The purpose of using <code>include </code>files
in this manner will become clearer after you see how the public and external declarations
work.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING10-56"></a>8.20.2 The PUBLIC,
EXTERN, and EXTRN Directives</font></strong></p>

<p><font face="Arial" size="2">Technically, the <code>include </code>directive provides
you with all the facilities you need to create modular programs. You can build up a
library of modules, each containing some specific routine, and include any necessary
modules into an assembly language program using the appropriate <code>include </code>commands.
MASM (and the accompanying LINK program) provides a better way: external and public
symbols. </font></p>

<p><font face="Arial" size="2">One major problem with the <code>include </code>mechanism
is that once you've debugged a routine, including<code> </code>it into an assembly wastes
a lot of time since MASM must reassemble bug-free code every time you assemble the main
program. A much better solution would be to preassemble the debugged modules and link the
object code modules together rather than reassembling the entire program every time you
change a single module. This is what the <code>public </code>and <code>extern </code>directives
provide for you. <code>Extrn </code>is an older directive that is a synonym for <code>extern</code>.
It provides compatibility with old source files. You should always use the <code>extern </code>directive
in new source code.</font></p>

<p><font face="Arial" size="2">To use the <code>public </code>and <code>extern </code>facilities,
you must create at least two source files. One file contains a set of variables and
procedures used by the second. The second file uses those variables and procedures without
knowing how they're implemented. To demonstrate, consider the following two modules: </font></p>

<pre><font face="Courier New" size="2">;Module #1:
 
                public  Var1, Var2, Proc1
DSEG            segment para public 'data'
Var1            word    ?
Var2            word    ?
DSEG            ends

CSEG            segment para public 'code'
                assume  cs:cseg, ds:dseg
Proc1           proc     near
                mov     ax, Var1
                add     ax, Var2
                mov     Var1, ax
                ret
Proc1           endp
CSEG            ends
                end

;Module #2:
                extern  Var1:word, Var2:word, Proc1:near
CSEG            segment para public 'code'
                 .
                 .
                 .
                mov     Var1, 2
                mov     Var2, 3
                call    Proc1
                 .
                 .
                 .
CSEG            ends
                end </font></pre>

<p><font face="Arial" size="2">Module #2 references <code>Var1</code>, <code>Var2</code>,
and <code>Proc1</code>, yet these symbols are external to module #2. Therefore, you must
declare them external with the <code>extern </code>directive. This directive takes the
following form: </font></p>

<pre><font face="Courier New" size="2">                extern  name:type {,name:type...}</font></pre>

<p><font face="Arial" size="2"><code>Name</code> is the name of the external symbol, and <code>type</code>
is the type of that symbol. <code>Type</code> may be any of <code>near, far, proc, byte,
word, dword, qword, tbyte,</code> <code>abs </code>(absolute, which is a constant), or
some other user defined type. </font></p>

<p><font face="Arial" size="2">The current module uses this type declaration. Neither MASM
nor the linker checks the declared type against the module defining <code>name</code> to
see if the types agree. Therefore, you must exercise caution when defining external
symbols. The <code>public </code>directive lets you export a symbol's value to external
modules. A <code>public </code>declaration takes the form: </font></p>

<pre><font face="Courier New" size="2">                public  name {,name ...}</font></pre>

<p><font face="Arial" size="2">Each symbol appearing in the operand field of the <code>public
</code>statement is available as an external symbol to another module. Likewise, all
external symbols within a module must appear within a <code>public </code>statement in
some other module.</font></p>

<p><font face="Arial" size="2">Once you create the source modules, you should assemble the
file containing the public declarations first. With MASM 6.x, you would use a command like</font></p>

<p><font face="Arial" size="2">ML /c pubs.asm</font></p>

<p><font face="Arial" size="2">The &quot;/c&quot; option tells MASM to perform a
&quot;compile-only&quot; assembly. That is, it will not try to link the code after a
successful assembly. This produces a &quot;pubs.obj&quot; object module.</font></p>

<p><font face="Arial" size="2">Next, assemble the file containing the external definitions
and link in the code using the MASM command:</font></p>

<p><font face="Arial" size="2">ML exts.asm pubs.obj</font></p>

<p><font face="Arial" size="2">Assuming there are no errors, this will produce a file
&quot;exts.exe&quot; which is the linked and executable form of the program. </font></p>

<p><font face="Arial" size="2">Note that the <code>extern </code>directive defines a
symbol in your source file. Any attempt to redefine that symbol elsewhere in your program
will produce a &quot;duplicate symbol&quot; error. This, as it turns out, is the source of
problems which Microsoft solved with the <code>externdef </code>directive.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING10-109"></a>8.20.3 The EXTERNDEF
Directive</font></strong></p>

<p><font face="Arial" size="2">The <code>externdef </code>directive is a combination of <code>public
</code>and <code>extern </code>all rolled into one. It uses the same syntax as the <code>extern
</code>directive, that is, you place a list of name:type entries in the operand field. If
MASM does not encounter another definition of the symbol in the current source file, <code>externdef
</code>behaves exactly like the <code>extern </code>statement. If the symbol does appear
in the source file, then <code>externdef </code>behaves like the <code>public </code>command.
With <code>externdef </code>there really is no need to use the <code>public </code>or <code>extern
</code>statements unless you feel somehow compelled to do so.</font></p>

<p><font face="Arial" size="2">The important benefit of the <code>externdef </code>directive
is that it lets you minimize duplication of effort in your source files. Suppose, for
example, you want to create a module with a bunch of support routines for other programs.
In addition to sharing some routines and some variables, suppose you want to share
constants and macros as well. The <code>include </code>file mechanism provides a perfect
way to handle this. You simply create an include file containing the constants, macros,
and <code>externdef </code>definitions and include this file in the module that implements
your routines and in the modules that use those routines:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch08a7.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/ch08a7.gif" ALIGN="bottom" NATURALSIZEFLAG="3" WIDTH="322" HEIGHT="129"> </font></p>

<p><font face="Arial" size="2">Note that <code>extern </code>and <code>public </code>wouldn't
work in this case because the implementation module needs the <code>public </code>directive
and the using module needs the <code>extern </code>directive. You would have to create two
separate header files. Maintaining two separate header files that contain mostly identical
definitions is not a good idea. The <code>externdef </code>directive provides a solution.</font></p>

<p><font face="Arial" size="2">Within your headers files you should create segment
definitions that match those in the including modules. Be sure to put the <code>externdef </code>directives
inside the same segments in which the symbol is actually defined. This associates a
segment value with the symbol so that MASM can properly make appropriate optimizations and
other calculations based on the symbol's full address: </font></p>

<pre><font face="Courier New" size="2">; From &quot;HEADER.A&quot; file:

cseg            segment para public 'code'

                externdef Routine1:near, Routine2:far

cseg            ends

dseg            segment para public 'data'

                externdef i:word, b:byte, flag:byte

dseg            ends</font></pre>

<p><font face="Arial" size="2">This text adopts the UCR Standard Library convention of
using an &quot;.a&quot; suffix for assembly language header files. Other common suffixes
in use include &quot;.inc&quot; and &quot;.def&quot;.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING10-131"></a>8.21 Make
    Files</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">Although using separate compilation reduces assembly time
and promotes code reuse and modularity, it is not without its own drawbacks. Suppose you
have a program that consists of two modules: pgma.asm and pgmb.asm. Also suppose that
you've already assembled both modules so that the files pgma.obj and pgmb.obj exist.
Finally, you make changes to pgma.asm and pgmb.asm and assemble the pgma.asm but forget to
assemble the pgmb.asm file. Therefore, the pgmb.obj file will be out of date since this
object file does not reflect the changes made to the pgmb.asm file. If you link the
program's modules together, the resulting .exe file will only contain the changes to the
pgma.asm file, it will not have the updated object code associated with pgmb.asm. As
projects get larger, as they have more modules associated with them, and as more
programmers begin working on the project, it gets very difficult to keep track of which
object modules are up to date.</font></p>

<p><font face="Arial" size="2">This complexity would normally cause someone to reassemble
(or recompile) all modules in a project, even if many of the .obj files are up to date,
simply because it might seem too difficult to keep track of which modules are up to date
and which are not. Doing so, of course, would eliminate many of the benefits that separate
compilation offers. Fortunately, there is a tool that can help you manage large projects:
nmake. The nmake program, will a little help from you, can figure out which files need to
be reassemble and which files have up to date .obj files. With a properly defined make
file, you can easily assemble only those modules that absolutely must be assembled to
generate a consistent program.</font></p>

<p><font face="Arial" size="2">A make file is a text file that lists assembly-time
dependencies between files. An .exe file, for example, is dependent on the source code
whose assembly produce the executable. If you make any changes to the source code you will
(probably) need to reassemble or recompile the source code to produce a new .exe file.</font></p>

<p><font face="Arial" size="2">Typical dependencies include the following: </font>

<ul>
  <li><font face="Arial" size="2">An executable file (.exe) generally depends only on the set
    of object files (.obj) that the linker combines to form the executable. </font></li>
  <li><font face="Arial" size="2">A given object code file (.obj) depends on the assembly
    language source files that were assembled to produce that object file. This includes the
    assembly language source files (.asm) and any files included during that assembly
    (generally .a files). </font></li>
  <li><font face="Arial" size="2">The source files and include files generally don't depend on
    anything. </font></li>
</ul>

<p><font face="Arial" size="2">A make file generally consists of a dependency statement
followed by a set of commands to handle that dependency. A dependency statement takes the
following form: </font></p>

<pre><font face="Courier New" size="2">dependent-file : list of files</font></pre>

<p><font face="Arial" size="2">Example: </font></p>

<pre><font face="Courier New" size="2">pgm.exe: pgma.obj pgmb.obj</font></pre>

<p><font face="Arial" size="2">This statement says that &quot;pgm.exe&quot; is dependent
upon pgma.obj and pgmb.obj. Any changes that occur to pgma.obj or pgmb.obj will require
the generate of a new pgm.exe file.</font></p>

<p><font face="Arial" size="2">The nmake.exe program uses a time/date stamp to determine
if a dependent file is out of date with respect to the files it depends upon. Any time you
make a change to a file, MS-DOS and Windows will update a modification time and date
associated with the file. The nmake.exe program compares the modification date/time stamp
of the dependent file against the modification date/time stamp of the files it depends
upon. If the dependent file's modification date/time is earlier than one or more of the
files it depends upon, or one of the files it depends upon is not present, then nmake.exe
assumes that some operation must be necessary to update the dependent file.</font></p>

<p><font face="Arial" size="2">When an update is necessary, nmake.exe executes the set of
(MS-DOS) commands following the dependency statement. Presumably, these commands would do
whatever is necessary to produce the updated file.</font></p>

<p><font face="Arial" size="2">The dependency statement must begin in column one. Any
commands that must execute to resolve the dependency must start on the line immediately
following the dependency statement and each command must be indented one tabstop. The
pgm.exe statement above would probably look something like the following: </font></p>

<pre><font face="Courier New" size="2">pgm.exe: pgma.obj pgmb.obj
	ml /Fepgm.exe pgma.obj pgmb.obj</font></pre>

<p><font face="Arial" size="2">(The &quot;/Fepgm.exe&quot; option tells MASM to name the
executable file &quot;pgm.exe.&quot;)</font></p>

<p><font face="Arial" size="2">If you need to execute more than one command to resolve the
dependencies, you can place several commands after the dependency statement in the
appropriate order. Note that you must indent all commands one tab stop. Nmake.exe ignores
any blank lines in a make file. Therefore, you can add blank lines, as appropriate, to
make the file easier to read and understand.</font></p>

<p><font face="Arial" size="2">There can be more than a single dependency statement in a
make file. In the example above, for example, pgm.exe depends upon the pgma.obj and
pgmb.obj files. Obviously, the .obj files depend upon the source files that generated
them. Therefore, before attempting to resolve the dependencies for pgm.exe, nmake.exe will
first check out the rest of the make file to see if pgma.obj or pgmb.obj depends on
anything. If they do, nmake.exe will resolve those dependencies first. Consider the
following make file: </font></p>

<pre><font face="Courier New" size="2">pgm.exe: pgma.obj pgmb.obj
	ml /Fepgm.exe pgma.obj pgmb.obj

pgma.obj: pgma.asm
	ml /c pgma.asm

pgmb.obj: pgmb.asm
	ml /c pgmb.asm</font></pre>

<p><font face="Arial" size="2">The nmake.exe program will process the first dependency
line it finds in the file. However, the files pgm.exe depends upon themselves have
dependency lines. Therefore, nmake.exe will first ensure that pgma.obj and pgmb.obj are up
to date before attempting to execute MASM to link these files together. Therefore, if the
only change you've made has been to pgmb.asm, nmake.exe takes the following steps
(assuming pgma.obj exists and is up to date).</font></p>

<p><font face="Arial" size="2">1. Nmake.exe processes the first dependency statement. It
notices that dependency lines for pgma.obj and pgmb.obj (the files on which pgm.exe
depends) exist. So it processes those statements first.</font></p>

<p><font face="Arial" size="2">2. Nmake.exe processes the pgma.obj dependency line. It
notices that the pgma.obj file is newer than the pgma.asm file, so it does not execute the
command following this dependency statement.</font></p>

<p><font face="Arial" size="2">3. Nmake.exe processes the pgmb.obj dependency line. It
notes that pgmb.obj is older than pgmb.asm (since we just changed the pgmb.asm source
file). Therefore, nmake.exe executes the DOS command following on the next line. This
generates a new pgmb.obj file that is now up to date.</font></p>

<p><font face="Arial" size="2">4. Having process the pgma.obj and pgmb.obj dependencies,
nmake.exe now returns its attention to the first dependency line. Since nmake.exe just
created a new pgmb.obj file, its date/time stamp will be newer than pgm.exe's. Therefore,
nmake.exe will execute the ml command that links pgma.obj and pgmb.obj together to form
the new pgm.exe file.</font></p>

<p><font face="Arial" size="2">Note that a properly written make file will instruct
nmake.exe to assembly only those modules absolutely necessary to produce a consistent
executable file. In the example above, nmake.exe did not bother to assemble pgma.asm since
its object file was already up to date. </font></p>

<p><font face="Arial" size="2">There is one final thing to emphasize with respect to
dependencies. Often, object files are dependent not only on the source file that produces
the object file, but any files that the source file includes as well. In the previous
example, there (apparently) were no such include files. Often, this is not the case. A
more typical make file might look like the following: </font></p>

<pre><font face="Courier New" size="2">pgm.exe: pgma.obj pgmb.obj
	ml /Fepgm.exe pgma.obj pgmb.obj

pgma.obj: pgma.asm pgm.a
	ml /c pgma.asm

pgmb.obj: pgmb.asm pgm.a
	ml /c pgmb.asm</font></pre>

<p><font face="Arial" size="2">Note that any changes to the pgm.a file will force
nmake.exe to reassemble both pgma.asm and pgmb.asm since the pgma.obj and pgmb.obj files
both depend upon the pgm.a include file. Leaving include files out of a dependency list is
a common mistake programmers make that can produce inconsistent .exe files.</font></p>

<p><font face="Arial" size="2">Note that you would not normally need to specify the UCR
Standard Library include files nor the Standard Library .lib files in the dependency list.
True, your resulting .exe file does depend on this code, but the Standard Library rarely
changes, so you can safely leave it out of your dependency list. Should you make a
modification to the Standard Library, simply delete any old .exe and .obj files and force
a reassembly of the entire system.</font></p>

<p><font face="Arial" size="2">Nmake.exe, by default, assumes that it will be processing a
make file named &quot;makefile&quot;. When you run nmake.exe, it looks for
&quot;makefile&quot; in the current directory. If it doesn't find this file, it complains
and terminates. Therefore, it is a good idea to collect the files for each project you
work on into their own subdirectory and give each project its own makefile. Then to create
an executable, you need only change into the appropriate subdirectory and run the
nmake.exe program.</font></p>

<p><font face="Arial" size="2">Although this section discusses the nmake program in
sufficient detail to handle most projects you will be working on, keep in mind that
nmake.exe provides considerable functionality that this chapter does not discuss. To learn
more about the nmake.exe program, consult the documentation that comes with MASM. </font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH08-8.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH08-8.html">Chapter Eight</a> (Part 9)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH08-11.html">Chapter Eight</a> (Part 11) </strong></font><a href="CH08-11.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Eight: MASM: Directives &amp;
Pseudo-Opcodes (Part 10)<br>
26 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_8/CH08-10.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:38 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
