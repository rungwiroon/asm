<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_8/CH08-1.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:29 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER EIGHT: MASM: DIRECTIVES &amp; PSEUDO-OPCODES (Part 1)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING1"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="../Chapter_7/CH07-2.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="../Chapter_7/CH07-1.html">Chapter
    Seven</a></strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH08-2.html">Chapter Eight</a> (Part 2) </strong></font><a href="CH08-2.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3" bgcolor="#FFFFFF" nowrap height="10"><a NAME="HEADING1-0"></a></td>
  </tr>
  <tr>
    <td width="100%" colspan="3" bgcolor="#F0F0F0"><font face="Arial" size="4"><strong>CHAPTER
    EIGHT:<br>
    MASM: DIRECTIVES &amp; PSEUDO-OPCODES (Part 1)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" colspan="3" nowrap height="10"></td>
  </tr>
  <tr>
    <td width="40%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING1-4"><b>8.0 </b>-
    Chapter Overview</a> <br>
    <a HREF="#HEADING1-19"><b>8.1 </b>- Assembly Language Statements</a> <br>
    <a HREF="#HEADING1-58"><b>8.2 </b>- The Location Counter</a> <br>
    <a HREF="#HEADING1-74"><b>8.3 </b>- Symbols</a> <br>
    <a HREF="#HEADING1-148"><b>8.4 </b>- Literal Constants </a><br>
    <a HREF="#HEADING1-160"><b>8.4.1 </b>- Integer Constants</a> <br>
    <a HREF="#HEADING1-175"><b>8.4.2 </b>- String Constants</a> <br>
    <a HREF="#HEADING1-193"><b>8.4.3 </b>- Real Constants</a> <br>
    <a HREF="#HEADING1-202"><b>8.4.4 </b>- Text Constants</a> <br>
    <a HREF="#HEADING1-206"><b>8.5 </b>- Declaring Manifest Constants Using Equates</a> <br>
    <a HREF="#HEADING1-285"><b>8.6 </b>- Processor Directives</a> <br>
    <a HREF="#HEADING1-311"><b>8.7 </b>- Procedures</a> <br>
    <a HREF="CH08-2.html#HEADING2-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-2.html#HEADING2-1"><b>8.8 </b>-
    Segments</a> <br>
    <a HREF="CH08-2.html#HEADING2-16" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-2.html#HEADING2-16"><b>8.8.1
    </b>- Segment Names</a> <br>
    <a HREF="CH08-2.html#HEADING2-48" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-2.html#HEADING2-48"><b>8.8.2
    </b>- Segment Loading Order</a> <br>
    <a HREF="CH08-2.html#HEADING2-72" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-2.html#HEADING2-72"><b>8.8.3
    </b>- Segment Operands</a> <br>
    <a HREF="CH08-2.html#HEADING2-74" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-2.html#HEADING2-74"><b>8.8.3.1
    </b>- The ALIGN Type</a> <br>
    <a HREF="CH08-2.html#HEADING2-164" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-2.html#HEADING2-164"><b>8.8.3.2
    </b>- The COMBINE Type</a> <br>
    <a HREF="CH08-3.html#HEADING3-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-3.html#HEADING3-1"><b>8.8.4 </b>-
    The CLASS Type</a> <br>
    <a HREF="CH08-3.html#HEADING3-34" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-3.html#HEADING3-34"><b>8.8.5
    </b>- The Read-only Operand</a> <br>
    <a HREF="CH08-3.html#HEADING3-42" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-3.html#HEADING3-42"><b>8.8.6
    </b>- The USE16, USE32, and FLAT Options</a> <br>
    <a HREF="CH08-3.html#HEADING3-55" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-3.html#HEADING3-55"><b>8.8.7
    </b>- Typical Segment Definitions</a> <br>
    <a HREF="CH08-3.html#HEADING3-76" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-3.html#HEADING3-76"><b>8.8.8
    </b>- Why You Would Want to Control the Loading Order</a> <br>
    <a HREF="CH08-3.html#HEADING3-94" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-3.html#HEADING3-94"><b>8.8.9
    </b>- Segment Prefixes</a> <br>
    <a HREF="CH08-3.html#HEADING3-98" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-3.html#HEADING3-98"><b>8.8.10
    </b>- Controlling Segments with the ASSUME Directive</a> <br>
    <a HREF="CH08-3.html#HEADING3-192" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-3.html#HEADING3-192"><b>8.8.11
    </b>- Combining Segments: The GROUP Directive</a> <br>
    <a HREF="CH08-3.html#HEADING3-295" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-3.html#HEADING3-295"><b>8.8.12
    </b>- Why Even Bother With Segments?</a> <br>
    <a HREF="CH08-4.html#HEADING4-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-4.html#HEADING4-1"><b>8.9 </b>-
    The END Directive</a> <br>
    <a HREF="CH08-4.html#HEADING4-4" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-4.html#HEADING4-4"><b>8.10 </b>-
    Variables</a> <br>
    <a HREF="CH08-4.html#HEADING4-13" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-4.html#HEADING4-13"><b>8.11 </b>-
    Label Types</a> <br>
    <a HREF="CH08-4.html#HEADING4-15" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-4.html#HEADING4-15"><b>8.11.1
    </b>- How to Give a Symbol a Particular Type</a> <br>
    <a HREF="CH08-4.html#HEADING4-42" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-4.html#HEADING4-42"><b>8.11.2
    </b>- Label Values</a> <br>
    <a HREF="CH08-4.html#HEADING4-44" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-4.html#HEADING4-44"><b>8.11.3
    </b>- Type Conflicts</a> <br>
    <a HREF="CH08-4.html#HEADING4-69" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-4.html#HEADING4-69"><b>8.12 </b>-
    Address Expressions</a> <br>
    <a HREF="CH08-4.html#HEADING4-83" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-4.html#HEADING4-83"><b>8.12.1
    </b>- Symbol Types and Addressing Modes</a> <br>
    <a HREF="CH08-4.html#HEADING4-101" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-4.html#HEADING4-101"><b>8.12.2
    </b>- Arithmetic and Logical Operators</a> <br>
    <a HREF="CH08-4.html#HEADING4-147" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-4.html#HEADING4-147"><b>8.12.3
    </b>- Coercion</a> <br>
    <a HREF="CH08-5.html#HEADING5-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-5.html#HEADING5-1"><b>8.12.4
    </b>- Type Operators</a> <br>
    <a HREF="CH08-5.html#HEADING5-135" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-5.html#HEADING5-135"><b>8.12.5
    </b>- Operator Precedence</a> <br>
    <a HREF="CH08-6.html#HEADING6-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-6.html#HEADING6-1"><b>8.13 </b>-
    Conditional Assembly</a> <br>
    <a HREF="CH08-6.html#HEADING6-10" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-6.html#HEADING6-10"><b>8.13.1
    </b>- IF Directive</a> <br>
    <a HREF="CH08-6.html#HEADING6-36" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-6.html#HEADING6-36"><b>8.13.2
    </b>- IFE directive</a> <br>
    <a HREF="CH08-6.html#HEADING6-38" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-6.html#HEADING6-38"><b>8.13.3
    </b>- IFDEF and IFNDEF</a> <br>
    <a HREF="CH08-6.html#HEADING6-51" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-6.html#HEADING6-51"><b>8.13.4
    </b>- IFB, IFNB</a> <br>
    <a HREF="CH08-6.html#HEADING6-69" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-6.html#HEADING6-69"><b>8.13.5
    </b>- IFIDN, IFDIF, IFIDNI, and IFDIFI</a> <br>
    <a HREF="CH08-7.html#HEADING7-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-7.html#HEADING7-1"><b>8.14 </b>-
    Macros</a> <br>
    <a HREF="CH08-7.html#HEADING7-3" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-7.html#HEADING7-3"><b>8.14.1
    </b>- Procedural Macros </a><br>
    <a HREF="CH08-7.html#HEADING7-192" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-7.html#HEADING7-192"><b>8.14.2
    </b>- Macros vs. 80x86 Procedures </a><br>
    <a HREF="CH08-7.html#HEADING7-248" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-7.html#HEADING7-248"><b>8.14.3
    </b>- The LOCAL Directive</a> <br>
    <a HREF="CH08-7.html#HEADING7-276" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-7.html#HEADING7-276"><b>8.14.4
    </b>- The EXITM Directive</a> <br>
    <a HREF="CH08-7.html#HEADING7-288" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-7.html#HEADING7-288"><b>8.14.5
    </b>- Macro Parameter Expansion and Macro Operators</a> <br>
    <a HREF="CH08-7.html#HEADING7-389" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-7.html#HEADING7-389"><b>8.14.6
    </b>- A Sample Macro to Implement For Loops</a> <br>
    <a HREF="CH08-8.html#HEADING8-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-8.html#HEADING8-1"><b>8.14.7
    </b>- Macro Functions</a> <br>
    <a HREF="CH08-8.html#HEADING8-39" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-8.html#HEADING8-39"><b>8.14.8
    </b>- Predefined Macros, Macro Functions, and Symbols</a> <br>
    <a HREF="CH08-8.html#HEADING8-125" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-8.html#HEADING8-125"><b>8.14.9
    </b>- Macros vs. Text Equates</a> <br>
    <a HREF="CH08-8.html#HEADING8-130" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-8.html#HEADING8-130"><b>8.14.10
    </b>- Macros: Good and Bad News</a> <br>
    <a HREF="CH08-9.html#HEADING9-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-9.html#HEADING9-1"><b>8.15 </b>-
    Repeat Operations</a> <br>
    <a HREF="CH08-9.html#HEADING9-51" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-9.html#HEADING9-51"><b>8.16 </b>-
    The FOR and FORC Macro Operations</a> <br>
    <a HREF="CH08-9.html#HEADING9-90" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-9.html#HEADING9-90"><b>8.17 </b>-
    The WHILE Macro Operation</a> <br>
    <a HREF="CH08-9.html#HEADING9-100" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-9.html#HEADING9-100"><b>8.18
    </b>- Macro Parameters</a> <br>
    <a HREF="CH08-10.html#HEADING10-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-10.html#HEADING10-1"><b>8.19
    </b>- Controlling the Listing</a> <br>
    <a HREF="CH08-10.html#HEADING10-3" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-10.html#HEADING10-3"><b>8.19.1
    </b>- The ECHO and %OUT Directives</a> <br>
    <a HREF="CH08-10.html#HEADING10-5" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-10.html#HEADING10-5"><b>8.19.2
    </b>- The TITLE Directive</a> <br>
    <a HREF="CH08-10.html#HEADING10-10" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-10.html#HEADING10-10"><b>8.19.3
    </b>- The SUBTTL Directive</a> <br>
    <a HREF="CH08-10.html#HEADING10-15" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-10.html#HEADING10-15"><b>8.19.4
    </b>- The PAGE Directive</a> <br>
    <a HREF="CH08-10.html#HEADING10-26" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-10.html#HEADING10-26"><b>8.19.5
    </b>- The .LIST, .NOLIST, and .XLIST Directives</a> <br>
    <a HREF="CH08-10.html#HEADING10-32" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-10.html#HEADING10-32"><b>8.19.6
    </b>- Other Listing Directives</a><br>
    <a HREF="CH08-10.html#HEADING10-34" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-10.html#HEADING10-34"><b>8.20
    </b>- Managing Large Programs</a> <br>
    <a HREF="CH08-10.html#HEADING10-41" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-10.html#HEADING10-41"><b>8.20.1
    </b>- The INCLUDE Directive</a> <br>
    <a HREF="CH08-10.html#HEADING10-56" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-10.html#HEADING10-56"><b>8.20.2
    </b>- The PUBLIC, EXTERN, and EXTRN Directives</a> <br>
    <a HREF="CH08-10.html#HEADING10-109" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-10.html#HEADING10-109"><b>8.20.3
    </b>- The EXTERNDEF Directive</a> <br>
    <a HREF="CH08-10.html#HEADING10-131" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-10.html#HEADING10-131"><b>8.21
    </b>- Make Files</a> <br>
    <a HREF="CH08-11.html#HEADING11-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-11.html#HEADING11-1"><b>8.22
    </b>- Sample Program</a> <br>
    <a HREF="CH08-11.html#HEADING11-3" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-11.html#HEADING11-3"><b>8.22.1
    </b>- EX8.MAK</a> <br>
    <a HREF="CH08-11.html#HEADING11-20" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-11.html#HEADING11-20"><b>8.22.2
    </b>- Matrix.A</a> <br>
    <a HREF="CH08-11.html#HEADING11-103" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-11.html#HEADING11-103"><b>8.22.3
    </b>- EX8.ASM</a> <br>
    <a HREF="CH08-11.html#HEADING11-686" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-11.html#HEADING11-686"><b>8.22.4
    </b>- GETI.ASM</a> <br>
    <a HREF="CH08-11.html#HEADING11-785" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-11.html#HEADING11-785"><b>8.22.5
    </b>- GetArray.ASM</a> <br>
    <a HREF="CH08-11.html#HEADING11-885" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/CH08-11.html#HEADING11-885"><b>8.22.6
    </b>- XProduct.ASM</a> </font></td>
    <td width="20" nowrap valign="top"></td>
    <td width="60%" valign="top"><font size="1" face="Arial">Copyright 1996 by Randall Hyde
    All rights reserved. <br>
    <br>
    Duplication other than for immediate display through a browser is prohibited by U.S.
    Copyright Law. <br>
    This material is provided on-line as a beta-test of this text. It is for the personal use
    of the reader only. If you are interested in using this material as part of a course,
    please contact rhyde@cs.ucr.edu <br>
    <br>
    Supporting software and other materials are available via anonymous ftp from
    ftp.cs.ucr.edu. See the &quot;/pub/pc/ibmpcdir&quot; directory for details. You may also
    download the material from &quot;Randall Hyde's Assembly Language Page&quot; at URL:
    http://webster.ucr.edu<br>
    <br>
    Notes: <br>
    This document does not contain the laboratory exercises, programming assignments,
    exercises, or chapter summary. These portions were omitted for several reasons: either
    they wouldn't format properly, they contained hyperlinks that were too much work to
    resolve, they were under constant revision, or they were not included for security
    reasons. Such omission should have very little impact on the reader interested in learning
    this material or evaluating this document. <br>
    <br>
    This document was prepared using Harlequin's Web Maker 2.2 and Quadralay's Webworks
    Publisher. Since HTML does not support the rich formatting options available in
    Framemaker, this document is only an approximation of the actual chapter from the
    textbook. <br>
    <br>
    If you are absolutely dying to get your hands on a version other than HTML, you might
    consider having the UCR Printing a Reprographics Department run you off a copy on their
    Xerox machines. For details, please read the following EMAIL message I received from the
    Printing and Reprographics Department: </font><blockquote>
      <p><font size="1" face="Arial">Hello Again Professor Hyde,<br>
      <br>
      Dallas gave me permission to take orders for the Computer Science 13 Manuals. We would
      need to take charge card orders. The only cards we take are: Master Card, Visa, and
      Discover. They would need to send the name, numbers, expiration date, type of card, and
      authorization to charge $95.00 for the manual and shipping, also we should have their
      phone number in case the company has any trouble delivery. They can use my e-mail address
      for the orders and I will process them as soon as possible. I would assume that two weeks
      would be sufficient for printing, packages and delivery time.<br>
      <br>
      I am open to suggestions if you can think of any to make this as easy as possible.<br>
      <br>
      Thank You for your business,<br>
      Kathy Chapman, Assistant<br>
      Printing and Reprographics University of California Riverside (909) 787-4443/4444 </font></p>
    </blockquote>
    <p><font size="1" face="Arial">We are currently working on ways to publish this text in a
    form other than HTML (e.g., Postscript, PDF, Frameviewer, hard copy, etc.). This, however,
    is a low-priority project. Please do not contact Randall Hyde concerning this effort. When
    something happens, an announcement will appear on &quot;Randall Hyde's Assembly Language
    Page.&quot; Please visit this WEB site at http://webster.ucr.edu for the latest scoop.</font></p>
    <p><font size="1" face="Arial">Redesigned 10/2000 with &quot;MS FrontPage 98&quot; using
    17&quot; monitor 1024x768<br>
    (c)&nbsp; 2000 <a href="mail%20to_%20bircom_yanoo.html">BIRCOM Entertainment'95</a></font></td>
  </tr>
</table>
</center></div>

<hr noshade size="1" color="#000000">

<p><font face="Arial" size="2">Statements like mov ax,0 and add ax,bx are meaningless to
the microprocessor. As arcane as these statements appear, they are still human readable
forms of 80x86 instructions. The 80x86 responds to commands like B80000 and 03C3. An
assembler is a program that converts strings like mov ax,0 to 80x86 machine code like
&quot;B80000&quot;. An assembly language program consists of statements like mov ax,0. The
assembler converts an assembly language source file to machine code - the binary
equivalent of the assembly language program. In this respect, the assembler program is
much like a compiler, it reads an ASCII source file from the disk and produces a machine
language program as output. The major difference between a compiler for a high level
language (HLL) like Pascal and an assembler is that the compiler usually emits several
machine instructions for each Pascal statement. The assembler generally emits a single
machine instruction for each assembly language statement. </font></p>

<p><font face="Arial" size="2">Attempting to write programs in machine language (i.e., in
binary) is not particularly bright. This process is very tedious, prone to mistakes, and
offers almost no advantages over programming in assembly language. The only major
disadvantage to assembly language over pure machine code is that you must first assemble
and link a program before you can execute it. However, attempting to assemble the code by
hand would take far longer than the small amount of time that the assembler takes to
perform the conversion for you. </font></p>

<p><font face="Arial" size="2">There is another disadvantage to learning assembly
language. An assembler like Microsoft's Macro Assembler (MASM) provides a large number of
features for assembly language programmers. Although learning about these features takes a
fair amount of time, they are so useful that it is well worth the effort.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING1-4"></a>8.0 Chapter
    Overview</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="0"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">Like Chapter Six, much of the information in this chapter
is reference material. Like any reference section, some knowledge is essential, other
material is handy, but optional, and some material you may never use while writing
programs. The following list outlines the information in this text. A &quot;*&quot; symbol
marks the essential material. The &quot;o&quot; symbol marks the optional and lesser used
subjects.</font></p>

<p><font face="Arial" size="2">* Assembly language statement source format</font></p>

<p><font face="Arial" size="2">o The location counter</font></p>

<p><font face="Arial" size="2">* Symbols and identifiers</font></p>

<p><font face="Arial" size="2">* Constants</font></p>

<p><font face="Arial" size="2">* Procedure declarations</font></p>

<p><font face="Arial" size="2">o Segments in an assembly language program</font></p>

<p><font face="Arial" size="2">* Variables</font></p>

<p><font face="Arial" size="2">* Symbol types</font></p>

<p><font face="Arial" size="2">* Address expressions (later subsections contain advanced
material)</font></p>

<p><font face="Arial" size="2">o Conditional assembly</font></p>

<p><font face="Arial" size="2">o Macros</font></p>

<p><font face="Arial" size="2">o Listing directives</font></p>

<p><font face="Arial" size="2">o Separate assembly</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING1-19"></a>8.1
    Assembly Language Statements</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">Assembly language statements in a source file use the
following format: </font></p>

<pre><font face="Courier New" size="2">{Label}         {Mnemonic       {Operand}}      {;Comment} </font></pre>

<p><font face="Arial" size="2">Each entity above is a field. The four fields above are the
label field, the mnemonic field, the operand field, and the comment field. </font></p>

<p><font face="Arial" size="2">The label field is (usually) an optional field containing a
symbolic label for the current statement. Labels are used in assembly language, just as in
HLLs, to mark lines as the targets of GOTOs (jumps). You can also specify variable names,
procedure names, and other entities using symbolic labels. Most of the time the label
field is optional, meaning a label need be present only if you want a label on that
particular line. Some mnemonics, however, require a label, others do not allow one. In
general, you should always begin your labels in column one (this makes your programs
easier to read). </font></p>

<p><font face="Arial" size="2">A mnemonic is an instruction name (e.g., <code>mov</code>, <code>add</code>,
etc.). The word mnemonic means memory aid. <code>mov </code>is much easier to remember
than the binary equivalent of the <code>mov </code>instruction! The braces denote that
this item is optional. Note, however, that you cannot have an operand without a mnemonic. </font></p>

<p><font face="Arial" size="2">The mnemonic field contains an assembler instruction.
Instructions are divided into three classes: 80x86 machine instructions, assembler
directives, and pseudo opcodes. 80x86 instructions, of course, are assembler mnemonics
that correspond to the actual 80x86 instructions introduced in Chapter Six. </font></p>

<p><font face="Arial" size="2">Assembler directives are special instructions that provide
information to the assembler but do not generate any code. Examples include the <code>segment
</code>directive, <code>equ</code>, <code>assume</code>, and <code>end</code>. These
mnemonics are not valid 80x86 instructions. They are messages to the assembler, nothing
else. </font></p>

<p><font face="Arial" size="2">A pseudo-opcode is a message to the assembler, just like an
assembler directive, however a pseudo-opcode will emit object code bytes. Examples of
pseudo-opcodes include <code>byte</code>, <code>word</code>, <code>dword</code>, <code>qword</code>,
and <code>tbyte</code>. These instructions emit the bytes of data specified by their
operands but they are not true 80X86 machine instructions. </font></p>

<p><font face="Arial" size="2">The operand field contains the operands, or parameters, for
the instruction specified in the mnemonic field. Operands never appear on lines by
themselves. The type and number of operands (zero, one, two, or more) depend entirely on
the specific instruction. </font></p>

<p><font face="Arial" size="2">The comment field allows you to annotate each line of
source code in your program. Note that the comment field always begins with a semicolon.
When the assembler is processing a line of text, it completely ignores everything on the
source line following a semicolon. </font></p>

<p><font face="Arial" size="2">Each assembly language statement appears on its own line in
the source file. You cannot have multiple assembly language statements on a single line.
On the other hand, since all the fields in an assembly language statement are optional,
blank lines are fine. You can use blank lines anywhere in your source file. Blank lines
are useful for spacing out certain sections of code, making them easier to read. </font></p>

<p><font face="Arial" size="2">The Microsoft Macro Assembler is a free form assembler. The
various fields of an assembly language statement may appear in any column (as long as they
appear in the proper order). Any number of spaces or tabs can separate the various fields
in the statement. To the assembler, the following two code sequences are identical:</font></p>

<p>______________________________________________________ </p>

<pre>                mov     ax, 0
                mov     bx, ax
                add     ax, dx
                mov     cx, ax</pre>

<p>______________________________________________________ </p>

<pre>		mov	ax, 0
	        mov	bx, ax
		add	ax, dx
		mov	cx, ax</pre>

<p>______________________________________________________</p>

<p><font face="Arial" size="2">The first code sequence is much easier to read than the
second (if you don't think so, perhaps you should go see a doctor!). With respect to
readability, the judicial use of spacing within your program can make all the difference
in the world. </font></p>

<p><font face="Arial" size="2">Placing the labels in column one, the mnemonics in column
17 (two tabstops), the operand field in column 25 (the third tabstop), and the comments
out around column 41 or 49 (five or six tabstops) produces the best looking listings.
Assembly language programs are hard enough to read as it is. Formatting your listings to
help make them easier to read will make them much easier to maintain. </font></p>

<p><font face="Arial" size="2">You may have a comment on the line by itself. In such a
case, place the semicolon in column one and use the entire line for the comment, examples:
</font></p>

<pre><font face="Courier New" size="2">; The following section of code positions the cursor to the upper
; left hand position on the screen:

                mov     X, 0
                mov     Y, 0

; Now clear from the current cursor position to the end of the
; screen to clear the video display:

;               etc.</font></pre>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3">8.2 The Location Counter</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">Recall that all addresses in the 80x86's memory space
consist of a segment address and an offset within that segment. The assembler, in the
process of converting your source file into object code, needs to keep track of offsets
within the current segment. The location counter is an assembler variable that handles
this. </font></p>

<p><font face="Arial" size="2">Whenever you create a segment in your assembly language
source file (see segments later in this chapter), the assembler associates the current
location counter value with it. The location counter contains the current offset into the
segment. Initially (when the assembler first encounters a segment) the location counter is
set to zero. When encountering instructions or pseudo-opcodes, MASM increments the
location counter for each byte written to the object code file. For example, MASM
increments the location counter by two after encountering <code>mov ax, bx</code> since
this instruction is two bytes long. </font></p>

<p><font face="Arial" size="2">The value of the location counter varies throughout the
assembly process. It changes for each line of code in your program that emits object code.
We will use the term location counter to mean the value of the location counter at a
particular statement before generating any code. Consider the following assembly language
statements: </font></p>

<pre><font face="Courier New" size="2">0 :             or      ah, 9
3 :             and     ah, 0c9h 
6 :             xor     ah, 40h 
9 :             pop     cx 
A :             mov     al, cl 
C :             pop     bp 
D :             pop     cx 
E :             pop     dx
F :             pop     ds 
10:             ret</font></pre>

<p><font face="Arial" size="2">The <code>or</code>, <code>and</code>, and <code>xor </code>instructions
are all three bytes long; the <code>mov </code>instruction is two bytes long; the
remaining instructions are all one byte long. If these instructions appear at the
beginning of a segment, the location counter would be the same as the numbers that appear
immediately to the left of each instruction above. For example, the <code>or </code>instruction
above begins at offset zero. Since the <code>or </code>instruction is three bytes long,
the next instruction (<code>and</code>) follows at offset three. Likewise, <code>and </code>is
three bytes long, so <code>xor </code>follows at offset six, etc.. </font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING1-74"></a>8.3 Symbols</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">Consider the <code>jmp </code>instruction for a moment.
This instruction takes the form: </font></p>

<pre><font face="Courier New" size="2">                jmp   target</font></pre>

<p><font face="Arial" size="2">Target is the destination address. Imagine how painful it
would be if you had to actually specify the target memory address as a numeric value. If
you've ever programmed in BASIC (where line numbers are the same thing as statement
labels) you've experienced about 10% of the trouble you would have in assembly language if
you had to specify the target of a <code>jmp </code>by an address. </font></p>

<p><font face="Arial" size="2">To illustrate, suppose you wanted to jump to some group of
instructions you've yet to write. What is the address of the target instruction? How can
you tell until you've written every instruction before the target instruction? What
happens if you change the program (remember, inserting and deleting instructions will
cause the location counter values for all the following instructions within that segment
to change). Fortunately, all these problems are of concern only to machine language
programmers. Assembly language programmers can deal with addresses in a much more
reasonable fashion - by using symbolic addresses. </font></p>

<p><font face="Arial" size="2">A symbol, identifier, or label , is a name associated with
some particular value. This value can be an offset within a segment, a constant, a string,
a segment address, an offset within a record, or even an operand for an instruction. In
any case, a label provides us with the ability to represent some otherwise
incomprehensible value with a familiar, mnemonic, name. </font></p>

<p><font face="Arial" size="2">A symbolic name consists of a sequence of letters, digits,
and special characters, with the following restrictions: </font>

<ul>
  <li><font face="Arial" size="2">A symbol cannot begin with a numeric digit. </font></li>
  <li><font face="Arial" size="2">A name can have any combination of upper and lower case
    alphabetic characters. The assembler treats upper and lower case equivalently. </font></li>
  <li><font face="Arial" size="2">A symbol may contain any number of characters, however only
    the first 31 are used. The assembler ignores all characters beyond the 31st. </font></li>
  <li><font face="Arial" size="2">The _, $, ?, and @ symbols may appear anywhere within a
    symbol. However, $ and ? are special symbols; you cannot create a symbol made up solely of
    these two characters. </font></li>
  <li><font face="Arial" size="2">A symbol cannot match any name that is a reserved symbol.
    The following symbols are reserved: </font></li>
</ul>

<pre><font face="Courier New" size="2">%out            .186                    .286                    .286P
.287            .386                    .386P                   .387
.486            .486P                   .8086                   .8087
.ALPHA          .BREAK                  .CODE                   .CONST
.CREF           .DATA                   .DATA?                  .DOSSEG
.ELSE           .ELSEIF                 .ENDIF                  .ENDW
.ERR            .ERR1                   .ERR2                   .ERRB
.ERRDEF         .ERRDIF                 .ERRDIFI                .ERRE
.ERRIDN         .ERRIDNI                .ERRNB                  .ERRNDEF
.ERRNZ          .EXIT                   .FARDATA                .FARDATA?
.IF             .LALL                   .LFCOND                 .LIST
.LISTALL        .LISTIF                 .LISTMACRO              .LISTMACROALL
.MODEL          .MSFLOAT                .NO87                   .NOCREF
.NOLIST         .NOLISTIF               .NOLISTMACRO            .RADIX
.REPEAT         .UNTIL                  .SALL                   .SEQ
.SFCOND         .STACK                  .STARTUP                .TFCOND
.UNTIL          .UNTILCXZ               .WHILE                  .XALL
.XCREF          .XLIST                  ALIGN                   ASSUME
BYTE            CATSTR                  COMM                    COMMENT
DB              DD                      DF                      DOSSEG
DQ              DT                      DW                      DWORD
ECHO            ELSE                    ELSEIF                  ELSEIF1
ELSEIF2         ELSEIFB                 ELSEIFDEF               ELSEIFDEF
ELSEIFE         ELSEIFIDN               ELSEIFNB                ELSEIFNDEF
END             ENDIF                   ENDM                    ENDP
ENDS            EQU                     EVEN                    EXITM
EXTERN          EXTRN                   EXTERNDEF               FOR
FORC            FWORD                   GOTO                    GROUP
IF              IF1                     IF2                     IFB
IFDEF           IFDIF                   IFDIFI                  IFE
IFIDN           IFIDNI                  IFNB                    IFNDEF
INCLUDE         INCLUDELIB              INSTR                   INVOKE
IRP             IRPC                    LABEL                   LOCAL
MACRO           NAME                    OPTION                  ORG
PAGE            POPCONTEXT              PROC                    PROTO
PUBLIC          PURGE                   PUSHCONTEXT             QWORD
REAL4           REAL8                   REAL10                  RECORD
REPEAT          REPT                    SBYTE                   SDWORD
SEGMENT         SIZESTR                 STRUC                   STRUCT
SUBSTR          SUBTITLE                SUBTTL                  SWORD
TBYTE           TEXTEQU                 TITLE                   TYPEDEF
UNION           WHILE                   WORD</font></pre>

<p><font face="Arial" size="2">In addition, all valid 80x86 instruction names and register
names are reserved as well. Note that this list applies to Microsoft's Macro Assembler
version 6.0. Earlier versions of the assembler have fewer reserved words. Later versions
may have more.</font></p>

<p><font face="Arial" size="2">Some examples of valid symbols include: </font></p>

<pre><font face="Courier New" size="2">        L1              Bletch          RightHere
        Right_Here      Item1           __Special
        $1234           @Home           $_@1 
        Dollar$         WhereAmI?       @1234</font></pre>

<p><font face="Arial" size="2">$1234 and @1234 are perfectly valid, strange though they
may seem.</font></p>

<p><font face="Arial" size="2">Some examples of illegal symbols include: </font></p>

<pre><font face="Courier New" size="2">1TooMany        - Begins with a digit. 
Hello.There     - Contains a period in the middle of the symbol. 
$               - Cannot have $ or ? by itself. 
LABEL           - Assembler reserved word. 
Right Here      - Symbols cannot contain spaces.
Hi,There        - or other special symbols besides _, ?, $, and @.</font></pre>

<p><font face="Arial" size="2">Symbols, as mentioned previously, can be assigned numeric
values (such as location counter values), strings, or even whole operands. To keep things
straightened out, the assembler assigns a type to each symbol. Examples of types include
near, far, byte, word, double word, quad word, text, and strings. How you declare labels
of a certain type is the subject of much of the rest of this chapter. For now, simply note
that the assembler always assigns some type to a label and will tend to complain if you
try to use a label at some point where it does not allow that type of label.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING1-148"></a>8.4
    Literal Constants </font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">The Microsoft Macro Assembler (MASM) is capable of
processing five different types of constants: integers, packed binary coded decimal
integers, real numbers, strings, and text. In this chapter we'll consider integers, reals,
strings, and text only. For more information about packed BCD integers please consult the
Microsoft Macro Assembler Programmer's Guide.</font></p>

<p><font face="Arial" size="2">A literal constant is one whose value is implicit from the
characters that make up the constant. Examples of literal constants include: </font>

<ul>
  <li><font face="Arial" size="2">123 </font></li>
  <li><font face="Arial" size="2">3.14159 </font></li>
  <li><font face="Arial" size="2">&quot;Literal String Constant&quot; </font></li>
  <li><font face="Arial" size="2">0FABCh </font></li>
  <li><font face="Arial" size="2">'A' </font></li>
  <li><font face="Arial" size="2">&lt;Text Constant&gt; </font></li>
</ul>

<p><font face="Arial" size="2">Except for the last example above, most of these literal
constants should be reasonably familiar to anyone who has written a program in a high
level language like Pascal or C++. Text constants are special forms of strings that allow
textual substitution during assembly.</font></p>

<p><font face="Arial" size="2">A literal constant's representation corresponds to what we
would normally expect for its &quot;real world value.&quot; Literal constants are also
known as non symbolic constants since they use the value's actual representation, rather
than some symbolic name, within your program. MASM also lets you define symbolic, or
manifest, constants in a program, but more on that later.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING1-160"></a>8.4.1 Integer Constants</font></strong></p>

<p><font face="Arial" size="2">An integer constant is a numeric value that can be
specified in binary, decimal, or hexadecimal. The choice of the base (or radix) is up to
you. The following table shows the legal digits for each radix: </font></p>
<div align="center"><center>

<table BORDER="1" bordercolor="#C0C0C0" width="30%" cellspacing="0" cellpadding="0">
  <caption><strong><font face="Arial" size="2">Digits Used With Each Radix</font></strong></caption>
  <tr>
    <th bgcolor="#F0F0F0"><font face="Arial" size="2">Name</font></th>
    <th bgcolor="#F0F0F0" align="center"><font face="Arial" size="2">Base</font></th>
    <th bgcolor="#F0F0F0"><font face="Arial" size="2">Valid Digits</font></th>
  </tr>
  <tr>
    <td><font face="Arial" size="2">Binary</font></td>
    <td align="center"><font face="Arial" size="2">2</font></td>
    <td><font face="Arial" size="2">0 1</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">Decimal</font></td>
    <td align="center"><font face="Arial" size="2">10</font></td>
    <td><font face="Arial" size="2">0 1 2 3 4 5 6 7 8 9</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">Hexadecimal</font></td>
    <td align="center"><font face="Arial" size="2">16</font></td>
    <td><font face="Arial" size="2">0 1 2 3 4 5 6 7 8 9 A B C D E F</font></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">To differentiate between numbers in the various bases, you
use a suffix character. If you terminate a number with a &quot;b&quot; or &quot;B&quot;,
then MASM assumes that it is a binary number. If it contains any digits other than zero or
one the assembler will generate an error. If the suffix is &quot;t&quot;, &quot;T&quot;,
&quot;d&quot; or &quot;D&quot;, then the assembler assumes that the number is a decimal
(base 10) value. A suffix of &quot;h&quot; or &quot;H&quot; will select the hexadecimal
radix.</font></p>

<p><font face="Arial" size="2">All integer constants must begin with a decimal digit,
including hexadecimal constants. To represent the value &quot;FDED&quot; you must specify
0FDEDh. The leading decimal digit is required by the assembler so that it can
differentiate between symbols and numeric constants; remember, &quot;FDEDh&quot; is a
perfectly valid symbol to the Microsoft Macro Assembler. </font></p>

<p><font face="Arial" size="2">Examples: </font></p>

<pre><font face="Courier New" size="2">                0F000h          12345d          0110010100b
                1234h           100h            08h</font></pre>

<p><font face="Arial" size="2">If you do not specify a suffix after your numeric
constants, the assembler uses the current default radix. Initially, the default radix is
decimal. Therefore, you can usually specify decimal values without the trailing
&quot;D&quot; character. The <code>radix </code>assembler directive can be used to change
the default radix to some other base. The <code>.radix </code>instruction takes the
following form: </font></p>

<pre><font face="Courier New" size="2">                .radix  base    ;Optional comment</font></pre>

<p><font face="Arial" size="2">Base is a decimal value between 2 and 16. </font></p>

<p><font face="Arial" size="2">The .<code>radix</code> statement takes effect as soon as
MASM encounters it in the source file. All the statements before the .<code>radix</code>
statement will use the previous default base for numeric constants. By sprinkling multiple
.<code>radix</code> instructions throughout your source file, you can switch the default
base amongst several values depending upon what's most convenient at each point in your
program. </font></p>

<p><font face="Arial" size="2">Generally, decimal is fine as the default base so the .<code>radix</code>
instruction doesn't get used much. However, faced with entering a gigantic table of
hexadecimal values, you can save a lot of typing by temporarily switching to base 16
before the table and switching back to decimal after the table. Note: if the default radix
is hexadecimal, you should use the &quot;T&quot; suffix to denote decimal values since
MASM will confuse the &quot;D&quot; suffix with a hexadecimal digit.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING1-175"></a>8.4.2 String Constants</font></strong></p>

<p><font face="Arial" size="2">A string constant is a sequence of characters surrounded by
apostrophes or quotation marks. </font></p>

<p><font face="Arial" size="2">Examples: </font></p>

<pre><font face="Courier New" size="2">                &quot;This is a string&quot;
                 'So is this'</font></pre>

<p><font face="Arial" size="2">You may freely place apostrophes inside string constants
enclosed by quotation marks and vice versa. If you want to place an apostrophe inside a
string delimited by apostrophes, you must place a pair of apostrophes next to each other
in the string, e.g., </font></p>

<pre><font face="Courier New" size="2">                'Doesn''t this look weird?' </font></pre>

<p><font face="Arial" size="2">Quotation marks appearing within a string delimited by
quotes must also be doubled up, e.g., </font></p>

<pre><font face="Courier New" size="2">&quot;Microsoft claims &quot;&quot;Our software is very fast.&quot;&quot;  Do you believe them?&quot;</font></pre>

<p><font face="Arial" size="2">Although you can double up apostrophes or quotes as shown
in the examples above, the easiest way to include these characters in a string is to use
the other character as the string delimiter: </font></p>

<pre><font face="Courier New" size="2">                &quot;Doesn't this look weird?&quot;
'Microsoft claims &quot;Our software is very fast.&quot; Do you believe them?'</font></pre>

<p><font face="Arial" size="2">The only time it would be absolutely necessary to double up
quotes or apostrophes in a string is if that string contained both symbols. This rarely
happens in real programs.</font></p>

<p><font face="Arial" size="2">Like the C and C++ programming languages, there is a subtle
difference between a character value and a string value. A single character (that is, a
string of length one) may appear anywhere MASM allows an integer constant or a string. If
you specify a character constant where MASM expects an integer constant, MASM uses the
ASCII code of that character as the integer value. Strings (whose length is greater than
one) are allowed only within certain contexts.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING1-193"></a>8.4.3 Real Constants</font></strong></p>

<p><font face="Arial" size="2">Within certain contexts, you can use floating point
constants. MASM allows you to express floating point constants in one of two forms:
decimal notation or scientific notation. These forms are quite similar to the format for
real numbers that Pascal, C, and other HLLs use. </font></p>

<p><font face="Arial" size="2">The decimal form is just a sequence of digits containing a
decimal point in some position of the number: </font></p>

<pre><font face="Courier New" size="2">        1.0     3.14159         625.25          -128.0          0.5</font></pre>

<p><font face="Arial" size="2">Scientific notation is also identical to the form used by
various HLLs: </font></p>

<pre><font face="Courier New" size="2">        1e5     1.567e-2                -6.02e-10               5.34e+12</font></pre>

<p><font face="Arial" size="2">The exact range of precision of the numbers depend on your
particular floating point package. However, MASM generally emits binary data for the above
constants that is compatible with the 80x87 numeric coprocessors. This form corresponds to
the numeric format specified by the IEEE standard for floating point values. In
particular, the constant 1.0 is not the binary equivalent of the integer one.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING1-202"></a>8.4.4 Text Constants</font></strong></p>

<p><font face="Arial" size="2">Text constants are not the same thing as string constants.
A textual constant substitutes verbatim during the assembly process. For example, the
characters <code>5[bx] </code>could be a textual constant associated with the symbol VAR1.
During assembly, an instruction of the form <code>mov ax, VAR1 </code>would be converted
to the instruction <code>mov ax, 5[bx]</code>. </font></p>

<p><font face="Arial" size="2">Textual equates are quite useful in MASM because MASM often
insists on long strings of text for some simple assembly language operands. Using text
equates allows you to simplify such operands by substituting some string of text for a
single identifier in a statement.</font></p>

<p><font face="Arial" size="2">A text constant consists of a sequence of characters
surrounded by the &quot;&lt;&quot; and &quot;&gt;&quot; symbols. For example the text
constant <code>5[bx] </code>would normally be written as <code>&lt;5[bx]&gt;</code>. When
the text substitution occurs, MASM strips the delimiting &quot;&lt;&quot; and
&quot;&gt;&quot; characters.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING1-206"></a>8.5
    Declaring Manifest Constants Using Equates</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">A manifest constant is a symbol name that represents some
fixed quantity during the assembly process. That is, it is a symbolic name that represents
some value. Equates are the mechanism MASM uses to declare symbolic constants. Equates
take three basic forms: </font></p>

<pre><font face="Courier New" size="2">symbol          equ     expression
symbol          =       expression
symbol          textequ expression</font></pre>

<p><font face="Arial" size="2">The expression operand is typically a numeric expression or
a text string. The symbol is given the value and type of the expression. The <code>equ</code>
and &quot;<code>=</code>&quot; directives have been with MASM since the beginning.
Microsoft added the <code>textequ</code> directive starting with MASM 6.0. </font></p>

<p><font face="Arial" size="2">The purpose of the &quot;=&quot; directive is to define
symbols that have an integer (or single character) quantity associated with them. This
directive does not allow real, string, or text operands. This is the primary directive you
should use to create numeric symbolic constants in your programs. Some examples: </font></p>

<pre><font face="Courier New" size="2">NumElements     =       16
                 .
                 .
                 .
Array           byte    NumElements dup (?)
                 .
                 .
                 .
                mov     cx, NumElements
                mov     bx, 0
ClrLoop:                mov     Array[bx], 0
                inc     bx
                loop    ClrLoop</font></pre>

<p><font face="Arial" size="2">The <code>textequ</code> directive defines a text
substitution symbol. The expression in the operand field must be a text constant delimited
with the &quot;&lt;&quot; and &quot;&gt;&quot; symbols. Whenever MASM encounters the
symbol within a statement, it substitutes the text in the operand field for the symbol.
Programmers typically use this equate to save typing or to make some code more readable: </font></p>

<pre><font face="Courier New" size="2">Count           textequ &lt;6[bp]&gt;
DataPtr         textequ &lt;8[bp]&gt;
                 .
                 .
                 .
                les     bx, DataPtr     ;Same as les bx, 8[bp]
                mov     cx, Count       ;Same as mov cx, 6[bp]
                mov     al, 0
ClrLp:          mov     es:[bx], al
                inc     bx
                loop    ClrLp</font></pre>

<p><font face="Arial" size="2">Note that it is perfectly legal to equate a symbol to a
blank operand using an equate like the following: </font></p>

<pre><font face="Courier New" size="2">BlankEqu        textequ &lt;&gt;</font></pre>

<p><font face="Arial" size="2">The purpose of such an equate will become clear in the
sections on conditional assembly and macros.</font></p>

<p><font face="Arial" size="2">The <code>equ</code> directive provides almost a superset
of the capabilities of the &quot;=&quot; and <code>textequ</code> directives. It allows
operands that are numeric, text, or string literal constants. The following are all legal
uses of the equ directive: </font></p>

<pre><font face="Courier New" size="2">One             equ     1
Minus1          equ     -1
TryAgain        equ     'Y'
StringEqu       equ     &quot;Hello there&quot;
TxtEqu          equ     &lt;4[si]&gt;
                 .
                 .
                 .
HTString        byte    StringEqu       ;Same as HTString equ &quot;Hello there&quot;
                 .
                 .
                 .
                mov     ax, TxtEqu      ;Same as mov ax, 4[si]
                 .
                 .
                 .
                mov     bl, One         ;Same as mov bl, 1
                cmp     al, TryAgain    ;Same as cmp al, 'Y'</font></pre>

<p><font face="Arial" size="2">Manifest constants you declare with equates help you
parameterize a program. If you use the same value, string, or text, multiple times within
a program, using a symbolic equate will make it very easy to change that value in future
modifications to the program. Consider the following example: </font></p>

<pre><font face="Courier New" size="2">Array           byte    16 dup (?)
                 .
                 .
                 .
                mov     cx, 16
                mov     bx, 0
ClrLoop:        mov     Array[bx], 0
                inc     bx
                loop    ClrLoop</font></pre>

<p><font face="Arial" size="2">If you decide you want Array to have 32 elements rather
than 16, you will need to search throughout your program an locate every reference to this
data and adjust the literal constants accordingly. Then there is the possibility that you
missed modifying some particular section of code, introducing a bug into your program. On
the other hand, if you use the <code>NumElements</code> symbolic constant shown earlier,
you would only have to change a single statement in your program, reassemble it, and you
would be in business; MASM would automatically update all references using <code>NumElements</code>.</font></p>

<p><font face="Arial" size="2">MASM lets you redefine symbols declared with the
&quot;=&quot; directive. That is, the following is perfectly legal: </font></p>

<pre><font face="Courier New" size="2">SomeSymbol      =       0
                .
                .
                .
SomeSymbol      =       1</font></pre>

<p><font face="Arial" size="2">Since you can change the value of a constant in the
program, the symbol's scope (where the symbol has a particular value) becomes important.
If you could not redefine a symbol, one would expect the symbol to have that constant
value everywhere in the program. Given that you can redefine a constant, a symbol's scope
cannot be the entire program. The solution MASM uses is the obvious one, a manifest
constant's scope is from the point it is defined to the point it is redefined. This has
one important ramification - you must declare all manifest constants with the <code>&quot;=&quot;
</code>directive before you use that constant. Of course, once you redefine a symbolic
constant, the previous value of that constant is forgotten. Note that you cannot redefine
symbols you declare with the <code>textequ</code> or <code>equ</code> directives.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING1-285"></a>8.6
    Processor Directives</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">By default, MASM will only assemble instructions that are
available on all members of the 80x86 family. In particular, this means it will not
assemble instructions that are not available on the 8086 and 8088 microprocessors. By
generating an error for non-8086 instructions, MASM prevents the accidental use of
instructions that are not available on various processors. This is great unless, of
course, you actually want to use those instructions available on processors beyond the
8086 and 8088. The processor directives let you enable the assembly of instructions
available on later processors.</font></p>

<p><font face="Arial" size="2">The processor directives are</font></p>

<p><font face="Arial" size="2">.8086 .8087 .186 .286 .287</font></p>

<p><font face="Arial" size="2">.286P .386 .387 .386P .486</font></p>

<p><font face="Arial" size="2">.486P .586 .586P</font></p>

<p><font face="Arial" size="2">None of these directives accept any operands.</font></p>

<p><font face="Arial" size="2">The processor directives enable all instructions available
on a given processor. Since the 80x86 family is upwards compatible, specifying a
particular processor directive enables all instructions on that processor and all earlier
processors as well.</font></p>

<p><font face="Arial" size="2">The .<code>8087</code>, .<code>287</code>, and .<code>387</code>
directives activate the floating point instruction set for the given floating point
coprocessors. However, the .<code>8086</code> directive also enables the 8087 instruction
set; likewise, .<code>286</code> enables the 80287 instruction set and .<code>386</code>
enables the 80387 floating point instruction set. About the only purpose for these FPU
(floating point unit) directives is to allow 80287 instructions with the 8086 or 80186
instruction set or 80387 instruction with the 8086, 80186, or 80286 instruction set.</font></p>

<p><font face="Arial" size="2">The processor directives ending with a &quot;P&quot; allow
assembly of privileged mode instructions. Privileged mode instructions are only useful to
those writing operating systems, certain device drivers, and other advanced system
routines. Since this text does not discuss privileged mode instructions, there is little
need to discuss these privileged mode directives further.</font></p>

<p><font face="Arial" size="2">The 80386 and later processors support two types of
segments when operating in protected mode - 16 bit segments and 32 bit segments. In real
mode, these processors support only 16 bit segments. The assembler must generate subtly
different opcodes for 16 and 32 bit segments. If you've specified a 32 bit processor using
<code>.386, .486,</code> or <code>.586,</code> MASM generates instructions for 32 bit
segments by default. If you attempt to run such code in real mode under MS-DOS, you will
probably crash the system. There are two solutions to this problem. The first is to
specify use16 as an operand to each segment you create in your program. The other solution
is slightly more practical, simply put the following statement after the 32 bit processor
directive: </font></p>

<pre><font face="Courier New" size="2">                option  segment:use16</font></pre>

<p><font face="Arial" size="2">This directive tells MASM to generate 16 bit segments by
default, rather than 32 bit segments. </font></p>

<p><font face="Arial" size="2">Note that MASM does not require an 80486 or Pentium
processor if you specify the <code>.486</code> or <code>.586 </code>directives. The
assembler itself is written in 80386 code so you only need an 80386 processor to assemble
any program with MASM. Of course, if you use 80486 or Pentium processor specific
instructions, you will need an 80486 or Pentium processor to run the assembled code.</font></p>

<p><font face="Arial" size="2">You can selectively enable or disable various instruction
sets throughout your program. For example, you can turn on 80386 instructions for several
lines of code and then return back to 8086 only instructions. The following code sequence
demonstrates this: </font></p>

<pre><font face="Courier New" size="2">                .386            ;Begin using 80386 instructions
                 .
                 .              ;This code can have 80386 instrs.
                 .
                .8086           ;Return back to 8086-only instr set.
                 .
                 .              ;This code can only have 8086 instrs.
                 .</font></pre>

<p><font face="Arial" size="2">It is possible to write a routine that detects, at
run-time, what processor a program is actually running on. Therefore, you can detect an
80386 processor and use 80386 instructions. If you do not detect an 80386 processor, you
can stick with 8086 instructions. By selectively turning 80386 instructions on in those
sections of your program that executes if an 80386 processor is present, you can take
advantage of the additional instructions. Likewise, by turning off the 80386 instruction
set in other sections of your program, you can prevent the inadvertent use of 80386
instructions in the 8086-only portion of the program.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING1-311"></a>8.7
    Procedures</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">Unlike HLLs, MASM doesn't enforce strict rules on exactly
what constitutes a procedure. You can call a procedure at any address in memory. The first
<code>ret </code>instruction encountered along that execution path terminates the
procedure. Such expressive freedom, however, is often abused yielding programs that are
very hard to read and maintain. Therefore, MASM provides facilities to declare procedures
within your code. The basic mechanism for declaring a procedure is: </font></p>

<pre><font face="Courier New" size="2">procname        proc    {NEAR or FAR}

            &lt;statements&gt;

procname        endp</font></pre>

<p><font face="Arial" size="2">As you can see, the definition of a procedure looks similar
to that for a segment. One difference is that procname (that is the name of the procedure
you're defining) must be a unique identifier within your program. Your code calls this
procedure using this name, it wouldn't do to have another procedure by the same name; if
you did, how would the program determine which routine to call?</font></p>

<p><font face="Arial" size="2"><code>Proc </code>allows several different operands, though
we will only consider three: the single keyword <code>near</code>, the single keyword <code>far</code>,
or a blank operand field. MASM uses these operands to determine if you're calling this
procedure with a <code>near</code> or <code>far </code>call instruction. They also
determine which type of <code>ret </code>instruction MASM emits within the procedure.
Consider the following two procedures: </font></p>

<pre><font face="Courier New" size="2">NProc           proc    near
                mov     ax, 0
                ret
NProc           endp

FProc           proc    far
                mov     ax, 0FFFFH
                ret
FProc           endp</font></pre>

<p><font face="Arial" size="2">and: </font></p>

<pre><font face="Courier New" size="2">                call    NPROC
                call    FPROC</font></pre>

<p><font face="Arial" size="2">The assembler automatically generates a three-byte (near)
call for the first <code>call</code> instruction above because it knows that <code>NProc </code>is
a near procedure. It also generates a five-byte (far) <code>call</code> instruction for
the second <code>call</code> because <code>FProc </code>is a far procedure. Within the
procedures themselves, MASM automatically converts all <code>ret </code>instructions to
near or far returns depending on the type of routine. </font></p>

<p><font face="Arial" size="2">Note that if you do not terminate a <code>proc/endp </code>section
with a <code>ret </code>or some other transfer of control instruction and program flow
runs into the <code>endp </code>directive, execution will continue with the next
executable instruction following the <code>endp</code>. For example, consider the
following: </font></p>

<pre><font face="Courier New" size="2">Proc1           proc
                mov     ax, 0
Proc1           endp

Proc2           proc
                mov     bx, 0FFFFH
                ret
Proc2           endp</font></pre>

<p><font face="Arial" size="2">If you call <code>Proc1</code>, control will flow on into <code>Proc2</code>
starting with the<code> mov bx,0FFFFh</code> instruction. Unlike high level language
procedures, an assembly language procedure does not contain an implicit return instruction
before the <code>endp</code> directive. So always be aware of how the <code>proc/endp </code>directives
work. </font></p>

<p><font face="Arial" size="2">There is nothing special about procedure declarations.
They're a convenience provided by the assembler, nothing more. You could write assembly
language programs for the rest of your life and never use the <code>proc </code>and <code>endp
</code>directives. Doing so, however, would be poor programming practice. <code>Proc </code>and
<code>endp </code>are marvelous documentation features which, when properly used, can help
make your programs much easier to read and maintain.</font></p>

<p><font face="Arial" size="2">MASM versions 6.0 and later treat all statement labels
inside a procedure as local. That is, you cannot refer directly to those symbols outside
the procedure. For more details, see &quot;How to Give a Symbol a Particular Type&quot;. </font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="../Chapter_7/CH07-2.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="../Chapter_7/CH07-1.html">Chapter
    Seven</a></strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH08-2.html">Chapter Eight</a> (Part 2) </strong></font><a href="CH08-2.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Eight: MASM: Directives &amp;
Pseudo-Opcodes (Part 1)<br>
26 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_8/CH08-1.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:30 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
