<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_8/CH08-4.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:36 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER EIGHT: MASM: DIRECTIVES &amp; PSEUDO-OPCODES (Part 4)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING4"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH08-3.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH08-3.html">Chapter Eight</a> (Part 3)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH08-5.html">Chapter Eight</a> (Part 5) </strong></font><a href="CH08-5.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10" colspan="2"><a NAME="HEADING4-1"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0" colspan="2"><font face="Arial" size="4"><strong>CHAPTER
    EIGHT:<br>
    MASM: DIRECTIVES &amp; PSEUDO-OPCODES (Part 4)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10" colspan="2"></td>
  </tr>
  <tr>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING4-1"><b>8.9 </b>-
    The END Directive</a> <br>
    <a HREF="#HEADING4-4"><b>8.10 </b>- Variables</a> <br>
    <a HREF="#HEADING4-13"><b>8.11 </b>- Label Types</a> <br>
    <a HREF="#HEADING4-15"><b>8.11.1 </b>- How to Give a Symbol a Particular Type</a> <br>
    <a HREF="#HEADING4-42"><b>8.11.2 </b>- Label Values</a> </font></td>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING4-44"><b>8.11.3 </b>-
    Type Conflicts</a> <br>
    <a HREF="#HEADING4-69"><b>8.12 </b>- Address Expressions</a> <br>
    <a HREF="#HEADING4-83"><b>8.12.1 </b>- Symbol Types and Addressing Modes</a> <br>
    <a HREF="#HEADING4-101"><b>8.12.2 </b>- Arithmetic and Logical Operators</a> <br>
    <a HREF="#HEADING4-147"><b>8.12.3 </b>- Coercion</a> </font></td>
  </tr>
  <tr>
    <td width="100%" valign="top" colspan="2" nowrap height="20"></td>
  </tr>
  <tr>
    <td width="100%" valign="top" colspan="2"><strong><font face="Arial" size="3">8.9 The END
    Directive</font></strong></td>
  </tr>
  <tr>
    <td width="100%" valign="top" colspan="2" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">The <code>end</code> directive terminates an assembly
language source file. In addition to telling MASM that it has reached the end of an
assembly language source file, the <code>end</code> directive's optional operand tells
MS-DOS where to transfer control when the program begins execution; that is, you specify
the name of the main procedure as an operand to the <code>end</code> directive. If the <code>end</code>
directive's operand is not present, MS-DOS will begin execution starting at the first byte
in the .exe file. Since it is often inconvenient to guarantee that your main program
begins with the first byte of object code in the .exe file, most programs specify a
starting location as the operand to the <code>end</code> directive. If you are using the
SHELL.ASM file as a skeleton for your assembly language programs, you will notice that the
<code>end</code> directive already specifies the procedure <code>main</code> as the
starting point for the program.</font></p>

<p><font face="Arial" size="2">If you are using separate assembly and you're linking
together several different object code files (see &quot;Managing Large Programs&quot;),
only one module can have a main program. Likewise, only one module should specify the
starting location of the program. If you specify more than one starting location, you will
confuse the linker and it will generate an error.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING4-4"></a>8.10
    Variables</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">Global variable declarations use the <code>byte/sbyte/db,
word/sword/dw, dword/sdword/dd, qword/dq, </code>and<code> tbyte/dt </code>pseudo-opcodes.
Although you can place your variables in any segment (including the code segment), most
beginning assembly language programmers place all their global variables in a single data
segment.</font></p>

<p><font face="Arial" size="2">A typical variable declaration takes the form: </font></p>

<pre><font face="Courier New" size="2">varname         byte    initial_value</font></pre>

<p><font face="Arial" size="2"><code>Varname</code> is the name of the variable you're
declaring and <code>initial_value </code>is the initial value you want that variable to
have when the program begins execution. &quot;?&quot; is a special initial value. It means
that you don't want to give a variable an initial value. When DOS loads a program
containing such a variable into memory, it does not initialize this variable to any
particular value. </font></p>

<p><font face="Arial" size="2">The declaration above reserves storage for a single byte.
This could be changed to any other variable type by simply changing the <code>byte </code>mnemonic
to some other appropriate pseudo-opcode. </font></p>

<p><font face="Arial" size="2">For the most part, this text will assume that you declare
all variables in a data segment, that is, a segment that the 80x86's <code>ds</code>
register will point at. In particular, most of the programs herein will place all
variables in the <code>DSEG</code> segment (<code>CSEG</code> is for code, <code>DSEG</code>
is for data, and <code>SSEG</code> is for the stack). See the SHELL.ASM program in Chaper
Four for more details on these segments.</font></p>

<p><font face="Arial" size="2">Since Chapter Five covers the declaration of variables,
data types, structures, arrays, and pointers in depth, this chapter will not waste any
more time discussing this subject. Refer to Chapter Five for more details.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING4-13"></a>8.11 Label
    Types</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">One unusual feature of Intel syntax assemblers (like MASM)
is that they are strongly typed. A strongly typed assembler associates a certain type with
symbols declared appearing in the source file and will generate a warning or an error
message if you attempt to use that symbol in a context that doesn't allow its particular
type. Although unusual in an assembler, most high level languages apply certain typing
rules to symbols declared in the source file. Pascal, of course, is famous for being a
strongly typed language. You cannot, in Pascal, assign a string to a numeric variable or
attempt to assign an integer value to a procedure label. Intel, in designing the syntax
for 8086 assembly language, decided that all the reasons for using a strongly typed
language apply to assembly language as well as Pascal. Therefore, standard Intel syntax
80x86 assemblers, like MASM, impose certain type restrictions on the use of symbols within
your assembly language programs.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING4-15"></a>8.11.1 How to Give a
Symbol a Particular Type</font></strong></p>

<p><font face="Arial" size="2">Symbols, in an 80x86 assembly language program, may be one
of eight different primitive types: byte, word, dword, qword, tbyte, near, far, and abs
(constant). Anytime you define a label with the <code>byte, word, dword, qword,</code> or <code>tbyte
</code>pseudo-opcodes, MASM associates the type of that pseudo-opcode with the label. For
example, the following variable declaration will create a symbol of type byte: </font></p>

<pre><font face="Courier New" size="2">BVar            byte    ?</font></pre>

<p><font face="Arial" size="2">Likewise, the following defines a dword symbol: </font></p>

<pre><font face="Courier New" size="2">DWVar           dword   ?</font></pre>

<p><font face="Arial" size="2">Variable types are not limited to the primitive types built
into MASM. If you create your own types using the <code>typedef</code> or <code>struct</code>
directives MASM will associate those types with any associated variable declarations.</font></p>

<p><font face="Arial" size="2">You can define near symbols (also known as statement
labels) in a couple of different ways. First, all procedure symbols declared with the <code>proc
</code>directive (with either a blank operand field or <code>near </code>in the operand
field) are near symbols. Statement labels are also near symbols. A statement label takes
the following form: </font></p>

<pre><font face="Courier New" size="2"><i>label</i>:          instr</font></pre>

<p><font face="Arial" size="2"><code>Instr</code> represents an 80x86 instruction. Note
that a colon must follow the symbol. It is not part of the symbol, the colon informs the
assembler that this symbol is a statement label and should be treated as a near<code> </code>typed
symbol. </font></p>

<p><font face="Arial" size="2">Statement labels are often the targets of jump and loop
instructions. For example, consider the following code sequence: </font></p>

<pre><font face="Courier New" size="2">                mov     cx, 25
Loop1:          mov     ax, cx
                call    PrintInteger
                loop    Loop1</font></pre>

<p><font face="Arial" size="2">The <code>loop </code>instruction decrements the <code>cx </code>register
and transfers control to the instruction labelled by <code>Loop1</code> until <code>cx </code>becomes
zero. </font></p>

<p><font face="Arial" size="2">Inside a procedure, statement labels are local. That is,
the scope of statement labels inside a procedure are visible only to code inside that
procedure. If you want to make a symbol global to a procedure, place two colons after the
symbol name. In the example above, if you needed to refer to <code>Loop1</code> outside of
the enclosing procedure, you would use the code: </font></p>

<pre><font face="Courier New" size="2">                mov     cx, 25
Loop1::         mov     ax, cx
                call    PrintInteger
                loop    Loop1</font></pre>

<p><font face="Arial" size="2">Generally, far symbols are the targets of jump and call
instructions. The most common method programmers use to create a far label is to place <code>far</code>
in the operand field of a <code>proc</code> directive. Symbols that are simply constants
are normally defined with the <code>equ </code>directive. You can also declare symbols
with different types using the <code>equ </code>and <code>extrn/extern/externdef </code>directives.
An explanation of the <code>extrn </code>directives appears in the section &quot;Managing
Large Programs&quot;.</font></p>

<p><font face="Arial" size="2">If you declare a numeric constant using an equate, MASM
assigns the type abs (absolute, or constant) to the system. Text and string equates are
given the type text. You can also assign an arbitrary type to a symbol using the equ
directive, see &quot;Type Operators&quot; for more details.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING4-42"></a>8.11.2 Label Values</font></strong></p>

<p><font face="Arial" size="2">Whenever you define a label using a directive or
pseudo-opcode, MASM gives it a type and a value. The value MASM gives the label is usually
the current location counter value. If you define the symbol with an equate the equate's
operand usually specifies the symbol's value. When encountering the label in an operand
field, as with the <code>loop </code>instruction above, MASM substitutes the label's value
for the label. </font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING4-44"></a>8.11.3 Type Conflicts</font></strong></p>

<p><font face="Arial" size="2">Since the 80x86 supports strongly typed symbols, the next
question to ask is &quot;What are they used for?&quot; In a nutshell, strongly typed
symbols can help verify proper operation of your assembly language programs. Consider the
following code sections: </font></p>

<pre><font face="Courier New" size="2">DSEG            segment public 'DATA'
                 .
                 .
                 .
I               byte    ?
                 .
                 .
                 .
DSEG            ends

CSEG            segment public 'CODE'
                 .
                 .
                 .
                mov     ax, I
                 .
                 .
                 .
CSEG            ends
                end</font></pre>

<p><font face="Arial" size="2">The <code>mov </code>instruction in this example is
attempting to load the <code>ax </code>register (16 bits) from a byte sized variable. Now
the 80x86 microprocessor is perfectly capable of this operation. It would load the <code>al
</code>register from the memory location associated with <code>I</code> and load the <code>ah
</code>register from the next successive memory location (which is probably the L.O. byte
of some other variable). However, this probably wasn't the original intent. The person who
wrote this code probably forgot that<code> I</code> is a byte sized variable and assumed
that it was a word variable - which is definitely an error in the logic of the program. </font></p>

<p><font face="Arial" size="2">MASM would never allow an instruction like the one above to
be assembled without generating a diagnostic message. This can help you find errors in
your programs, particularly difficult-to-find errors. On occasion, advanced assembly
language programmers may want to execute a statement like the one above. MASM provides
certain coercion operators that bypass MASM's safety mechanisms and allow illegal
operations (see &quot;Coercion&quot;).</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING4-69"></a>8.12
    Address Expressions</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">An address expression is an algebraic expression that
produces a numeric result that MASM merges into the displacement field of an instruction.
An integer constant is probably the simplest example of an address expression. The
assembler simply substitutes the value of the numeric constant for the specified operand.
For example, the following instruction fills the immediate data fields of the <code>mov </code>instruction
with zeros: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, 0</font></pre>

<p><font face="Arial" size="2">Another simple form of an addressing mode is a symbol. Upon
encountering a symbol, MASM substitutes the value of that symbol. For example, the
following two statements emit the same object code as the instruction above: </font></p>

<pre><font face="Courier New" size="2">Value           equ     0
                mov     ax, Value</font></pre>

<p><font face="Arial" size="2">An address expression, however, can be much more complex
than this. You can use various arithmetic and logical operators to modify the basic value
of some symbols or constants. </font></p>

<p><font face="Arial" size="2">Keep in mind that MASM computes address expressions during
assembly, not at run time. For example, the following instruction does not load <code>ax</code>
from location <code>Var</code> and add one to it: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, Var1+1</font></pre>

<p><font face="Arial" size="2">Instead, this instruction loads the <code>al </code>register
with the byte stored at the address of <code>Var1</code> plus one and then loads the <code>ah
</code>register with the byte stored at the address of <code>Var1</code> plus two. </font></p>

<p><font face="Arial" size="2">Beginning assembly language programmers often confuse
computations done at assembly time with those done at run time. Take extra care to
remember that MASM computes all address expressions at assembly time!</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING4-83"></a>8.12.1 Symbol Types and
Addressing Modes</font></strong></p>

<p><font face="Arial" size="2">Consider the following instruction: </font></p>

<pre><font face="Courier New" size="2">                jmp     Location</font></pre>

<p><font face="Arial" size="2">Depending on how the label <code>Location</code> is
defined, this <code>jmp </code>instruction will perform one of several different
operations. If you'll look back at the chapter on the 80x86 instruction set, you'll notice
that the <code>jmp </code>instruction takes several forms. As a recap, they are </font></p>

<pre><font face="Courier New" size="2">                jmp     label           (short)
                jmp     label           (near)
                jmp     label           (far)
                jmp     reg             (indirect near, through register)
                jmp     mem/reg         (indirect near, through memory)
                jmp     mem/reg         (indirect far, thorugh memory)</font></pre>

<p><font face="Arial" size="2">Notice that MASM uses the same mnemonic (<code>jmp</code>)
for each of these instructions; how does it tell them apart? The secret lies with the
operand. If the operand is a statement label within the current segment, the assembler
selects one of the first two forms depending on the distance to the target instruction. If
the operand is a statement label within a different segment, then the assembler selects <code>jmp
</code>(far) label. If the operand following the <code>jmp </code>instruction is a
register, then MASM uses the indirect near <code>jmp </code>and the program jumps to the
address in the register. If a memory location is selected, the assembler uses one of the
following jumps: </font>

<ul>
  <li><font face="Arial" size="2">NEAR if the variable was declared with <code>word/sword/dw</code>
    </font></li>
  <li><font face="Arial" size="2">FAR if the variable was declared with <code>dword/sdword/dd</code>
    </font></li>
</ul>

<p><font face="Arial" size="2">An error results if you've used <code>byte/sbyte/db</code>,
<code>qword/dq</code>, or <code>tbyte/dt</code> or some other type.</font></p>

<p><font face="Arial" size="2">If you've specified an indirect address, e.g., <code>jmp
[bx]</code>, the assembler will generate an error because it cannot determine if <code>bx</code>
is pointing at a word or a dword variable. For details on how you specify the size, see
the section on coercion in this chapter.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING4-101"></a>8.12.2 Arithmetic and
Logical Operators</font></strong></p>

<p><font face="Arial" size="2">MASM recognizes several arithmetic and logical operators.
The following tables provide a list of such operators: </font></p>
<div align="center"><center>

<table BORDER="1" width="50%" cellspacing="0" cellpadding="0" bordercolor="#C0C0C0">
  <caption><strong><font face="Arial" size="2">Arithmetic Operators</font></strong></caption>
  <tr>
    <th bgcolor="#F0F0F0"><font face="Arial" size="2">Operator</font></th>
    <th bgcolor="#F0F0F0"><font face="Arial" size="2">Syntax</font></th>
    <th bgcolor="#F0F0F0"><font face="Arial" size="2">Description</font></th>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">+</font></td>
    <td><font face="Arial" size="2">+expr</font></td>
    <td><font face="Arial" size="2">Positive (unary)</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td><font face="Arial" size="2">-expr</font></td>
    <td><font face="Arial" size="2">Negation (unary)</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">+</font></td>
    <td><font face="Arial" size="2">expr + expr</font></td>
    <td><font face="Arial" size="2">Addition</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td><font face="Arial" size="2">expr - expr</font></td>
    <td><font face="Arial" size="2">Subtraction</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">*</font></td>
    <td><font face="Arial" size="2">expr * expr</font></td>
    <td><font face="Arial" size="2">Multiplication</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">/</font></td>
    <td><font face="Arial" size="2">expr / expr</font></td>
    <td><font face="Arial" size="2">Division</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">MOD</font></td>
    <td><font face="Arial" size="2">expr MOD expr</font></td>
    <td><font face="Arial" size="2">Modulo (remainder)</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">[ ]</font></td>
    <td><font face="Arial" size="2">expr [ expr ]</font></td>
    <td><font face="Arial" size="2">Addition (index operator)</font></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table BORDER="1" bordercolor="#C0C0C0" cellspacing="0" cellpadding="0" width="50%">
  <caption><strong><font face="Arial" size="2">Logical Operators</font></strong></caption>
  <tr>
    <th bgcolor="#F0F0F0" align="center"><font face="Arial" size="2">Operator</font></th>
    <th bgcolor="#F0F0F0"><font face="Arial" size="2">Syntax</font></th>
    <th bgcolor="#F0F0F0"><font face="Arial" size="2">Description</font></th>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">SHR</font></td>
    <td><font face="Arial" size="2">expr SHR expr</font></td>
    <td><font face="Arial" size="2">Shift right</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">SHL</font></td>
    <td><font face="Arial" size="2">expr SHL expr</font></td>
    <td><font face="Arial" size="2">Shift left</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">NOT</font></td>
    <td><font face="Arial" size="2">NOT expr</font></td>
    <td><font face="Arial" size="2">Logical (bit by bit) NOT</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">AND</font></td>
    <td><font face="Arial" size="2">expr AND expr</font></td>
    <td><font face="Arial" size="2">Logical AND</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">OR</font></td>
    <td><font face="Arial" size="2">expr OR expr</font></td>
    <td><font face="Arial" size="2">Logical OR</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">XOR</font></td>
    <td><font face="Arial" size="2">expr XOR expr</font></td>
    <td><font face="Arial" size="2">Logical XOR</font></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table BORDER="1" cellspacing="0" cellpadding="0" bordercolor="#C0C0C0" width="50%">
  <caption><strong><font face="Arial" size="2">Relational Operators</font></strong></caption>
  <tr>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">Operator</font></th>
    <th bgcolor="#F0F0F0"><font face="Arial" size="2">Syntax</font></th>
    <th bgcolor="#F0F0F0"><font face="Arial" size="2">Description</font></th>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">EQ</font></td>
    <td><font face="Arial" size="2">expr EQ expr</font></td>
    <td><font face="Arial" size="2">True (0FFh) if equal, false (0) otherwise</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">NE</font></td>
    <td><font face="Arial" size="2">expr NE expr</font></td>
    <td><font face="Arial" size="2">True (0FFh) if not equal, false (0) otherwise</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">LT</font></td>
    <td><font face="Arial" size="2">expr LT expr</font></td>
    <td><font face="Arial" size="2">True (0FFh) if less, false (0) otherwise</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">LE</font></td>
    <td><font face="Arial" size="2">expr LE expr</font></td>
    <td><font face="Arial" size="2">True (0FFh) if less or equal, false (0) otherwise</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">GT</font></td>
    <td><font face="Arial" size="2">expr GT expr</font></td>
    <td><font face="Arial" size="2">True (0FFh) if greater, false (0) otherwise</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">GE</font></td>
    <td><font face="Arial" size="2">expr GE expr</font></td>
    <td><font face="Arial" size="2">True (0FFh) if greater or equal, false (0) otherwise</font></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">You must not confuse these operators with 80x86
instructions! The addition operator adds two values together, their sum becomes an operand
to an instruction. This addition is performed when assembling the program, not at run
time. If you need to perform an addition at execution time, use the <code>add </code>or <code>adc
</code>instructions. </font></p>

<p><font face="Arial" size="2">You're probably wondering &quot;What are these operators
used for?&quot; The truth is, not much. The addition operator gets used quite a bit, the
subtraction somewhat, the comparisons once in a while, and the rest even less. Since
addition and subtraction are the only operators beginning assembly language programmers
regularly employ, this discussion considers only those two operators and brings up the
others as required throughout this text. </font></p>

<p><font face="Arial" size="2">The addition operator takes two forms: expr+expr or
expr[expr]. For example, the following instruction loads the accumulator, not from memory
location <code>COUNT</code>, but from the very next location in memory: </font></p>

<pre><font face="Courier New" size="2">                mov     al, COUNT+1</font></pre>

<p><font face="Arial" size="2">The assembler, upon encountering this statement, will
compute the sum of <code>COUNT</code>'s address plus one. The resulting value is the
memory address for this instruction. As you may recall, the <code>mov al, memory</code>
instruction is three bytes long and takes the form:</font></p>

<p><font face="Arial" size="2">Opcode | L. O. Displacement Byte | H. O. Displacement Byte</font></p>

<p><font face="Arial" size="2">The two displacement bytes of this instruction contain the
sum <code>COUNT+1</code>. </font></p>

<p><font face="Arial" size="2">The <code>expr[expr]</code> form of the addition operation
is for accessing elements of arrays. If <code>AryData</code> is a symbol that represents
the address of the first element of an array, <code>AryData[5]</code> represents the
address of the fifth byte into <code>AryData</code>. The expression <code>AryData+5</code>
produces the same result, and either could be used interchangeably, however, for arrays
the expr[expr] form is a little more self documenting. One trap to avoid: <code>expr1[expr2][expr3]</code>
does not automatically index (properly) into a two dimensional array for you. This simply
computes the sum <code>expr1+expr2+expr3</code>. </font></p>

<p><font face="Arial" size="2">The subtraction operator works just like the addition
operator, except it computes the difference rather than the sum. This operator will become
very important when we deal with local variables in Chapter 11. </font></p>

<p><font face="Arial" size="2">Take care when using multiple symbols in an address
expression. MASM restricts the operations you can perform on symbols to addition and
subtraction and only allows the following forms: </font></p>

<pre><font face="Courier New" size="2">Expression:             Resulting type:

reloc + const           Reloc, at address specified.

reloc - const           Reloc, at address specified.

reloc - reloc           Constant whose value is the number of bytes between
                        the first and second operands. Both variables must
                        physically appear in the same segment in the
                        current source file.</font></pre>

<p><font face="Arial" size="2">Reloc stands for relocatable symbol or expression. This can
be a variable name, a statement label, a procedure name, or any other symbol associated
with a memory location in the program. It could also be an expression that produces a
relocatable result. MASM does not allow any operations other than addition and subtraction
on expressions whose resulting type is relocatable. You cannot, for example, compute the
product of two relocatable symbols.</font></p>

<p><font face="Arial" size="2">The first two forms above are very common in assembly
language programs. Such an address expression will often consist of a single relocatable
symbol and a single constant (e.g., &quot;<code>var + 1</code>&quot;). You won't use the
third form very often, but it is very useful once in a while. You can use this form of an
address expression to compute the distance, in bytes, between two points in your program.
The <code>procsize</code> symbol in the following code, for example, computes the size of <code>Proc1</code>:
</font></p>

<pre><font face="Courier New" size="2">Proc1           proc    near
                push    ax
                push    bx
                push    cx
                mov     cx, 10
                lea     bx, SomeArray
                mov     ax, 0
ClrArray:       mov     [bx], ax
                add     bx, 2
                loop    ClrArray
                pop     cx
                pop     bx
                pop     ax
                ret
Proc1           endp

procsize        =       $ - Proc1</font></pre>

<p><font face="Arial" size="2">&quot;$&quot; is a special symbol MASM uses to denote the
current offset within the segment (i.e., the location counter). It is a relocatable
symbol, as is <code>Proc1</code>, so the equate above computes the difference between the
offset at the start of <code>Proc1</code> and the end of <code>Proc1</code>. This is the
length of the <code>Proc1</code> procedure, in bytes.</font></p>

<p><font face="Arial" size="2">The operands to the operators other than addition and
subtraction must be constants or an expression yielding a constant (e.g., &quot;<code>$-Proc1</code>&quot;
above produces a constant value). You'll mainly use these operators in macros and with the
conditional assembly directives.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING4-147"></a>8.12.3 Coercion</font></strong></p>

<p><font face="Arial" size="2">Consider the following program segment: </font></p>

<pre><font face="Courier New" size="2">DSEG            segment public 'DATA'
I               byte    ?
J               byte    ?
DSEG            ends

CSEG            segment
                 .
                 .
                 .
                mov     al, I
                mov     ah, J
                 .
                 .
                 .
CSEG            ends</font></pre>

<p><font face="Arial" size="2">Since I and J are adjacent, there is no need to use two <code>mov
</code>instructions to load <code>al </code>and <code>ah</code>, a simple <code>mov ax, I</code>
instruction would do the same thing. Unfortunately, the assembler will balk at<code> mov
ax, I </code>since I is a byte. The assembler will complain if you attempt to treat it as
a word. As you can see, however, there are times when you'd probably like to treat a byte
variable as a word (or treat a word as a byte or double word, or treat a double word as a
something else). </font></p>

<p><font face="Arial" size="2">Temporarily changing the type of a label for some
particular occurrence is coercion. Expressions can be coerced to a different type using
the MASM <code>ptr</code> operator. You use the <code>ptr</code> operator as follows:</font></p>

<p><font face="Arial" size="2">type PTR expression</font></p>

<p><font face="Arial" size="2">Type is any of <code>byte, word, dword, tbyte, near</code>,
<code>far</code>, or other type and expression is any general expression that is the
address of some object. The coercion operator returns an expression with the same value as
expression, but with the type specified by type. To handle the above problem you'd use the
assembly language instruction: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, word ptr I</font></pre>

<p><font face="Arial" size="2">This instructs the assembler to emit the code that will
load the <code>ax </code>register with the word at address I. This will, of course, load <code>al
</code>with I and <code>ah </code>with J. </font></p>

<p><font face="Arial" size="2">Code that uses double word values often makes extensive use
of the coercion operator. Since <code>lds </code>and <code>les</code> are the only 32-bit
instructions on pre-80386 processors, you cannot (without coercion) store an integer value
into a 32-bit variable using the <code>mov </code>instruction on those earlier CPUs. If
you've declared <code>DBL</code> using the <code>dword </code>pseudo-opcode, then an
instruction of the form <code>mov DBL,ax</code> will generate an error because it's
attempting to move a 16 bit quantity into a 32 bit variable. Storing values into a double
word variable requires the use of the <code>ptr </code>operator. The following code
demonstrates how to store the <code>ds </code>and <code>bx </code>registers into the
double word variable <code>DBL</code>: </font></p>

<pre><font face="Courier New" size="2">                mov     word ptr DBL, bx
                mov     word ptr DBL+2, ds</font></pre>

<p><font face="Arial" size="2">You will use this technique often as various UCR Standard
Library and MS-DOS calls return a double word value in a pair of registers. </font></p>

<p><font face="Arial" size="2">Warning: If you coerce a <code>jmp </code>instruction to
perform a <code>far </code>jump to a <code>near </code>label, other than performance
degradation (the far <code>jmp </code>takes longer to execute), your program will work
fine. If you coerce a <code>call </code>to perform a far call to a near subroutine, you're
headed for trouble. Remember, far calls push the <code>cs </code>register onto the stack
(with the return address). When executing a near <code>ret</code> instruction, the old <code>cs
</code>value will not be popped off the stack, leaving junk on the stack. The very next <code>pop
</code>or <code>ret </code>instruction will not operate properly since it will pop the <code>cs
</code>value off the stack rather than the original value pushed onto the stack.</font></p>

<p><font face="Arial" size="2">Expression coercion can come in handy at times. Other times
it is essential. However, you shouldn't get carried away with coercion since data type
checking is a powerful debugging tool built in to MASM. By using coercion, you override
this protection provided by the assembler. Therefore, always take care when overriding
symbol types with the <code>ptr </code>operator. </font></p>

<p><font face="Arial" size="2">One place where you'll need coercion is with the <code>mov
memory, immediate</code> instruction. Consider the following instruction: </font></p>

<pre><font face="Courier New" size="2">                mov     [bx], 5</font></pre>

<p><font face="Arial" size="2">Unfortunately, the assembler has no way of telling whether <code>bx
</code>points at a byte, word, or double word item in memory. The value of the immediate
operand isn't of any use. Even though five is a byte quantity, this instruction might be
storing the value 0005h into a word variable, or 00000005 into a double word variable. If
you attempt to assemble this statement, the assembler will generate an error to the effect
that you must specify the size of the memory operand. You can easily accomplish this using
the <code>byte ptr</code>, <code>word ptr</code>, and <code>dword ptr </code>operators as
follows: </font></p>

<pre><font face="Courier New" size="2">                mov     byte ptr [bx], 5        ;For a byte variable
                mov     word ptr [bx], 5        ;For a word variable
                mov     dword ptr [bx], 5       ;For a dword variable</font></pre>

<p><font face="Arial" size="2">Lazy programmers might complain that typing strings like
&quot;<code>word ptr</code>&quot; or &quot;<code>far ptr</code>&quot; is too much work.
Wouldn't it have been nice had Intel chosen a single character symbol rather than these
long phrases? Well, quit complaining and remember the<code> textequ</code> directive. With
the equate directive you can substitute a long string like &quot;<code>word ptr</code>&quot;
for a short symbol. You'll find equates like the following in many programs, including
several in this text: </font></p>

<pre><font face="Courier New" size="2">byp             textequ &lt;byte ptr&gt;      ;Remember, &quot;bp&quot; is a reserved symbol!
wp              textequ &lt;word ptr&gt;
dp              textequ &lt;dword ptr&gt;
np              textequ &lt;near ptr&gt;
fp              textequ &lt;far ptr&gt;</font></pre>

<p><font face="Arial" size="2">With equates like the above, you can use statements like
the following: </font></p>

<pre><font face="Courier New" size="2">                mov     byp [bx], 5
                mov     ax, wp I
                mov     wp DBL, bx
                mov     wp DBL+2, ds</font></pre>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH08-3.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH08-3.html">Chapter Eight</a> (Part 3)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH08-5.html">Chapter Eight</a> (Part 5) </strong></font><a href="CH08-5.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Eight: MASM: Directives &amp;
Pseudo-Opcodes (Part 4)<br>
26 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_8/CH08-4.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:36 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
