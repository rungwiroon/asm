<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_8/CH08-7.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:37 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER EIGHT: MASM: DIRECTIVES &amp; PSEUDO-OPCODES (Part 7)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING7"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH08-6.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH08-6.html">Chapter Eight</a> (Part 6)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH08-8.html">Chapter Eight</a> (Part 8) </strong></font><a href="CH08-8.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10" colspan="2"><a NAME="HEADING7-1"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0" colspan="2"><font face="Arial" size="4"><strong>CHAPTER
    EIGHT:<br>
    MASM: DIRECTIVES &amp; PSEUDO-OPCODES (Part 7)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10" colspan="2"></td>
  </tr>
  <tr>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING7-1"><b>8.14 </b>-
    Macros</a> <br>
    <a HREF="#HEADING7-3"><b>8.14.1 </b>- Procedural Macros</a><br>
    <a HREF="#HEADING7-192"><b>8.14.2 </b>- Macros vs. 80x86 Procedures</a><br>
    <a HREF="#HEADING7-248"><b>8.14.3 </b>- The LOCAL Directive</a> </font></td>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING7-276"><b>8.14.4
    </b>- The EXITM Directive</a> <br>
    <a HREF="#HEADING7-288"><b>8.14.5 </b>- Macro Parameter Expansion and Macro Operators</a> <br>
    <a HREF="#HEADING7-389"><b>8.14.6 </b>- A Sample Macro to Implement For Loops</a> </font></td>
  </tr>
  <tr>
    <td width="100%" valign="top" nowrap height="20" colspan="2"></td>
  </tr>
  <tr>
    <td width="100%" valign="top" colspan="2"><strong><font face="Arial" size="3">8.14 Macros</font></strong></td>
  </tr>
  <tr>
    <td width="100%" valign="top" nowrap height="1" colspan="2" bgcolor="#000000"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">A macro is like a procedure that inserts a block of
statements at various points in your program during assembly. There are three general
types of macros that MASM supports: procedural macros, functional macros, and looping
macros. Along with conditional assembly, these tools provide the traditional if, loop,
procedure, and function constructs found in many high level languages. Unlike the assembly
instructions you write, the conditional assembly and macro language constructs execute
during assembly. The conditional assembly and macros statements do not exist when your
assembly language program is running. The purpose of these statements is to control which
statements MASM assembles into your final &quot;.exe&quot; file. While the conditional
assembly directives select or omit certain statements for assembly, the macro directives
let you emit repetitive sequences of instructions to an assembly language file like high
level language procedures and loops let you repetitively execute sequences of high level
language statements.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING7-3"></a>8.14.1 Procedural Macros </font></strong></p>

<p><font face="Arial" size="2">The following sequence defines a macro: </font></p>

<pre><font face="Courier New" size="2">name             macro  {parameter1 {parameter2 {,...}}}

              &lt;statements&gt;
              
                endm</font></pre>

<p><font face="Arial" size="2"><code>Name</code> must be a valid and unique symbol in the
source file. You will use this identifier to invoke the macro. The (optional) parameter
names are placeholders for values you specify when you invoke the macro; the braces above
denote the optional items, they should not actually appear in your source code. These
parameter names are local to the macro and may appear elsewhere in the program. </font></p>

<p><font face="Arial" size="2">Example of a macro definition: </font></p>

<pre><font face="Courier New" size="2">COPY            macro   Dest, Source
                mov     ax, Source
                mov     Dest, ax
                endm</font></pre>

<p><font face="Arial" size="2">This macro will copy the word at the source address to the
word at the destination address. The symbols <code>Dest</code> and <code>Source</code> are
local to the macro and may appear elsewhere in the program. </font></p>

<p><font face="Arial" size="2">Note that MASM does not immediately assemble the
instructions between the <code>macro </code>and <code>endm </code>directives when MASM
encounters the macro. Instead, the assembler stores the text corresponding to the macro
into a special table (called the symbol table). MASM inserts these instructions into your
program when you invoke the macro.</font></p>

<p><font face="Arial" size="2">To invoke (use) a macro, simply specify the macro name as a
MASM mnemonic. When you do this, MASM will insert the statements between the macro and
endm directives into your code at the point of the macro invocation. If your macro has
parameters, MASM will substitute the actual parameters appearing as operands for the
formal parameters appearing in the macro definition. MASM does a straight textual
substitution, just as though you had created text equates for the parameters.</font></p>

<p><font face="Arial" size="2">Consider the following code that uses the <code>COPY</code>
macro defined above: </font></p>

<pre><font face="Courier New" size="2">                call    SetUpX
                copy    Y, X
                add     Y, 5 </font></pre>

<p><font face="Arial" size="2">This program segment will issue a call to <code>SetUpX</code>
(which, presumably, does something to the variable <code>X</code>) then invokes the <code>COPY</code>
macro, that copies the value in the variable<code> X </code>into the variable <code>Y</code>.
Finally, it adds five to the value contained in variable <code>Y</code>. </font></p>

<p><font face="Arial" size="2">Note that this instruction sequence is absolutely identical
to: </font></p>

<pre><font face="Courier New" size="2">                call    SetUpX
                mov     ax, X
                mov     Y, ax
                add     Y, 5 </font></pre>

<p><font face="Arial" size="2">In some instances using macros can save a considerable
amount of typing in your programs. For example, suppose you want to access elements of
various two dimensional arrays. As you may recall, the formula to compute the row-major
address for an array element is</font></p>

<p><font face="Arial" size="2">element address = base address + (First Index * Row Size +
Second Index) * element size</font></p>

<p><font face="Arial" size="2">Suppose you want write some assembly code that achieves the
same result as the following C code: </font></p>

<pre><font face="Courier New" size="2">int a[16][7], b[16][7], x[7][16];
int i,j;

        for (i=0; i&lt;16; i = i + 1)
                for (j=0; j &lt; 7; j = j + 1)
                        x[j][i] = a[i][j]*b[15-i][j];</font></pre>

<p><font face="Arial" size="2">The 80x86 code for this sequence is rather complex because
of the number of array accesses. The complete code is </font></p>

<pre><font face="Courier New" size="2">                .386                    ;Uses some 286 &amp; 386 instrs.
                option  segment:use16   ;Required for real mode programs
                 .
                 .
                 .
a               sword   16 dup (7 dup (?))
b               sword   16 dup (7 dup (?))
x               sword   7 dup (16 dup (?))
                 .
                 .
                 .
i               textequ &lt;cx&gt;            ;Hold I in CX register.
j               textequ &lt;dx&gt;            ;Hold J in DX register.

                mov     I, 0            ;Initialize I loop index with zero.
ForILp:         cmp     I, 16           ;Is I less than 16?
                jnl     ForIDone        ;If so, fall into body of I loop.

                mov     J, 0            ;Initialize J loop index with zero.
ForJLp:         cmp     J, 7            ;Is J less than 7?
                jnl     ForJDone        ;If so, fall into body of J loop.

                imul    bx, I, 7        ;Compute index for a[i][j].
                add     bx, J
                add     bx, bx          ;Element size is two bytes.
                mov     ax, A[bx]       ;Get a[i][j]

                mov     bx, 15          ;Compute index for b[15-I][j].
                sub     bx, I
                imul    bx, 7
                add     bx, J
                add     bx, bx          ;Element size is two bytes.
                imul    ax, b[bx]       ;Compute a[i][j] * b[16-i][j]

                imul    bx, J, 16       ;Compute index for X[J][I]
                add     bx, I
                add     bx, bx
                mov     X[bx], ax       ;Store away result.

                inc     J               ;Next loop iteration.
                jmp     ForJLp

ForJDone:       inc     I               ;Next I loop iteration.
                jmp     ForILp

ForIDone:                               ;Done with nested loop.</font></pre>

<p><font face="Arial" size="2">This is a lot of code for only five C/C++ statements! If
you take a close look at this code, you'll notice that a large number of the statements
simply compute the index into the three arrays. Furthermore, the code sequences that
compute these array indices are very similar. If they were exactly the same, it would be
obvious we could write a macro to replace the three array index computations. Since these
index computations are not identical, one might wonder if it is possible to create a macro
that will simplify this code. The answer is yes; by using macro parameters it is very easy
to write such a macro. Consider the following code: </font></p>

<pre><font face="Courier New" size="2">i               textequ &lt;cx&gt;            ;Hold I in CX register.
j               textequ &lt;dx&gt;            ;Hold J in DX register.

NDX2            macro   Index1, Index2, RowSize
                imul    bx, Index1, RowSize
                add     bx, Index2
                add     bx, bx
                endm

                mov     I, 0            ;Initialize I loop index with zero.
ForILp:         cmp     I, 16           ;Is I less than 16?
                jnl     ForIDone        ;If so, fall into body of I loop.

                mov     J, 0            ;Initialize J loop index with zero.
ForJLp:         cmp     J, 7            ;Is J less than 7?
                jnl     ForJDone        ;If so, fall into body of J loop.

                NDX2    I, J, 7
                mov     ax, A[bx]       ;Get a[i][j]

                mov     bx, 15          ;Compute index for b[15-I][j].
                sub     bx, I
                NDX2    bx, J, 7
                imul    ax, b[bx]       ;Compute a[i][j] * b[15-i][j]

                NDX2    J, I, 16
                mov     X[bx], ax       ;Store away result.

                inc     J               ;Next loop iteration.
                jmp     ForJLp

ForJDone:       inc     I               ;Next I loop iteration.
                jmp     ForILp

ForIDone:                               ;Done with nested loop.</font></pre>

<p><font face="Arial" size="2">One problem with the <code>NDX2</code> macro is that you
need to know the row size of an array (since it is a macro parameter). In a short example
like this one, that isn't much of a problem. However, if you write a large program you can
easily forget the sizes and have to look them up or, worse yet, &quot;remember&quot; them
incorrectly and introduce a bug into your program. One reasonable question to ask is if
MASM could figure out the row size of the array automatically. The answer is yes.</font></p>

<p><font face="Arial" size="2">MASM's <code>length</code> operator is a holdover from the
pre-6.0 days. It was supposed to return the number of elements in an array. However, all
it really returns is the first value appearing in the array's operand field. For example, <code>(length
a)</code> would return 16 given the definition for <code>a</code> above. MASM corrected
this problem by introducing the <code>lengthof</code> operator that properly returns the
total number of elements in an array. (<code>Lengthof a)</code>, for example, properly
returns 112 (16 * 7). Although the<code> (length a) </code>operator returns the wrong
value for our purposes (it returns the column size rather than the row size), we can use
its return value to compute the row size using the expression <code>(lengthof a)/(length
a)</code>. With this knowledge, consider the following two macros: </font></p>

<pre><font face="Courier New" size="2">; LDAX- This macro loads ax with the word at address Array[Index1][Index2]
;       Assumptions:    You've declared the array using a statement like
;                       Array word Colsize dup (RowSize dup (?))
;                       and the array is stored in row major order.
;
;       If you specify the (optional) fourth parameter, it is an 80x86
;       machine instruction to substitute for the MOV instruction that
;       loads AX from Array[bx].

LDAX            macro   Array, Index1, Index2, Instr
                imul    bx, Index1, (lengthof Array) / (length Array)
                add     bx, Index2
                add     bx, bx

; See if the caller has supplied the fourth operand.

                ifb     &lt;Instr&gt;
                mov     ax, Array[bx]           ;If not, emit a MOV instr.
                else
                instr   ax, Array[bx]           ;If so, emit user instr.
                endif
                endm

; STAX- This macro stores ax into the word at address Array[Index1][Index2]
;       Assumptions: Same as above

STAX            macro   Array, Index1, Index2
                imul    bx, Index1, (lengthof Array) / (length Array)
                add     bx, Index2
                add     bx, bx
                mov     Array[bx], ax
                endm</font></pre>

<p><font face="Arial" size="2">With the macros above, the original program becomes: </font></p>

<pre><font face="Courier New" size="2">i               textequ &lt;cx&gt;            ;Hold I in CX register.
j               textequ &lt;dx&gt;            ;Hold J in DX register.

                mov     I, 0            ;Initialize I loop index with zero.
ForILp:         cmp     I, 16           ;Is I less than 16?
                jnl     ForIDone        ;If so, fall into body of I loop.

                mov     J, 0            ;Initialize J loop index with zero.
ForJLp:         cmp     J, 7            ;Is J less than 7?
                jnl     ForJDone        ;If so, fall into body of J loop.

                ldax    A, I, J         ;Fetch A[I][J]
                mov     bx, 16          ;Compute 16-I.
                sub     bx, I
                ldax    b, bx, J, imul  ;Multiply in B[16-I][J].
                stax    x, J, I         ;Store to X[J][I]

                inc     J               ;Next loop iteration.
                jmp     ForJLp

ForJDone:       inc     I               ;Next I loop iteration.
                jmp     ForILp

ForIDone:                               ;Done with nested loop.</font></pre>

<p><font face="Arial" size="2">As you can plainly see, the code for the loops above is
getting shorter and shorter by using these macros. Of course, the entire code sequence is
actually longer because the macros represent more lines of code that they save in the
original program. However, that is an artifact of this particular program. In general,
you'd probably have more than three array accesses; furthermore, you can always put the <code>LDAX</code>
and <code>STAX</code> macros in a library file and automatically include them anytime
you're dealing with two dimensional arrays. Although, technically, your program might
actually contain more assembly language statements if you include these macros in your
code, you only had to write those macros once. After that, it takes very little effort to
include the macros in any new program.</font></p>

<p><font face="Arial" size="2">We can shorten this code sequence even more using some
additional macros. However, there are a few additional topics to cover before we can do
that, so keep reading.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING7-192"></a>8.14.2 Macros vs. 80x86
Procedures </font></strong></p>

<p><font face="Arial" size="2">Beginning assembly language programmers often confuse
macros and procedures. A procedure is a single section of code that you call from various
points in the program. A macro is a sequence of instructions that MASM replicates in your
program each time you use the macro. Consider the following two code fragments: </font></p>

<pre><font face="Courier New" size="2">Proc_1          proc    near
                mov     ax, 0
                mov     bx, ax
                mov     cx, 5
                ret
Proc_1          endp

Macro_1         macro
                mov     ax, 0
                mov     bx, ax
                mov     cx, 5
                endm

                call    Proc_1
                 .
                 .
                call    Proc_1
                 .
                 .
                Macro_1
                 .
                 .
                Macro_1</font></pre>

<p><font face="Arial" size="2">Although the macro and procedure produce the same result,
they do it in different ways. The procedure definition generates code when the assembler
encounters the <code>proc</code> directive. A call to this procedure requires only three
bytes. At execution time, the 80x86: </font>

<ul>
  <li><font face="Arial" size="2">encounters the <code>call</code> instruction, </font></li>
  <li><font face="Arial" size="2">pushes the return address onto the stack, </font></li>
  <li><font face="Arial" size="2">jumps to <code>Proc_1</code>, </font></li>
  <li><font face="Arial" size="2">executes the code therein, </font></li>
  <li><font face="Arial" size="2">pops the return address off the stack, and </font></li>
  <li><font face="Arial" size="2">returns to the calling code. </font></li>
</ul>

<p><font face="Arial" size="2">The macro, on the other hand, does not emit any code when
processing the statements between the <code>macro</code> and <code>endm</code> directives.
However, upon encountering <code>Macro_1</code> in the mnemonic field, MASM will assemble
every statement between the <code>macro</code> and <code>endm</code> directives and emit
that code to the output file. At run time, the CPU executes these instructions without the
<code>call/ret </code>overhead. </font></p>

<p><font face="Arial" size="2">The execution of a macro expansion is usually faster than
the execution of the same code implemented with a procedure. However, this is another
example of the classic speed/space trade-off. Macros execute faster by eliminating the
call/return sequence. However, the assembler copies the macro code into your program at
each macro invocation. If you have a lot of macro invocations within your program, it will
be much larger than the same program that uses procedures.</font></p>

<p><font face="Arial" size="2">Macro invocations and procedure invocations are
considerably different. To invoke a macro, you simply specify the macro name as though it
were an instruction or directive. To invoke a procedure you need to use the <code>call</code>
instruction. In many contexts it is unfortunate that you use two separate invocation
mechanisms for such similar operations. The real problem occurs if you want to switch a
macro to a procedure or vice versa. It might be that you've been using macro expansion for
a particular operation, but now you've expanded the macro so many times it makes more
sense to use a procedure. Maybe just the opposite is true, you've been using a procedure
but you want to expand the code in-line to improve it's performance. The problem with
either conversion is that you will have to find every invocation of the macro or procedure
call and modify it. Modifying the procedure or macro is easy, but locating and changing
all the invocations can be quite a bit of work. Fortunately, there is a very simple
technique you can use so procedure calls share the same syntax as macro invocation. The
trick is to create a macro or a text equate for each procedure you write that expands into
a call to that procedure. For example, suppose you write a procedure <code>ClearArray</code>
that zeros out arrays. When writing the code, you could do the following: </font></p>

<pre><font face="Courier New" size="2">ClearArray      textequ &lt;call $$ClearArray&gt;
$$ClearArray    proc    near
                 .
                 .
                 .
$$ClearArray    endm</font></pre>

<p><font face="Courier New" size="2">To call the ClearArray procedure, you'd simply use a
statement like the following: </font></p>

<pre><font face="Courier New" size="2">
                 .
                 .
                 .
        &lt;Set up parameters for ClearArray&gt;
                ClearArray
                 .
                 .
                 .</font></pre>

<p><font face="Arial" size="2">If you ever change the <code>$$ClearArray</code> procedure
to a macro, all you need to do is name it <code>ClearArray</code> and dispose of the <code>textequ</code>
for the procedure. Conversely, if you already have a macro and you want to convert it to a
procedure, Simply name the procedure $$procname and create a text equate that emits a call
to this procedure. This allows you to use the same invocation syntax for procedures or
macros.</font></p>

<p><font face="Arial" size="2">This text won't normally use the technique described above,
except for the UCR Standard Library routines. This is not because this isn't a good way to
invoke procedures. Some people have trouble differentiating macros and procedures, so this
text will use explicit calls to help avoid that confusion. Standard Library calls are an
exception because using macro invocations is the standard way to call these routines.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING7-248"></a>8.14.3 The LOCAL
Directive</font></strong></p>

<p><font face="Arial" size="2">Consider the following macro<code> </code>definition: </font></p>

<pre><font face="Courier New" size="2">LJE             macro   Dest
                jne     SkipIt
                jmp     Dest
SkipIt:
                endm</font></pre>

<p><font face="Arial" size="2">This macro does a &quot;long jump if equal&quot;. However,
there is one problem with it. Since MASM copies the macro text verbatim (allowing, of
course, for parameter substitution), the symbol <code>SkipIt</code> will be redefined each
time the <code>LJE</code> macro appears. When this happens, the assembler will generate a
multiple definition error. To overcome this problem, the <code>local </code>directive can
be used to define a local symbol within the macro. Consider the following macro
definition: </font></p>

<pre><font face="Courier New" size="2">LJE             macro   Dest
                local   SkipIt
                jne     SkipIt
                jmp     Dest
SkipIt:
                endm</font></pre>

<p><font face="Arial" size="2">In this macro definition, <code>SkipIt</code> is a local
symbol. Therefore, the assembler will generate a new copy of <code>SkipIt</code> each time
you invoke the macro. This will prevent MASM from generating an error. </font></p>

<p><font face="Arial" size="2">The <code>local </code>directive, if it appears within your
macro definition, must appear immediately after the <code>macro </code>directive. If you
need multiple local symbols, you can specify several of them in the local directive's
operand field. Simply separate each symbol with a comma: </font></p>

<pre><font face="Courier New" size="2">IFEQUAL         macro   a, b
                local   ElsePortion, Done
                mov     ax, a
                cmp     ax, b
                jne     ElsePortion
                inc     bx
                jmp     Done
ElsePortion:    dec     bx
Done:
                endm</font></pre>

<pre><strong><font face="Arial" size="3">8.14.4 The EXITM Directive</font></strong></pre>

<p><font face="Arial" size="2">The <code>exitm </code>directive immediately terminates the
expansion of a macro, exactly as though MASM encountered <code>endm</code>. MASM ignores
all text from the <code>exitm </code>directive to the <code>endm</code>. </font></p>

<p><font face="Arial" size="2">You're probably wondering why anyone would ever use the <code>exitm
</code>directive. After all, if MASM ignores all text between <code>exitm </code>and <code>endm</code>,
why bother sticking an <code>exitm </code>directive into your macro in the first place?
The answer is conditional assembly. Conditional assembly can be used to conditionally
execute the <code>exitm </code>directive, thereby allowing further macro expansion under
certain conditions, consider the following: </font></p>

<pre><font face="Courier New" size="2">Bytes           macro   Count 
                byte    Count
                if      Count eq 0
                exitm
                endif
                byte    Count dup (?)
                endm</font></pre>

<p><font face="Arial" size="2">Of course, this simple example could have been coded
without using the <code>exitm </code>directive (the conditional assembly directive is all
we require), but it does demonstrate how the <code>exitm </code>directive can be used
within a conditional assembly sequence to control its influence.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING7-288"></a>8.14.5 Macro Parameter
Expansion and Macro Operators</font></strong></p>

<p><font face="Arial" size="2">Since MASM does a textual substitution for macro parameters
when you invoke a macro, there are times when a macro invocation might not produce the
results you expect. For example, consider the following (admittedly dumb) macro
definition: </font></p>

<pre><font face="Courier New" size="2">Index           =       8

; Problem-      This macro attempts to load AX with the element of a word
;               array specified by the macro's parameter. This parameter
;               must be an assembly-time constant.

Problem         macro   Parameter
                mov     ax, Array[Parameter*2]
                endm
                 .
                 .
                 .
                Problem 2
                 .
                 .
                 .
                Problem Index+2</font></pre>

<p><font face="Arial" size="2">When MASM expands the first invocation of Problem above, it
produces the instruction: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, Array[2*2]</font></pre>

<p><font face="Arial" size="2">Okay, so far so good. This code loads element two of Array
into ax. However, consider the expansion of the second invocation to Problem, above: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, Array[Index+2*2]</font></pre>

<p><font face="Arial" size="2">Because MASM's address expressions support operator
precedence (see &quot;Operator Precedence&quot;), this macro expansion will not produce
the correct result. It will access the sixth element of <code>Array</code> (at index 12)
rather than the tenth element at index 20.</font></p>

<p><font face="Arial" size="2">The problem above occurs because MASM simply replaces a
formal parameter by the actual parameter's text, not the actual parameter's value. This
pass by name parameter passing mechanism should be familiar to long-time C and C++
programmers who use the <code>#define </code>statement. If you think that macro (pass by
name) parameters work just like Pascal and C's pass by value parameters, you are setting
yourself up for eventual disaster. </font></p>

<p><font face="Arial" size="2">One possible solution, that works well for macros like the
above, is to put parentheses around macro parameters that occur within expressions inside
the macro. Consider the following code: </font></p>

<pre><font face="Courier New" size="2">Problem         macro   Parameter
                mov     ax, Array[(Parameter)*2]
                endm
                 .
                 .
                 .
                Problem Index+2</font></pre>

<p><font face="Arial" size="2">This macro invocation expands to </font></p>

<pre><font face="Courier New" size="2">                mov     ax, Array[(Index+2)*2]</font></pre>

<p><font face="Arial" size="2">This produces the expected result.</font></p>

<p><font face="Arial" size="2">Textual parameter substitution is but one problem you'll
run into when using macros. Another problem occurs because MASM has two types of assembly
time values: numeric and text. Unfortunately, MASM expects numeric values in some contexts
and text values in others. They are not fully interchangeable. Fortunately, MASM provides
a set of operators that let you convert between one form and the other (if it is possible
to do so). To understand the subtle differences between these two types of values, look at
the following statements: </font></p>

<pre><font face="Courier New" size="2">Numeric         =       10+2
Textual         textequ &lt;10+2&gt;</font></pre>

<p><font face="Arial" size="2">MASM evaluates the numeric expression &quot;<code>10+2</code>&quot;
and associates the value twelve with the symbol <code>Numeric</code>. For the symbol <code>Textual</code>,
MASM simply stores away the string &quot;<code>10+2</code>&quot; and substitutes it for <code>Textual</code>
anywhere you use it in an expression.</font></p>

<p><font face="Arial" size="2">In many contexts, you could use either symbol. For example,
the following two statements both load <code>ax</code> with twelve: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, Numeric     ;Same as mov ax, 12
                mov     ax, Textual     ;Same as mov ax, 10+2</font></pre>

<p><font face="Arial" size="2">However, consider the following two statements: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, Numeric*2   ;Same as mov ax, 12*2
                mov     ax, Textual*2   ;Same as mov ax, 10+2*2</font></pre>

<p><font face="Arial" size="2">As you can see, the textual substitution that occurs with
text equates can lead to the same problems you encountered with textual substitution of
macro parameters.</font></p>

<p><font face="Arial" size="2">MASM will automatically convert a text object to a numeric
value, if the conversion is necessary. Other than the textual substitution problem
described above, you can use a text value (whose string represents a numeric quantity)
anywhere MASM requires a numeric value. </font></p>

<p><font face="Arial" size="2">Going the other direction, numeric value to text value, is
not automatic. Therefore, MASM provides an operator you can use to convert numeric data to
textual data: the &quot;%&quot; operator. This expansion operator forces an immediate
evaluation of the following expression and then it converts the result of the expression
into a string of digits. Look at these invocations of the <code>Problem</code> macro: </font></p>

<pre><font face="Courier New" size="2">                Problem 10+2    ;Parameter is &quot;10+2&quot;
                Problem %10+2   ;Parameter is &quot;12&quot;</font></pre>

<p><font face="Arial" size="2">In the second example above, the text expansion operator
instructs MASM to evaluate the expression &quot;10+2&quot; and convert the resulting
numeric value to a text value consisting of the digits that represent the value twelve.
Therefore, these two macro expand into the following statements (respectively): </font></p>

<pre><font face="Courier New" size="2">                mov     ax, Array[10+2*2]       ;Problem 10+2 expansion
                mov     ax, Array[12*2]         ;Problem %10+2 expansion</font></pre>

<p><font face="Arial" size="2">MASM provides a second operator, the substitution operator
that lets you expand macro parameter names where MASM does not normally expect a symbol.
The substitution operator is the ampersand (&quot;&amp;&quot;) character. If you surround
a macro parameter name with ampersands inside a macro, MASM will substitute the
parameter's text regardless of the location of the symbol. This lets you expand macro
parameters whose names appear inside other identifiers or inside literal strings. The
following macro demonstrates the use of this operator: </font></p>

<pre><font face="Courier New" size="2">DebugMsg        macro   Point, String
Msg&amp;String&amp;     byte    &quot;At point &amp;Point&amp;: &amp;String&amp;&quot;
                endm
                 .
                 .
                 .
                DebugMsg 5, &lt;Assertion fails&gt;</font></pre>

<p><font face="Arial" size="2">The macro invocation immediately above produces the
statement: </font></p>

<pre><font face="Courier New" size="2">Msg5            byte    &quot;At point 5: Assertion failed&quot;</font></pre>

<p><font face="Arial" size="2">Note how the substitution operator allowed this macro to
concatenate &quot;<code>Msg</code>&quot; and &quot;5&quot; to produce the label on the
byte directive. Also note that the expansion operator lets you expand macro identifiers
even if they appear in a literal string constant. Without the ampersands in the string,
MASM would have emitted the statement: </font></p>

<pre><font face="Courier New" size="2">Msg5            byte    &quot;At point point: String&quot;</font></pre>

<p><font face="Arial" size="2">Another important operator active within macros is the
literal character operator, the exclamation mark (&quot;!&quot;). This symbol instructs
MASM to pass the following character through without any modification. You would normally
use this symbol if you need to include one of the following symbols as a character within
a macro:</font></p>

<p><font face="Arial" size="2">! &amp; &gt; %</font></p>

<p><font face="Arial" size="2">For example, had you really wanted the string in the <code>DebugMsg</code>
macro to display the ampersands, you would use the definition: </font></p>

<pre><font face="Courier New" size="2">DebugMsg        macro   Point, String
Msg&amp;String&amp;     byte    &quot;At point !&amp;Point!&amp;: !&amp;String!&amp;&quot;
                endm

&quot;Debug 5, &lt;Assertion fails&gt;&quot; would produce the following statement:
Msg5            byte    &quot;At point &amp;Point&amp;: &amp;String&amp;&quot;</font></pre>

<p><font face="Arial" size="2">Use the &quot;&lt;&quot; and &quot;&gt;&quot; symbols to
delimit text data inside MASM. The following two invocations of the PutData macro show how
you can use these delimiters in a macro: </font></p>

<pre><font face="Courier New" size="2">PutData         macro   TheName, TheData
PD_&amp;TheName&amp;    byte    TheData
                endm
                 .
                 .
                 .
                PutData MyData, 5, 4, 3         ;Emits &quot;PD_MyData byte 5&quot;
                PutData MyData, &lt;5, 4, 3&gt;       ;Emits &quot;PD_MyData byte 5, 4, 3&quot;</font></pre>

<p><font face="Arial" size="2">You can use the text delimiters to surround objects that
you wish to treat as a single parameter rather than as a list of multiple parameters. In
the <code>PutData</code> example above, the first invocation passes four parameters to <code>PutData</code>
(<code>PutData</code> ignores the last two). In the second invocation, there are two
parameters, the second consisting of the text <em>5, 4, 3</em>.</font></p>

<p><font face="Arial" size="2">The last macro operator of interest is the &quot;;;&quot;
operator. This operator begins a macro comment. MASM normally copies all text from the
macro into the body of the program during assembly, including all comments. However, if
you begin a comment with &quot;;;&quot; rather than a single semicolon, MASM will not
expand the comment as part of the code during macro expansion. This increases the speed of
assembly by a tiny amount and, more importantly, it does not clutter a program listing
with copies of the same comment (see &quot;Controlling the Listing&quot; to learn about
program listings). </font></p>
<div align="center"><center>

<table BORDER="1" bordercolor="#C0C0C0" cellspacing="0" cellpadding="0" width="30%">
  <caption><strong><font face="Arial" size="2">Macro Operators</font></strong></caption>
  <tr>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">Operator</font></th>
    <th bgcolor="#F0F0F0"><font face="Arial" size="2">Description</font></th>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">&amp;</font></td>
    <td><font face="Arial" size="2">Text substitution operator</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">&lt; &gt;</font></td>
    <td><font face="Arial" size="2">Literal text operator</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">!</font></td>
    <td><font face="Arial" size="2">Literal character operator</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">%</font></td>
    <td><font face="Arial" size="2">Expression operator</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">;;</font></td>
    <td><font face="Arial" size="2">Macro comment</font></td>
  </tr>
</table>
</center></div>

<p><strong><font face="Arial" size="3"><a NAME="HEADING7-389"></a>8.14.6 A Sample Macro to
Implement For Loops</font></strong></p>

<p><font face="Arial" size="2">Remember the for loops and matrix operations used in a
previous example? At the conclusion of that section there was a brief comment that we
could &quot;improve&quot; that code even more using macros, but the example had to wait.
With the description of macro operators out of the way, we can now finish that discussion.
The macros that implement the <code>for</code> loop are </font></p>

<pre><font face="Courier New" size="2">; First, three macros that let us construct symbols by concatenating others.
; This is necessary because this code needs to expand several components in
; text equates multiple times to arrive at the proper symbol. 
;
; MakeLbl-      Emits a label create by concatenating the two parameters
;               passed to this macro.

MakeLbl         macro   FirstHalf, SecondHalf
&amp;FirstHalf&amp;&amp;SecondHalf&amp;:
                endm

jgDone          macro   FirstHalf, SecondHalf
                jg      &amp;FirstHalf&amp;&amp;SecondHalf&amp;
                endm

jmpLoop         macro   FirstHalf, SecondHalf
                jmp     &amp;FirstHalf&amp;&amp;SecondHalf&amp;
                endm

; ForLp-                This macro appears at the beginning of the for loop. To invoke
;               this macro, use a statement of the form:
;
;               ForLp   LoopCtrlVar, StartVal, StopVal
;
; Note: &quot;FOR&quot; is a MASM reserved word, which is why this macro doesn't
; use that name.

ForLp           macro   LCV, Start, Stop

; We need to generate a unique, global symbol for each for loop we create.
; This symbol needs to be global because we will need to reference it at the
; bottom of the loop. To generate a unique symbol, this macro concatenates
; &quot;FOR&quot; with the name of the loop control variable and a unique numeric value
; that this macro increments each time the user constructs a for loop with the
; same loop control variable.

                ifndef  $$For&amp;LCV&amp;      ;;Symbol = $$FOR concatenated with LCV
$$For&amp;LCV&amp;      =       0               ;;If this is the first loop w/LCV, use
                else                    ;; zero, otherwise increment the value.
$$For&amp;LCV&amp;      =       $$For&amp;LCV&amp; + 1
                endif

; Emit the instructions to initialize the loop control variable:

                mov     ax, Start
                mov     LCV, ax

; Output the label at the top of the for loop. This label takes the form
;               $$FOR LCV x
; where LCV is the name of the loop control variable and X is a unique number
; that this macro increments for each for loop that uses the same loop control
; variable.

                MakeLbl $$For&amp;LCV&amp;, %$$For&amp;LCV&amp;

; Okay, output the code to see if this for loop is complete.
; The jgDone macro generates a jump (if greater) to the label the
; Next macro emits below the bottom of the for loop.

                mov     ax, LCV
                cmp     ax, Stop
                jgDone  $$Next&amp;LCV&amp;, %$$For&amp;LCV&amp;
                endm

; The Next macro terminates the for loop. This macro increments the loop
; control variable and then transfers control back to the label at the top of
; the for loop.

Next            macro   LCV
                inc     LCV
                jmpLoop $$For&amp;LCV&amp;, %$$For&amp;LCV&amp;
                MakeLbl $$Next&amp;LCV&amp;, %$$For&amp;LCV&amp;
                endm</font></pre>

<p><font face="Arial" size="2">With these macros and the LDAX/STAX macros, the code from
the array manipulation example presented earlier becomes very simple. It is </font></p>

<pre><font face="Courier New" size="2">                ForLp   I, 0, 15
                ForLp   J, 0, 6

                ldax    A, I, J         ;Fetch A[I][J]
                mov     bx, 15          ;Compute 16-I.
                sub     bx, I
                ldax    b, bx, J, imul  ;Multiply in B[15-I][J].
                stax    x, J, I         ;Store to X[J][I]

                Next    J
                Next    I</font></pre>

<p><font face="Arial" size="2">Although this code isn't quite as short as the original
C/C++ example, it's getting pretty close!</font></p>

<p><font face="Arial" size="2">While the main program became much simpler, there is a
question of the macros themselves. The <code>ForLp</code> and <code>Next</code> macros are
extremely complex! If you had to go through this effort every time you wanted to create a
macro, assembly language programs would be ten times harder to write if you decided to use
macros. Fortunately, you only have to write (and debug) a macro like this once. Then you
can use it as many times as you like, in many different programs, without having to worry
much about it's implementation. </font></p>

<p><font face="Arial" size="2">Given the complexity of the <code>For</code> and <code>Next</code>
macros, it is probably a good idea to carefully describe what each statement in these
macros is doing. However, before discussing the macros themselves, we should discuss
exactly how one might implement a <code>for/next</code> loop in assembly language. This
text fully explores the for loop a little later, but we can certainly go over the basics
here. Consider the following Pascal <code>for</code> loop: </font></p>

<pre><font face="Courier New" size="2">        for variable := StartExpression to EndExpression do
                Some_Statement;</font></pre>

<p><font face="Arial" size="2">Pascal begins by computing the value of <code>StartExpression</code>.
It then assigns this value to the loop control variable (<code>variable</code>). It then
evaluates <code>EndExpression</code> and saves this value in a temporary location. Then
the Pascal <code>for</code> statement enters the loop's body. The first thing the loop
does is compare the value of <code>variable</code> against the value it computed for <code>EndExpression</code>.
If the value of <code>variable</code> is greater than this value for <code>EndExpression</code>,
Pascal transfers to the first statement after the <code>for</code> loop, otherwise it
executes <code>Some_Statement</code>. After the Pascal for loop executes <code>Some_Statement</code>,
it adds one to <code>variable</code> and jumps back to the point where it compares the
value of <code>variable</code> against the computed value for <code>EndExpression</code>.
Converting this code directly into assembly language yields the following code: </font></p>

<pre><font face="Courier New" size="2">;Note: This code assumes StartExpression and EndExpression are simple variables.
;If this is not the case, compute the values for these expression and place
;them in these variables.

                mov     ax, StartExpression
                mov     Variable, ax
ForLoop:        mov     ax, Variable
                cmp     ax, EndExpression
                jg      ForDone

        &lt;Code for Some_Statement&gt;

                inc     Variable
                jmp     ForLoop
ForDone:</font></pre>

<p><font face="Arial" size="2">To implement this as a set of macros, we need to be able to
write a short piece of code that will write the above assembly language statements for us.
At first blush, this would seem easy, why not use the following code? </font></p>

<pre><font face="Courier New" size="2">ForLp           macro   Variable, Start, Stop
                mov     ax, Start
                mov     Variable, ax
ForLoop:        mov     ax, Variable
                cmp     ax, Stop
                jg      ForDone
                endm

Next            macro   Variable
                inc     Variable
                jmp     ForLoop
ForDone:
                endm</font></pre>

<p><font face="Arial" size="2">These two macros would produce correct code - exactly once.
However, a problem develops if you try to use these macros a second time. This is
particularly evident when using nested loops:</font> </p>

<pre><font face="Courier New" size="2">                ForLp   I, 1, 10
                ForLp   J, 1, 10
                 .
                 .
                 .
                Next    J
                Next    I</font></pre>

<p><font face="Arial" size="2">The macros above emit the following 80x86 code: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, 1           ;The ForLp I, 1, 10
                mov     I, ax           ; macro emits these
ForLoop:        mov     ax, I           ; statements.
                cmp     ax, 10          ;       .
                jg      ForDone         ;       .

                mov     ax, 1           ;The ForLp J, 1, 10
                mov     J, ax           ; macro emits these
ForLoop:        mov     ax, J           ; statements.
                cmp     ax, 10          ;        .
                jg      ForDone         ;        .
                 .
                 .
                 .
                inc     J               ;The Next J macro emits these
                jmp     ForLp           ; statements.
ForDone:
                inc     I               ;The Next I macro emits these
                jmp     ForLp           ; statements.
ForDone:</font></pre>

<p><font face="Arial" size="2">The problem, evident in the code above, is that each time
you use the <code>ForLp</code> macro you emit the label &quot;<code>ForLoop</code>&quot;
to the code. Likewise, each time you use the <code>Next</code> macro, you emit the label
&quot;<code>ForDone</code>&quot; to the code stream. Therefore, if you use these macros
more than once (within the same procedure), you will get a duplicate symbol error. To
prevent this error, the macros must generate unique labels each time you use them.
Unfortunately, the <code>local</code> directive will not work here. The <code>local</code>
directive defines a unique symbol within a single macro invocation. If you look carefully
at the code above, you'll see that the <code>ForLp</code> macro emits a symbol that the
code in the <code>Next</code> macro references. Likewise, the <code>Next</code> macro
emits a label that the <code>ForLp</code> macro references. Therefore, the label names
must be global since the two macros can reference each other's labels.</font></p>

<p><font face="Arial" size="2">The solution the actual <code>ForLp</code> and <code>Next</code>
macros use is to generate globally known labels of the form &quot;$$For&quot; +
&quot;variable name&quot; + &quot;some unique number.&quot; and &quot;$$Next&quot; +
&quot;variable name&quot; + &quot;some unique number&quot;. For the example given above,
the real <code>ForLp</code> and <code>Next</code> macros would generate the following
code: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, 1           ;The ForLp I, 1, 10
                mov     I, ax           ; macro emits these
$$ForI0:        mov     ax, I           ; statements.
                cmp     ax, 10          ;       .
                jg      $$NextI0        ;       .

                mov     ax, 1           ;The ForLp J, 1, 10
                mov     J, ax           ; macro emits these
$$ForJ0:        mov     ax, J           ; statements.
                cmp     ax, 10          ;        .
                jg      $$NextJ0        ;        .
                 .
                 .
                 .
                inc     J               ;The Next J macro emits these
                jmp     $$ForJ0         ; statements.
$$NextJ0:
                inc     I               ;The Next I macro emits these
                jmp     $$ForI0         ; statements.
$$NextI0:</font></pre>

<p><font face="Arial" size="2">The real question is, &quot;How does one generate such
labels?&quot;</font></p>

<p><font face="Arial" size="2">Constructing a symbol of the form &quot;<code>$$ForI</code>&quot;
or &quot;<code>$$NextJ</code>&quot; is pretty easy. Just create a symbol by concatenating
the string &quot;<code>$$For</code>&quot; or &quot;<code>$$Next</code>&quot; with the loop
control variable's name. The problem occurs when you try to append a numeric value to the
end of that string. The actual <code>ForLp</code> and <code>Next</code> code accomplishes
this creating assembly time variable names of the form &quot;<code>$$Forvariable_name</code>&quot;
and incrementing this variable for each loop with the given loop control variable name. By
calling the macros <code>MakeLbl</code>, <code>jgDone</code>, and <code>jmpLoop, ForLp </code>and<code>
Next </code>output<code> </code>the appropriate labels and ancillary instructions. </font></p>

<p><font face="Arial" size="2">The <code>ForLp</code> and <code>Next</code> macros are
very complex. Far more complex than you would typically find in a program. They do,
however, demonstrate the power of MASM's macro facilities. By the way, there are much
better ways to create these symbols using macro functions. We'll discuss macro functions
next.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH08-6.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH08-6.html">Chapter Eight</a> (Part 6)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH08-8.html">Chapter Eight</a> (Part 8) </strong></font><a href="CH08-8.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Eight: MASM: Directives &amp;
Pseudo-Opcodes (Part 7)<br>
26 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_8/CH08-7.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:37 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
