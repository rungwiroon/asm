<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_8/CH08-2.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:30 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER EIGHT: MASM: DIRECTIVES &amp; PSEUDO-OPCODES (Part 2)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING2"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH08-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH08-1.html">Chapter Eight</a> (Part 1)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH08-3.html">Chapter Eight</a> (Part 3) </strong></font><a href="CH08-3.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10" colspan="2"><a NAME="HEADING2-0"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0" colspan="2"><font face="Arial" size="4"><strong>CHAPTER
    EIGHT:<br>
    MASM: DIRECTIVES &amp; PSEUDO-OPCODES (Part 2)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10" colspan="2"></td>
  </tr>
  <tr>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING2-1"><b>8.8 </b>-
    Segments</a> <br>
    <a HREF="#HEADING2-16"><b>8.8.1 </b>- Segment Names</a> <br>
    <a HREF="#HEADING2-48"><b>8.8.2 </b>- Segment Loading Order</a> </font></td>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING2-72"><b>8.8.3 </b>-
    Segment Operands</a> <br>
    <a HREF="#HEADING2-74"><b>8.8.3.1 </b>- The ALIGN Type</a> <br>
    <a HREF="#HEADING2-164"><b>8.8.3.2 </b>- The COMBINE Type</a> </font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="20" colspan="2"></td>
  </tr>
  <tr>
    <td width="100%" colspan="2"><strong><font face="Arial" size="3"><a NAME="HEADING2-1"></a>8.8
    Segments</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="1" colspan="2" bgcolor="#000000"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">All programs consist of one or more segments. Of course,
while your program is running, the 80x86's segment registers point at the currently active
segments. On 80286 and earlier processors, you can have up to four active segments at once
(code, data, extra, and stack); on the 80386 and later processors, there are two
additional segment registers: <code>fs</code> and <code>gs</code>. Although you cannot
access data in more than four or six segments at any one given instant, you can modify the
80x86's segment registers and point them at other segments in memory under program
control. This means that a program can access more than four or six segments. The question
is &quot;how do you create these different segments in a program and how do you access
them at run-time?&quot;</font></p>

<p><font face="Arial" size="2">Segments, in your assembly language source file, are
defined with the <code>segment </code>and <code>ends </code>directives. You can put as
many segments as you like in your program. Well, actually you are limited to 65,536
different segments by the 80x86 processors and MASM probably doesn't even allow that many,
but you will probably never exceed the number of segments MASM allows you to put in your
program. </font></p>

<p><font face="Arial" size="2">When MS-DOS begins execution of your program, it
initializes two segment registers. It points <code>cs</code> at the segment containing
your main program and it points <code>ss</code> at your stack segment. From that point
forward, you are responsible for maintaining the segment registers yourself.</font></p>

<p><font face="Arial" size="2">To access data in some particular segment, an 80x86 segment
register must contain the address of that segment. If you access data in several different
segments, your program will have to load a segment register with that segment's address
before accessing it. If you are frequently accessing data in different segments, you will
spend considerable time reloading segment registers. Fortunately, most programs exhibit
locality of reference when accessing data. This means that a piece of code will likely
access the same group of variables many times during a given time period. It is easy to
organize your programs so that variables you often access together appear in the same
segment. By arranging your programs in this manner, you can minimize the number of times
you need to reload the segment registers. In this sense, a segment is nothing more than a
cache of often accessed data.</font></p>

<p><font face="Arial" size="2">In real mode, a segment can be up to 64 Kilobytes long.
Most pure assembly language programs use less than 64K code, 64K global data, and 64K
stack space. Therefore, you can often get by with no more than three or four segments in
your programs. In fact, the SHELL.ASM file (containing the skeletal assembly language
program) only defines four segments and you will generally only use three of them. If you
use the SHELL.ASM file as the basis for your programs, you will rarely need to worry about
segmentation on the 80x86. On the other hand, if you want to write complex 80x86 programs,
you will need to understand segmentation.</font></p>

<p><font face="Arial" size="2">A segment in your file should take the following form: </font></p>

<pre><font face="Courier New" size="2">segmentname     segment    {READONLY} {align} {combine} {use} {'class'}

             &lt;statements&gt;

segmentname     ends</font></pre>

<p><font face="Arial" size="2">The following sections describe each of the operands to the
<code>segment</code> directive.</font></p>

<p><font face="Arial" size="2">Note: segmentation is a concept that many beginning
assembly language programmers find difficult to understand. Note that you do not have to
completely understand segmentation to begin writing 80x86 assembly language programs. If
you make a copy of the SHELL.ASM file for each program you write, you can effectively
ignore segmentation issues. The main purpose of the SHELL.ASM file is to take care of the
segmentation details for you. As long as you don't write extremely large programs or use a
vast amount of data, you should be able to use SHELL.ASM and forget about segmentation.
Nonetheless, eventually you may want to write larger assembly language programs, or you
may want to write assembly language subroutines for a high level language like Pascal or
C++. At that point you will need to know quite a bit about segmentation. The bottom line
is this, you can get by without having to learn about segmentation right now, but sooner
or later you will need to understand it if you intend to continue writing 80x86 assembly
language code.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-16"></a>8.8.1 Segment Names</font></strong></p>

<p><font face="Arial" size="2">The segment directive requires a label in the label field.
This label is the segment's name. MASM uses segment names for three purposes: to combine
segments, to determine if a segment override prefix is necessary, and to obtain the
address of a segment. You must also specify the segment's name in the label field of the <code>ends</code>
directive that ends the segment.</font></p>

<p><font face="Arial" size="2">If the segment name is not unique (i.e., you've defined it
somewhere else in the program), the other uses must also be segment definitions. If there
is another segment with this same name, then the assembler treats this segment definition
as a continuation of the previous segment using the same name. Each segment has its own
location counter value associated with it. When you begin a new segment (that is, one
whose name has not yet appeared in the source file) MASM creates a new location counter
variable, initially zero, for the segment. If MASM encounters a segment definition that is
a continuation of a previous segment, then MASM uses the value of the location counter at
the end of that previous segment. E.g., </font></p>

<pre><font face="Courier New" size="2">CSEG            segment
                mov             ax, bx
                ret
CSEG            ends

DSEG            segment
Item1           byte            0 
Item2           word            0 
DSEG            ends

CSEG            segment
                mov             ax, 10
                add             ax, Item1
                ret
CSEG            ends
                end</font></pre>

<p><font face="Arial" size="2">The first segment (<code>CSEG</code>) starts with a
location counter value of zero. The <code>mov ax,bx </code>instruction is two bytes long
and the <code>ret </code>instruction is one byte long, so the location counter is three at
the end of the segment. <code>DSEG</code> is another three byte segment, so the location
counter associated with <code>DSEG</code> also contains three at the end of the segment.
The third segment has the same name as the first segment (<code>CSEG</code>), therefore
the assembler will assume that they are the same segment with the second occurrence simply
being an extension of the first. Therefore, code placed in the second <code>CSEG</code>
segment will be assembled starting at offset three within <code>CSEG</code> - effectively
continuing the code in the first <code>CSEG</code> segment.</font></p>

<p><font face="Arial" size="2">Whenever you specify a segment name as an operand to an
instruction, MASM will use the immediate addressing mode and substitute the address of
that segment for its name. Since you cannot load an immediate value into a segment
register with a single instruction, loading the segment address into a segment register
typically takes two instructions. For example, the following three instructions appear at
the beginning of the SHELL.ASM file, they initialize the <code>ds</code> and <code>es</code>
registers so they point at the <code>dseg</code> segment: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, dseg        ;Loads ax with segment address of dseg.
                mov     ds, ax          ;Point ds at dseg.
                mov     es, ax          ;Point es at dseg.</font></pre>

<p><font face="Arial" size="2">The other purpose for segment names is to provide the
segment component of a variable name. Remember, 80x86 addresses contain two components: a
segment and an offset. Since the 80x86 hardware defaults most data references to the data
segment, it is common practice among assembly language programmers to do the same thing;
that is, not bother to specify a segment name when accessing variables in the data
segment. In fact, a full variable reference consists of the segment name, a colon, and the
offset name: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, dseg:Item1
                mov     dseg:Item2, ax</font></pre>

<p><font face="Arial" size="2">Technically, you should prefix all your variables with the
segment name in this fashion. However, most programmers don't bother because of the extra
typing involved. Most of the time you can get away with this; however, there are a few
times when you really will need to specify the segment name. Fortunately, those situations
are rare and only occur in very complex programs, not the kind you're likely to run into
for a while.</font></p>

<p><font face="Arial" size="2">It is important that you realize that specifying a segment
name before a variable's name does not mean that you can access data in a segment without
having some segment register pointing at that segment. Except for the <code>jmp</code> and
<code>call</code> instructions, there are no 80x86 instructions that let you specify a
full 32 bit segmented direct address. All other memory references use a segment register
to supply the segment component of the address.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-48"></a>8.8.2 Segment Loading
Order</font></strong></p>

<p><font face="Arial" size="2">Segments normally load into memory in the order that they
appear in your source file. In the example above, DOS would load the <code>CSEG</code>
segment into memory before the <code>DSEG</code> segment. Even though the <code>CSEG</code>
segment appears in two parts, both before and after <code>DSEG</code>. <code>CSEG</code>'s
declaration before any occurrence of <code>DSEG</code> tells DOS to load the entire <code>CSEG</code>
segment into memory before <code>DSEG</code>. To load <code>DSEG</code> before <code>CSEG</code>,
you could use the following program: </font></p>

<pre><font face="Courier New" size="2">DSEG            segment public
DSEG            ends

CSEG            segment public
                mov     ax, bx
                ret
CSEG            ends

DSEG            segment public
Item1           byte    0
Item2           word    0
DSEG            ends

CSEG            segment public
                mov     ax, 10
                add     ax, Item1
                ret
CSEG            ends
                end</font></pre>

<p><font face="Arial" size="2">The empty segment declaration for <code>DSEG</code> doesn't
emit any code. The location counter value for <code>DSEG</code> is zero at the end of the
segment definition. Hence it's zero at the beginning of the next <code>DSEG</code>
segment, exactly as it was in the previous version of this program. However, since the <code>DSEG</code>
declaration appears first in the program, DOS will load it into memory first.</font></p>

<p><font face="Arial" size="2">The order of appearance is only one of the factors
controlling the loading order. For example, if you use the &quot;<code>.alpha</code>&quot;
directive, MASM will organize the segments alphabetically rather than in order of first
appearance. The optional operands to the segment directive also control segment loading
order. These operands are the subject of the next section.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-72"></a>8.8.3 Segment Operands</font></strong></p>

<p><font face="Arial" size="2">The <code>segment </code>directive allows six different
items in the operand field: an align operand, a combine operand, a class operand, a <code>readonly</code>
operand, a &quot;<code>uses</code>&quot; operand, and a size operand. Three of these
operands control how DOS loads the segment into memory, the other three control code
generation.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-74"></a>8.8.3.1 The ALIGN Type</font></strong></p>

<p><font face="Arial" size="2">The align parameter is one of the following words: <code>byte,
word, dword, para,</code> or <code>page</code>. These keywords instruct the assembler,
linker, and DOS to load the segment on a byte, word, double word, paragraph, or page
boundary. The align parameter is optional. If one of the above keywords does not appear as
a parameter to the segment directive, the default alignment is paragraph (a paragraph is a
multiple of 16 bytes).</font></p>

<p><font face="Arial" size="2">Aligning a segment on a byte boundary loads the segment
into memory starting at the first available byte after the last segment. Aligning on a
word boundary will start the segment at the first byte with an even address after the last
segment. Aligning on a <code>dword </code>boundary will locate the current segment at the
first address that is an even multiple of four after the last segment. </font></p>

<p><font face="Arial" size="2">For example, if segment #1 is declared first in your source
file and segment #2 immediate follows and is byte aligned, the segments will be stored in
memory as follows:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch08a.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/ch08a.gif" ALIGN="bottom" NATURALSIZEFLAG="3" WIDTH="347" HEIGHT="79"> </font></p>

<pre><font face="Courier New" size="2">seg1            segment
                 .
                 .
                 .
seg1            ends

seg2            segment byte
                 .
                 .
                 .
seg2            ends</font></pre>

<p><font face="Arial" size="2">If segments one and two are declared as below, and segment
#2 is word aligned, the segments appear in memory as shown below:</font></p>

<p align="center"><img SRC="images/ch08a1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/ch08a1.gif" ALIGN="bottom" NATURALSIZEFLAG="3" WIDTH="413" HEIGHT="99"> </p>

<pre><font face="Courier New" size="2">seg1            segment
                 .
                 .
                 .
seg1            ends

seg2            segment word
                 .
                 .
                 .
seg2            ends</font></pre>

<p><font face="Arial" size="2">Another example: if segments one and two are as below, and
segment #2 is double word aligned, the segments will be stored in memory as shown below:</font></p>

<p align="center"><img SRC="images/ch08a2.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/ch08a2.gif" ALIGN="bottom" NATURALSIZEFLAG="3" WIDTH="422" HEIGHT="99"> </p>

<pre><font face="Courier New" size="2">seg1            segment
                 .
                 .
                 .
seg1            ends

seg2            segment dword
                 .
                 .
                 .
seg2            ends</font></pre>

<p><font face="Arial" size="2">Since the 80x86's segment registers always point at
paragraph addresses, most segments are aligned on a 16 byte paragraph (<code>para</code>)
boundary. For the most part, your segments should always be aligned on a paragraph
boundary unless you have a good reason to choose otherwise. </font></p>

<p><font face="Arial" size="2">For example, if segments one and two are declared as below,
and segment #2 is paragraph aligned, DOS will store the segments in memory as shown below:</font></p>

<p align="center"><img SRC="images/ch08a3.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/ch08a3.gif" ALIGN="bottom" NATURALSIZEFLAG="3" WIDTH="411" HEIGHT="99"> </p>

<pre><font face="Courier New" size="2">seg1            segment
                 .
                 .
                 .
seg1            ends

seg2            segment para
                 .
                 .
                 .
seg2            ends</font></pre>

<p><font face="Arial" size="2">Page boundary alignment forces the segment to begin at the
next address that is an even multiple of 256 bytes. Certain data buffers may require
alignment on 256 (or 512) byte boundaries. The page alignment option can be useful in this
situation. </font></p>

<p><font face="Arial" size="2">For example, if segments one and two are declared as below,
and segment #2 is page aligned, the segments will be stored in memory as shown below:</font></p>

<p align="center"><img SRC="images/ch08a4.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/ch08a4.gif" ALIGN="bottom" NATURALSIZEFLAG="3" WIDTH="405" HEIGHT="99"> </p>

<pre><font face="Courier New" size="2">seg1            segment
                 .
                 .
                 .
seg1            ends

seg2            segment page
                 .
                 .
                 .
seg2            ends</font></pre>

<p><font face="Arial" size="2">If you choose any alignment other than <code>byte</code>,
the assembler, linker, and DOS may insert several dummy bytes between the two segments, so
that the segment is properly aligned. Since the 80x86 segment registers must always point
at a paragraph address (that is, they must be paragraph aligned), you might wonder how the
processor can address a segment that is aligned on a byte, word, or double word boundary.
It's easy. Whenever you specify a segment alignment which forces the segment to begin at
an address that is not a paragraph boundary, the assembler/linker will assume that the
segment register points at the previous paragraph address and the location counter will
begin at some offset into that segment other than zero. For example, suppose that segment
#1 above ends at physical address 10F87h and segment #2 is byte aligned. The code for
segment #2 will begin at segment address 10F80h. However, this will overlap segment #1 by
eight bytes. To overcome this problem, the location counter for segment #2 will begin at
8, so the segment will be loaded into memory just beyond segment #1.</font></p>

<p><font face="Arial" size="2">If segment #2 is byte aligned and segment #1 doesn't end at
an even paragraph address, MASM adjusts the starting location counter for segment #2 so
that it can use the previous paragraph address to access it:</font></p>

<p align="center"><img SRC="images/ch08a5.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/ch08a5.gif" ALIGN="bottom" NATURALSIZEFLAG="3" WIDTH="446" HEIGHT="111"> </p>

<p><font face="Arial" size="2">Since the 80x86 requires all segments to start on a
paragraph boundary in memory, the Microsoft Assembler (by default) assumes that you want
paragraph alignment for your segments. The following segment definition is always aligned
on a paragraph boundary: </font></p>

<pre><font face="Courier New" size="2">CSEG            segment
                mov     ax, bx
                ret
CSEG            ends
                end</font></pre>

<pre><strong><font face="Arial" size="3">8.8.3.2 The COMBINE Type</font></strong></pre>

<p><font face="Arial" size="2">The combine type controls the order that segments with the
same name are written out to the object code file produced by the assembler. To specify
the combine type you use one of the keywords <code>public</code>, <code>stack</code>, <code>common</code>,
<code>memory</code>, or <code>at</code>. <code>Memory </code>is a synonym for <code>public
</code>provided for compatibility reasons; you should always use <code>public </code>rather
than <code>memory</code>. <code>Common </code>and <code>at </code>are advanced combine
types that won't be considered in this text. The <code>stack </code>combine type should be
used with your stack segments. The <code>public </code>combine type should be used with
most everything else. </font></p>

<p><font face="Arial" size="2">The <code>public </code>and <code>stack </code>combine
types essentially perform the same operation. They concatenate segments with the same name
into a single contiguous segment, just as described earlier. The difference between the
two is the way that DOS handles the initialization of the stack segment and stack pointer
registers. All programs should have at least one <code>stack </code>type segment (or the
linker will generate a warning); the rest should all be <code>public </code>. MS-DOS will
automatically point the stack segment register at the segment you declare with the <code>stack
</code>combine type when it loads the program into memory.</font></p>

<p><font face="Arial" size="2">If you do not specify a combine type, then the assembler
will not concatenate the segments when producing the object code file. In effect, the
absence of any combine type keyword produces a private combine type by default. Unless the
class types are the same (see the next section), each segment will be emitted as MASM
encounters it in the source file. For example, consider the following program: </font></p>

<pre><font face="Courier New" size="2">CSEG            segment public
                mov     ax, 0
                mov     VAR1, ax
CSEG            ends

DSEG            segment public
I               word    ?
DSEG            ends

CSEG            segment public
                mov     bx, ax
                ret
CSEG            ends

DSEG            segment public
J               word    ?
DSEG            ends
                end</font></pre>

<p><font face="Arial" size="2">This program section will produce the same code as: </font></p>

<pre><font face="Courier New" size="2">CSEG            segment public
                mov     ax, 0
                mov     VAR1, ax
                mov     bx, ax
                ret
CSEG            ends

DSEG            segment public
I               word    ?
J               word    ?
DSEG            ends
                end</font></pre>

<p><font face="Arial" size="2">The assembler automatically joins all segments that have
the same name and are public. The reason the assembler allows you to separate the segments
like this is for convenience. Suppose you have several procedures, each of which requires
certain variables. You could declare all the variables in one segment somewhere, but this
is often distracting. Most people like to declare their variables right before the
procedure that uses them. By using the public combine type with the segment declaration,
you may declare your variables right before using them and the assembler will
automatically move those variable declarations into the proper segment when assembling the
program. For example, </font></p>

<pre><font face="Courier New" size="2">CSEG            segment public

; This is procedure #1

DSEG            segment public

;Local vars for proc #1.

VAR1            word    ?
DSEG            ends

                mov     AX, 0
                mov     VAR1, AX
                mov     BX, AX
                ret

; This is procedure #2

DSEG            segment public
I               word    ?
J               word    ?
DSEG            ends

                mov     ax, I
                add     ax, J
                ret
CSEG            ends
                end</font></pre>

<p><font face="Arial" size="2">Note that you can nest segments any way you please.
Unfortunately, Microsoft's Macro Assembler scoping rules do not work the same way as a HLL
like Pascal. Normally, once you define a symbol within your program, it is visible
everywhere else in the program.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH08-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH08-1.html">Chapter Eight</a> (Part 1)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH08-3.html">Chapter Eight</a> (Part 3) </strong></font><a href="CH08-3.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Eight: MASM: Directives &amp;
Pseudo-Opcodes (Part 2)<br>
26 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_8/CH08-2.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:36 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
