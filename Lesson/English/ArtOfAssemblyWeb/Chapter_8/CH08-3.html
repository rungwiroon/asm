<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_8/CH08-3.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:36 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER EIGHT: MASM: DIRECTIVES &amp; PSEUDO-OPCODES (Part 3)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING3"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH08-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH08-1.html">Chapter Eight</a> (Part 2)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH08-4.html">Chapter Eight</a> (Part 4) </strong></font><a href="CH08-4.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10" colspan="2"><a NAME="HEADING3-0"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0" colspan="2"><font face="Arial" size="4"><strong>CHAPTER
    EIGHT:<br>
    MASM: DIRECTIVES &amp; PSEUDO-OPCODES (Part 3)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10" colspan="2"></td>
  </tr>
  <tr>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING3-1"><b>8.8.4 </b>-
    The CLASS Type</a> <br>
    <a HREF="#HEADING3-34"><b>8.8.5 </b>- The Read-only Operand</a> <br>
    <a HREF="#HEADING3-42"><b>8.8.6 </b>- The USE16, USE32, and FLAT Options</a> <br>
    <a HREF="#HEADING3-55"><b>8.8.7 </b>- Typical Segment Definitions</a> <br>
    <a HREF="#HEADING3-76"><b>8.8.8 </b>- Why You Would Want to Control the Loading Order</a> </font></td>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING3-94"><b>8.8.9 </b>-
    Segment Prefixes</a> <br>
    <a HREF="#HEADING3-98"><b>8.8.10 </b>- Controlling Segments with the ASSUME Directive</a> <br>
    <a HREF="#HEADING3-192"><b>8.8.11 </b>- Combining Segments: The GROUP Directive</a> <br>
    <a HREF="#HEADING3-295"><b>8.8.12 </b>- Why Even Bother With Segments?</a> </font></td>
  </tr>
  <tr>
    <td width="100%" colspan="2" nowrap height="20"></td>
  </tr>
</table>
</center></div>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-1"></a>8.8.4 The CLASS Type</font></strong></p>

<p><font face="Arial" size="2">The final operand to the <code>segment </code>directive is
usually the class type. The class type specifies the ordering of segments that do not have
the same segment name. This operand consists of a symbol enclosed by apostrophes
(quotation marks are not allowed here). Generally, you should use the following names:
CODE (for segments containing program code); DATA (for segments containing variables,
constant data, and tables); CONST (for segments containing constant data and tables); and
STACK (for a stack segment). The following program section illustrates their use: </font></p>

<pre><font face="Courier New" size="2">CSEG            segment public 'CODE'
                mov     ax, bx
                ret
CSEG            ends

DSEG            segment public 'DATA'
Item1           byte    0
Item2           word    0
DSEG            ends

CSEG            segment public 'CODE'
                mov     ax, 10
                add     AX, Item1
                ret
CSEG            ends

SSEG            segment stack 'STACK'
STK             word    4000 dup (?)
SSEG            ends

C2SEG           segment public 'CODE'
                ret
C2SEG           ends
                end</font></pre>

<p><font face="Arial" size="2">The actual loading procedure is accomplished as follows.
The assembler locates the first segment in the file. Since it's a <code>public </code>combined
segment, MASM concatenates all other <code>CSEG</code> segments to the end of this
segment. Finally, since its combine class is '<code>CODE</code>', MASM appends all
segments (<code>C2SEG</code>) with the same class afterwards. After processing these
segments, MASM scans the source file for the next uncombined segment and repeats the
process. In the example above, the segments will be loaded in the following order: <code>CSEG</code>,
<code>CSEG</code> (2nd occurrence), <code>C2SEG</code>, <code>DSEG</code>, and then <code>SSEG</code>.
The general rule concerning how your files will be loaded into memory is the following: </font>

<ul>
  <li><font face="Arial" size="2">(1) The assembler combines all public segments that have the
    same name. </font></li>
  <li><font face="Arial" size="2">(2) Once combined, the segments are output to the object
    code file in the order of their appearance in the source file. If a segment name appears
    twice within a source file (and it's public), then the combined segment will be output to
    the object code file at the position denoted by the first occurrence of the segment within
    the source file. </font></li>
  <li><font face="Arial" size="2">(3) The linker reads the object code file produced by the
    assembler and rearranges the segments when creating the executable file. The linker begins
    by writing the first segment found in the object code file to the .EXE file. Then it
    searches throughout the object code file for every segment with the same class name. Such
    segments are sequentially written to the .EXE file. </font></li>
  <li><font face="Arial" size="2">(4) Once all the segments with the same class name as the
    first segment are emitted to the .EXE file, the linker scans the object code file for the
    next segment which doesn't belong to the same class as the previous segment(s). It writes
    this segment to the .EXE file and repeats step (3) for each segment belonging to this
    class. </font></li>
  <li><font face="Arial" size="2">(5) Finally, the linker repeats step (4) until it has linked
    all the segments in the object code file. </font></li>
</ul>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-34"></a>8.8.5 The Read-only
Operand</font></strong></p>

<p><font face="Arial" size="2">If <code>readonly<em> </em></code>is the first operand of
the <code>segment </code>directive, the assembler will generate an error if it encounters
any instruction that attempts to write to this segment. This is most useful for code
segments, though is it possible to imagine a read-only data segment. This option does not
actually prevent you from writing to this segment at run-time. It is very easy to trick
the assembler and write to this segment anyway. However, by specifying <code>readonly </code>you
can catch some common programming errors you would otherwise miss. Since you will rarely
place writable variables in your code segments, it's probably a good idea to make your
code segments <code>readonly</code>.</font></p>

<p><font face="Arial" size="2">Example of <code>READONLY</code> operand: </font></p>

<pre><font face="Courier New" size="2">seg1            segment readonly para public 'DATA'
                 .
                 .
                 .
seg1            ends</font></pre>

<pre><strong><font face="Arial" size="3">8.8.6 The USE16, USE32, and FLAT Options</font></strong></pre>

<p><font face="Arial" size="2">When working with an 80386 or later processor, MASM
generates different code for 16 versus 32 bit segments. When writing code to execute in
real mode under DOS, you must always use 16 bit segments. Thirty-two bit segments are only
applicable to programs running in protected mode. Unfortunately, MASM often defaults to 32
bit mode whenever you select an 80386 or later processor using a directive like<code>
.386,</code> <code>.486, </code>or<code> .586 </code>in your program. If you want to use
32 bit instructions, you will have to explicitly tell MASM to use 16 bit segments. The <code>use16</code>,<code>
use32</code>, and <code>flat </code>operands to the <code>segment </code>directive let you
specify the segment size.</font></p>

<p><font face="Arial" size="2">For most DOS programs, you will always want to use the <code>use16
</code>operand. This tells MASM that the segment is a 16 bit segment and it assembles the
code accordingly. If you use one of the directives to activate the 80386 or later
instruction sets, you should put <code>use16 </code>in all your code segments or MASM will
generate bad code.</font></p>

<p><font face="Arial" size="2">Example of <code>use16 </code>operand: </font></p>

<pre><font face="Courier New" size="2">seg1            segment para public use16 'data'
                 .
                 .
                 .
seg1            ends</font></pre>

<p><font face="Arial" size="2">The <code>use32 </code>and <code>flat </code>operands tell
MASM to generate code for a 32 bit segment. Since this text does not deal with protected
mode programming, we will not consider these options. See the MASM Programmer's Guide for
more details.</font></p>

<p><font face="Arial" size="2">If you want to force <code>use16 </code>as the default in a
program that allows 80386 or later instructions, there is one way to accomplish this.
Place the following directive in your program before any segments: </font></p>

<pre><font face="Courier New" size="2">                .option segment:use16</font></pre>

<pre><strong><font face="Arial" size="3">8.8.7 Typical Segment Definitions</font></strong></pre>

<p><font face="Arial" size="2">Has the discussion above left you totally confused? Don't
worry about it. Until you're writing extremely large programs, you needn't concern
yourself with all the operands associated with the <code>segment </code>directive. For
most programs, the following three segments should prove sufficient: </font></p>

<pre><font face="Courier New" size="2">DSEG            segment para public 'DATA'

; Insert your variable definitions here

DSEG            ends

CSEG            segment para public use16 'CODE'

; Insert your program instructions here

CSEG            ends

SSEG            segment para stack 'STACK'
stk             word    1000h dup (?)
EndStk          equ     this word
SSEG            ends
                end</font></pre>

<p><font face="Arial" size="2">The SHELL.ASM file automatically declares these three
segments for you. If you always make a copy of the SHELL.ASM file when writing a new
assembly language program, you probably won't need to worry about segment declarations and
segmentation in general.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-76"></a>8.8.8 Why You Would Want
to Control the Loading Order</font></strong></p>

<p><font face="Arial" size="2">Certain DOS calls require that you pass the length of your
program as a parameter. Unfortunately, computing the length of a program containing
several segments is a very difficult process. However, when DOS loads your program into
memory, it will load the entire program into a contiguous block of RAM. Therefore, to
compute the length of your program, you need only know the starting and ending addresses
of your program. By simply taking the difference of these two values, you can compute the
length of your program. </font></p>

<p><font face="Arial" size="2">In a program that contains multiple segments, you will need
to know which segment was loaded first and which was loaded last in order to compute the
length of your program. As it turns out, DOS always loads the program segment prefix, or
PSP, into memory just before the first segment of your program. You must consider the
length of the PSP when computing the length of your program. MS-DOS passes the segment
address of the PSP in the <code>ds </code>register. So computing the difference of the
last byte in your program and the PSP will produce the length of your program. The
following code segment computes the length of a program in paragraphs: </font></p>

<pre><font face="Courier New" size="2">CSEG            segment public 'CODE'
                mov     ax, ds          ;Get PSP segment address
                sub     ax, seg LASTSEG ;Compute difference

; AX now contains the length of this program (in paragraphs)
                 .
                 .
                 .
CSEG            ends

; Insert ALL your other segments here.

LASTSEG         segment para public 'LASTSEG'
LASTSEG         ends
                end</font></pre>

<pre><strong><font face="Arial" size="3">8.8.9 Segment Prefixes</font></strong></pre>

<p><font face="Arial" size="2">When the 80x86 references a memory operand, it usually
references a location within the current data segment. However, you can instruct the 80x86
microprocessor to reference data in one of the other segments using a segment prefix
before an address expression. </font></p>

<p><font face="Arial" size="2">A segment prefix is either <code>ds</code>:, <code>cs:</code>,
<code>ss:</code>, <code>es:</code>, <code>fs:</code>, or <code>gs:</code>. When used in
front of an address expression, a segment prefix instructs the 80x86 to fetch its memory
operand from the specified segment rather than the default segment. For example, <code>mov
ax, cs:I[bx]</code> loads the accumulator from address <code>I+bx</code> within the
current code segment. If the <code>cs:</code> prefix were absent, this instruction would
normally load the data from the current data segment. Likewise, <code>mov ds:[bp],ax </code>stores
the accumulator into the memory location pointed at by the <code>bp </code>register in the
current data segment (remember, whenever using <code>bp </code>as a base register it
points into the stack segment). </font></p>

<p><font face="Arial" size="2">Segment prefixes are instruction opcodes. Therefore,
whenever you use a segment prefix you are increasing the length (and decreasing the speed)
of the instruction utilizing the segment prefix. Therefore, you don't want to use segment
prefixes unless you have a good reason to do so.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-98"></a>8.8.10 Controlling
Segments with the ASSUME Directive</font></strong></p>

<p><font face="Arial" size="2">The 80x86 generally references data items relative to the <code>ds
</code>segment register (or stack segment). Likewise, all code references (jumps, calls,
etc.) are always relative to the current code segment. There is only one catch - how does
the assembler know which segment is the data segment and which is the code segment (or
other segment)? The <code>segment </code>directive doesn't tell you what type of segment
it happens to be in the program. Remember, a data segment is a data segment because the <code>ds</code>
register points at it. Since the <code>ds </code>register can be changed at run time
(using an instruction like <code>mov ds,ax</code>), any segment can be a data segment.
This has some interesting consequences for the assembler. When you specify a segment in
your program, not only must you tell the CPU that a segment is a data segment, but you
must also tell the assembler where and when that segment is a data (or
code/stack/extra/F/G) segment. The <code>assume </code>directive provides this information
to the assembler. </font></p>

<p><font face="Arial" size="2">The <code>assume </code>directive takes the following form:
</font></p>

<pre><font face="Courier New" size="2">                assume {CS:seg} {DS:seg} {ES:seg} {FS:seg} {GS:seg} {SS:seg}</font></pre>

<p><font face="Arial" size="2">The braces surround optional items, you do not type the
braces as part of these operands. Note that there must be at least one operand. <code>Seg</code>
is either the name of a segment (defined with the <code>segment </code>directive) or the
reserved word <code>nothing</code>. Multiple operands in the operand field of the <code>assume
</code>directive must be separated by commas. Examples of valid assume directives: </font></p>

<pre><font face="Courier New" size="2">                assume  DS:DSEG
                assume  CS:CSEG, DS:DSEG, ES:DSEG, SS:SSEG
                assume  CS:CSEG, DS:NOTHING</font></pre>

<p><font face="Arial" size="2">The <code>assume </code>directive tells the assembler that
you have loaded the specified segment register(s) with the segment addresses of the
specified value. Note that this directive does not modify any of the segment registers, it
simply tells the assembler to assume the segment registers are pointing at certain
segments in the program. Like the processor selection and equate directives, the assume
directive modifies the assembler's behavior from the point MASM encounters it until
another <code>assume</code> directive changes the stated assumption.</font></p>

<p><font face="Arial" size="2">Consider the following program: </font></p>

<pre><font face="Courier New" size="2">DSEG1           segment para public 'DATA'
var1            word    ?
DSEG1           ends

DSEG2           segment para public 'DATA'
var2            word    ?
DSEG2           ends

CSEG            segment para public 'CODE'
                assume  CS:CSEG, DS:DSEG1, ES:DSEG2
                mov     ax, seg DSEG1
                mov     ds, ax
                mov     ax, seg DSEG2
                mov     es, ax

                mov     var1, 0
                mov     var2, 0
                 .
                 .
                 .
                assume  DS:DSEG2
                mov     ax, seg DSEG2
                mov     ds, ax
                mov     var2, 0
                 .
                 .
                 .
CSEG            ends
                end</font></pre>

<p><font face="Arial" size="2">Whenever the assembler encounters a symbolic name, it
checks to see which segment contains that symbol. In the program above, <code>var1</code>
appears in the <code>DSEG1</code> segment and <code>var2</code> appears in the <code>DSEG2</code>
segment. Remember, the 80x86 microprocessor doesn't know about segments declared within
your program, it can only access data in segments pointed at by the <code>cs, ds, es, ss,
fs, </code>and<code> gs </code>segment registers. The <code>assume </code>statement in
this program tells the assembler the <code>ds </code>register points at <code>DSEG1</code>
for the first part of the program and at <code>DSEG2</code> for the second part of the
program. </font></p>

<p><font face="Arial" size="2">When the assembler encounters an instruction of the form <code>mov
var1,0</code>, the first thing it does is determine <code>var1</code>'s segment. It then
compares this segment against the list of assumptions the assembler makes for the segment
registers. If you didn't declare <code>var1</code> in one of these segments, then the
assembler generates an error claiming that the program cannot access that variable. If the
symbol (<code>var1</code> in our example) appears in one of the currently assumed
segments, then the assembler checks to see if it is the data segment. If so, then the
instruction is assembled as described in the appendices. If the symbol appears in a
segment other than the one that the assembler assumes <code>ds </code>points at, then the
assembler emits a segment override prefix byte, specifying the actual segment that
contains the data. </font></p>

<p><font face="Arial" size="2">In the example program above, MASM would assemble <code>mov
VAR1,0 </code>without a segment prefix byte. MASM would assemble the first occurrence of
the <code>mov VAR2,0</code> instruction with an <code>es: </code>segment prefix byte since
the assembler assumes <code>es</code>, rather than <code>ds</code>, is pointing at segment
<code>DSEG2</code>. MASM would assemble the second occurrence of this instruction without
the <code>es:</code> segment prefix byte since the assembler, at that point in the source
file, assumes that <code>ds </code>points at <code>DSEG2</code>. Keep in mind that it is
very easy to confuse the assembler. Consider the following code: </font></p>

<pre><font face="Courier New" size="2">CSEG            segment para public 'CODE'
                assume  CS:CSEG, DS:DSEG1, ES:DSEG2
                mov     ax, seg DSEG1
                mov     ds, ax
                 .
                 .
                 .
                jmp     SkipFixDS

                assume  DS:DSEG2

FixDS:          mov     ax, seg DSEG2
                mov     ds, ax
SkipFixDS:
                 .
                 .
                 .
CSEG            ends
                end</font></pre>

<p><font face="Arial" size="2">Notice that this program jumps around the code that loads
the <code>ds </code>register with the segment value for <code>DSEG2</code>. This means
that at label <code>SkipFixDS</code> the <code>ds </code>register contains a pointer to <code>DSEG1</code>,
not <code>DSEG2</code>. However, the assembler isn't bright enough to realize this
problem, so it blindly assumes that <code>ds </code>points at <code>DSEG2</code> rather
than <code>DSEG1</code>. This is a disaster waiting to happen. Because the assembler
assumes you're accessing variables in <code>DSEG2</code> while the <code>ds </code>register
actually points at <code>DSEG1</code>, such accesses will reference memory locations in <code>DSEG1</code>
at the same offset as the variables accessed in <code>DSEG2</code>. This will scramble the
data in <code>DSEG1</code> (or cause your program to read incorrect values for the
variables assumed to be in segment <code>DSEG2</code>).</font></p>

<p><font face="Arial" size="2">For beginning programmers, the best solution to the problem
is to avoid using multiple (data) segments within your programs as much as possible. Save
the multiple segment accesses for the day when you're prepared to deal with problems like
this. As a beginning assembly language programmer, simply use one code segment, one data
segment, and one stack segment and leave the segment registers pointing at each of these
segments while your program is executing. The <code>assume </code>directive is quite
complex and can get you into a considerable amount of trouble if you misuse it. Better not
to bother with fancy uses of <code>assume </code>until you are quite comfortable with the
whole idea of assembly language programming and segmentation on the 80x86. </font></p>

<p><font face="Arial" size="2">The <code>nothing </code>reserved word tells the assembler
that you haven't the slightest idea where a segment register is pointing. It also tells
the assembler that you're not going to access any data relative to that segment register
unless you explicitly provide a segment prefix to an address. A common programming
convention is to place <code>assume</code> directives before all procedures in a program.
Since segment pointers to declared segments in a program rarely change except at procedure
entry and exit, this is the ideal place to put assume directives: </font></p>

<pre><font face="Courier New" size="2">                assume  ds:P1Dseg, cs:cseg, es:nothing
Procedure1      proc    near
                push    ds              ;Preserve DS
                push    ax              ;Preserve AX
                mov     ax, P1Dseg      ;Get pointer to P1Dseg into the
                mov     ds, ax          ; ds register.
                 .
                 .
                 .
                pop     ax              ;Restore ax's value.
                pop     ds              ;Restore ds' value.
                ret
Procedure1      endp</font></pre>

<p><font face="Arial" size="2">The only problem with this code is that MASM still assumes
that <code>ds</code> points at <code>P1Dseg</code> when it encounters code after <code>Procedure1</code>.
The best solution is to put a second assume directive after the <code>endp</code>
directive to tell MASM it doesn't know anything about the value in the <code>ds</code>
register: </font></p>

<pre><font face="Courier New" size="2">                 .
                 .
                 .
                ret
Procedure1      endp
                assume  ds:nothing</font></pre>

<p><font face="Arial" size="2">Although the next statement in the program will probably be
yet another <code>assume</code> directive giving the assembler some new assumptions about <code>ds</code>
(at the beginning of the procedure that follows the one above), it's still a good idea to
adopt this convention. If you fail to put an <code>assume</code> directive before the next
procedure in your source file, the <code>assume ds:nothing</code> statement above will
keep the assembler from assuming you can access variables in <code>P1Dseg</code>.</font></p>

<p><font face="Arial" size="2">Segment override prefixes always override any assumptions
made by the assembler. <code>mov ax, cs:var1</code> always loads the <code>ax </code>register
with the word at offset <code>var1</code> within the current code segment, regardless of
where you've defined <code>var1</code>. The main purpose behind the segment override
prefixes is handling indirect references. If you have an instruction of the form <code>mov
ax,[bx]</code> the assembler assumes that <code>bx</code> points into the data segment. If
you really need to access data in a different segment you can use a segment override,
thusly, <code>mov ax, es:[bx]</code>.</font></p>

<p><font face="Arial" size="2">In general, if you are going to use multiple data segments
within your program, you should use full segment:offset names for your variables. E.g., <code>mov
ax, DSEG1:I</code> and <code>mov bx,DSEG2:J</code>. This does not eliminate the need to
load the segment registers or make proper use of the <code>assume </code>directive, but it
will make your program easier to read and help MASM locate possible errors in your
program.</font></p>

<p><font face="Arial" size="2">The <code>assume </code>directive is actually quite useful
for other things besides just setting the default segment. You'll see some more uses for
this directive a little later in this chapter.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-192"></a>8.8.11 Combining
Segments: The GROUP Directive</font></strong></p>

<p><font face="Arial" size="2">Most segments in a typical assembly language program are
less than 64 Kilobytes long. Indeed, most segments are much smaller than 64 Kilobytes in
length. When MS-DOS loads the program's segments into memory, several of the segments may
fall into a single 64K region of memory. In practice, you could combine these segments
into a single segment in memory. This might possibly improve the efficiency of your code
if it saves having to reload segment registers during program execution. </font></p>

<p><font face="Arial" size="2">So why not simply combine such segments in your assembly
language code? Well, as the next section points out, maintaining separate segments can
help you structure your programs better and help make them more modular. This modularity
is very important in your programs as they get more complex. As usual, improving the
structure and modularity of your programs may cause them to become less efficient.
Fortunately, MASM provides a directive, <code>group</code>, that lets you treat two
segments as the same physical segment without abandoning the structure and modularity of
your program.</font></p>

<p><font face="Arial" size="2">The <code>group</code> directive lets you create a new
segment name that encompasses the segments it groups together. For example, if you have
two segments named &quot;<code>Module1Data</code>&quot; and &quot;<code>Module2Data</code>&quot;
that you wish to combine into a single physical segment, you could use the group directive
as follows: </font></p>

<pre><font face="Courier New" size="2">ModuleData      group   Module1Data, Module2Data</font></pre>

<p><font face="Arial" size="2">The only restriction is that the end of the second module's
data must be no more than 64 kilobytes away from the start of the first module in memory.
MASM and the linker will not automatically combine these segments and place them together
in memory. If there are other segments between these two in memory, then the total of all
such segments must be less than 64K in length. To reduce this problem, you can use the
class operand to the segment directive to tell the linker to combine the two segments in
memory by using the same class name: </font></p>

<pre><font face="Courier New" size="2">ModuleData      group   Module1Data, Module2Data

Module1Data     segment para public 'MODULES'
                 .
                 .
                 .
Module1Data     ends
                 .
                 .
                 .
Module2Data     segment byte public 'MODULES'
                 .
                 .
                 .
Module2Data     ends</font></pre>

<p><font face="Arial" size="2">With declarations like those above, you can use &quot;<code>ModuleData</code>&quot;
anywhere MASM allows a segment name, as the operand to a <code>mov</code> instruction, as
an operand to the <code>assume</code> directive, etc. The following example demonstrates
the usage of the <code>ModuleData</code> segment name: </font></p>

<pre><font face="Courier New" size="2">                assume  ds:ModuleData
Module1Proc     proc    near
                push    ds              ;Preserve ds' value.
                push    ax              ;Preserve ax's value.
                mov     ax, ModuleData  ;Load ds with the segment address
                mov     ds, ax          ; of ModuleData.
                 .
                 .
                 .
                pop     ax              ;Restore ax's and ds' values.
                pop     ds
                ret
Module1Proc     endp
                assume  ds:nothing</font></pre>

<p><font face="Arial" size="2">Of course, using the <code>group</code> directive in this
manner hasn't really improved the code. Indeed, by using a different name for the data
segment, one could argue that using <code>group</code> in this manner has actually
obfuscated the code. However, suppose you had a code sequence that needed to access
variables in both the <code>Module1Data</code> and <code>Module2Data </code>segments. If
these segments were physically and logically separate you would have to load two segment
registers with the addresses of these two segments in order to access their data
concurrently. This would cost you a segment override prefix on all the instructions that
access one of the segments. If you cannot spare an extra segment register, the situation
will be even worse, you'll have to constantly load new values into a single segment
register as you access data in the two segments. You can avoid this overhead by combining
the two logical segments into a single physical segment and accessing them through their
group rather than individual segment names.</font></p>

<p><font face="Arial" size="2">If you group two or more segments together, all you're
really doing is creating a pseudo-segment that encompasses the segments appearing in the <code>group</code>
directive's operand field. Grouping segments does not prevent you from accessing the
individual segments in the grouping list. The following code is perfectly legal: </font></p>

<pre><font face="Courier New" size="2">                assume  ds:Module1Data
                mov     ax, Module1Data
                mov     ds, ax
                 .
        &lt; Code that accesses data in Module1Data &gt;
                 .
                assume  ds:Module2Data
                mov     ax, Module2Data
                mov     ds, ax
                 .
        &lt; Code that accesses data in Module2Data &gt;
                 .
                assume  ds:ModuleData
                mov     ax, ModuleData
                mov     ds, ax
                 .
        &lt; Code that accesses data in both Module1Data and Module2Data &gt;
                 .
                 .
                 .</font></pre>

<p><font face="Arial" size="2">When the assembler processes segments, it usually starts
the location counter value for a given segment at zero. Once you group a set of segments,
however, an ambiguity arises; grouping two segments causes MASM and the linker to
concatenate the variables of one or more segments to the end of the first segment in the
group list. They accomplish this by adjusting the offsets of all symbols in the
concatenated segments as though they were all symbols in the same segment. The ambiguity
exists because MASM allows you to reference a symbol in its segment or in the group
segment. The symbol has a different offset depending on the choice of segment. To resolve
the ambiguity, MASM uses the following algorithm: </font>

<ul>
  <li><font face="Arial" size="2">If MASM doesn't know that a segment register is pointing at
    the symbol's segment or a group containing that segment, MASM generates an error. </font></li>
  <li><font face="Arial" size="2">If an <code>assume</code> directive associates the segment
    name with a segment register but does not associate a segment register with the group
    name, then MASM uses the offset of the symbol within its segment. </font></li>
  <li><font face="Arial" size="2">If an <code>assume</code> directive associates the group
    name with a segment register but does not associate a segment register with the symbol's
    segment name, MASM uses the offset of the symbol with the group. </font></li>
  <li><font face="Arial" size="2">If an <code>assume</code> directive provides segment
    register association with both the symbol's segment and its group, MASM will pick the
    offset that would not require a segment override prefix. For example, if the assume
    directive specifies that <code>ds</code> points at the group name and <code>es</code>
    points at the segment name, MASM will use the group offset if the default segment register
    would be <code>ds</code> since this would not require MASM to emit a segment override
    prefix opcode. If either choice results in the emission of a segment override prefix, MASM
    will choose the offset (and segment override prefix) associated with the symbol's segment.
    </font></li>
</ul>

<p><font face="Arial" size="2">MASM uses the algorithm above if you specify a variable
name without a segment prefix. If you specify a segment register override prefix, then
MASM may choose an arbitrary offset. Often, this turns out to be the group offset. So the
following instruction sequence, without an assume directive telling MASM that the <code>BadOffset</code>
symbol is in <code>seg1</code> may produce bad object code: </font></p>

<pre><font face="Courier New" size="2">DataSegs        group   Data1, Data2, Data3
                 .
                 .
                 .
Data2           segment
                 .
                 .
                 .
BadOffset       word    ?
                 .
                 .
                 .
Data2           ends
                 .
                 .
                 .
                assume  ds:nothing, es:nothing, fs:nothing, gs:nothing
                mov     ax, Data2               ;Force ds to point at data2 despite
                mov     ds, ax                  ; the assume directive above.

                mov     ax, ds:BadOffset        ;May use the offset from DataSegs
                                                ; rather than Data2!</font></pre>

<p><font face="Arial" size="2">If you want to force the correct offset, use the variable
name containing the complete segment:offset address form: </font></p>

<pre><font face="Courier New" size="2">; To force the use of the offset within the DataSegs group use an instruction
; like the following:

                mov     ax, DataSegs:BadOffset

; To force the use of the offset within Data2, use:

                mov     ax, Data2:BadOffset</font></pre>

<p><font face="Arial" size="2">You must use extra care when working with groups within
your assembly language programs. If you force MASM to use an offset within some particular
segment (or group) and the segment register is not pointing at that particular segment or
group, MASM may not generate an error message and the program will not execute correctly.
Reading the offsets MASM prints in the assembly listing will not help you find this error.
MASM always displays the offsets within the symbol's segment in the assembly listing. The
only way to really detect that MASM and the linker are using bad offsets is to get into a
debugger like CodeView and look at the actual machine code bytes produced by the linker
and loader.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-295"></a>8.8.12 Why Even Bother
With Segments?</font></strong></p>

<p><font face="Arial" size="2">After reading the previous sections, you're probably
wondering what possible good could come from using segments in your programs. To be
perfectly frank, if you use the SHELL.ASM file as a skeleton for the assembly language
programs you write, you can get by quite easily without ever worrying about segments,
groups, segment override prefixes, and full segment:offset names. As a beginning assembly
language programmer, it's probably a good idea to ignore much of this discussion on
segmentation until you are much more comfortable with 80x86 assembly language programming.
However, there are three reasons you'll want to learn more about segmentation if you
continue writing assembly language programs for any length of time: the real-mode 64K
segment limitation, program modularity, and interfacing with high level languages.</font></p>

<p><font face="Arial" size="2">When operating in real mode, segments can be a maximum of
64 kilobytes long. If you need to access more than 64K of data or code in your programs,
you will need to use more than one segment. This fact, more than any other reason, has
dragged programmers (kicking and screaming) into the world of segmentation. Unfortunately,
this is as far as many programmers get with segmentation. They rarely learn more than just
enough about segmentation to write a program that accesses more than 64K of data. As a
result, when a segmentation problem occurs because they don't fully understand the
concept, they blame segmentation for their problems and they avoid using segmentation as
much as possible.</font></p>

<p><font face="Arial" size="2">This is too bad because segmentation is a powerful memory
management tool that lets you organize your programs into logical entities (segments) that
are, in theory, independent of one another. The field of software engineering studies how
to write correct, large programs. Modularity and independence are two of the primary tools
software engineers use to write large programs that are correct and easy to maintain. The
80x86 family provides, in hardware, the tools to implement segmentation. On other
processors, segmentation is enforced strictly by software. As a result, it is easier to
work with segments on the 80x86 processors.</font></p>

<p><font face="Arial" size="2">Although this text does not deal with protected mode
programming, it is worth pointing out that when you operate in protected mode on 80286 and
later processors, the 80x86 hardware can actually prevent one module from accessing
another module's data (indeed, the term &quot;protected mode&quot; means that segments are
protected from illegal access). Many debuggers available for MS-DOS operate in protected
mode allowing you to catch array and segment bounds violations. Soft-ICE and Bounds
Checker from NuMega are examples of such products. Most people who have worked with
segmentation in a protected mode environment (e.g., OS/2 or Windows) appreciate the
benefits that segmentation offers.</font></p>

<p><font face="Arial" size="2">Another reason for studying segmentation on the 80x86 is
because you might want to write an assembly language function that a high level language
program can call. Since the HLL compiler makes certain assumptions about the organization
of segments in memory, you will need to know a little bit about segmentation in order to
write such code. </font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH08-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH08-1.html">Chapter Eight</a> (Part 2)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH08-4.html">Chapter Eight</a> (Part 4) </strong></font><a href="CH08-4.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Eight: MASM: Directives &amp;
Pseudo-Opcodes (Part 3)<br>
26 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_8/CH08-3.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:36 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
