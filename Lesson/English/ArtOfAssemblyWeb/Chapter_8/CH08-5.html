<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_8/CH08-5.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:36 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER EIGHT: MASM: DIRECTIVES &amp; PSEUDO-OPCODES (Part 5)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING5"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH08-4.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH08-4.html">Chapter Eight</a> (Part 4)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH08-6.html">Chapter Eight</a> (Part 6) </strong></font><a href="CH08-6.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10"><a NAME="HEADING5-1"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0"><font face="Arial" size="4"><strong>CHAPTER EIGHT:<br>
    MASM: DIRECTIVES &amp; PSEUDO-OPCODES (Part 5)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10"></td>
  </tr>
  <tr>
    <td width="100%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING5-1"><b>8.12.4 </b>-
    Type Operators</a> <br>
    <a HREF="#HEADING5-135"><b>8.12.5 </b>- Operator Precedence</a> </font></td>
  </tr>
  <tr>
    <td width="100%" valign="top" nowrap height="20"></td>
  </tr>
</table>
</center></div>

<h3><strong><font face="Arial" size="3">8.12.4 Type Operators</font></strong></h3>

<p><font face="Arial" size="2">The &quot;<code>xxxx</code> <code>ptr</code>&quot; coercion
operator is an example of a type operator. MASM expressions possess two major attributes:
a value and a type. The arithmetic, logical, and relational operators change an
expression's value. The type operators change its type. The previous section demonstrated
how the <code>ptr </code>operator could change an expression's type. There are several
additional type operators as well. </font></p>
<div align="center"><center>

<table BORDER="1" bordercolor="#C0C0C0" cellspacing="0" cellpadding="0" width="100%">
  <caption><font face="Arial" size="2"><strong>Type Operators</strong></font></caption>
  <tr>
    <th bgcolor="#F0F0F0"><font face="Arial" size="2">Operator</font></th>
    <th bgcolor="#F0F0F0"><font face="Arial" size="2">Syntax</font></th>
    <th bgcolor="#F0F0F0"><font face="Arial" size="2">Description</font></th>
  </tr>
  <tr>
    <td><font face="Arial" size="2">PTR</font></td>
    <td><font face="Arial" size="2">byte ptr expr<br>
    <br>
    word ptr expr<br>
    <br>
    dword ptr expr<br>
    <br>
    qword ptr expr<br>
    <br>
    tbyte ptr expr<br>
    <br>
    near ptr expr<br>
    <br>
    far ptr expr</font></td>
    <td><font face="Arial" size="2">Coerce expr to point at a byte.<br>
    <br>
    Coerce expr to point at a word.<br>
    <br>
    Coerce expr to point at a dword.<br>
    <br>
    Coerce expr to point at a qword.<br>
    <br>
    Coerce expr to point at a tbyte.<br>
    <br>
    Coerce expr to a near value.<br>
    <br>
    Coerce expr to a far value.</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">short</font></td>
    <td><font face="Arial" size="2">short expr</font></td>
    <td><font face="Arial" size="2">expr must be within <em>±</em>128 bytes of the current
    jmp instruction (typically a JMP instruction). This operator forces the JMP instruction to
    be two bytes long (if possible).</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">this</font></td>
    <td><font face="Arial" size="2">this type</font></td>
    <td><font face="Arial" size="2">Returns an expression of the specified type whose value is
    the current location counter.</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">seg</font></td>
    <td><font face="Arial" size="2">seg label</font></td>
    <td><font face="Arial" size="2">Returns the segment address portion of label.</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">offset</font></td>
    <td><font face="Arial" size="2">offset label</font></td>
    <td><font face="Arial" size="2">Returns the offset address portion of label.</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">.type</font></td>
    <td><font face="Arial" size="2">type label</font></td>
    <td><font face="Arial" size="2">Returns a byte that indicates whether this symbol is a
    variable, statement label, or structure name. Superceded by opattr.</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">opattr</font></td>
    <td><font face="Arial" size="2">opattr label</font></td>
    <td><font face="Arial" size="2">Returns a 16 bit value that gives information about label.</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">length</font></td>
    <td><font face="Arial" size="2">length variable</font></td>
    <td><font face="Arial" size="2">Returns the number of array elements for a single
    dimension array. If a multi-dimension array, this operator returns the number of elements
    for the first dimension.</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">lengthof</font></td>
    <td><font face="Arial" size="2">lengthof variable</font></td>
    <td><font face="Arial" size="2">Returns the number of items in array variable.</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">type</font></td>
    <td><font face="Arial" size="2">type symbol</font></td>
    <td><font face="Arial" size="2">Returns a expression whose type is the same as symbol and
    whose value is the size, in bytes, for the specified symbol. </font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">size</font></td>
    <td><font face="Arial" size="2">size variable</font></td>
    <td><font face="Arial" size="2">Returns the number of bytes allocated for single dimension
    array variable. Useless for multi-dimension arrays. Superceded by sizeof.</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">sizeof</font></td>
    <td><font face="Arial" size="2">sizeof variable</font></td>
    <td><font face="Arial" size="2">Returns the size, in bytes, of array variable.</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">low</font></td>
    <td><font face="Arial" size="2">low expr</font></td>
    <td><font face="Arial" size="2">Returns the L.O. byte of expr.</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">lowword</font></td>
    <td><font face="Arial" size="2">lowword expr</font></td>
    <td><font face="Arial" size="2">Returns the L.O. word of expr.</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">high</font></td>
    <td><font face="Arial" size="2">high expr</font></td>
    <td><font face="Arial" size="2">Returns the H.O. byte of expr.</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">highword</font></td>
    <td><font face="Arial" size="2">highword expr</font></td>
    <td><font face="Arial" size="2">Returns the H.O. word of expr.</font></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">The <code>short </code>operator works exclusively with the <code>jmp
</code>instruction. Remember, there are two <code>jmp </code>direct near instructions, one
that has a range of 128 bytes around the <code>jmp</code>, one that has a range of 32,768
bytes around the current instruction. MASM will automatically generate a short jump if the
target address is up to 128 bytes before the current instruction. This operator is mainly
present for compatibility with old MASM (pre-6.0) code.</font></p>

<p><font face="Arial" size="2">The <code>this </code>operator forms an expression with the
specified type whose value is the current location counter. The instruction <code>mov bx,
this word</code>, for example, will load the <code>bx </code>register with the value
8B1Eh, the opcode for <code>mov bx, memory</code>. The address <code>this word</code> is
the address of the opcode for this very instruction! You mostly use the <code>this </code>operator
with the <code>equ </code>directive to give a symbol some type other than constant. For
example, consider the following statement: </font></p>

<pre><font face="Courier New" size="2">HERE            equ     this near</font></pre>

<p><font face="Arial" size="2">This statement assigns the current location counter value
to <code>HERE</code> and sets the type of <code>HERE</code> to near. This, of course,
could have been done much easier by simply placing the label <code>HERE</code>: on the
line by itself. However, the <code>this</code> operator with the <code>equ</code>
directive does have some useful applications, consider the following: </font></p>

<pre><font face="Courier New" size="2">WArray          equ     this word
BArray          byte    200 dup (?)</font></pre>

<p><font face="Arial" size="2">In this example the symbol <code>BArray</code> is of type
byte. Therefore, instructions accessing <code>BArray</code> must contain byte operands
throughout. MASM would flag a <code>mov ax, BArray+8</code> instruction as an error.
However, using the symbol <code>WArray</code> lets you access the same exact memory
locations (since <code>WArray</code> has the value of the location counter immediately
before encountering the <code>byte </code>pseudo-opcode) so <code>mov ax,WArray+8</code>
accesses location <code>BArray+8</code>. Note that the following two instructions are
identical: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, word ptr BArray+8
                mov     ax, WArray+8</font></pre>

<p><font face="Arial" size="2">The <code>seg </code>operator does two things. First, it
extracts the segment portion of the specified address, second, it converts the type of the
specified expression from address to constant. An instruction of the form <code>mov ax,
seg symbol </code>always loads the accumulator with the constant corresponding to the
segment portion of the address of <code>symbol</code>. If the symbol is the name of a
segment, MASM will automatically substitute the paragraph address of the segment for the
name. However, it is perfectly legal to use the <code>seg</code> operator as well. The
following two statements are identical if <code>dseg</code> is the name of a segment: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, dseg
                mov     ax, seg dseg</font></pre>

<p><font face="Arial" size="2"><code>Offset </code>works like <code>seg</code>, except it
returns the offset portion of the specified expression rather than the segment portion. If
<code>VAR1</code> is a word variable, <code>mov ax, VAR1</code> will always load the two
bytes at the address specified by <code>VAR1</code> into the <code>ax</code> register. The<code>
mov ax, offset VAR1 </code>instruction, on the other hand, loads the offset (address) of <code>VAR1</code>
into the <code>ax </code>register. Note that you can use the <code>lea</code> instruction
or the <code>mov</code> instruction with the <code>offset</code> operator to load the
address of a scalar variable into a 16 bit register. The following two instructions both
load <code>bx</code> with the address of variable <code>J</code>: </font></p>

<pre><font face="Courier New" size="2">                mov     bx, offset J
                lea     bx, J</font></pre>

<p><font face="Arial" size="2">The <code>lea</code> instruction is more flexible since you
can specify any memory addressing mode, the <code>offset</code> operator only allows a
single symbol (i.e., displacement only addressing). Most programmers use the <code>mov</code>
form for scalar variables and the <code>lea</code> instructor for other addressing modes.
This is because the <code>mov</code> instruction was faster on earlier processors.</font></p>

<p><font face="Arial" size="2">One very common use for the <code>seg</code> and <code>offset</code>
operators is to initialize a segment and pointer register with the segmented address of
some object. For example, to load <code>es:di </code>with the address of<code> SomeVar, </code>you
could use the following code: </font></p>

<pre><font face="Courier New" size="2">                mov     di, seg SomeVar
                mov     es, di
                mov     di, offset SomeVar</font></pre>

<p><font face="Arial" size="2">Since you cannot load a constant directly into a segment
register, the code above copies the segment portion of the address into <code>di</code>
and then copies <code>di</code> into <code>es</code> before copying the offset into <code>di</code>.
This code uses the <code>di</code> register to copy the segment portion of the address
into <code>es</code> so that it will affect as few other registers as possible.</font></p>

<p><font face="Arial" size="2"><code>Opattr </code>returns a 16 bit value providing
specific information about the expression that follows it. The <code>.type</code> operator
is an older version of <code>opattr</code> that returns the L.O. eight bits of this value.
Each bit in the value of these operators has the following meaning: </font></p>
<div align="center"><center>

<table BORDER="1" bordercolor="#C0C0C0" cellspacing="0" cellpadding="0" width="50%">
  <caption><font face="Arial" size="2"><strong>OPATTR/.TYPE Return Value</strong></font></caption>
  <tr>
    <th bgcolor="#F0F0F0" align="center"><font face="Arial" size="2">Bit(s)</font></th>
    <th bgcolor="#F0F0F0"><font face="Arial" size="2">Meaning</font></th>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">0</font></td>
    <td><font face="Arial" size="2">References a label in the code segment if set.</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">1</font></td>
    <td><font face="Arial" size="2">References a memory variable or relocatable data object if
    set.</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">2</font></td>
    <td><font face="Arial" size="2">Is an immediate (absolute/constant) value if set.</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">3</font></td>
    <td><font face="Arial" size="2">Uses direct memory addressing if set.</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">4</font></td>
    <td><font face="Arial" size="2">Is a register name, if set.</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">5</font></td>
    <td><font face="Arial" size="2">References no undefined symbols and there is no error, if
    set.</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td><font face="Arial" size="2">Is an SS: relative reference, if set.</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">7</font></td>
    <td><font face="Arial" size="2">References an external name.</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">8-10</font></td>
    <td><font face="Arial" size="2">000 - no language type<br>
    <br>
    001 - C/C++ language type<br>
    <br>
    010 - SYSCALL language type<br>
    <br>
    011 - STDCALL language type<br>
    <br>
    100 - Pascal language type<br>
    <br>
    101 - FORTRAN language type<br>
    <br>
    110 - BASIC language type</font></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">The language bits are for programmers writing code that
interfaces with high level languages like C++ or Pascal. Such programs use the simplified
segment directives and MASM's HLL features. </font></p>

<p><font face="Arial" size="2">You would normally use these values with MASM's conditional
assembly directives and macros. This allows you to generate different instruction
sequences depending on the type of a macro parameter or the current assembly
configuration. For more details, see &quot;Conditional Assembly&quot; and
&quot;Macros&quot;.</font></p>

<p><font face="Arial" size="2">The <code>size</code>, <code>sizeof</code>, <code>length</code>,
and <code>lengthof </code>operators compute the sizes of variables (including arrays) and
return that size and their value. You shouldn't normally use <code>size </code>and <code>length</code>.
The <code>sizeof</code> and <code>lengthof</code> operators have superceded these
operators. <code>Size</code> and <code>length</code> do not always return reasonable
values for arbitrary operands. MASM 6.x includes them to remain compatible with older
versions of the assembler. However, you will see an example later in this chapter where
you can use these operators.</font></p>

<p><font face="Arial" size="2">The <code>sizeof variable</code> operator returns the
number of bytes directly allocated to the specified variable. The following examples
illustrate the point: </font></p>

<pre><font face="Courier New" size="2">a1              byte    ?                       ;SIZEOF(a1) = 1
a2              word    ?                       ;SIZEOF(a2) = 2
a4              dword   ?                       ;SIZEOF(a4) = 4
a8              real8   ?                       ;SIZEOF(a8) = 8
ary0            byte    10 dup (0)              ;SIZEOF(ary0) = 10
ary1            word    10 dup (10 dup (0))     ;SIZEOF(ary1) = 200</font></pre>

<p><font face="Arial" size="2">You can also use the <code>sizeof </code>operator to
compute the size, in bytes, of a structure or other data type. This is very useful for
computing an index into an array using the formula from Chapter Four: </font></p>

<pre><font face="Courier New" size="2">        Element_Address := base_address + index*Element_Size</font></pre>

<p><font face="Arial" size="2">You may obtain the element size of an array or structure
using the <code>sizeof </code>operator. So if you have an array of structures, you can
compute an index into the array as follows: </font></p>

<pre><font face="Courier New" size="2">        .286                            ;Allow 80286 instructions.
s       struct
        &lt;some number of fields&gt;
s       ends

         .
         .
         .

array   s       16 dup ({})             ;An array of 16 &quot;s&quot; elements

         .
         .
         .

        imul    bx, I, sizeof s         ;Compute BX := I * elementsize
        mov     al, array[bx].fieldname</font></pre>

<p><font face="Arial" size="2">You can also apply the <code>sizeof</code> operator to
other data types to obtain their size in bytes. For example, <code>sizeof byte</code>
returns 1, <code>sizeof word</code> returns two, and <code>sizeof dword</code> returns 4.
Of course, applying this operator to MASM's built-in data types is questionable since the
size of those objects is fixed. However, if you create your own data types using <code>typedef</code>,
it makes perfect sense to compute the size of the object using the <code>sizeof</code>
operator: </font></p>

<pre><font face="Courier New" size="2">integer         typedef word
Array           integer 16 dup (?)
                 .
                 .
                 .
                imul    bx, bx, sizeof integer
                 .
                 .
                 .</font></pre>

<p><font face="Arial" size="2">In the code above, <code>sizeof integer </code>would return
two, just like <code>sizeof word</code>. However, if you change the <code>typedef</code>
statement so that <code>integer</code> is a <code>dword</code> rather than a <code>word</code>,
the<code> sizeof integer</code> operand would automatically change its value to four to
reflect the new size of an integer.</font></p>

<p><font face="Arial" size="2">The <code>lengthof </code>operator returns the total number
of elements in an array. For the <code>Array</code> variable above, <code>lengthof Array</code>
would return 16. If you have a two dimensional array, <code>lengthof </code>returns the
total number of elements in that array.</font></p>

<p><font face="Arial" size="2">When you use the <code>lengthof</code> and <code>sizeof</code>
operators with arrays, you must keep in mind that it is possible for you to declare arrays
in ways that MASM can misinterpret. For example, the following statements all declare
arrays containing eight words: </font></p>

<pre><font face="Courier New" size="2">A1              word    8 dup (?)

A2              word    1, 2, 3, 4, 5, 6, 7, 8

; Note: the &quot;\&quot; is a &quot;line continuation&quot; symbol. It tells MASM to append
;       the next line to the end of the current line.

A3              word    1, 2, 3, 4, \
                        5, 6, 7, 8

A4              word    1, 2, 3, 4
                word    5, 6, 7, 8</font></pre>

<p><font face="Arial" size="2">Applying the <code>sizeof</code> and <code>lengthof</code>
operators to <code>A1</code>, <code>A2</code>, and <code>A3</code> produces sixteen
(sizeof) and eight (lengthof). However, <code>sizeof(A4) </code>produces eight and<code>
lengthof(A4) </code>produces four. This happens because MASM thinks that the arrays begin
and end with a single data declaration. Although the <code>A4</code> declaration sets
aside eight consecutive words, just like the other three declarations above, MASM thinks
that the two word directives declare two separate arrays rather than a single array. So if
you want to initialize the elements of a large array or a multidimensional array and you
also want to be able to apply the <code>lengthof</code> and <code>sizeof</code> operators
to that array, you should use <code>A3</code>'s form of declaration rather than <code>A4</code>'s.</font></p>

<p><font face="Arial" size="2">The <code>type</code> operator returns a constant that is
the number of bytes of the specified operand. For example, <code>type(word)</code> returns
the value two. This revelation, by itself, isn't particularly interesting since the <code>size</code>
and <code>sizeof</code> operators also return this value. However, when you use the type
operator with the comparison operators (eq, ne, le, lt, gt, and ge), the comparison
produces a true result only if the types of the operands are the same. Consider the
following definitions: </font></p>

<pre><font face="Courier New" size="2">Integer         typedef word
J               word    ?
K               sword   ?
L               integer ?
M               word    ?

                byte    type (J) eq word        ;value = 0FFh
                byte    type (J) eq sword       ;value = 0
                byte    type (J) eq type (L)    ;value = 0FFh
                byte    type (J) eq type (M)    ;value = 0FFh
                byte    type (L) eq integer     ;value = 0FFh
                byte    type (K) eq dword       ;value = 0</font></pre>

<p><font face="Arial" size="2">Since the code above <code>typedef</code>'d <code>Integer</code>
to <code>word</code>, MASM treats integers and words as the same type. Note that with the
exception of the last example above, the value on either side of the <code>eq</code>
operator is two. Therefore, when using the comparison operations with the <code>type</code>
operator, MASM compares more than just the value. Therefore, <code>type</code> and <code>sizeof</code>
are not synonymous. E.g., </font></p>

<pre><font face="Courier New" size="2">                byte    type (J) eq type (K)            ;value = 0
                byte    (sizeof J) equ (sizeof K)       ;value = 0FFh</font></pre>

<p><font face="Arial" size="2">The <code>type</code> operator is especially useful when
using MASM's conditional assembly directives. See &quot;Conditional Assembly&quot; for
more details.</font></p>

<p><font face="Arial" size="2">The examples above also demonstrate another interesting
MASM feature. If you use a type name within an expression, MASM treats it as though you'd
entered &quot;<code>type(name)</code>&quot; where name is a symbol of the given type. In
particular, specifying a type name returns the size, in bytes, of an object of that type.
Consider the following examples: </font></p>

<pre><font face="Courier New" size="2">Integer         typedef word
s               struct
d               dword   ?
w               word    ?
b               byte    ?
s               ends

                byte    word            ;value = 2
                byte    sword           ;value = 2
                byte    byte            ;value = 1
                byte    dword           ;value = 4
                byte    s               ;value = 7
                byte    word eq word    ;value = 0FFh
                byte    word eq sword   ;value = 0
                byte    b eq dword      ;value = 0
                byte    s eq byte       ;value = 0
                byte    word eq Integer ;value = 0FFh</font></pre>

<p><font face="Arial" size="2">The <code>high </code>and <code>low </code>operators, like <code>offset</code>
and <code>seg</code>, change the type of expression from whatever it was to a constant.
These operators also affect the value of the expression - they decompose it into a high
order byte and a low order byte. The <code>high </code>operator extracts bits eight
through fifteen of the expression, the <code>low </code>operator extracts and returns bits
zero through seven. <code>Highword </code>and <code>lowword </code>extract the H.O. and
L.O. 16 bits of an expression:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch08a6.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH08/ch08a6.gif" ALIGN="bottom" NATURALSIZEFLAG="3" WIDTH="375" HEIGHT="117"> </font></p>

<p><font face="Arial" size="2">You can extract bits 16-23 and 24-31 using expressions of
the form <code>low</code>( <code>highword</code>( expr )) and <code>high</code>( <code>highword</code>(
expr )), respectively.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-135"></a>8.12.5 Operator
Precedence</font></strong></p>

<p><font face="Arial" size="2">Although you will rarely need to use a complex address
expression employing more than two operands and a single operator, the need does arise on
occasion. MASM supports a simple operator precedence convention based on the following
rules: </font>

<ul>
  <li><font face="Arial" size="2">MASM executes operators of a higher precedence first. </font></li>
  <li><font face="Arial" size="2">Operators of an equal precedence are left associative and
    evaluate from left to right. </font></li>
  <li><font face="Arial" size="2">Parentheses override the normal precedence. </font></li>
</ul>

<ul>
  <div align="center"><center><table BORDER="1" bordercolor="#C0C0C0" cellspacing="0" cellpadding="0" width="60%">
    <caption><font face="Arial" size="2"><strong>Operator Precedence</strong></font></caption>
    <tr>
      <th bgcolor="#F0F0F0" align="center"><font face="Arial" size="2">Precedence</font></th>
      <th bgcolor="#F0F0F0"><font face="Arial" size="2">Operators</font></th>
    </tr>
    <tr>
      <td align="center"><font face="Arial" size="2">(Highest)</font></td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td align="center"><font face="Arial" size="2">1</font></td>
      <td><font face="Arial" size="2">length, lengthof, size, sizeof, ( ), [ ], &lt; &gt;</font></td>
    </tr>
    <tr>
      <td align="center"><font face="Arial" size="2">2</font></td>
      <td><font face="Arial" size="2">. (structure field name operator)</font></td>
    </tr>
    <tr>
      <td align="center"><font face="Arial" size="2">3</font></td>
      <td><font face="Arial" size="2">CS: DS: ES: FS: GS: SS: (Segment override prefixes)</font></td>
    </tr>
    <tr>
      <td align="center"><font face="Arial" size="2">4</font></td>
      <td><font face="Arial" size="2">ptr offset set type opattr this</font></td>
    </tr>
    <tr>
      <td align="center"><font face="Arial" size="2">5</font></td>
      <td><font face="Arial" size="2">high, low, highword, lowword</font></td>
    </tr>
    <tr>
      <td align="center"><font face="Arial" size="2">6</font></td>
      <td><font face="Arial" size="2">+ - (unary)</font></td>
    </tr>
    <tr>
      <td align="center"><font face="Arial" size="2">7</font></td>
      <td><font face="Arial" size="2">* / mod shl shr</font></td>
    </tr>
    <tr>
      <td align="center"><font face="Arial" size="2">8</font></td>
      <td><font face="Arial" size="2">+ - (binary)</font></td>
    </tr>
    <tr>
      <td align="center"><font face="Arial" size="2">9</font></td>
      <td><font face="Arial" size="2">eq ne lt le gt ge</font></td>
    </tr>
    <tr>
      <td align="center"><font face="Arial" size="2">10</font></td>
      <td><font face="Arial" size="2">not</font></td>
    </tr>
    <tr>
      <td align="center"><font face="Arial" size="2">11</font></td>
      <td><font face="Arial" size="2">and</font></td>
    </tr>
    <tr>
      <td align="center"><font face="Arial" size="2">12</font></td>
      <td><font face="Arial" size="2">or xor</font></td>
    </tr>
    <tr>
      <td align="center"><font face="Arial" size="2">13</font></td>
      <td><font face="Arial" size="2">short .type</font></td>
    </tr>
    <tr>
      <td align="center"><font face="Arial" size="2">(Lowest)</font></td>
      <td>&nbsp;</td>
    </tr>
  </table>
  </center></div>
</ul>

<p><font face="Arial" size="2">Parentheses should only surround expressions. Some
operators, like <code>sizeof</code> and <code>lengthof</code>, require type names, not
expressions. They do not allow you to put parentheses around the name. Therefore, &quot;<code>(sizeof
X)</code>&quot; is legal, but &quot;<code>sizeof(X)</code>&quot; is not. Keep this in mind
when using parentheses to override operator precedence in an expression. If MASM generates
an error, you may need to rearrange the parentheses in your expression.</font></p>

<p><font face="Arial" size="2">As is true for expressions in a high level language, it is
a good idea to always use parentheses to explicitly state the precedence in all complex
address expressions (complex meaning that the expression has more than one operator). This
generally makes the expression more readable and helps avoid precedence related bugs.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH08-4.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH08-4.html">Chapter Eight</a> (Part 4)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH08-6.html">Chapter Eight</a> (Part 6) </strong></font><a href="CH08-6.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Eight: MASM: Directives &amp;
Pseudo-Opcodes (Part 5)<br>
26 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_8/CH08-5.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:37 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
