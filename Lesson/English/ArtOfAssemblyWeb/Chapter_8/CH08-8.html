<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_8/CH08-8.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:37 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER EIGHT: MASM: DIRECTIVES &amp; PSEUDO-OPCODES (Part 8)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING8"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH08-7.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH08-7.html">Chapter Eight</a> (Part 7)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH08-9.html">Chapter Eight</a> (Part 9) </strong></font><a href="CH08-9.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10"><a NAME="HEADING8-1"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0"><font face="Arial" size="4"><strong>CHAPTER EIGHT:<br>
    MASM: DIRECTIVES &amp; PSEUDO-OPCODES (Part 8)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10"></td>
  </tr>
  <tr>
    <td width="100%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING8-1"><b>8.14.7 </b>-
    Macro Functions</a> <br>
    <a HREF="#HEADING8-39"><b>8.14.8 </b>- Predefined Macros, Macro Functions, and Symbols</a>
    <br>
    <a HREF="#HEADING8-125"><b>8.14.9 </b>- Macros vs. Text Equates</a> <br>
    <a HREF="#HEADING8-130"><b>8.14.10 </b>- Macros: Good and Bad News</a> </font></td>
  </tr>
  <tr>
    <td width="100%" valign="top" nowrap height="20"></td>
  </tr>
</table>
</center></div>

<h3><strong><font face="Arial" size="3">8.14.7 Macro Functions</font></strong></h3>

<p><font face="Arial" size="2">A macro function is a macro whose sole purpose is to return
a value for use in the operand field of some other statement. Although there is the
obvious parallel between procedures and functions in a high level language and procedural
macros and functional macros, the analogy is far from perfect. Macro functions do not let
you create sequences of code that emit some instructions that compute a value when the
program actually executes. Instead, macro functions simply compute some value at assembly
time that MASM can use as an operand.</font></p>

<p><font face="Arial" size="2">A good example of a macro function is the <code>Date</code>
function. This macro function packs a five bit day, four bit month, and seven bit year
value into 16 bits and returns that 16 bit value as the result. If you needed to create an
initialized array of dates, you could use code like the following: </font></p>

<pre><font face="Courier New" size="2">DateArray       word    Date(2, 4, 84)
                word    Date(1, 1, 94)
                word    Date(7, 20, 60)
                word    Date(7, 19, 69)
                word    Date(6, 18, 74)
                 .
                 .
                 .</font></pre>

<p><font face="Arial" size="2">The <code>Date</code> function would pack the data and the <code>word</code>
directive would emit the 16 bit packed value for each date to the object code file. You
invoke macro functions by using their name where MASM expects a text expression of some
sort. If the macro function requires any parameters, you must enclose them within
parentheses, just like the parameters to <code>Date</code>, above.</font></p>

<p><font face="Arial" size="2">Macro functions look exactly like standard macros with two
exceptions: they do not contain any statements that generate code and they return a text
value via an operand to the <code>exitm</code> directive. Note that you cannot return a
numeric value with a macro function. If you need to return a numeric value, you must first
convert it to a text value.</font></p>

<p><font face="Arial" size="2">The following macro function implements <code>Date</code>
using the 16 bit date format given in Chapter One: </font></p>

<pre><font face="Courier New" size="2">Date            macro   month, day, year
                local   Value
Value           =       (month shl 12) or (day shl 7) or year
                exitm   %Value
                endm</font></pre>

<p><font face="Arial" size="2">The text expansion operator (&quot;%&quot;) is necessary in
the operand field of the <code>exitm</code> directive because macro functions always
return textual data, not numeric data. The expansion operator converts the numeric value
to a string of digits acceptable to <code>exitm</code>.</font></p>

<p><font face="Arial" size="2">One minor problem with the code above is that this function
returns garbage if the date isn't legal. A better design would generate an error if the
input date is illegal. You can use the &quot;<code>.err</code>&quot; directive and
conditional assembly to do this. The following implementation of <code>Date</code> checks
the month, day, and year values to see if they are somewhat reasonable: </font></p>

<pre><font face="Courier New" size="2">Date            macro   month, day, year
                local   Value

                if      (month gt 12) or (month lt 1) or \
                        (day gt 31) or (day lt 1) or \
                        (year gt 99) (year lt 1)
                .err
                exitm   &lt;0&gt;             ;;Must return something!
                endif

Value           =       (month shl 12) or (day shl 7) or year
                exitm   %Value
                endm</font></pre>

<p><font face="Arial" size="2">With this version, any attempt to specify a totally
outrageous date triggers the assembly of the &quot;.<code>err</code>&quot; directive that
forces an error at assembly time.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING8-39"></a>8.14.8 Predefined Macros,
Macro Functions, and Symbols</font></strong></p>

<p><font face="Arial" size="2">MASM provides four built-in macros and four corresponding
macro functions. In addition, MASM also provides a large number of predefined symbols you
can access during assembly. Although you would rarely use these macros, functions, and
variables outside of moderately complex macros, they are essential when you do need them.</font></p>
<div align="center"><center>

<table BORDER="1" bordercolor="#C0C0C0" cellspacing="0" cellpadding="0" width="100%">
  <caption><font face="Arial" size="2"><strong>MASM Predefined Macros</strong></font></caption>
  <tr>
    <th bgcolor="#F0F0F0" align="center"><font face="Arial" size="2">Name</font></th>
    <th bgcolor="#F0F0F0"><font face="Arial" size="2">operands</font></th>
    <th bgcolor="#F0F0F0"><font face="Arial" size="2">Example</font></th>
    <th bgcolor="#F0F0F0"><font face="Arial" size="2">Description</font></th>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">substr</font></td>
    <td><font face="Arial" size="2">string, start, length<br>
    <br>
    Returns: text data</font></td>
    <td><font face="Arial" size="2">NewStr substr Oldstr, 1, 3</font></td>
    <td><font face="Arial" size="2">Returns a string consisting of the characters from start
    to start+length in the string operand. The length operand is optional. If it is not
    present, MASM returns all characters from position start through the end of the string.</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">instr</font></td>
    <td><font face="Arial" size="2">start, string, substr<br>
    <br>
    &nbsp;<br>
    <br>
    Returns: numeric data</font></td>
    <td><font face="Arial" size="2">Pos instr 2, OldStr, &lt;ax&gt;</font></td>
    <td><font face="Arial" size="2">Searches for &quot;substr&quot; within &quot;string&quot;
    starting at position &quot;start.&quot; The starting value is optional. If it is missing,
    MASM begins searching for the string from position one. If MASM cannot find the substring
    within the string operand, it returns the value zero.</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">sizestr</font></td>
    <td><font face="Arial" size="2">string<br>
    <br>
    &nbsp;<br>
    <br>
    Returns: numeric data</font></td>
    <td><font face="Arial" size="2">StrSize sizestr OldStr</font></td>
    <td><font face="Arial" size="2">Returns the size of the string in the operand field.</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">catstr</font></td>
    <td><font face="Arial" size="2">string, string, ...<br>
    <br>
    &nbsp;<br>
    <br>
    Returns: text data</font></td>
    <td><font face="Arial" size="2">NewStr catstr OldStr, &lt;$$&gt;</font></td>
    <td><font face="Arial" size="2">Creates a new string by concatenating each of the strings
    appearing in the operand field of the <code>catstr</code> macro.</font></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">The <code>substr</code> and <code>catstr</code> macros
return text data. In some respects, they are similar to the <code>textequ</code> directive
since you use them to assign textual data to a symbol at assembly time. The <code>instr</code>
and <code>sizestr</code> are similar to the &quot;=&quot; directive insofar as they return
a numeric value.</font></p>

<p><font face="Arial" size="2">The <code>catstr</code> macro can eliminate the need for
the <code>MakeLbl</code> macro found in the <code>ForLp</code> macro. Compare the
following version of <code>ForLp</code> to the previous version (see &quot;A Sample Macro
to Implement For Loops&quot;). </font></p>

<pre><font face="Courier New" size="2">ForLp           macro   LCV, Start, Stop
                local   ForLoop

                ifndef  $$For&amp;LCV&amp;
$$For&amp;LCV&amp;      =       0
                else
$$For&amp;LCV&amp;      =       $$For&amp;LCV&amp; + 1
                endif

                mov     ax, Start
                mov     LCV, ax

; Due to bug in MASM, this won't actually work. The idea is sound, though
; Read on for correct solution. 

ForLoop         textequ @catstr($For&amp;LCV&amp;, %$$For&amp;LCV&amp;)
&amp;ForLoop&amp;:
                mov     ax, LCV
                cmp     ax, Stop
                jgDone  $$Next&amp;LCV&amp;, %$$For&amp;LCV&amp;
                endm</font></pre>

<p><font face="Arial" size="2">MASM also provides macro function forms for <code>catstr</code>,
<code>instr</code>, <code>sizestr</code>, and <code>substr</code>. To differentiate these
macro functions from the corresponding predefined macros, MASM uses the names <code>@catstr,</code>
<code>@instr,</code> <code>@sizestr,</code> and <code>@substr</code>. The the following
equivalences between these operations: </font></p>

<pre><font face="Courier New" size="2">Symbol          catstr  String1, String2, ...
Symbol          textequ @catstr(String1, String2, ...)

Symbol          substr  SomeStr, 1, 5
Symbol          textequ @substr(SomeStr, 1, 5)

Symbol          instr   1, SomeStr, SearchStr
Symbol          =       @substr(1, SomeStr, SearchStr)

Symbol          sizestr SomeStr
Symbol          =       @sizestr(SomeStr)</font></pre>
<div align="center"><center>

<table BORDER="1" bordercolor="#C0C0C0" cellspacing="0" cellpadding="0" width="60%">
  <caption><font face="Arial" size="2"><strong>MASM Predefined Macro Functions</strong></font></caption>
  <tr>
    <th bgcolor="#F0F0F0"><font face="Arial" size="2">Name</font></th>
    <th bgcolor="#F0F0F0"><font face="Arial" size="2">Parameters</font></th>
    <th bgcolor="#F0F0F0"><font face="Arial" size="2">Example</font></th>
  </tr>
  <tr>
    <td><font face="Arial" size="2">@substr</font></td>
    <td><font face="Arial" size="2">string, start, length Returns: text data</font></td>
    <td><font face="Arial" size="2">ifidn @substr(parm, 1, 4), &lt;[bx]&gt;</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">@instr</font></td>
    <td><font face="Arial" size="2">start, string, substr Returns: numeric data</font></td>
    <td><font face="Arial" size="2">if @instr(parm,&lt;bx&gt;)</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">@sizestr</font></td>
    <td><font face="Arial" size="2">string Returns: numeric data</font></td>
    <td><font face="Arial" size="2">byte @sizestr(SomeStr)</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">@catstr</font></td>
    <td><font face="Arial" size="2">string, string, ... Returns: text data</font></td>
    <td><font face="Arial" size="2">jg @catstr($$Next&amp;LCV&amp;, %$$For&amp;LCV&amp;)</font></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">The last example above shows how to get rid of the <code>jgDone</code>
and <code>jmpLoop</code> macros in the <code>ForLp</code> macro. A final, improved,
version of the <code>ForLp</code> and <code>Next</code> macros, eliminating the three
support macros and working around the bug in MASM might look something like the following:
</font></p>

<pre><font face="Courier New" size="2">ForLp           macro   LCV, Start, Stop
                local   ForLoop

                ifndef  $$For&amp;LCV&amp;
$$For&amp;LCV&amp;      =       0
                else
$$For&amp;LCV&amp;      =       $$For&amp;LCV&amp; + 1
                endif

                mov     ax, Start
                mov     LCV, ax

ForLoop         textequ @catstr($For&amp;LCV&amp;, %$$For&amp;LCV&amp;)
&amp;ForLoop&amp;:
                mov     ax, LCV
                cmp     ax, Stop
                jg      @catstr($$Next&amp;LCV&amp;, %$$For&amp;LCV&amp;)
                endm

Next            macro   LCV
                local   NextLbl
                inc     LCV
                jmp     @catstr($$For&amp;LCV&amp;, %$$For&amp;LCV&amp;)
NextLbl         textequ @catstr($Next&amp;LCV&amp;, %$$For&amp;LCV&amp;)
&amp;NextLbl&amp;:
                endm</font></pre>

<p><font face="Arial" size="2">MASM also provides a large number of built in variables
that return information about the current assembly. The following table describes these
built in assembly time variables. </font></p>
<div align="center"><center>

<table BORDER="1" bordercolor="#C0C0C0" width="100%" cellspacing="0" cellpadding="0">
  <caption><font face="Arial" size="2"><strong>MASM Predefined Assembly Time Variables</strong></font></caption>
  <tr>
    <th bgcolor="#F0F0F0"><font face="Arial" size="2">Category</font></th>
    <th bgcolor="#F0F0F0"><font face="Arial" size="2">Name</font></th>
    <th bgcolor="#F0F0F0"><font face="Arial" size="2">Description</font></th>
    <th bgcolor="#F0F0F0"><font face="Arial" size="2">Return result</font></th>
  </tr>
  <tr>
    <td rowspan="2"><font face="Arial" size="2">Date &amp; Time Information</font></td>
    <td><font face="Arial" size="2">@Date</font></td>
    <td><font face="Arial" size="2">Returns the date of assembly.</font></td>
    <td><font face="Arial" size="2">Text value</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">@Time</font></td>
    <td><font face="Arial" size="2">Returns a string denoting the time of assembly.</font></td>
    <td><font face="Arial" size="2">Text value</font></td>
  </tr>
  <tr>
    <td rowspan="4"><font face="Arial" size="2">Environment Information</font></td>
    <td><font face="Arial" size="2">@CPU</font></td>
    <td><font face="Arial" size="2">Returns a 16 bit value whose bits determine the active
    processor directive. Specifying the <code>.8086, .186, .286, .386, .486, </code>and <code>.586</code>
    directives enable additional instructions in MASM. They also set the corresponding bits in
    the <code>@cpu</code> variable. Note that MASM sets all the bits for the processors it can
    handle at any one given time. For example, if you use the .386 directive, MASM sets bits
    zero, one, two, and three in the @cpu variable.</font></td>
    <td><font face="Arial" size="2">Bit 0 - 8086 instrs permissible.<br>
    <br>
    Bit 1 - 80186 instrs permissible.<br>
    <br>
    Bit 2 - 80286 instrs permissible.<br>
    <br>
    Bit 3- 80386 instrs permissible.<br>
    <br>
    Bit 4- 80486 instrs permissible.<br>
    <br>
    Bit 5- Pentium instrs permissible.<br>
    <br>
    Bit 6- Reserved for 80686 (?).<br>
    <br>
    Bit 7- Protected mode instrs okay.<br>
    <br>
    &nbsp;<br>
    <br>
    Bit 8- 8087 instrs permissible.<br>
    <br>
    Bit 10- 80287 instrs permissible.<br>
    <br>
    Bit 11- 80386 instrs permissible.<br>
    <br>
    (bit 11 is also set for 80486 and Pentium instr sets).</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">@Environ</font></td>
    <td><font face="Arial" size="2">@Environ(<code>name</code>) returns the text associated
    with DOS environment variable <code>name</code>. The parameter must be a text value that
    evaluates to a valid DOS environment variable name.</font></td>
    <td><font face="Arial" size="2">Text value</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">@Interface</font></td>
    <td><font face="Arial" size="2">Returns a numeric value denoting the current language type
    in use. Note that this information is similar to that provided by the opattr attribute.<br>
    <br>
    &nbsp;<br>
    <br>
    The H.O. bit determines if you are assembling code for MS-DOS/Windows or OS/2.<br>
    <br>
    &nbsp;<br>
    <br>
    This directive is mainly useful for those using MASM's simplified segment directives.
    Since this text does not deal with the simplified directives, further discussion of this
    variable is unwarranted.</font></td>
    <td><font face="Arial" size="2">Bits 0-2<br>
    <br>
    000- No language type<br>
    <br>
    001- C<br>
    <br>
    010- SYSCALL<br>
    <br>
    011- STDCALL<br>
    <br>
    100- Pascal<br>
    <br>
    101- FORTRAN<br>
    <br>
    110- BASIC<br>
    <br>
    &nbsp;<br>
    <br>
    Bit 7<br>
    <br>
    0- MS-DOS or Windows<br>
    <br>
    1- OS/2</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">@Version</font></td>
    <td><font face="Arial" size="2">Returns a numeric value that is the current MASM version
    number multiplied by 100. For example, MASM 6.11's <code>@version</code> variable returns
    611.</font></td>
    <td><font face="Arial" size="2">Numeric value</font></td>
  </tr>
  <tr>
    <td rowspan="3"><font face="Arial" size="2">File Information</font></td>
    <td><font face="Arial" size="2">@FileCur</font></td>
    <td><font face="Arial" size="2">Returns the current source or include file name, including
    any necessary pathname information.</font></td>
    <td><font face="Arial" size="2">Text value</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">@FileName</font></td>
    <td><font face="Arial" size="2">Returns the current source file name (base name only, no
    path information). If in an include file, this variable returns the name of the source
    file that included the current file.</font></td>
    <td><font face="Arial" size="2">Text value</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">@Line</font></td>
    <td><font face="Arial" size="2">Returns the current line number in the source file.</font></td>
    <td><font face="Arial" size="2">Numeric value</font></td>
  </tr>
  <tr>
    <td rowspan="9"><font face="Arial" size="2">Segment<br>
    <br>
    Information</font></td>
    <td><font face="Arial" size="2">@code</font></td>
    <td><font face="Arial" size="2">Returns the name of the current code segment.</font></td>
    <td><font face="Arial" size="2">Text value</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">@data</font></td>
    <td><font face="Arial" size="2">Returns the name of the current data segment.</font></td>
    <td><font face="Arial" size="2">Text value</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">@FarData?</font></td>
    <td><font face="Arial" size="2">Returns the name of the current far data segment.</font></td>
    <td><font face="Arial" size="2">Text value</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">@WordSize</font></td>
    <td><font face="Arial" size="2">Returns two if this is a 16 bit segment, four if this is a
    32 bit segment.</font></td>
    <td><font face="Arial" size="2">Numeric value</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">@CodeSize</font></td>
    <td><font face="Arial" size="2">Returns zero for Tiny, Small, Compact, and Flat models.
    Returns one for Medium, Large, and Huge models.</font></td>
    <td><font face="Arial" size="2">Numeric value</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">@DataSize</font></td>
    <td><font face="Arial" size="2">Returns zero for Tiny, Small, Medium, and Flat memory
    models. Returns one for Compact and Large models. Returns two for Huge model programs.</font></td>
    <td><font face="Arial" size="2">Numeric value</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">@Model</font></td>
    <td><font face="Arial" size="2">Returns one for Tiny model, two for Small model, three for
    Compact model, four for Medium model, five for Large model, six for Huge model, and seven
    for Flag model.</font></td>
    <td><font face="Arial" size="2">Numeric value</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">@CurSeg</font></td>
    <td><font face="Arial" size="2">Returns the name of the current code segment.</font></td>
    <td><font face="Arial" size="2">Text value</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">@stack</font></td>
    <td><font face="Arial" size="2">The name of the current stack segment.</font></td>
    <td><font face="Arial" size="2">Text value</font></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">Although there is insufficient space to go into detail
about the possible uses for each of these variables, a few examples might demonstrate some
of the possibilities. Other uses of these variables will appear throughout the text;
however, the most impressive uses will be the ones you discover.</font></p>

<p><font face="Arial" size="2">The <code>@CPU</code> variable is quite useful if you want
to assemble different code sequences in your program for different processors. The section
on conditional assembly in this chapter described how you could create a symbol to
determine if you are assembling the code for an 80386 and later processor or a stock 8086
processor. The<code> @CPU</code> symbol provides a symbol that will tell you exactly which
instructions are allowable at any given point in your program. The following is a rework
of that example using the <code>@CPU </code>variable:</font> </p>

<pre><font face="Courier New" size="2">                if      @CPU and 100b   ;Need an 80286 or later processor
                shl     ax, 4           ; for this instruction.
                else                    ;Must be 8086 processor.
                mov     cl, 4
                shl     ax, cl
                endif</font></pre>

<p><font face="Arial" size="2">You can use the <code>@Line</code> directive to put special
diagnostic messages in your code. The following code would print an error message
including the line number in the source file of the offending assertion, if it detects an
error at run-time: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, ErrorFlag
                cmp     ax, 0
                je      NoError
                mov     ax, @Line       ;Load AX with current line #
                call    PrintError      ;Go print error message and Line #
                jmp     Quit            ;Terminate program.</font></pre>

<pre><strong><font face="Arial" size="3">8.14.9 Macros vs. Text Equates</font></strong></pre>

<p><font face="Arial" size="2">Macros, macro functions, and text equates all substitute
text in a program. While there is some overlap between them, they really do serve
different purposes in an assembly language program. </font></p>

<p><font face="Arial" size="2">Text equates perform a single text substitution on a line.
They do not allow any parameters. However, you can replace text anywhere on a line with a
text equate. You can expand a text equate in the label, mnemonic, operand, or even the
comment field. Furthermore, you can replace multiple fields, even an entire line with a
single symbol.</font></p>

<p><font face="Arial" size="2">Macro functions are legal in the operand field only.
However, you can pass parameters to macro functions making them considerably more general
than simple text equates.</font></p>

<p><font face="Arial" size="2">Procedural macros let you emit sequences of statements
(with text equates you can emit, at most, one statement).</font></p>

<p><font face="Arial" size="3"><strong><a NAME="HEADING8-130"></a>8.14.10 Macros: Good and
Bad News</strong></font></p>

<p><font face="Arial" size="2">Macros offer considerable convenience. They let you insert
several instructions into your source file by simply typing a single command. This can
save you an incredible amount of typing when entering huge tables, each line of which
contains some bizarre, but repeated calculation. It's useful (in certain cases) for
helping make your programs more readable. Few would argue that <code>ForLp I,1,10 </code>is
not more readable than the corresponding 80x86 code. Unfortunately, it's easy to get
carried away and produce code that is inefficient, hard to read, and hard to maintain.</font></p>

<p><font face="Arial" size="2">A lot of so-called &quot;advanced&quot; assembly language
programmers get carried away with the idea that they can create their own instructions via
macro definitions and they start creating macros for every imaginable function under the
sun. The <code>COPY</code> macro presented earlier is a good example. The 80x86 doesn't
support a memory to memory move operation. Fine, we'll create a macro that does the job
for us. Soon, the assembly language program doesn't look like 80x86 assembly language at
all. Instead, a large number of the statements are macro invocations. Now this may be
great for the programmer who has created all these macros and intimately understands their
operation. To the 80x86 programmer who isn't familiar with those macros, however, it's all
gibberish. Maintaining a program someone else wrote, that contains &quot;new&quot;
instructions implemented via macros, is a horrible task. Therefore, you should rarely use
macros as a device to create new instructions on the 80x86.</font></p>

<p><font face="Arial" size="2">Another problem with macros is that they tend to hide side
effects. Consider the <code>COPY</code> macro presented earlier. If you encountered a
statement of the form <code>COPY VAR1,VAR2</code> in an assembly language program, you'd
think that this was an innocuous statement that copies <code>VAR2</code> to <code>VAR1</code>.
Wrong! It also destroys the current contents of the <code>ax </code>register leaving a
copy of the value in VAR2 in the <code>ax </code>register. This macro invocation doesn't
make this very clear. Consider the following code sequence: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, 5
                copy    Var2, Var1
                mov     Var1, ax</font></pre>

<p><font face="Arial" size="2">This code sequence copies <code>Var1</code> into <code>Var2</code>
and then (supposedly) stores five into <code>Var1</code>. Unfortunately, the <code>COPY</code>
macro has wiped out the value in <code>ax </code>(leaving the value originally contained
in <code>Var1</code> alone), so this instruction sequence does not modify <code>Var1</code>
at all! </font></p>

<p><font face="Arial" size="2">Another problem with macros is efficiency. Consider the
following invocations of the <code>COPY</code> macro: </font></p>

<pre><font face="Courier New" size="2">                copy    Var3, Var1
                copy    Var2, Var1
                copy    Var0, Var1</font></pre>

<p><font face="Arial" size="2">These three statements generate the code: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, Var1
                mov     Var3, ax
                mov     ax, Var1
                mov     Var2, ax
                mov     ax, Var1
                mov     Var0, ax</font></pre>

<p><font face="Arial" size="2">Clearly, the last two <code>mov ax,Var1</code> instructions
are superfluous. The <code>ax </code>register already contains a copy of <code>Var1</code>,
there is no need to reload <code>ax </code>with this value. Unfortunately, this
inefficiency, while perfectly obvious in the expanded code, isn't obvious at all in the
macro invocations. </font></p>

<p><font face="Arial" size="2">Another problem with macros is complexity. In order to
generate efficient code, you can create extremely complex macros using conditional
assembly (especially <code>ifb</code>, <code>ifidn</code>, etc.), repeat loops (described
a little later), and other directives. Unfortunately, these macros are small programs all
on their own. You can have bugs in your macros just as you can have bugs in your assembly
language program. And the more complex your macros become, the more likely they'll contain
bugs that will, of course, become bugs in your program when invoking the macro. </font></p>

<p><font face="Arial" size="2">Overusing macros, especially complex ones, produces hard to
read code that is hard to maintain. Despite the enthusiastic claims of those who love
macros, the unbridled use of macros within a program generally causes more bugs than it
helps to prevent. If you're going to use macros, go easy on them.</font></p>

<p><font face="Arial" size="2">There is a good side to macros, however. If you standardize
on a set of macros and document all your programs as using these macros, they may help
make your programs more readable. Especially if those macros have easily identifiable
names. The UCR Standard Library for 80x86 Assembly Language Programmers uses macros for
most library calls.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH08-7.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH08-7.html">Chapter Eight</a> (Part 7)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH08-9.html">Chapter Eight</a> (Part 9) </strong></font><a href="CH08-9.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Eight: MASM: Directives &amp;
Pseudo-Opcodes (Part 8)<br>
26 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_8/CH08-8.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:37 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
