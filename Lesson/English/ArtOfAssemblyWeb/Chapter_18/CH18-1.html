<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_18/CH18-1.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:34 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER EIGHTEEN: RESIDENT PROGRAMS (Part 1)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING1"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" height="25" nowrap><p align="left"><a href="../Chapter_17/CH17-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a> <a href="../Chapter_17/CH17-1.html"><font face="Arial" size="2"><strong>Chapter Seventeen</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" height="25" nowrap><font face="Arial" size="2"><strong><a href="../toc.html">Table of Content</a></strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" height="25" nowrap><font face="Arial" size="2"><strong><p align="right"><a href="CH18-2.html">Chapter Eighteen</a>
    (Part 2) <a href="CH18-2.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></strong></font></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3" nowrap height="10"></td>
  </tr>
  <tr>
    <td width="100%" colspan="3" bgcolor="#F0F0F0"><font face="Arial" size="4"><strong>CHAPTER
    EIGHTEEN:<br>
    RESIDENT PROGRAMS (Part 1)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" colspan="3" nowrap height="10"></td>
  </tr>
  <tr>
    <td width="40%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING1-3"><b>18.1 </b>-
    DOS Memory Usage and TSRs </a><br>
    <a HREF="CH18-2.html#HEADING2-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH18/CH18-2.html#HEADING2-1"><b>18.2 </b>-
    Active vs. Passive TSRs </a><br>
    <a HREF="CH18-3.html#HEADING3-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH18/CH18-3.html#HEADING3-1"><b>18.3 </b>-
    Reentrancy </a><br>
    <a HREF="CH18-3.html#HEADING3-4" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH18/CH18-3.html#HEADING3-4"><b>18.3.1
    </b>- Reentrancy Problems with DOS </a><br>
    <a HREF="CH18-3.html#HEADING3-14" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH18/CH18-3.html#HEADING3-14"><b>18.3.2
    </b>- Reentrancy Problems with BIOS </a><br>
    <a HREF="CH18-3.html#HEADING3-29" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH18/CH18-3.html#HEADING3-29"><b>18.3.3
    </b>- Reentrancy Problems with Other Code</a> <br>
    <a HREF="CH18-3.html#HEADING3-34" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH18/CH18-3.html#HEADING3-34"><b>18.4 </b>-
    The Multiplex Interrupt (INT 2Fh) </a><br>
    <a HREF="CH18-4.html#HEADING4-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH18/CH18-4.html#HEADING4-1"><b>18.5 </b>-
    Installing a TSR </a><br>
    <a HREF="CH18-4.html#HEADING4-98" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH18/CH18-4.html#HEADING4-98"><b>18.6 </b>-
    Removing a TSR </a><br>
    <a HREF="CH18-4.html#HEADING4-166" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH18/CH18-4.html#HEADING4-166"><b>18.7
    </b>- Other DOS Related Issues</a> <br>
    <a HREF="CH18-5.html#HEADING5-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH18/CH18-5.html#HEADING5-1"><b>18.8 </b>-
    A Keyboard Monitor TSR</a> <br>
    <a HREF="CH18-6.html#HEADING6-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH18/CH18-6.html#HEADING6-1"><b>18.9 </b>-
    Semiresident Programs</a></font></td>
    <td width="20" nowrap valign="top"></td>
    <td width="60%" valign="top"><font size="1" face="Arial">Copyright 1996 by Randall Hyde
    All rights reserved. <br>
    <br>
    Duplication other than for immediate display through a browser is prohibited by U.S.
    Copyright Law. <br>
    This material is provided on-line as a beta-test of this text. It is for the personal use
    of the reader only. If you are interested in using this material as part of a course,
    please contact rhyde@cs.ucr.edu <br>
    <br>
    Supporting software and other materials are available via anonymous ftp from
    ftp.cs.ucr.edu. See the &quot;/pub/pc/ibmpcdir&quot; directory for details. You may also
    download the material from &quot;Randall Hyde's Assembly Language Page&quot; at URL:
    http://webster.ucr.edu<br>
    <br>
    Notes: <br>
    This document does not contain the laboratory exercises, programming assignments,
    exercises, or chapter summary. These portions were omitted for several reasons: either
    they wouldn't format properly, they contained hyperlinks that were too much work to
    resolve, they were under constant revision, or they were not included for security
    reasons. Such omission should have very little impact on the reader interested in learning
    this material or evaluating this document. <br>
    <br>
    This document was prepared using Harlequin's Web Maker 2.2 and Quadralay's Webworks
    Publisher. Since HTML does not support the rich formatting options available in
    Framemaker, this document is only an approximation of the actual chapter from the
    textbook. <br>
    <br>
    If you are absolutely dying to get your hands on a version other than HTML, you might
    consider having the UCR Printing a Reprographics Department run you off a copy on their
    Xerox machines. For details, please read the following EMAIL message I received from the
    Printing and Reprographics Department: </font><blockquote>
      <p><font size="1" face="Arial">Hello Again Professor Hyde,<br>
      <br>
      Dallas gave me permission to take orders for the Computer Science 13 Manuals. We would
      need to take charge card orders. The only cards we take are: Master Card, Visa, and
      Discover. They would need to send the name, numbers, expiration date, type of card, and
      authorization to charge $95.00 for the manual and shipping, also we should have their
      phone number in case the company has any trouble delivery. They can use my e-mail address
      for the orders and I will process them as soon as possible. I would assume that two weeks
      would be sufficient for printing, packages and delivery time.<br>
      <br>
      I am open to suggestions if you can think of any to make this as easy as possible.<br>
      <br>
      Thank You for your business,<br>
      Kathy Chapman, Assistant<br>
      Printing and Reprographics University of California Riverside (909) 787-4443/4444 </font></p>
    </blockquote>
    <p><font size="1" face="Arial">We are currently working on ways to publish this text in a
    form other than HTML (e.g., Postscript, PDF, Frameviewer, hard copy, etc.). This, however,
    is a low-priority project. Please do not contact Randall Hyde concerning this effort. When
    something happens, an announcement will appear on &quot;Randall Hyde's Assembly Language
    Page.&quot; Please visit this WEB site at http://webster.ucr.edu for the latest scoop.</font></p>
    <p><font size="1" face="Arial">Redesigned 10/2000 with &quot;MS FrontPage 98&quot; using
    17&quot; monitor 1024x768<br>
    (c) 2000 <a href="mail%20to_%20bircom_yanoo.html">BIRCOM Entertainment'95</a></font></td>
  </tr>
</table>
</center></div>

<hr noshade size="1" color="#000000">

<p><font face="Arial" size="2">Most MS-DOS applications are transient. They load into
memory, execute, terminate, and DOS uses the memory allocated to the application for the
next program the user executes. Resident programs follow these same rules, except for the
last. A resident program, upon termination, does not return all memory back to DOS.
Instead, a portion of the program remains resident, ready to be reactivated by some other
program at a future time.</font></p>

<p><font face="Arial" size="2">Resident programs, also known as terminate and stay
resident programs or TSRs, provide a tiny amount of multitasking to an otherwise single
tasking operating system. Until Microsoft Windows became popular, resident programs were
the most popular way to allow multiple applications to coexist in memory at one time.
Although Windows has diminished the need for TSRs for background processing, TSRs are
still valuable for writing device drivers, antiviral tools, and program patches. This
chapter will discuss the issues you must deal with when writing resident programs.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING1-3"></a>18.1 DOS
    Memory Usage and TSRs</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">When you first boot DOS, the memory layout will look
something like the following:</font></p>

<p align="center"><img SRC="images/ch18a.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH18/ch18a.gif" NATURALSIZEFLAG="3" ALIGN="bottom" border="0" WIDTH="388" HEIGHT="147"> </p>

<p><font face="Arial" size="2">DOS maintains a free memory pointer that points the the
beginning of the block of free memory. When the user runs an application program, DOS
loads this application starting at the address the free memory pointer contains. Since DOS
generally runs only a single application at a time, all the memory from the free memory
pointer to the end of RAM (0BFFFFh) is available for the application's use:</font></p>

<p align="center"><img SRC="images/ch18a1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH18/ch18a1.gif" NATURALSIZEFLAG="3" ALIGN="bottom" border="0" WIDTH="264" HEIGHT="151"> </p>

<p><font face="Arial" size="2">When the program terminates normally via DOS function 4Ch
(the Standard Library <code>exitpgm</code> macro), MS-DOS reclaims the memory in use by
the application and resets the free memory pointer to just above DOS in low memory.</font></p>

<p><font face="Arial" size="2">MS-DOS provides a second termination call which is
identical to the terminate call with one exception, it does not reset the free memory
pointer to reclaim all the memory in use by the application. Instead, this terminate and
stay resident call frees all but a specified block of memory. The TSR call (<code>ah</code>=31h)
requires two parameters, a process termination code in the <code>al</code> register
(usually zero) and <code>dx</code> must contain the size of the memory block to protect,
in paragraphs. When DOS executes this code, it adjusts the free memory pointer so that it
points at a location dx*16 bytes above the program's PSP. This leaves memory looking like
this:</font></p>

<p align="center"><img SRC="images/ch18a2.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH18/ch18a2.gif" NATURALSIZEFLAG="3" ALIGN="bottom" border="0" WIDTH="292" HEIGHT="151"> </p>

<p><font face="Arial" size="2">When the user executes a new application, DOS loads it into
memory at the new free memory pointer address, protecting the resident program in memory:</font></p>

<p align="center"><img SRC="images/ch18a3.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH18/ch18a3.gif" NATURALSIZEFLAG="3" ALIGN="bottom" border="0" WIDTH="358" HEIGHT="146"> </p>

<p><font face="Arial" size="2">When this new application terminates, DOS reclaims its
memory and readjusts the free memory pointer to its location before running the
application - just above the resident program. By using this free memory pointer scheme,
DOS can protect the memory in use by the resident program.</font></p>

<p><font face="Arial" size="2">The trick to using the terminate and stay resident call is
to figure out how many paragraphs should remain resident. Most TSRs contain two sections
of code: a resident portion and a transient portion. The transient portion is the data,
main program, and support routines that execute when you run the program from the command
line. This code will probably never execute again. Therefore, you should not leave it in
memory when your program terminates. After all, every byte consumed by the TSR program is
one less byte available to other application programs.</font></p>

<p><font face="Arial" size="2">The resident portion of the program is the code that
remains in memory and provides whatever functions are necessary of the TSR. Since the PSP
is usually right before the first byte of program code, to effectively use the DOS TSR
call, your program must be organized as follows:</font></p>

<p align="center"><img SRC="images/ch18a4.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH18/ch18a4.gif" NATURALSIZEFLAG="3" ALIGN="bottom" border="0" WIDTH="304" HEIGHT="122"> </p>

<p><font face="Arial" size="2">To use TSRs effectively, you need to organize your code and
data so that the resident portions of your program loads into lower memory addresses and
the transient portions load into the higher memory addresses. MASM and the Microsoft
Linker both provide facilities that let you control the loading order of segments within
your code. The simple solution, however, is to put all your resident code and data in a
single segment and make sure that this segment appears first in every source module of
your program. In particular, if you are using the UCR Standard Library SHELL.ASM file, you
must make sure that you define your resident segments before the include directives for
the standard library files. Otherwise MS-DOS will load all the standard library routines
before your resident segment and that would waste considerable memory. Note that you only
need to define your resident segment first, you do not have to place all the resident code
and data before the includes. The following will work just fine:</font></p>

<pre><font face="Courier New" size="2">ResidentSeg     segment para public 'resident'
ResidentSeg     ends</font></pre>

<pre><font face="Courier New" size="2">EndResident     segment para public 'EndRes'
EndResident     ends</font></pre>

<pre><font face="Courier New" size="2">                .xlist
                include         stdlib.a
                includelib      stdlib.lib
                .list</font></pre>

<pre><font face="Courier New" size="2">ResidentSeg     segment para public 'resident'
                assume  cs:ResidentSeg, ds:ResidentSeg</font></pre>

<pre><font face="Courier New" size="2">PSP             word    ?               ;This var must be here!</font></pre>

<pre><font face="Courier New" size="2">; Put resident code and data here</font></pre>

<pre><font face="Courier New" size="2">ResidentSeg     ends</font></pre>

<pre><font face="Courier New" size="2">dseg            segment para public 'data'</font></pre>

<pre><font face="Courier New" size="2">; Put transient data here</font></pre>

<pre><font face="Courier New" size="2">dseg            ends</font></pre>

<pre><font face="Courier New" size="2">cseg            segment para public 'code'
                assume  cs:cseg, ds:dseg</font></pre>

<pre><font face="Courier New" size="2">; Put Transient code here.</font></pre>

<pre><font face="Courier New" size="2">cseg            ends
                etc.</font></pre>

<p><font face="Arial" size="2">The purpose of the <code>EndResident</code> segment will
become clear in a moment. For more information on DOS memory ordering, see Chapter Six.</font></p>

<p><font face="Arial" size="2">Now the only problem is to figure out the size of the
resident code, in paragraphs. With your code structured in the manner shown above,
determining the size of the resident program is quite easy, just use the following
statements to terminate the transient portion of your code (in cseg):</font></p>

<pre><font face="Courier New" size="2">                mov     ax, ResidentSeg ;Need access to ResidentSeg
                mov     es, ax
                mov     ah, 62h         ;DOS Get PSP call.
                int     21h
                mov     es:PSP, bx      ;Save PSP value in PSP variable.</font></pre>

<pre><font face="Courier New" size="2">; The following code computes the sixe of the resident portion of the code.
; The EndResident segment is the first segment in memory after resident code.
; The program's PSP value is the segment address of the start of the resident
; block. By computing EndResident-PSP we compute the size of the resident
; portion in paragraphs.</font></pre>

<pre><font face="Courier New" size="2">                mov     dx, EndResident ;Get EndResident segment address.
                sub     dx, bx          ;Subtract PSP.</font></pre>

<pre><font face="Courier New" size="2">; Okay, execute the TSR call, preserving only the resident code.</font></pre>

<pre><font face="Courier New" size="2">                mov     ax, 3100h       ;AH=31h (TSR), AL=0 (return code).
                int     21h</font></pre>

<p><font face="Arial" size="2">Executing the code above returns control to MS-DOS,
preserving your resident code in memory.</font></p>

<p><font face="Arial" size="2">There is one final memory management detail to consider
before moving on to other topics related to resident programs - accessing data within an
resident program. Procedures within a resident program become active in response to a
direct call from some other program or a hardware interrupt (see the next section). Upon
entry, the resident routine may specify that certain registers contain various parameters,
but one thing you cannot expect is for the calling code to properly set up the segment
registers for you. Indeed, the only segment register that will contain a meaningful value
(to the resident code) is the code segment register. Since many resident functions will
want to access local data, this means that those functions may need to set up <code>ds</code>
or some other segment register(s) upon initial entry. For example, suppose you have a
function, count, that simply counts the number of times some other code calls it once it
has gone resident. One would thing that the body of this function would contain a single
instruction: <code>inc counter</code>. Unfortunately, such an instruction would increment
the variable at <code>counter</code>'s offset in the current data segment (that is, the
segment pointed at by the <code>ds</code> register). It is unlikely that <code>ds</code>
would be pointing at the data segment associated with the count procedure. Therefore, you
would be incrementing some word in a different segment (probably the caller's data
segment). This would produce disastrous results. </font></p>

<p><font face="Arial" size="2">There are two solutions to this problem. The first is to
put all variables in the code segment (a very common practice in resident sections of
code) and use a <code>cs:</code> segment override prefix on all your variables. For
example, to increment the <code>counter</code> variable you could use the instruction <code>inc
cs:counter</code>. This technique works fine if there are only a few variable references
in your procedures. However, it suffers from a few serious drawbacks. First, the segment
override prefix makes your instructions larger and slower; this is a serious problem if
you access many different variables throughout your resident code. Second, it is easy to
forget to place the segment override prefix on a variable, thereby causing the TSR
function to wipe out memory in the caller's data segment. Another solution to the segment
problem is to change the value in the <code>ds</code> register upon entry to a resident
procedure and restore it upon exit. The following code demonstrates how to do this:</font></p>

<pre><font face="Courier New" size="2">                push    ds      ;Preserve original DS value.
                push    cs      ;Copy CS's value to DS.
                pop     ds
                inc     Counter ;Bump the variable's value.
                pop     ds      ;Restore original DS value.</font></pre>

<p><font face="Arial" size="2">Of course, using the cs: segment override prefix is a much
more reasonable solution here. However, had the code been extensive and had accessed many
local variables, loading ds with cs (assuming you put your variables in the resident
segment) would be more efficient.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF"><p align="left"><a href="../Chapter_17/CH17-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a> <a href="../Chapter_17/CH17-1.html"><font face="Arial" size="2"><strong>Chapter
    Seventeen</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF"><font face="Arial" size="2"><strong><a href="../toc.html">Table of Content</a></strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF"><font face="Arial" size="2"><strong><p align="right"><a href="CH18-2.html">Chapter Eighteen</a> (Part 2) <a href="CH18-2.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></strong></font></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Eighteen: Resident Programs
(Part 1)<br>
29 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_18/CH18-1.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:40 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
