<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_19/CH19-2.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:43 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER NINETEEN: PROCESSES, COROUTINES AND CONCURRENCY (Part 2)</title>
</head>

<body stylesrc="../toc.html" topmargin="10" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING2"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" height="25" nowrap><p align="left"><a href="CH19-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a> <font face="Arial" size="2"><strong><a href="CH19-1.html">Chapter Nineteen</a>
    (Part 1)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" height="25" nowrap><font face="Arial" size="2"><strong><a href="../toc.html">Table of Content</a></strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" height="25" nowrap><font face="Arial" size="2"><strong><p align="right"><a href="CH19-3.html">Chapter Nineteen</a>
    (Part 3) <a href="CH19-2.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></strong></font></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" nowrap height="10"><a NAME="HEADING2-1"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0"><font face="Arial" size="4"><strong>CHAPTER NINETEEN:<br>
    PROCESSES, COROUTINES AND CONCURRENCY (Part 2)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10"></td>
  </tr>
  <tr>
    <td width="100%"><font face="Arial" size="2"><a HREF="#HEADING2-1"><b>19.1.2 </b>-
    Exception Handling in DOS: The Break Handler</a> <br>
    <a HREF="#HEADING2-9"><b>19.1.3 </b>- Exception Handling in DOS: The Critical Error
    Handler</a> </font></td>
  </tr>
</table>
</center></div>

<h3><strong><font face="Arial" size="3">19.1.2 Exception Handling in DOS: The Break
Handler</font></strong></h3>

<p><font face="Arial" size="2">Whenever the users presses a ctrl-C or ctrl-Break key
MS-DOS may trap such a key sequence and execute an <code>int 23h</code> instruction.
MS-DOS provides a default break handler routine that terminates the program. However, a
well-written program generally replaces the default break handler with one of its own so
it can capture ctrl-C or ctrl-break key sequences and shut the program down in an orderly
fashion.</font></p>

<p><font face="Arial" size="2">When DOS terminates a program due to a break interrupt, it
flushes file buffers, closes all open files, releases memory belonging to the application,
all the normal stuff it does on program termination. However, it does not restore any
interrupt vectors (other than interrupt 23h and interrupt 24h). If your code has replaced
any interrupt vectors, especially hardware interrupt vectors, then those vectors will
still be pointing at your program's interrupt service routines after DOS terminates your
program. This will probably crash the system when DOS loads a new program over the top of
your code. Therefore, you should write a break handler so your application can shut itself
down in an orderly fashion if the user presses ctrl-C or ctrl-break.</font></p>

<p><font face="Arial" size="2">The easiest, and perhaps most universal, break handler
consists of a single instruction - <code>iret</code>. If you point the interrupt 23h
vector at an <code>iret</code> instruction, MS-DOS will simply ignore any ctrl-C or
ctrl-break keys you press. This is very useful for turning off the break handling during
critical sections of code that you do not want the user to interrupt.</font></p>

<p><font face="Arial" size="2">On the other hand, simply turning off ctrl-C and ctrl-break
handling throughout your entire program is not satisfactory either. If for some reason the
user wants to abort your program, pressing ctrl-break or ctrl-C is what they will probably
try to do this. If your program disallows this, the user may resort to something more
drastic like ctrl-alt-delete to reset the machine. This will certainly mess up any open
files and may cause other problems as well (of course, you don't have to worry about
restoring any interrupt vectors!).</font></p>

<p><font face="Arial" size="2">To patch in your own break handler is easy - just store the
address of your break handler routine into the interrupt vector 23h. You don't even have
to save the old value, DOS does this for you automatically (it stores the original vector
at offset 0Eh in the PSP). Then, when the users presses a ctrl-C or ctrl-break key, MS-DOS
transfers control to your break handler.</font></p>

<p><font face="Arial" size="2">Perhaps the best response for a break handler is to set
some flag to tell the application and break occurred, and then leave it up to the
application to test this flag a reasonable points to determine if it should shut down. Of
course, this does require that you test this flag at various points throughout your
application, increasing the complexity of your code. Another alternative is to save the
original int 23h vector and transfer control to DOS' break handler after you handle
important operations yourself. You can also write a specialized break handler to return a
DOS termination code that the parent process can read.</font></p>

<p><font face="Arial" size="2">Of course, there is no reason you cannot change the
interrupt 23h vector at various points throughout your program to handle changing
requirements. At various points you can disable the break interrupt entirely, restore
interrupt vectors at others, or prompt the user at still other points.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-9"></a>19.1.3 Exception Handling
in DOS: The Critical Error Handler</font></strong></p>

<p><font face="Arial" size="2">DOS invokes the critical error handler by executing an int
24h instruction whenever some sort of I/O error occurs. The default handler prints the
familiar message:</font></p>

<pre><font face="Courier New" size="2">I/O Device Specific Error Message
Abort, Retry, Ignore, Fail?</font></pre>

<p><font face="Arial" size="2">If the user presses an &quot;A&quot;, this code immediately
returns to DOS' COMMAND.COM program; it doesn't even close any open files. If the user
presses an &quot;R&quot; to retry, MS-DOS will retry the I/O operation, though this
usually results in another call to the critical error handler. The &quot;I&quot; option
tells MS-DOS to ignore the error and return to the calling program as though nothing had
happened. An &quot;F&quot; response instructs MS-DOS to return an error code to the
calling program and let it handle the problem.</font></p>

<p><font face="Arial" size="2">Of the above options, having the user press &quot;A&quot;
is the most dangerous. This causes an immediate return to DOS and your code does not get
the chance to clean up anything. For example, if you've patched some interrupt vectors,
your program will not get the opportunity to restore them if the user selects the abort
option. This may crash the system when MS-DOS loads the next program over the top of your
interrupt service routine(s) in memory.</font></p>

<p><font face="Arial" size="2">To intercept DOS critical errors, you will need to patch
the interrupt 24h vector to point at your own interrupt service routine. Upon entry into
your interrupt 24h service routine, the stack will contain the following data:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch19a.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH19/ch19a.gif" WIDTH="355" HEIGHT="278"> </font></p>

<p><font face="Arial" size="2">MS-DOS passes important information in several of the
registers to your critical error handler. By inspecting these values you can determine the
cause of the critical error and the device on which it occurred. The high order bit of the
<code>ah</code> register determines if the error occurred on a block structured device
(typically a disk or tape) or a character device. The other bits in ah have the following
meaning:</font></p>
<div align="center"><center>

<table BORDER="1" bordercolor="#C0C0C0" width="30%" cellspacing="0" cellpadding="0">
  <caption><font face="Arial" size="2"><strong>Device Error Bits in AH</strong></font></caption>
  <tr>
    <th align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">Bit(s)</font></strong></th>
    <th bgcolor="#F0F0F0"><p align="center"><font face="Arial" size="2">Description</font></th>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">0</font></strong></td>
    <td><font face="Arial" size="2">0=Read operation.<br>
    1=Write operation.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">1-2</font></strong></td>
    <td><font face="Arial" size="2">Indicates affected disk area.<br>
    00- MS-DOS area.<br>
    01- File allocation table (FAT).<br>
    10- Root directory.<br>
    11- Files area.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">3</font></strong></td>
    <td><font face="Arial" size="2">0- Fail response not allowed.<br>
    1- Fail response is okay.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">4</font></strong></td>
    <td><font face="Arial" size="2">0- Retry response not allowed.<br>
    1- Retry response is okay.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">5</font></strong></td>
    <td><font face="Arial" size="2">0- Ignore response is not allowed.<br>
    1- Ignore response is okay.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">6</font></strong></td>
    <td><font face="Arial" size="2">Undefined</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">7</font></strong></td>
    <td><font face="Arial" size="2">0- Character device error.<br>
    1- Block structured device error.</font></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">In addition to the bits in ah, for block structured devices
the <code>al</code> register contains the drive number where the error occurred (0=A, 1=B,
2=C, etc.). The value in the <code>al</code> register is undefined for character devices.</font></p>

<p><font face="Arial" size="2">The lower half of the <code>di</code> register contains
additional information about the block device error (the upper byte of <code>di</code> is
undefined, you will need to mask out those bits before attempting to test this data).</font></p>
<div align="center"><center>

<table BORDER="1" bordercolor="#C0C0C0" width="45%" cellspacing="0" cellpadding="0">
  <caption><font face="Arial" size="2"><strong>Block Structured Device Error Codes (in L.O.
  byte of DI)</strong></font></caption>
  <tr>
    <th align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">Error Code</font></strong></th>
    <th bgcolor="#F0F0F0"><p align="center"><font face="Arial" size="2">Description</font></th>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">0</font></strong></td>
    <td><font face="Arial" size="2">Write protection error.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">1</font></strong></td>
    <td><font face="Arial" size="2">Unknown drive.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">2</font></strong></td>
    <td><font face="Arial" size="2">Drive not ready.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">3</font></strong></td>
    <td><font face="Arial" size="2">Invalid command.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">4</font></strong></td>
    <td><font face="Arial" size="2">Data error (CRC error).</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">5</font></strong></td>
    <td><font face="Arial" size="2">Length of request structure is incorrect.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">6</font></strong></td>
    <td><font face="Arial" size="2">Seek error on device.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">7</font></strong></td>
    <td><font face="Arial" size="2">Disk is not formatted for MS-DOS.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">8</font></strong></td>
    <td><font face="Arial" size="2">Sector not found.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">9</font></strong></td>
    <td><font face="Arial" size="2">Printer out of paper.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">0Ah</font></strong></td>
    <td><font face="Arial" size="2">Write error.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">0Bh</font></strong></td>
    <td><font face="Arial" size="2">Read error.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">0Ch</font></strong></td>
    <td><font face="Arial" size="2">General failure.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">0Fh</font></strong></td>
    <td><font face="Arial" size="2">Disk was changed at inappropriate time.</font></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">Upon entry to your critical error handler, interrupts are
turned off. Because this error occurs as a result of some MS-DOS call, MS-DOS is already
entered and you will not be able to make any calls other than functions 1-0Ch and 59h (get
extended error information).</font></p>

<p><font face="Arial" size="2">Your critical error handler must preserve all registers
except <code>al</code>. The handler must return to DOS with an <code>iret</code>
instruction and <code>al</code> must contain one of the following codes:</font></p>
<div align="center"><center>

<table BORDER="1" bordercolor="#C0C0C0" width="30%" cellspacing="0" cellpadding="0">
  <caption><font face="Arial" size="2"><strong>Critical Error Handler Return Codes</strong></font></caption>
  <tr>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">Code</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">Meaning</font></th>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">0</font></strong></td>
    <td><font face="Arial" size="2">Ignore device error.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">1</font></strong></td>
    <td><font face="Arial" size="2">Retry I/O operation again.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">2</font></strong></td>
    <td><font face="Arial" size="2">Terminate process (abort).</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">3</font></strong></td>
    <td><font face="Arial" size="2">Fail current system call.</font></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">The following code provides a trivial example of a critical
error handler. The main program attempts to send a character to the printer. If you do not
connect a printer, or turn off the printer before running this program, it will generate
the critical error.</font></p>

<pre><font face="Courier New" size="2">; Sample INT 24h critical error handler.
;
; This code demonstrates a sample critical error handler.
; It patches into INT 24h and displays an appropriate error
; message and asks the user if they want to retry, abort, ignore,
; or fail (just like DOS).

                .xlist
                include         stdlib.a
                includelib      stdlib.lib
                .list


dseg            segment para public 'data'

Value           word    0
ErrCode         word    0

dseg            ends

cseg            segment para public 'code'
                assume  cs:cseg, ds:dseg

; A replacement critical error handler. Note that this routine
; is even worse than DOS', but it demonstrates how to write
; such a routine. Note that we cannot call any Standard Library
; I/O routines in the critical error handler because they do not
; use DOS calls 1-0Ch, which are the only allowable DOS calls at
; this point.


CritErrMsg      byte    cr,lf
                byte    &quot;DOS Critical Error!&quot;,cr,lf
                byte    &quot;A)bort, R)etry, I)gnore, F)ail? $&quot;

MyInt24         proc    far
                push    dx
                push    ds
                push    ax

                push    cs
                pop     ds
Int24Lp:        lea     dx, CritErrMsg
                mov     ah, 9           ;DOS print string call.
                int     21h

                mov     ah, 1           ;DOS read character call.
                int     21h
                and     al, 5Fh         ;Convert l.c. -&gt; u.c.

                cmp     al, 'I'         ;Ignore?
                jne     NotIgnore
                pop     ax
                mov     al, 0
                jmp     Quit24

NotIgnore:      cmp     al, 'r'         ;Retry?
                jne     NotRetry
                pop     ax
                mov     al, 1
                jmp     Quit24

NotRetry:       cmp     al, 'A'         ;Abort?
                jne     NotAbort
                pop     ax
                mov     al, 2
                jmp     Quit24

NotAbort:       cmp     al, 'F'
                jne     BadChar
                pop     ax
                mov     al, 3
Quit24:         pop     ds
                pop     dx
                iret

BadChar:        mov     ah, 2
                mov     dl, 7           ;Bell character
                jmp     Int24Lp
MyInt24         endp



Main            proc
                mov     ax, dseg
                mov     ds, ax
                mov     es, ax
                meminit

                mov     ax, 0
                mov     es, ax
                mov     word ptr es:[24h*4], offset MyInt24
                mov     es:[24h*4 + 2], cs

                mov     ah, 5
                mov     dl, 'a'
                int     21h
                rcl     Value, 1
                and     Value, 1
                mov     ErrCode, ax
                printf
                byte    cr,lf,lf
                byte    &quot;Print char returned with error status %d and &quot;
                byte    &quot;error code %d\n&quot;,0
                dword   Value, ErrCode

Quit:           ExitPgm                 ;DOS macro to quit program.
Main            endp

cseg            ends



; Allocate a reasonable amount of space for the stack (8k).
; Note: if you use the pattern matching package you should set up a
;       somewhat larger stack.

sseg            segment para stack 'stack'
stk             db      1024 dup (&quot;stack &quot;)
sseg            ends


; zzzzzzseg must be the last segment that gets loaded into memory!
; This is where the heap begins.

zzzzzzseg       segment para public 'zzzzzz'
LastBytes       db      16 dup (?)
zzzzzzseg       ends
                end     Main</font></pre>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF"><p align="left"><a href="CH19-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a> <font face="Arial" size="2"><strong><a href="CH19-1.html">Chapter Nineteen</a> (Part 1)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF"><font face="Arial" size="2"><strong><a href="../toc.html">Table of Content</a></strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF"><font face="Arial" size="2"><strong><p align="right"><a href="CH19-3.html">Chapter Nineteen</a> (Part 3) <a href="CH19-2.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></strong></font></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Nineteen: Processes,
Coroutines and Concurrency (Part 2)<br>
29 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_19/CH19-2.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:45 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
