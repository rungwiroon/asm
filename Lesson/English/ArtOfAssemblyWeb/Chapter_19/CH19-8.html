<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_19/CH19-8.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:47 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER NINETEEN: PROCESSES, COROUTINES AND CONCURRENCY (Part 8)</title>
</head>

<body stylesrc="../toc.html" topmargin="10" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING8"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" height="25" nowrap><p align="left"><a href="CH19-7.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a> <font face="Arial" size="2"><strong><a href="CH19-7.html">Chapter Nineteen</a>
    (Part 7)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" height="25" nowrap><font face="Arial" size="2"><strong><a href="../toc.html">Table of Content</a></strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" height="25" nowrap><font face="Arial" size="2"><strong><p align="right"><a href="CH19-9.html">Chapter Nineteen</a>
    (Part 9) <a href="CH19-9.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></strong></font></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" nowrap height="10"><a NAME="HEADING8-1"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0"><font face="Arial" size="4"><strong>CHAPTER NINETEEN:<br>
    PROCESSES, COROUTINES AND CONCURRENCY (Part 8)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10"></td>
  </tr>
  <tr>
    <td width="100%"><font face="Arial" size="2"><a HREF="#HEADING8-1"><b>19.3.2 </b>- 32-bit
    Coroutines</a> </font></td>
  </tr>
</table>
</center></div>

<h3><strong><font face="Arial" size="3">19.3.2 32-bit Coroutines</font></strong></h3>

<p><font face="Arial" size="2">The existing Standard Library (v1.0) coroutine package is
not suitable for programs that use the 80386 and later 32 bit register sets. As mentioned
earlier, the problem lies in the fact that the Standard Library only preserves the 16-bit
registers when switching between processes. However, it is a relatively trivial extension
to modify the Standard Library so that it saves 32 bit registers. To do so, just change
the definition of the <code>pcb</code> (to make room for the 32 bit registers) and the <code>sl_cocall</code>
routine:</font></p>

<pre><font face="Courier New" size="2">                .386
                option  segment:use16

dseg            segment para public 'data'

wp              equ     &lt;word ptr&gt;

; 32-bit PCB.  Note we only keep the L.O. 16 bits of SP since we are
; operating in real mode.

pcb32           struc
regsp           word    ?
regss           word    ?
regip           word    ?
regcs           word    ?

regeax          dword   ?
regebx          dword   ?
regecx          dword   ?
regedx          dword   ?
regesi          dword   ?
regedi          dword   ?
regebp          dword   ?

regds           word    ?
reges           word    ?
regflags        dword   ?
pcb32           ends


DefaultPCB      pcb32   &lt;&gt;
DefaultCortn    pcb32   &lt;&gt;

CurCoroutine    dd      DefaultCortn    ;Points at the currently executing
                                        ; coroutine.
dseg            ends


cseg            segment para public 'slcode'

;============================================================================
;
; Coroutine support.
;
; COINIT- ES:DI contains the address of the current (default) process.

CoInit32        proc    far
                assume  ds:dseg
                push    ax
                push    ds
                mov     ax, dseg
                mov     ds, ax
                mov     wp dseg:CurCoroutine, di
                mov     wp dseg:CurCoroutine+2, es
                pop     ds
                pop     ax
                ret
CoInit32        endp


; COCALL32- transfers control to a coroutine.  ES:DI contains the address
; of the PCB.  This routine transfers control to that coroutine and then
; returns a pointer to the caller's PCB in ES:DI.

cocall32        proc    far
                assume  ds:dseg
                pushfd
                push    ds
                push    es                      ;Save these for later
                push    edi
                push    eax
                mov     ax, dseg
                mov     ds, ax
                cli                             ;Critical region ahead.


; Save the current process' state:

                les     di, dseg:CurCoroutine
                pop     es:[di].pcb32.regeax
                mov     es:[di].pcb32.regebx, ebx
                mov     es:[di].pcb32.regecx, ecx
                mov     es:[di].pcb32.regedx, edx
                mov     es:[di].pcb32.regesi, esi
                pop     es:[di].pcb32.regedi
                mov     es:[di].pcb32.regebp, ebp

                pop     es:[di].pcb32.reges
                pop     es:[di].pcb32.regds
                pop     es:[di].pcb32.regflags
                pop     es:[di].pcb32.regip
                pop     es:[di].pcb32.regcs
                mov     es:[di].pcb32.regsp, sp
                mov     es:[di].pcb32.regss, ss

                mov     bx, es                  ;Save so we can return in
                mov     ecx, edi                ; ES:DI later.
                mov     edx, es:[di].pcb32.regedi
                mov     es, es:[di].pcb32.reges
                mov     di, dx                  ;Point es:di at new PCB

                mov     wp dseg:CurCoroutine, di
                mov     wp dseg:CurCoroutine+2, es

                mov     es:[di].pcb32.regedi, ecx ;The ES:DI return values.
                mov     es:[di].pcb32.reges, bx

; Okay, switch to the new process:

                mov     ss, es:[di].pcb32.regss
                mov     sp, es:[di].pcb32.regsp
                mov     eax, es:[di].pcb32.regeax
                mov     ebx, es:[di].pcb32.regebx
                mov     ecx, es:[di].pcb32.regecx
                mov     edx, es:[di].pcb32.regedx
                mov     esi, es:[di].pcb32.regesi
                mov     ebp, es:[di].pcb32.regebp
                mov     ds, es:[di].pcb32.regds

                push    es:[di].pcb32.regflags
                push    es:[di].pcb32.regcs
                push    es:[di].pcb32.regip
                push    es:[di].pcb32.regedi
                mov     es, es:[di].pcb32.reges
                pop     edi
                iret
cocall32        endp


; CoCall32l works just like cocall above, except the address of the pcb
; follows the call in the code stream rather than being passed in ES:DI.
; Note: this code does *not* return the caller's PCB address in ES:DI.
;

cocall32l       proc    far
                assume  ds:dseg
                push    ebp
                mov     bp, sp
                pushfd
                push    ds
                push    es
                push    edi
                push    eax
                mov     ax, dseg
                mov     ds, ax
                cli                             ;Critical region ahead.

; Save the current process' state:

                les     di, dseg:CurCoroutine
                pop     es:[di].pcb32.regeax
                mov     es:[di].pcb32.regebx, ebx
                mov     es:[di].pcb32.regecx, ecx
                mov     es:[di].pcb32.regedx, edx
                mov     es:[di].pcb32.regesi, esi
                pop     es:[di].pcb32.regedi
                pop     es:[di].pcb32.reges
                pop     es:[di].pcb32.regds
                pop     es:[di].pcb32.regflags
                pop     es:[di].pcb32.regebp
                pop     es:[di].pcb32.regip
                pop     es:[di].pcb32.regcs
                mov     es:[di].pcb32.regsp, sp
                mov     es:[di].pcb32.regss, ss

                mov     dx, es:[di].pcb32.regip ;Get return address (ptr to
                mov     cx, es:[di].pcb32.regcs ; PCB address.
                add     es:[di].pcb32.regip, 4  ;Skip ptr on return.
                mov     es, cx                  ;Get the ptr to the new pcb
                mov     di, dx                  ; address, then fetch the
                les     di, es:[di]             ; pcb val.
                mov     wp dseg:CurCoroutine, di
                mov     wp dseg:CurCoroutine+2, es

; Okay, switch to the new process:

                mov     ss, es:[di].pcb32.regss
                mov     sp, es:[di].pcb32.regsp
                mov     eax, es:[di].pcb32.regeax
                mov     ebx, es:[di].pcb32.regebx
                mov     ecx, es:[di].pcb32.regecx
                mov     edx, es:[di].pcb32.regedx
                mov     esi, es:[di].pcb32.regesi
                mov     ebp, es:[di].pcb32.regebp
                mov     ds, es:[di].pcb32.regds

                push    es:[di].pcb32.regflags
                push    es:[di].pcb32.regcs
                push    es:[di].pcb32.regip
                push    es:[di].pcb32.regedi
                mov     es, es:[di].pcb32.reges
                pop     edi
                iret


cocall32l       endp
cseg            ends
                end</font></pre>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF"><p align="left"><a href="CH19-7.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a> <font face="Arial" size="2"><strong><a href="CH19-7.html">Chapter Nineteen</a> (Part 7)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF"><font face="Arial" size="2"><strong><a href="../toc.html">Table of Content</a></strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF"><font face="Arial" size="2"><strong><p align="right"><a href="CH19-9.html">Chapter Nineteen</a> (Part 9) <a href="CH19-9.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></strong></font></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Nineteen: Processes,
Coroutines and Concurrency (Part 8)<br>
29 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_19/CH19-8.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:47 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
