<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_19/CH19-6.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:45 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER NINETEEN: PROCESSES, COROUTINES AND CONCURRENCY (Part 6)</title>
</head>

<body stylesrc="http://Voodoo2/masm/toc.html" topmargin="10" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING6"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" height="25" nowrap><p align="left"><a href="CH19-5.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a> <font face="Arial" size="2"><strong><a href="CH19-5.html">Chapter Nineteen</a>
    (Part 5)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" height="25" nowrap><font face="Arial" size="2"><strong><a href="../toc.html">Table of Content</a></strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" height="25" nowrap><font face="Arial" size="2"><strong><p align="right"><a href="CH19-7.html">Chapter Nineteen</a>
    (Part 7) <a href="CH19-7.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></strong></font></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" nowrap height="10"><a NAME="HEADING6-1"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0"><font face="Arial" size="4"><strong>CHAPTER NINETEEN:<br>
    PROCESSES, COROUTINES AND CONCURRENCY (Part 6)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10"></td>
  </tr>
  <tr>
    <td width="100%"><a HREF="#HEADING6-1"><font face="Arial" size="2"><b>19.3 </b>-
    Coroutines</font></a></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="20"></td>
  </tr>
  <tr>
    <td width="100%"><strong><font face="Arial" size="3">19.3 Coroutines</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="1" bgcolor="#000000"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">DOS processes, even when using shared memory, suffer from
one primary drawback - each program executes to completion before returning control back
to the parent process. While this paradigm is suitable for many applications, it certainly
does not suffice for all. A common paradigm is for two programs to swap control of the CPU
back and forth while executing. This mechanism, slightly different from the subroutine
call and return mechanism, is a coroutine.</font></p>

<p><font face="Arial" size="2">Before discussing coroutines, it is probably a good idea to
provide a solid definition for the term process. In a nutshell, a process is a program
that is executing. A program can exist on the disk; processes exist in memory and have a
program stack (with return addresses, etc.) associated with them. If there are multiple
processes in memory at one time, each process must have its own program stack.</font></p>

<p><font face="Arial" size="2">A cocall operation transfers control between two processes.
A cocall is effectively a call and a return instruction all rolled into one operation.
From the point of view of the process executing the cocall, the cocall operation is
equivalent to a procedure call; from the point of view of the processing being called, the
cocall operation is equivalent to a return operation. When the second process cocalls the
first, control resumes not at the beginning of the first process, but immediately after
the cocall operation. If two processes execute a sequence of mutual cocalls, control will
transfer between the two processes in the following fashion:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch19a1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH19/ch19a1.gif" WIDTH="201" HEIGHT="404" NATURALSIZEFLAG="3" ALIGN="bottom"> </font></p>

<p><font face="Arial" size="2">Cocalls are quite useful for games where the
&quot;players&quot; take turns, following different strategies. The first player executes
some code to make its first move, then cocalls the second player and allows it to make a
move. After the second player makes its move, it cocalls the first process and gives the
first player its second move, picking up immediately after its cocall. This transfer of
control bounces back and forth until one player wins.</font></p>

<p><font face="Arial" size="2">The 80x86 CPUs do not provide a cocall instruction.
However, it is easy to implement cocalls with existing instructions. Even so, there is
little need for you to supply your own cocall mechanism, the UCR Standard Library provides
a cocall package for 8086, 80186, and 80286 processors. This package includes the <code>pcb</code>
(process control block) data structure and three functions you can call: <code>coinit</code>,
<code>cocall</code>, and <code>cocalll</code>.</font></p>

<p><font face="Arial" size="2">The <code>pcb</code> structure maintains the current state
of a process. The <code>pcb</code> maintains all the register values and other accounting
information for a process. When a process makes a cocall, it stores the return address for
the cocall in the <code>pcb</code>. Later, when some other process cocalls this process,
the cocall operation simply reloads the registers, include <code>cs:ip</code>, from the <code>pcb</code>
and that returns control to the next instruction after the first process' cocall. The <code>pcb</code>
structure takes the following form:</font></p>

<pre><font face="Courier New" size="2">pcb             struct
NextProc        dword   ?       ;Link to next PCB (for multitasking).
regsp           word    ?
regss           word    ?
regip           word    ?
regcs           word    ?
regax           word    ?
regbx           word    ?
regcx           word    ?
regdx           word    ?
regsi           word    ?
regdi           word    ?
regbp           word    ?
regds           word    ?
reges           word    ?
regflags        word    ?
PrcsID          word    ?
StartingTime    dword   ?       ;Used for multitasking accounting.
StartingDate    dword   ?       ;Used for multitasking accounting.
CPUTime         dword   ?       ;Used for multitasking accounting.</font></pre>

<p><font face="Arial" size="2">Four of these fields (as labelled) exist for preemptive
multitasking and have no meaning for coroutines. We will discuss preemptive multitasking
in the next section.</font></p>

<p><font face="Arial" size="2">There are two important things that should be evident from
this structure. First, the main reason the existing Standard Library coroutine support is
limited to 16 bit register is because there is only room for the 16 bit versions of each
of the registers in the <code>pcb</code>. If you want to support the 80386 and later 32
bit register sets, you would need to modify the <code>pcb</code> structure and the code
that saves and restores registers in the <code>pcb</code>.</font></p>

<p><font face="Arial" size="2">The second thing that should be evident is that the
coroutine code preserves all registers across a cocall. This means you cannot pass
information from one process to another in the registers when using a cocall. You will
need to pass data between processes in global memory locations. Since coroutines generally
exist in the same program, you will not even need to resort to the shared memory
techniques. Any variables you declare in your data segment will be visible to all
coroutines.</font></p>

<p align="left"><font face="Arial" size="2">Note, by the way, that a program may contain
more than two coroutines. If coroutine one cocalls coroutine two, and coroutine two
cocalls coroutine three, and then coroutine three cocalls coroutine one, coroutine one
picks up immediately after the cocall it made to coroutine two.</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch19a2.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH19/ch19a2.gif" WIDTH="219" HEIGHT="212" NATURALSIZEFLAG="3" ALIGN="bottom"> </font></p>

<p><font face="Arial" size="2">Since a cocall effectively returns to the target coroutine,
you might wonder what happens on the first cocall to any process. After all, if that
process has not executed any code, there is no &quot;return address&quot; where you can
resume execution. This is an easy problem to solve, we need only initialize the return
address of such a process to the address of the first instruction to execute in that
process.</font></p>

<p><font face="Arial" size="2">A similar problem exists for the stack. When a program
begins execution, the main program (coroutine one) takes control and uses the stack
associated with the entire program. Since each process must have its own stack, where do
the other coroutines get their stacks? </font></p>

<p><font face="Arial" size="2">The easiest way to initialize the stack and initial address
for a coroutine is to do this when declaring a <code>pcb</code> for a process. Consider
the following <code>pcb</code> variable declaration:</font></p>

<pre><font face="Courier New" size="2">ProcessTwo      pcb     {0, offset EndStack2, seg EndStack2,
                            offset StartLoc2, seg StartLoc2}</font></pre>

<p><font face="Arial" size="2">This definition initializes the NextProc field with NULL
(the Standard Library coroutine functions do not use this field) and initialize the<code>
ss:sp</code> and <code>cs:ip</code> fields with the last address of a stack area (<code>EndStack2</code>)
and the first instruction of the process (<code>StartLoc2</code>). Now all you need to do
is reserve a reasonable amount of stack storage for the process. You can create multiple
stacks in the SHELL.ASM <code>sseg</code> as follows:</font></p>

<pre><font face="Courier New" size="2">sseg            segment para stack 'stack'

; Stack for process #2:

stk2            byte    1024 dup (?)
EndStack2       word    ?

; Stack for process #3:

stk3            byte    1024 dup (?)
EndStack3       word    ?

; The primary stack for the main program (process #1) must appear at 
; the end of sseg.

stk             byte    1024 dup (?)
sseg            ends</font></pre>

<p><font face="Arial" size="2">There is the question of &quot;how much space should one
reserve for each stack?&quot; This, of course, varies with the application. If you have a
simple application that doesn't use recursion or allocate any local variables on the
stack, you could get by with as little as 256 bytes of stack space for a process. On the
other hand, if you have recursive routines or allocate storage on the stack, you will need
considerably more space. For simple programs, 1-8K stack storage should be sufficient.
Keep in mind that you can allocate a maximum of 64K in the SHELL.ASM sseg. If you need
additional stack space, you will need to up the other stacks in a different segment (they
do not need to be in <code>sseg</code>, it's just a convenient place for them) or you will
need to allocate the stack space differently.</font></p>

<p><font face="Arial" size="2">Note that you do not have to allocate the stack space as an
array within your program. You can also allocate stack space dynamically using the
Standard Library <code>malloc</code> call. The following code demonstrates how to set up
an 8K dynamically allocated stack for the <code>pcb</code> variable <code>Process2</code>:</font></p>

<pre><font face="Courier New" size="2">                mov     cx, 8192
                malloc
                jc      InsufficientRoom
                mov     Process2.ss, es
                mov     Process2.sp, di</font></pre>

<p><font face="Arial" size="2">Setting up the coroutines the main program will call is
pretty easy. However, there is the issue of setting up the <code>pcb</code> for the main
program. You cannot initialize the <code>pcb</code> for the main program the same way you
initialize the <code>pcb</code> for the other processes; it is already running and has
valid <code>cs:ip</code> and <code>ss:sp</code> values. Were you to initialize the main
program's <code>pcb</code> the same way we did for the other processes, the system would
simply restart the main program when you make a cocall back to it. To initialize the <code>pcb</code>
for the main program, you must use the <code>coinit</code> function. The <code>coinit</code>
function expects you to pass it the address of the main program's <code>pcb</code> in the<code>
es:di</code> register pair. It initializes some variables internal to the Standard Library
so the first cocall operation will save the 80x86 machine state in the <code>pcb</code>
you specify by<code> es:di</code>. After the <code>coinit</code> call, you can begin
making cocalls to other processes in your program.</font></p>

<p><font face="Arial" size="2">To cocall a coroutine, you use the Standard Library <code>cocall</code>
function. The cocall function call takes two forms. Without any parameters this function
transfers control to the coroutine whose <code>pcb</code> address appears in the <code>es:di</code>
register pair. If the address of a <code>pcb</code> appears in the operand field of this
instruction, <code>cocall</code> transfers control to the specified coroutine (don't
forget, the name of the <code>pcb</code>, not the process, must appear in the operand
field).</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF"><p align="left"><a href="CH19-5.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a> <font face="Arial" size="2"><strong><a href="CH19-5.html">Chapter Nineteen</a> (Part 5)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF"><font face="Arial" size="2"><strong><a href="../toc.html">Table of Content</a></strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF"><font face="Arial" size="2"><strong><p align="right"><a href="CH19-7.html">Chapter Nineteen</a> (Part 7) <a href="CH19-7.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></strong></font></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Nineteen: Processes,
Coroutines and Concurrency (Part 6)<br>
29 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_19/CH19-6.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:47 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
