<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_19/CH19-1.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:42 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER NINETEEN: PROCESSES, COROUTINES AND CONCURRENCY (Part 1)</title>
</head>

<body stylesrc="../toc.html" topmargin="10" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING1"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" height="25" nowrap><p align="left"><a href="../Chapter_18/CH18-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a> <a href="../Chapter_18/CH18-1.html"><font face="Arial" size="2"><strong>Chapter Eighteen</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" height="25" nowrap><font face="Arial" size="2"><strong><a href="../toc.html">Table of Content</a></strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" height="25" nowrap><font face="Arial" size="2"><strong><p align="right"><a href="CH19-2.html">Chapter Nineteen</a>
    (Part 2) <a href="CH19-2.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></strong></font></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3" nowrap height="10"><a NAME="HEADING1-0"></a></td>
  </tr>
  <tr>
    <td width="100%" colspan="3" bgcolor="#F0F0F0"><font face="Arial" size="4"><strong>CHAPTER
    NINETEEN:<br>
    PROCESSES, COROUTINES AND CONCURRENCY (Part 1)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" colspan="3" nowrap height="10"></td>
  </tr>
  <tr>
    <td width="40%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING1-4"><b>19.1 </b>-
    DOS Processes</a> <br>
    <a HREF="#HEADING1-6"><b>19.1.1 </b>- Child Processes in DOS</a> <br>
    <a HREF="#HEADING1-10"><b>19.1.1.1 </b>- Load and Execute</a> <br>
    <a HREF="#HEADING1-147"><b>19.1.1.2 </b>- Load Program</a> <br>
    <a HREF="#HEADING1-161"><b>19.1.1.3 </b>- Loading Overlays</a> <br>
    <a HREF="#HEADING1-170"><b>19.1.1.4 </b>- Terminating a Process</a> <br>
    <a HREF="#HEADING1-181"><b>19.1.1.5 </b>- Obtaining the Child Process Return Code</a> <br>
    <a HREF="CH19-2.html#HEADING2-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH19/CH19-2.html#HEADING2-1"><b>19.1.2
    </b>- Exception Handling in DOS: The Break Handler</a> <br>
    <a HREF="CH19-2.html#HEADING2-9" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH19/CH19-2.html#HEADING2-9"><b>19.1.3
    </b>- Exception Handling in DOS: The Critical Error Handler</a> <br>
    <a HREF="CH19-3.html#HEADING3-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH19/CH19-3.html#HEADING3-1"><b>19.1.4
    </b>- Exception Handling in DOS: Traps</a> <br>
    <a HREF="CH19-3.html#HEADING3-4" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH19/CH19-3.html#HEADING3-4"><b>19.1.5
    </b>- Redirection of I/O for Child Processes</a> <br>
    <a HREF="CH19-4.html#HEADING4-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH19/CH19-4.html#HEADING4-1"><b>19.2 </b>-
    Shared Memory</a> <br>
    <a HREF="CH19-4.html#HEADING4-5" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH19/CH19-4.html#HEADING4-5"><b>19.2.1
    </b>- Static Shared Memory</a> <br>
    <a HREF="CH19-5.html#HEADING5-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH19/CH19-5.html#HEADING5-1"><b>19.2.2
    </b>- Dynamic Shared Memory</a> <br>
    <a HREF="CH19-6.html#HEADING6-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH19/CH19-6.html#HEADING6-1"><b>19.3 </b>-
    Coroutines</a> <br>
    <a HREF="CH19-7.html#HEADING7-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH19/CH19-7.html#HEADING7-1"><b>19.3.1
    </b>- AMAZE.ASM</a> <br>
    <a HREF="CH19-8.html#HEADING8-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH19/CH19-8.html#HEADING8-1"><b>19.3.2
    </b>- 32-bit Coroutines</a> <br>
    <a HREF="CH19-9.html#HEADING9-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH19/CH19-9.html#HEADING9-1"><b>19.4 </b>-
    Multitasking</a> <br>
    <a HREF="CH19-9.html#HEADING9-8" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH19/CH19-9.html#HEADING9-8"><b>19.4.1
    </b>- Lightweight and HeavyWeight Processes</a> <br>
    <a HREF="CH19-10.html#HEADING10-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH19/CH19-10.html#HEADING10-1"><b>19.4.2
    </b>- The UCR Standard Library Processes Package</a> <br>
    <a HREF="CH19-10.html#HEADING10-19" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH19/CH19-10.html#HEADING10-19"><b>19.4.3
    </b>- Problems with Multitasking</a> <br>
    <a HREF="CH19-11.html#HEADING11-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH19/CH19-11.html#HEADING11-1"><b>19.4.4
    </b>- A Sample Program with Threads</a> <br>
    <a HREF="CH19-12.html#HEADING12-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH19/CH19-12.html#HEADING12-1"><b>19.5
    </b>- Synchronization</a> <br>
    <a HREF="CH19-12.html#HEADING12-118" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH19/CH19-12.html#HEADING12-118"><b>19.5.1
    </b>- Atomic Operations, Test &amp; Set, and Busy-Waiting</a> <br>
    <a HREF="CH19-13.html#HEADING13-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH19/CH19-13.html#HEADING13-1"><b>19.5.2
    </b>- Semaphores</a> <br>
    <a HREF="CH19-14.html#HEADING14-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH19/CH19-14.html#HEADING14-1"><b>19.5.3
    </b>- The UCR Standard Library Semaphore Support</a> <br>
    <a HREF="CH19-14.html#HEADING14-14" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH19/CH19-14.html#HEADING14-14"><b>19.5.4
    </b>- Using Semaphores to Protect Critical Regions</a> <br>
    <a HREF="CH19-14.html#HEADING14-258" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH19/CH19-14.html#HEADING14-258"><b>19.5.5
    </b>- Using Semaphores for Barrier Synchronization</a> <br>
    <a HREF="CH19-15.html#HEADING15-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH19/CH19-15.html#HEADING15-1"><b>19.6
    </b>- Deadlock</a></font> </td>
    <td width="20" nowrap valign="top"></td>
    <td width="60%" valign="top"><font size="1" face="Arial">Copyright 1996 by Randall Hyde
    All rights reserved. <br>
    <br>
    Duplication other than for immediate display through a browser is prohibited by U.S.
    Copyright Law. <br>
    This material is provided on-line as a beta-test of this text. It is for the personal use
    of the reader only. If you are interested in using this material as part of a course,
    please contact rhyde@cs.ucr.edu <br>
    <br>
    Supporting software and other materials are available via anonymous ftp from
    ftp.cs.ucr.edu. See the &quot;/pub/pc/ibmpcdir&quot; directory for details. You may also
    download the material from &quot;Randall Hyde's Assembly Language Page&quot; at URL:
    http://webster.ucr.edu<br>
    <br>
    Notes: <br>
    This document does not contain the laboratory exercises, programming assignments,
    exercises, or chapter summary. These portions were omitted for several reasons: either
    they wouldn't format properly, they contained hyperlinks that were too much work to
    resolve, they were under constant revision, or they were not included for security
    reasons. Such omission should have very little impact on the reader interested in learning
    this material or evaluating this document. <br>
    <br>
    This document was prepared using Harlequin's Web Maker 2.2 and Quadralay's Webworks
    Publisher. Since HTML does not support the rich formatting options available in
    Framemaker, this document is only an approximation of the actual chapter from the
    textbook. <br>
    <br>
    If you are absolutely dying to get your hands on a version other than HTML, you might
    consider having the UCR Printing a Reprographics Department run you off a copy on their
    Xerox machines. For details, please read the following EMAIL message I received from the
    Printing and Reprographics Department: </font><blockquote>
      <p><font size="1" face="Arial">Hello Again Professor Hyde,<br>
      <br>
      Dallas gave me permission to take orders for the Computer Science 13 Manuals. We would
      need to take charge card orders. The only cards we take are: Master Card, Visa, and
      Discover. They would need to send the name, numbers, expiration date, type of card, and
      authorization to charge $95.00 for the manual and shipping, also we should have their
      phone number in case the company has any trouble delivery. They can use my e-mail address
      for the orders and I will process them as soon as possible. I would assume that two weeks
      would be sufficient for printing, packages and delivery time.<br>
      <br>
      I am open to suggestions if you can think of any to make this as easy as possible.<br>
      <br>
      Thank You for your business,<br>
      Kathy Chapman, Assistant<br>
      Printing and Reprographics University of California Riverside (909) 787-4443/4444 </font></p>
    </blockquote>
    <p><font size="1" face="Arial">We are currently working on ways to publish this text in a
    form other than HTML (e.g., Postscript, PDF, Frameviewer, hard copy, etc.). This, however,
    is a low-priority project. Please do not contact Randall Hyde concerning this effort. When
    something happens, an announcement will appear on &quot;Randall Hyde's Assembly Language
    Page.&quot; Please visit this WEB site at http://webster.ucr.edu for the latest scoop.</font></p>
    <p><font size="1" face="Arial">Redesigned 10/2000 with &quot;MS FrontPage 98&quot; using
    17&quot; monitor 1024x768<br>
    (c)&nbsp; 2000 <a href="mail%20to_%20bircom_yanoo.html">BIRCOM Entertainment'95</a></font></td>
  </tr>
</table>
</center></div>

<hr noshade size="1" color="#000000">

<p><font face="Arial" size="2">When most people speak of multitasking, they usually mean
the ability to run several different application programs concurrently on one machine.
Given the structure of the original 80x86 chips and MS-DOS' software design, this is very
difficult to achieve when running DOS. Look at how long it's taken Microsoft to get
Windows to multitask as well as it does. </font></p>

<p><font face="Arial" size="2">Given the problems large companies like Microsoft have had
trying to get multitasking to work, you might thing that it is a very difficult thing to
manage. However, this isn't true. Microsoft has problems trying to make different
applications that are unaware of one another work harmoniously together. Quite frankly,
they have not succeeded in getting existing DOS applications to multitask well. Instead,
they've been working on developers to write new programs that work well under Windows.</font></p>

<p><font face="Arial" size="2">Multitasking is not trivial, but it is not that difficult
when you write an application with multitasking specifically in mind. You can even write
programs that multitask under DOS if you only take a few precautions. In this chapter, we
will discuss the concept of a DOS process, a coroutine, and a general process. </font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING1-4"></a>19.1 DOS
    Processes</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">Although MS-DOS is a single tasking operating system, this
does not mean there can only be one program at a time in memory. Indeed, the whole purpose
of the previous chapter was to describe how to get two or more programs operating in
memory at one time. However, even if we ignore TSRs for the time being, you can still load
several programs into memory at one time under DOS. The only catch is, DOS only provides
the ability for them to run one at a time in a very specific fashion. Unless the processes
are cooperating, their execution profile follows a very strict pattern.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING1-6"></a>19.1.1 Child Processes in
DOS</font></strong></p>

<p><font face="Arial" size="2">When a DOS application is running, it can load and
executing some other program using the DOS EXEC function. Under normal circumstances, when
an application (the parent) runs a second program (the child), the child process executes
to completion and then returns to the parent. This is very much like a procedure call,
except it is a little more difficult to pass parameters between the two.</font></p>

<p><font face="Arial" size="2">MS-DOS provides several functions you can use to load and
execute program code, terminate processes, and obtain the exit status for a process. The
following table lists many of these operations.</font></p>
<div align="center"><center>

<table BORDER="1" bordercolor="#C0C0C0" width="80%" cellspacing="0" cellpadding="0">
  <caption><strong><font face="Arial" size="2">DOS Character Oriented Functions</font></strong></caption>
  <tr>
    <th bgcolor="#F0F0F0" align="center"><font face="Arial" size="2">Function<br>
    #(AH)</font></th>
    <th bgcolor="#F0F0F0" align="center"><font face="Arial" size="2">Input<br>
    Parameters</font></th>
    <th bgcolor="#F0F0F0" align="center"><font face="Arial" size="2">Output<br>
    Parameters</font></th>
    <th bgcolor="#F0F0F0" align="center"><font face="Arial" size="2">Description</font></th>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">4Bh</font></td>
    <td><font face="Arial" size="2"><code>al</code>- 0<br>
    <code>ds:dx</code>- pointer to program name.<br>
    <code>es:bx</code>- pointer to LOADEXEC structure.</font></td>
    <td><font face="Arial" size="2"><code>ax</code>- error code if carry set.</font></td>
    <td><font face="Arial" size="2">Load and execute program</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">4Bh</font></td>
    <td><font face="Arial" size="2"><code>al</code>- 1<br>
    <code>ds:dx</code>- pointer to program name.<br>
    <code>es:bx</code>- pointer to LOAD structure.</font></td>
    <td><font face="Arial" size="2"><code>ax</code>- error code if carry set.</font></td>
    <td><font face="Arial" size="2">Load program</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">4Bh</font></td>
    <td><font face="Arial" size="2"><code>al</code>- 3<br>
    <code>ds:dx</code>- pointer to program name.<br>
    <code>es:bx</code>- pointer to OVERLAY structure.</font></td>
    <td><font face="Arial" size="2"><code>ax</code>- error code if carry set.</font></td>
    <td><font face="Arial" size="2">Load overlay</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">4Ch</font></td>
    <td><font face="Arial" size="2"><code>al</code>- process return code</font></td>
    <td>&nbsp;</td>
    <td><font face="Arial" size="2">Terminate execution</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">4Dh</font></td>
    <td>&nbsp;</td>
    <td><font face="Arial" size="2"><code>al</code>- return value<br>
    <code>ah</code>- termination method.</font></td>
    <td><font face="Arial" size="2">Get child process return value</font></td>
  </tr>
</table>
</center></div>

<p><strong><font face="Arial" size="3"><a NAME="HEADING1-10"></a>19.1.1.1 Load and Execute</font></strong></p>

<p><font face="Arial" size="2">The &quot;load and execute&quot; call requires two
parameters. The first, in ds:dx, is a pointer to a zero terminated string containing the
pathname of the program to execute. This must be a &quot;.COM&quot; or &quot;.EXE&quot;
file and the string must contain the program name's extension. The second parameter, in <code>es:bx</code>,
is a pointer to a LOADEXEC data structure. This data structure takes the following form: </font></p>

<pre><font face="Courier New" size="2">LOADEXEC        struct
EnvPtr          word    ?       ;Pointer to environment area
CmdLinePtr      dword   ?       ;Pointer to command line
FCB1            dword   ?       ;Pointer to default FCB1
FCB2            dword   ?       ;Pointer to default FCB2
LOADEXEC        ends</font></pre>

<p><font face="Arial" size="2"><code>Envptr</code> is the segment address of the DOS
environment block created for the new application. If this field contains a zero, DOS
creates a copy of the current process' environment block for the child process. If the
program you are running does not access the environment block, you can save several
hundred bytes to a few kilobytes by pointing the environment pointer field to a string of
four zeros.</font></p>

<p><font face="Arial" size="2">The <code>CmdLinePtr</code> field contains the address of
the command line to supply to the program. DOS will copy this command line to offset 80h
in the new PSP it creates for the child process. A valid command line consists of a byte
containing a character count, a least one space, any character belonging to the command
line, and a terminating carriage return character (0Dh). The first byte should contain the
length of the ASCII characters in the command line, not including the carriage return. If
this byte contains zero, then the second byte of the command line should be the carriage
return, not a space. Example: </font></p>

<pre><font face="Courier New" size="2">MyCmdLine       byte    12, &quot; file1 file2&quot;,cr</font></pre>

<p><font face="Arial" size="2">The <code>FCB1</code> and <code>FCB2</code> fields need to
point at the two default file control blocks for this program. FCBs became obsolete with
DOS 2.0, but Microsoft has kept FCBs around for compatibility anyway. For most programs
you can point both of these fields at the following string of bytes: </font></p>

<pre><font face="Courier New" size="2">DfltFCB         byte    3,&quot; &quot;,0,0,0,0,0</font></pre>

<p><font face="Arial" size="2">The load and execute call will fail if there is
insufficient memory to load the child process. When you create an &quot;.EXE&quot; file
using MASM, it creates an executable file that grabs all available memory, by default.
Therefore, there will be no memory available for the child process and DOS will always
return an error. Therefore, you must readjust the memory allocation for the parent process
before attempting to run the child process.</font></p>

<p><font face="Arial" size="2">There are other possible errors as well. For example, DOS
might not be able to locate the program name you specify with the zero terminated string.
Or, perhaps, there are too many open files and DOS doesn't have a free buffer available
for the file I/O. If an error occurs, DOS returns with the carry flag set and an
appropriate error code in the <code>ax</code> register. The following example program
executes the &quot;COMMAND.COM&quot; program, allowing a user to execute DOS commands from
inside your application. When the user types &quot;exit&quot; at the DOS command line, DOS
returns control to your program. </font></p>

<pre><font face="Courier New" size="2">; RUNDOS.ASM -  Demonstrates how to invoke a copy of the COMMAND.COM
;               DOS command line interpreter from your programs.

                include stdlib.a
                includelib      stdlib.lib

dseg            segment para public 'data'

; MS-DOS EXEC structure.

ExecStruct      word    0               ;Use parent's Environment blk.
                dword   CmdLine         ;For the cmd ln parms.
                dword   DfltFCB
                dword   DfltFCB

DfltFCB         byte    3,&quot; &quot;,0,0,0,0,0
CmdLine         byte    0, 0dh          ;Cmd line for program.
PgmName         dword   filename        ;Points at pgm name.

filename        byte    &quot;c:\command.com&quot;,0

dseg            ends

cseg            segment para public 'code'
                assume  cs:cseg, ds:dseg

Main            proc
                mov     ax, dseg        ;Get ptr to vars segment
                mov     ds, ax

                MemInit                 ;Start the memory mgr.

; Okay, we've built the MS-DOS execute structure and the necessary
; command line, now let's see about running the program.
; The first step is to free up all the memory that this program
; isn't using. That would be everything from zzzzzzseg on.
;
; Note: unlike some previous examples in other chapters, it is okay
; to call Standard Library routines in this program after freeing
; up memory. The difference here is that the Standard Library
; routines are loaded early in memory and we haven't free up the
; storage they are sitting in.

                mov     ah, 62h         ;Get our PSP value
                int     21h
                mov     es, bx
                mov     ax, zzzzzzseg   ;Compute size of
                sub     ax, bx          ; resident run code.
                mov     bx, ax
                mov     ah, 4ah         ;Release unused memory.
                int     21h


; Tell the user what is going on:

                print
                byte    cr,lf
                byte    &quot;RUNDOS- Executing a copy of command.com&quot;,cr,lf
                byte    &quot;Type 'EXIT' to return control to RUN.ASM&quot;,cr,lf
                byte    0

; Warning! No Standard Library calls after this point. We've just
; released the memory that they're sitting in. So the program load
; we're about to do will wipe out the Standard Library code.

                mov     bx, seg ExecStruct
                mov     es, bx
                mov     bx, offset ExecStruct   ;Ptr to program record.
                lds     dx, PgmName
                mov     ax, 4b00h               ;Exec pgm
                int     21h

; In MS-DOS 6.0 the following code isn't required. But in various older
; versions of MS-DOS, the stack is messed up at this point. Just to be
; safe, let's reset the stack pointer to a decent place in memory.
;
; Note that this code preserves the carry flag and the value in the
; AX register so we can test for a DOS error condition when we are done
; fixing the stack.

                mov     bx, sseg
                mov     ss, ax
                mov     sp, offset EndStk
                mov     bx, seg dseg
                mov     ds, bx

; Test for a DOS error:

                jnc     GoodCommand
                print
                byte    &quot;DOS error #&quot;,0
                puti
                print
                byte    &quot; while attempting to run COMMAND.COM&quot;,cr,lf
                byte    0
                jmp     Quit

; Print a welcome back message.

GoodCommand:    print
                byte    &quot;Welcome back to RUNDOS. Hope you had fun.&quot;,cr,lf
                byte    &quot;Now returning to MS-DOS' version of COMMAND.COM.&quot;
                byte    cr,lf,lf,0

; Return control to MS-DOS

Quit:           ExitPgm
Main            endp
cseg            ends

sseg            segment para stack 'stack'
                dw      128 dup (0)
sseg            ends

zzzzzzseg       segment para public 'zzzzzzseg'
Heap            db      200h dup (?)
zzzzzzseg       ends
                end     Main</font></pre>

<h3><strong><font face="Arial" size="3"><a name="HEADING1-147"></a>19.1.1.2 Load Program</font></strong></h3>

<p><font face="Arial" size="2">The load and execute function gives the parent process very
little control over the child process. Unless the child communicates with the parent
process via a trap or interrupt, DOS suspends the parent process until the child
terminates. In many cases the parent program may want to load the application code and
then execute some additional operations before the child process takes over. Semiresident
programs, appearing in the previous chapter, provide a good example. The DOS &quot;load
program&quot; function provides this capability; it will load a program from the disk and
return control back to the parent process. The parent process can do whatever it feels is
appropriate before passing control to the child process.</font></p>

<p><font face="Arial" size="2">The load program call requires parameters that are very
similar to the load and execute call. Indeed, the only difference is the use of the LOAD
structure rather than the LOADEXEC structure, and even these structures are very similar
to one another. The LOAD data structure includes two extra fields not present in the
LOADEXE structure: </font></p>

<pre><font face="Courier New" size="2">LOAD            struct
EnvPtr          word    ?       ;Pointer to environment area.
CmdLinePtr      dword   ?       ;Pointer to command line.
FCB1            dword   ?       ;Pointer to default FCB1.
FCB2            dword   ?       ;Pointer to default FCB2.
SSSP            dword   ?       ;SS:SP value for child process.
CSIP            dword   ?       ;Initial program starting point.
LOAD            ends</font></pre>

<p><font face="Arial" size="2">The LOAD command is useful for many purposes. Of course,
this function provides the primary vehicle for creating semiresident programs; however, it
is also quite useful for providing extra error recovery, redirecting application I/O, and
loading several executable processes into memory for concurrent execution.</font></p>

<p><font face="Arial" size="2">After you load a program using the DOS load command, you
can obtain the PSP address for that program by issuing the DOS get PSP address call. This
would allow the parent process to modify any values appearing in the child process' PSP
prior to its execution. DOS stores the termination address for a procedure in the PSP.
This termination address normally appears in the double word at offset 10h in the PSP. If
you do not change this location, the program will return to the first instruction beyond
the int 21h instruction for the load function. Therefore, before actually transferring
control to the user application, you should change this termination address.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING1-161"></a>19.1.1.3 Loading
Overlays</font></strong></p>

<p><font face="Arial" size="2">Many programs contain blocks of code that are independent
of one other; that is, while routines in one block of code execute, the program will not
call routines in the other independent blocks of code. For example, a modern game may
contain some initialization code, a &quot;staging area&quot; where the user chooses
certain options, an &quot;action area&quot; where the user plays the game, and a
&quot;debriefing area&quot; that goes over the player's actions. When running in a 640K
MS-DOS machine, all this code may not fit into available memory at the same time. To
overcome this memory limitation, most large programs use overlays. An overlay is a portion
of the program code that shares memory for its code with other code modules. The DOS load
overlay function provides support for large programs that need to use overlays.</font></p>

<p><font face="Arial" size="2">Like the load and load/execute functions, the load overlay
expects a pointer to the code file's pathname in the <code>ds:dx</code> register pair and
the address of a data structure in the <code>es:bx</code> register pair. This overlay data
structure has the following format: </font></p>

<pre><font face="Courier New" size="2">overlay         struct
StartSeg        word    ?
RelocFactor     word    0
overlay         ends</font></pre>

<p><font face="Arial" size="2">The <code>StartSeg</code> field contains the segment
address where you want DOS to load the program. The <code>RelocFactor</code> field
contains a relocation factor. This value should be zero unless you want the starting
offset of the segment to be something other than zero.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING1-170"></a>19.1.1.4 Terminating a
Process</font></strong></p>

<p><font face="Arial" size="2">The process termination function is nothing new to you by
now, you've used this function over and over again already if you written any assembly
language programs and run them under DOS (the Standard Library <code>ExitPgm</code> macro
executes this command). In this section we'll look at exactly what the terminate process
function call does.</font></p>

<p><font face="Arial" size="2">First of all, the terminate process function gives you the
ability to pass a single byte termination code back to the parent process. Whatever value
you pass in al to the terminate call becomes the return, or termination code. The parent
process can test this value using the Get Child Process Return Value call (see the next
section). You can also test this return value in a DOS batch file using the &quot;if
errorlevel&quot; statement.</font></p>

<p><font face="Arial" size="2">The terminate process command does the following: </font>

<ul>
  <li><font face="Arial" size="2">Flushes file buffers and closes files. </font></li>
  <li><font face="Arial" size="2">Restores the termination address (int 22h) from offset 0Ah
    in the PSP (this is the return address of the process). </font></li>
  <li><font face="Arial" size="2">Restores the address of the Break handler (int 23h) from
    offset 0Eh in the PSP (see &quot;Exception Handling in DOS: The Break Handler&quot;) </font></li>
  <li><font face="Arial" size="2">Restores the address of the critical error handler (int 24h)
    from offset 12h in the PSP (see &quot;Exception Handling in DOS: The Critical Error
    Handler&quot;). </font></li>
  <li><font face="Arial" size="2">Deallocates any memory held by the process. </font></li>
</ul>

<p><font face="Arial" size="2">Unless you really know what you're doing, you should not
change the values at offsets 0Ah, 0Eh, or 12h in the PSP. By doing so you could produce an
inconsistent system when your program terminates.</font></p>

<p><font face="Arial" size="3"><strong><a NAME="HEADING1-181"></a>19.1.1.5 Obtaining the
Child Process Return Code</strong></font></p>

<p><font face="Arial" size="2">A parent process can obtain the return code from a child
process by making the DOS Get Child Process Return Code function call. This call returns
the value in the <code>al</code> register at the point of termination plus information
that tells you how the child process terminated.</font></p>

<p><font face="Arial" size="2">This call (<code>ah</code>=4Dh) returns the termination
code in the al register. It also returns the cause of termination in the ah register. The <code>ah</code>
register will contain one of the following values:</font></p>
<div align="center"><center>

<table BORDER="1" bordercolor="#C0C0C0" cellspacing="0" cellpadding="0" width="40%">
  <caption><strong><font face="Arial" size="2">Termination Cause</font></strong></caption>
  <tr>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">Value in AH</font></th>
    <th bgcolor="#F0F0F0"><p align="center"><font face="Arial" size="2">Reason for Termination</font></th>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">0</font></strong></td>
    <td><font face="Arial" size="2">Normal termination (int 21h, ah=4Ch)</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">1</font></strong></td>
    <td><font face="Arial" size="2">Terminated by ctrl-C</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">2</font></strong></td>
    <td><font face="Arial" size="2">Terminated by critical error</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">3</font></strong></td>
    <td><font face="Arial" size="2">TSR termination (int 21h, ah=31h)</font></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">The termination code appearing in <code>al</code> is valid
only for normal and TSR terminations.</font></p>

<p><font face="Arial" size="2">Note that you can only call this routine once after a child
process terminates. MS-DOS returns meaningless values in AX after the first such call.
Likewise, if you use this function without running a child process, the results you obtain
will be meaningless. DOS does not return if you do this. </font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF"><p align="left"><a href="../Chapter_18/CH18-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a> <a href="../Chapter_18/CH18-1.html"><font face="Arial" size="2"><strong>Chapter
    Eighteen</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF"><font face="Arial" size="2"><strong><a href="../toc.html">Table of Content</a></strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF"><font face="Arial" size="2"><strong><p align="right"><a href="CH19-2.html">Chapter Nineteen</a> (Part 2) <a href="CH19-2.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></strong></font></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Nineteen: Processes,
Coroutines and Concurrency (Part 1)<br>
29 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_19/CH19-1.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:43 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
