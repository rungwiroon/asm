<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_19/CH19-10.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:47 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER NINETEEN: PROCESSES, COROUTINES AND CONCURRENCY (Part 10)</title>
</head>

<body stylesrc="../toc.html" topmargin="10" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING10"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" height="25" nowrap><p align="left"><a href="CH19-9.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a> <font face="Arial" size="2"><strong><a href="CH19-9.html">Chapter Nineteen</a>
    (Part 9)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" height="25" nowrap><font face="Arial" size="2"><strong><a href="../toc.html">Table of Content</a></strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" height="25" nowrap><font face="Arial" size="2"><strong><p align="right"><a href="CH19-11.html">Chapter Nineteen</a>
    (Part 11) <a href="CH19-11.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></strong></font></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" nowrap height="10"><a NAME="HEADING10-1"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0"><font face="Arial" size="4"><strong>CHAPTER NINETEEN:<br>
    PROCESSES, COROUTINES AND CONCURRENCY (Part 10)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10"></td>
  </tr>
  <tr>
    <td width="100%"><font face="Arial" size="2"><a HREF="#HEADING10-1"><b>19.4.2 </b>- The
    UCR Standard Library Processes Package</a> <br>
    <a HREF="#HEADING10-19"><b>19.4.3 </b>- Problems with Multitasking</a> </font></td>
  </tr>
</table>
</center></div>

<h3><strong><font face="Arial" size="3">19.4.2 The UCR Standard Library Processes Package</font></strong></h3>

<p><font face="Arial" size="2">The UCR Standard Library provides six routines to let you
manage threads. These routines include <code>prcsinit</code>, <code>prcsquit</code>, <code>fork</code>,
<code>die</code>, <code>kill</code>, and <code>yield</code>. These functions let you
initialize and shut down the threads system, start new processes, terminate processes, and
voluntarily pass the CPU off to another process.</font></p>

<p><font face="Arial" size="2">The <code>prcsinit</code> and <code>prcsquit</code>
functions let you initialize and shutdown the system. The <code>prcsinit</code> call
prepares the threads package. You must call this routine before executing any of the other
five process routines. The <code>prcsquit</code> function shuts down the threads system in
preparation for program termination. <code>Prcsinit</code> patches into the timer
interrupt (interrupt 8). <code>Prcsquit</code> restores the interrupt 8 vector. It is very
important that you call <code>prcsquit</code> before your program returns to DOS. Failure
to do so will leave the int 8 vector pointing off into memory which may cause the system
to crash when DOS loads the next program. Your program must patch the break and critical
error exception vectors to ensure that you call <code>prcsquit</code> in the event of
abnormal program termination. Failure to do so may crash the system if the user terminates
the program with ctrl-break or an abort on an I/O error. P<code>rcsinit</code> and <code>prcsquit</code>
do not require any parameters, nor do they return any values.</font></p>

<p><font face="Arial" size="2">The <code>fork</code> call spawns a new process. On entry, <code>es:di</code>
must point at a pcb for the new process. The <code>regss</code> and <code>regsp</code>
fields of the <code>pcb</code> must contain the address of the top of the stack area for
this new process. The <code>fork</code> call fills in the other fields of the <code>pcb</code>
(including cs:ip).</font></p>

<p><font face="Arial" size="2">For each call you make to <code>fork</code>, the <code>fork</code>
routine returns twice, once for each thread of execution. The parent process typically
returns first, but this is not certain; the child process is usually the second return
from the <code>fork</code> call. To differentiate the two calls, <code>fork</code> returns
two process identifiers (PIDs) in the <code>ax</code> and <code>bx</code> registers. For
the parent process, <code>fork</code> returns with <code>ax</code> containing zero and <code>bx</code>
containing the PID of the child process. For the child process, <code>fork</code> returns
with <code>ax</code> containing the child's PID and <code>bx</code> containing zero. Note
that both threads return and continuing executing the same code after the call to <code>fork</code>.
If you want the child and parent processes to take separate paths, you would execute code
like the following:</font></p>

<pre><font face="Courier New" size="2">                lesi    NewPCB          ;Assume regss/regsp are initialized.
                fork
                test    ax, ax          ;Parent PID is zero at this point.
                je      ParentProcess   ;Go elsewhere if parent process.

; Child process continues execution here</font></pre>

<p><font face="Arial" size="2">The parent process should save the child's PID. You can use
the PID to terminate a process at some later time.</font></p>

<p><font face="Arial" size="2">It is important to repeat that you must initialize the <code>regss</code>
and <code>regsp</code> fields in the <code>pcb</code> before calling <code>fork</code>.
You must allocate storage for a stack (dynamically or statically) and point <code>ss:sp</code>
at the last word of this stack area. Once you call <code>fork</code>, the process package
uses whatever value that happens to be in the <code>regss</code> and <code>regsp</code>
fields. If you have not initialized these values, they will probably contain zero and when
the process starts it will wipe out the data at address 0:FFFE. This may crash the system
at one point or another.</font></p>

<p><font face="Arial" size="2">The <code>die</code> call kills the current process. If
there are multiple processes running, this call transfers control to some other processes
waiting to run. If the current process is the only process on the system's run queue, then
this call will crash the system.</font></p>

<p><font face="Arial" size="2">The <code>kill</code> call lets one process terminate
another. Typically, a parent process will use this call to terminate a child process. To
kill a process, simply load the <code>ax</code> register with the PID of the process you
want to terminate and then call <code>kill</code>. If a process supplies its own PID to
the <code>kill</code> function, the process terminates itself (that is, this is equivalent
to a <code>die</code> call). If there is only one process in the run queue and that
process kills itself, the system will crash.</font></p>

<p><font face="Arial" size="2">The last multitasking management routine in the process
package is the <code>yield</code> call. <code>Yield</code> voluntarily gives up the CPU.
This is a direct call to the dispatcher, that will switch to another task in the run
queue. Control returns after the <code>yield</code> call when the next time slice is given
to this process. If the current process is the only one in the queue, <code>yield</code>
immediately returns. You would normally use the <code>yield</code> call to free up the CPU
between long I/O operations (like waiting for a keypress). This would allow other tasks to
get maximum use of the CPU while your process is just spinning in a loop waiting for some
I/O operation to complete.</font></p>

<p><font face="Arial" size="2">The Standard Library multitasking routines only work with
the 16 bit register set of the 80x86 family. Like the coroutine package, you will need to
modify the pcb and the dispatcher code if you want to support the 32 bit register set of
the 80386 and later processors. This task is relatively simple and the code is quite
similar to that appearing in the section on coroutines; so there is no need to present the
solution here.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING10-19"></a>19.4.3 Problems with
Multitasking</font></strong></p>

<p><font face="Arial" size="2">When threads share code and data certain problems can
develop. First of all, reentrancy becomes a problem. You cannot call a non-reentrant
routine (like DOS) from two separate threads if there is ever the possibility that the
non-reentrant code could be interrupted and control transferred to a second thread that
reenters the same routine. Reentrancy is not the only problem, however. It is quite
possible to design two routines that access shared variables and those routines misbehave
depending on where the interrupts occur in the code sequence. We will explore these
problems in the section on synchronization (see &quot;Synchronization&quot;), just be
aware, for now, that these problems exist.</font></p>

<p><font face="Arial" size="2">Note that simply turning off the interrupts (with <code>cli</code>)
may not solve the reentrancy problem. Consider the following code:</font></p>

<pre><font face="Courier New" size="2">                cli                     ;Prevent reentrancy.
                mov     ah, 3Eh         ;DOS close call.
                mov     bx, Handle
                int     21h
                sti                     ;Turn interrupts back on.</font></pre>

<p><font face="Arial" size="2">This code will not prevent DOS from being reentered because
DOS (and BIOS) turn the interrupts back on! There is a solution to this problem, but it's
not by using <code>cli</code> and <code>sti</code>.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF"><p align="left"><a href="CH19-9.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a> <font face="Arial" size="2"><strong><a href="CH19-9.html">Chapter Nineteen</a> (Part 9)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF"><font face="Arial" size="2"><strong><a href="../toc.html">Table of Content</a></strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF"><font face="Arial" size="2"><strong><p align="right"><a href="CH19-11.html">Chapter Nineteen</a> (Part 11) <a href="CH19-11.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></strong></font></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Nineteen: Processes,
Coroutines and Concurrency (Part 10)<br>
29 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_19/CH19-10.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:47 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
