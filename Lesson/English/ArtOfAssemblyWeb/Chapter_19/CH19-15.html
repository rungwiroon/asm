<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_19/CH19-15.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:47 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER NINETEEN: PROCESSES, COROUTINES AND CONCURRENCY (Part 15)</title>
</head>

<body stylesrc="../toc.html" topmargin="10" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING15"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" height="25" nowrap><p align="left"><a href="CH19-14.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a> <font face="Arial" size="2"><strong><a href="CH19-14.html">Chapter
    Nineteen</a> (Part 14)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" height="25" nowrap><font face="Arial" size="2"><strong><a href="../toc.html">Table of Content</a></strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" height="25" nowrap><font face="Arial" size="2"><strong><p align="right"><a href="../Chapter_20/CH20-1.html">Chapter
    Twenty</a>&nbsp; <a href="../Chapter_20/CH20-1.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></strong></font></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" nowrap height="10"><a NAME="HEADING15-1"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0"><font face="Arial" size="4"><strong>CHAPTER NINETEEN:<br>
    PROCESSES, COROUTINES AND CONCURRENCY (Part 15)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10"></td>
  </tr>
  <tr>
    <td width="100%"><font face="Arial" size="2"><a HREF="#HEADING15-1"><b>19.6 </b>- Deadlock</a>
    </font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="20"></td>
  </tr>
  <tr>
    <td width="100%"><strong><font face="Arial" size="3">19.6 Deadlock</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">Although semaphores can solve any synchronization problems,
don't get the impression that semaphores don't introduce problems of their own. As you've
already seen, the improper use of semaphores can result in the indefinite suspension of
processes waiting on the semaphore queue. However, even if you correctly wait and signal
individual semaphores, it is quite possible for correct operations on combinations of
semaphores to produce this same effect. Indefinite suspension of a process because of
semaphore problems is a serious issue. This degenerate situation is known as deadlock or
deadly embrace.</font></p>

<p><font face="Arial" size="2">Deadlock occurs when one process holds one resource and is
waiting for another while a second process is holding that other resource and waiting for
the first. To see how deadlock can occur, consider the following code:</font></p>

<pre><font face="Courier New" size="2">; Process one:

                lesi    Semaph1
                WaitSemaph

        // Assume interrupt occurs here //

                lesi    Semaph2
                WaitSemaph
                 .
                 .
                 .

; Process two:

                lesi    Semaph2
                WaitSemaph
                lesi    Semaph1
                WaitSemaph
                 .
                 .
                 .</font></pre>

<p><font face="Arial" size="2">Process one grabs the semaphore associated with <code>Semaph1</code>.
Then a timer interrupt comes along which causes a context switch to process two. Process
two grabs the semaphore associated with <code>Semaph2</code> and then tries to get <code>Semaph1</code>.
However, process one is already holding <code>Semaph1</code>, so process two blocks and
waits for process one to release this semaphore. This returns control (eventually) to
process one. Process one then tries to graph <code>Semaph2</code>. Unfortunately, process
two is already holding <code>Semaph2</code>, so process one blocks waiting for <code>Semaph2</code>.
Now both processes are blocked waiting for the other. Since neither process can run,
neither process can release the semaphore the other needs. Both processes are deadlocked.</font></p>

<p><font face="Arial" size="2">One easy way to prevent deadlock from occurring is to never
allow a process to hold more than one semaphore at a time. Unfortunately, this is not a
practical solution; many processes may need to have exclusive access to several resources
at one time. However, we can devise another solution by observing the pattern that
resulted in deadlock in the previous example. Deadlock came about because the two
processes grabbed different semaphores and then tried to grab the semaphore that the other
was holding. In other words, they grabbed the two semaphores in a different order (process
one grabbed Semaph1 first and Semaph2 second, process two grabbed <code>Semaph2</code>
first and <code>Semaph1</code> second). It turns out that two process will never deadlock
if they wait on common semaphores in the same order. We could modify the previous example
to eliminate the possibility of deadlock thusly:</font></p>

<pre><font face="Courier New" size="2">; Process one:

                lesi    Semaph1
                WaitSemaph
                lesi    Semaph2
                WaitSemaph
                 .
                 .
                 .

; Process two:

                lesi    Semaph1
                WaitSemaph
                lesi    Semaph2
                WaitSemaph
                 .
                 .
                 .</font></pre>

<p><font face="Arial" size="2">Now it doesn't matter where the interrupt occurs above,
deadlock cannot occur. If the interrupt occurs between the two <code>WaitSemaph</code>
calls in process one (as before), when process two attempts to wait on <code>Semaph1</code>,
it will block and process one will continue with <code>Semaph2</code> available.</font></p>

<p><font face="Arial" size="2">An easy way to keep out of trouble with deadlock is to
number all your semaphore variables and make sure that all processes acquire (wait on)
semaphores from the smallest numbered semaphore to the highest. This ensures that all
processes acquire the semaphores in the same order, and that ensures that deadlock cannot
occurs.</font></p>

<p><font face="Arial" size="2">Note that this policy of acquiring semaphores only applies
to semaphores that a process holds concurrently. If a process needs semaphore six for a
while, and then it needs semaphore two after it has released semaphore six, there is no
problem acquiring semaphore two after releasing semaphore six. However, if at any point
the process needs to hold both semaphores, it must acquire semaphore two first.</font></p>

<p><font face="Arial" size="2">Processes may release the semaphores in any order. The
order that a process releases semaphores does not affect whether deadlock can occur. Of
course, processes should always release a semaphore as soon as the process is done with
the resource guarded by that semaphore; there may be other processes waiting on that
semaphore.</font></p>

<p><font face="Arial" size="2">While the above scheme works and is easy to implement, it
is by no means the only way to handle deadlock, nor is it always the most efficient.
However, it is simple to implement and it always works. For more information on deadlocks,
see a good operating systems text.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF"><p align="left"><a href="CH19-14.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a> <font face="Arial" size="2"><strong><a href="CH19-14.html">Chapter Nineteen</a> (Part 14)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF"><font face="Arial" size="2"><strong><a href="../toc.html">Table of Content</a></strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF"><font face="Arial" size="2"><strong><p align="right"><a href="../Chapter_20/CH20-1.html">Chapter Twenty</a>
    &nbsp; <a href="../Chapter_20/CH20-1.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></strong></font></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Nineteen: Processes,
Coroutines and Concurrency (Part 15)<br>
29 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_19/CH19-15.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:47 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
