<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_19/CH19-4.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:45 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER NINETEEN: PROCESSES, COROUTINES AND CONCURRENCY (Part 4)</title>
</head>

<body stylesrc="../toc.html" topmargin="10" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING4"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" height="25" nowrap><p align="left"><a href="CH19-3.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a> <font face="Arial" size="2"><strong><a href="CH19-3.html">Chapter Nineteen</a>
    (Part 3)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" height="25" nowrap><font face="Arial" size="2"><strong><a href="../toc.html">Table of Content</a></strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" height="25" nowrap><font face="Arial" size="2"><strong><p align="right"><a href="CH19-5.html">Chapter Nineteen</a>
    (Part 5) <a href="CH19-5.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></strong></font></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" nowrap height="10"><a NAME="HEADING4-1"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0"><font face="Arial" size="4"><strong>CHAPTER NINETEEN:<br>
    PROCESSES, COROUTINES AND CONCURRENCY (Part 4)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10"></td>
  </tr>
  <tr>
    <td width="100%"><font face="Arial" size="2"><a HREF="#HEADING4-1"><b>19.2 </b>- Shared
    Memory</a> <br>
    <a HREF="#HEADING4-5"><b>19.2.1 </b>- Static Shared Memory</a> </font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="20"></td>
  </tr>
  <tr>
    <td width="100%"><strong><font face="Arial" size="3">19.2 Shared Memory</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="1" bgcolor="#000000"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">The only problem with running different DOS programs as
part of a single application is interprocess communication. That is, how do all these
programs talk to one other? When a typical DOS application runs, DOS loads in all code and
data segments; there is no provision, other than reading data from a file or the process
termination code, for one process to pass information to another. Although file I/O will
work, it is cumbersome and slow. The ideal solution would be for one process to leave a
copy of various variables that other processes can share. Your programs can easily do this
using shared memory.</font></p>

<p><font face="Arial" size="2">Most modern multitasking operating systems provide for
shared memory - memory that appears in the address space of two or more processes.
Furthermore, such shared memory is often persistent, meaning it continues to hold values
after its creator process terminates. This allows other processes to start later and use
the values left behind by the shared variables' creator.</font></p>

<p><font face="Arial" size="2">Unfortunately, MS-DOS is not a modern multitasking
operating system and it does not support shared memory. However, we can easily write a
resident program that provides this capability missing from DOS. The following sections
describe how to create two types of shared memory regions - static and dynamic.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING4-5"></a>19.2.1 Static Shared
Memory</font></strong></p>

<p><font face="Arial" size="2">A TSR to implement static shared memory is trivial. It is a
passive TSR that provides three functions - verify presence, remove, and return segment
pointer. The transient portion simply allocates a 64K data segment and then terminates.
Other processes can obtain the address of the 64K shared memory block by making the
&quot;return segment pointer&quot; call. These processes can place all their shared data
into the segment belonging to the TSR. When one process quits, the shared segment remains
in memory as part of the TSR. When a second process runs and links with the shared
segment, the variables from the shared segment are still intact, so the new process can
access those values. When all processes are done sharing data, the user can remove the
shared memory TSR with the remove function.</font></p>

<p><font face="Arial" size="2">As mentioned above, there is almost nothing to the shared
memory TSR. The following code implements it:</font></p>

<pre><font face="Courier New" size="2">; SHARDMEM.ASM
;
; This TSR sets aside a 64K shared memory region for other processes to use.
;
; Usage:
;
;       SHARDMEM -              Loads resident portion and activates
;                               shared memory capabilities.
;
;       SHARDMEM REMOVE -       Removes shared memory TSR from memory.
;
; This TSR checks to make sure there isn't a copy already active in
; memory. When removing itself from memory, it makes sure there are
; no other interrupts chained into INT 2Fh before doing the remove.
;
;
;
; The following segments must appear in this order and before the
; Standard Library includes.

ResidentSeg     segment para public 'Resident'
ResidentSeg     ends

SharedMemory    segment para public 'Shared'
SharedMemory    ends

EndResident     segment para public 'EndRes'
EndResident     ends

                .xlist
                .286
                include         stdlib.a
                includelib      stdlib.lib
                .list


; Resident segment that holds the TSR code:

ResidentSeg     segment para public 'Resident'
                assume  cs:ResidentSeg, ds:nothing

; Int 2Fh ID number for this TSR:

MyTSRID         byte    0
                byte    0               ;Padding so we can print it.

; PSP is the psp address for this program.

PSP             word    0

OldInt2F        dword   ?


; MyInt2F-      Provides int 2Fh (multiplex interrupt) support for this
;               TSR. The multiplex interrupt recognizes the following
;               subfunctions (passed in AL):
;
;               00h- Verify presence.   Returns 0FFh in AL and a pointer
;                                       to an ID string in es:di if the
;                                       TSR ID (in AH) matches this
;                                       particular TSR.
;
;               01h- Remove.            Removes the TSR from memory.
;                                       Returns 0 in AL if successful,
;                                       1 in AL if failure.
;
;               10h- Return Seg Adrs.   Returns the segment address of the
;                                       shared segment in ES.

MyInt2F         proc    far
                assume  ds:nothing

                cmp     ah, MyTSRID     ;Match our TSR identifier?
                je      YepItsOurs
                jmp     OldInt2F

; Okay, we know this is our ID, now check for a verify, remove, or
; return segment call.

YepItsOurs:     cmp     al, 0           ;Verify Call
                jne     TryRmv
                mov     al, 0ffh        ;Return success.
                lesi    IDString
                iret                    ;Return back to caller.

IDString        byte    &quot;Static Shared Memory TSR&quot;,0

TryRmv:         cmp     al, 1           ;Remove call.
                jne     TryRetSeg

; See if we can remove this TSR:

                push    es
                mov     ax, 0
                mov     es, ax
                cmp     word ptr es:[2Fh*4], offset MyInt2F
                jne     TRDone
                cmp     word ptr es:[2Fh*4 + 2], seg MyInt2F
                je      CanRemove       ;Branch if we can.
TRDone:         mov     ax, 1           ;Return failure for now.
                pop     es
                iret

; Okay, they want to remove this guy *and* we can remove it from memory.
; Take care of all that here.

                assume  ds:ResidentSeg

CanRemove:      push    ds
                pusha
                cli                     ;Turn off the interrupts while
                mov     ax, 0           ; we mess with the interrupt
                mov     es, ax          ; vectors.
                mov     ax, cs
                mov     ds, ax

                mov     ax, word ptr OldInt2F
                mov     es:[2Fh*4], ax
                mov     ax, word ptr OldInt2F+2
                mov     es:[2Fh*4 + 2], ax


; Okay, one last thing before we quit- Let's give the memory allocated
; to this TSR back to DOS.

                mov     ds, PSP
                mov     es, ds:[2Ch]    ;Ptr to environment block.
                mov     ah, 49h         ;DOS release memory call.
                int     21h

                mov     ax, ds          ;Release program code space.
                mov     es, ax
                mov     ah, 49h
                int     21h

                popa
                pop     ds
                pop     es
                mov     ax, 0           ;Return Success.
                iret

; See if they want us to return the segment address of our shared segment
; here.

TryRetSeg:      cmp     al, 10h         ;Return Segment Opcode
                jne IllegalOp
                mov     ax, SharedMemory
                mov     es, ax
                mov     ax, 0           ;Return success
                clc
                iret

; They called us with an illegal subfunction value. Try to do as little
; damage as possible.

IllegalOp:      mov     ax, 0           ;Who knows what they were thinking?
                iret
MyInt2F         endp
                assume  ds:nothing
ResidentSeg     ends


; Here's the segment that will actually hold the shared data.

SharedMemory    segment para public 'Shared'
                db      0FFFFh dup (?)
SharedMemory    ends


cseg            segment para public 'code'
                assume  cs:cseg, ds:ResidentSeg

; SeeIfPresent- Checks to see if our TSR is already present in memory.
;               Sets the zero flag if it is, clears the zero flag if
;               it is not.

SeeIfPresent    proc    near
                push    es
                push    ds
                push    di
                mov     cx, 0ffh        ;Start with ID 0FFh.
IDLoop:         mov     ah, cl
                push    cx
                mov     al, 0           ;Verify presence call.
                int     2Fh
                pop     cx
                cmp     al, 0           ;Present in memory?
                je      TryNext
                strcmpl
                byte    &quot;Static Shared Memory TSR&quot;,0
                je      Success

TryNext:        dec     cl              ;Test USER IDs of 80h..FFh
                js      IDLoop
                cmp     cx, 0           ;Clear zero flag.
Success:                pop     di
                pop     ds
                pop     es
                ret
SeeIfPresent    endp



; FindID-               Determines the first (well, last actually) TSR ID available
;               in the multiplex interrupt chain. Returns this value in
;               the CL register.
;
;               Returns the zero flag set if it locates an empty slot.
;               Returns the zero flag clear if failure.

FindID          proc    near
                push    es
                push    ds
                push    di

                mov     cx, 0ffh        ;Start with ID 0FFh.
IDLoop:         mov     ah, cl
                push    cx
                mov     al, 0           ;Verify presence call.
                int     2Fh
                pop     cx
                cmp     al, 0           ;Present in memory?
                je      Success
                dec     cl              ;Test USER IDs of 80h..FFh
                js      IDLoop
                xor     cx, cx
                cmp     cx, 1           ;Clear zero flag
Success:                pop     di
                pop     ds
                pop     es
                ret
FindID          endp



Main            proc
                meminit

                mov     ax, ResidentSeg
                mov     ds, ax

                mov     ah, 62h         ;Get this program's PSP
                int     21h             ; value.
                mov     PSP, bx

; Before we do anything else, we need to check the command line
; parameters. If there is one, and it is the word &quot;REMOVE&quot;, then remove
; the resident copy from memory using the multiplex (2Fh) interrupt.

                argc
                cmp     cx, 1           ;Must have 0 or 1 parms.
                jb      TstPresent
                je      DoRemove
Usage:          print
                byte    &quot;Usage:&quot;,cr,lf
                byte    &quot; shardmem&quot;,cr,lf
                byte    &quot;or shardmem REMOVE&quot;,cr,lf,0
                ExitPgm


; Check for the REMOVE command.

DoRemove:       mov     ax, 1
                argv
                stricmpl
                byte    &quot;REMOVE&quot;,0
                jne     Usage

                call    SeeIfPresent
                je      RemoveIt
                print
                byte    &quot;TSR is not present in memory, cannot remove&quot;
                byte    cr,lf,0
                ExitPgm

RemoveIt:       mov     MyTSRID, cl
                printf
                byte    &quot;Removing TSR (ID #%d) from memory...&quot;,0
                dword   MyTSRID

                mov     ah, cl
                mov     al, 1           ;Remove cmd, ah contains ID
                int     2Fh
                cmp     al, 1           ;Succeed?
                je      RmvFailure
                print
                byte    &quot;removed.&quot;,cr,lf,0
                ExitPgm

RmvFailure:     print
                byte    cr,lf
                byte    &quot;Could not remove TSR from memory.&quot;,cr,lf
                byte    &quot;Try removing other TSRs in the reverse order &quot;
                byte    &quot;you installed them.&quot;,cr,lf,0
                ExitPgm



; Okay, see if the TSR is already in memory. If so, abort the
; installation process.

TstPresent:     call    SeeIfPresent
                jne     GetTSRID
                print
                byte    &quot;TSR is already present in memory.&quot;,cr,lf
                byte    &quot;Aborting installation process&quot;,cr,lf,0
                ExitPgm


; Get an ID for our TSR and save it away.

GetTSRID:       call    FindID
                je      GetFileName
                print
                byte    &quot;Too many resident TSRs, cannot install&quot;,cr,lf,0
                ExitPgm


; Things look cool so far, so install the interrupts

GetFileName:    mov     MyTSRID, cl
                print
                byte    &quot;Installing interrupts...&quot;,0


; Patch into the INT 2Fh interrupt chain.

                cli                             ;Turn off interrupts!
                mov     ax, 0
                mov     es, ax
                mov     ax, es:[2Fh*4]
                mov     word ptr OldInt2F, ax
                mov     ax, es:[2Fh*4 + 2]
                mov     word ptr OldInt2F+2, ax
                mov     es:[2Fh*4], offset MyInt2F
                mov     es:[2Fh*4+2], seg ResidentSeg
                sti                             ;Okay, ints back on.

; We're hooked up, the only thing that remains is to zero out the shared
; memory segment and then terminate and stay resident.

                printf
                byte    &quot;Installed, TSR ID #%d.&quot;,cr,lf,0
                dword   MyTSRID

                mov     ax, SharedMemory        ;Zero out the shared
                mov     es, ax                  ; memory segment.
                mov     cx, 32768               ;32K words = 64K bytes.
                xor     ax, ax                  ;Store all zeros,
                mov     di, ax                  ; starting at offset zero.
        rep     stosw


                mov     dx, EndResident         ;Compute size of program.
                sub     dx, PSP
                mov     ax, 3100h               ;DOS TSR command.
                int     21h
Main            endp
cseg            ends

sseg            segment para stack 'stack'
stk             db      256 dup (?)
sseg            ends

zzzzzzseg       segment para public 'zzzzzz'
LastBytes       db      16 dup (?)
zzzzzzseg       ends
                end     Main</font></pre>

<p><font face="Arial" size="2">This program simply carves out a chunk of memory (the 64K
in the SharedMemory segment) and returns a pointer to it in <code>es</code> whenever a
program executes the appropriate <code>int 2Fh</code> call (<code>ah</code>= TSR ID and <code>al</code>=10h).
The only catch is how do we declared shared variables in the applications that use shared
memory? Well, that's fairly easy if we play a sneaky trick on MASM, the Linker, DOS, and
the 80x86.</font></p>

<p><font face="Arial" size="2">When DOS loads your program into memory, it generally loads
the segments in the same order they first appear in your source files. The UCR Standard
Library, for example, takes advantage of this by insisting that you include a segment
named <code>zzzzzzseg</code> at the end of all your assembly language source files. The
UCR Standard Library memory management routines build the heap starting at <code>zzzzzzseg</code>,
it must be the last segment (containing valid data) because the memory management routines
may overwrite anything following <code>zzzzzzseg</code>.</font></p>

<p><font face="Arial" size="2">For our shared memory segment, we would like to create a
segment something like the following:</font></p>

<pre><font face="Courier New" size="2">SharedMemory    segment para public 'Shared'</font></pre>

<pre><font face="Courier New" size="2">; // define all shared variables here//</font></pre>

<pre><font face="Courier New" size="2">SharedMemory    ends</font></pre>

<p><font face="Arial" size="2">Applications that share data would define all shared
variables in this shared segment. There are, however, five problems. First, how do we tell
the assembler/linker/DOS/80x86 that this is a shared segment, rather than having a
separate segment for each program? Well, this problem is easy to solve; we don't bother
telling MASM, the linker, or DOS anything. The way we make the different applications all
share the same segment in memory is to invoke the shared memory TSR in the code above with
function code 10h. This returns the address of the TSR's SharedMemory segment in the <code>es</code>
register. In our assembly language programs we fool MASM into thinking <code>es</code>
points at its local shared memory segment when, in fact, <code>es</code> points at the
global segment.</font></p>

<p><font face="Arial" size="2">The second problem is minor, but annoying nonetheless. When
you create a segment, MASM, the linker, and DOS set aside storage for that segment. If you
declare a large number of variables in a shared segment, this can waste memory since the
program will actually use the memory space in the global shared segment. One easy way to
reclaim the storage that MASM reserves for this segment is to define the shared segment
after <code>zzzzzzseg</code> in your shared memory applications. By doing so, the Standard
Library will absorb any memory reserved for the (dummy) shared memory segment into the
heap, since all memory after <code>zzzzzzseg</code> belongs to the heap (when you use the
standard <code>meminit</code> call).</font></p>

<p><font face="Arial" size="2">The third problem is slightly more difficult to deal with.
Since you will not be use the local segment, you cannot initialize any variables in the
shared memory segment by placing values in the operand field of byte, word, dword, etc.,
directives. Doing so will only initialize the local memory in the heap, the system will
not copy this data to the global shared segment. Generally, this isn't a problem because
processes won't normally initialize shared memory as they load. Instead, there will
probably be a single application you run first that initializes the shared memory area for
the rest of the processes that using the global shared segment.</font></p>

<p><font face="Arial" size="2">The fourth problem is that you cannot initialize any
variables with the address of an object in shared memory. For example, if the variable
shared_K is in the shared memory segment, you could not use a statement like the
following:</font></p>

<pre><font face="Courier New" size="2">                printf
                byte    &quot;Value of shared_K is %d\n&quot;,0
                dword   shared_K</font></pre>

<p><font face="Arial" size="2">The problem with this code is that MASM initializes the
double word after the string above with the address of the shared_K variable in the local
copy of the shared data segment. This will not print out the copy in the global shared
data segment. </font></p>

<p><font face="Arial" size="2">The last problem is anything but minor. All programs that
use the global shared memory segment must define their variables at identical offsets
within the shared segment. Given the way MASM assigns offsets to variables within a
segment, if you are one byte off in the declaration of any of your variables, your program
will be accessing its variables at different addresses than other processes sharing the
global shared segment. This will scramble memory and produce a disaster. The only
reasonable way to declare variables for shared memory programs is to create an include
file with all the shared variable declarations for all concerned programs. Then include
this single file into all the programs that share the variables. Now you can add, remove,
or modify variables without having to worry about maintaining the shared variable
declarations in the other files.</font></p>

<p><font face="Arial" size="2">The following two sample programs demonstrate the use of
shared memory. The first application reads a string from the user and stuffs it into
shared memory. The second application reads that string from shared memory and displays it
on the screen.</font></p>

<p><font face="Arial" size="2">First, here is the include file containing the single
shared variable declaration used by both applications:</font></p>

<pre><font face="Courier New" size="2">; shmvars.asm
;
; This file contains the shared memory variable declarations used by
; all applications that refer to shared memory.

InputLine		byte	128 dup (?)</font></pre>

<p><font face="Arial" size="2">Here is the first application that reads an input string
from the user and shoves it into shared memory:</font></p>

<pre><font face="Courier New" size="2">; SHMAPP1.ASM
;
; This is a shared memory application that uses the static shared memory
; TSR (SHARDMEM.ASM). This program inputs a string from the user and
; passes that string to SHMAPP2.ASM through the shared memory area.
;
;
                .xlist
                include         stdlib.a
                includelib      stdlib.lib
                .list

dseg            segment para public 'data'
ShmID           byte    0
dseg            ends

cseg            segment para public 'code'
                assume  cs:cseg, ds:dseg, es:SharedMemory

; SeeIfPresent- Checks to see if the shared memory TSR is present in memory.
;               Sets the zero flag if it is, clears the zero flag if
;               it is not. This routine also returns the TSR ID in CL.

SeeIfPresent    proc    near
                push    es
                push    ds
                push    di
                mov     cx, 0ffh        ;Start with ID 0FFh.
IDLoop:         mov     ah, cl
                push    cx
                mov     al, 0           ;Verify presence call.
                int     2Fh
                pop     cx
                cmp     al, 0           ;Present in memory?
                je      TryNext
                strcmpl
                byte    &quot;Static Shared Memory TSR&quot;,0
                je      Success

TryNext:        dec     cl              ;Test USER IDs of 80h..FFh
                js      IDLoop
                cmp     cx, 0           ;Clear zero flag.
Success:        pop     di
                pop     ds
                pop     es
                ret
SeeIfPresent    endp



; The main program for application #1 links with the shared memory
; TSR and then reads a string from the user (storing the string into
; shared memory) and then terminates.

Main            proc
                assume  cs:cseg, ds:dseg, es:SharedMemory
                mov     ax, dseg
                mov     ds, ax
                meminit

                print
                byte    &quot;Shared memory application #1&quot;,cr,lf,0

; See if the shared memory TSR is around:

                call    SeeIfPresent
                je      ItsThere
                print
                byte    &quot;Shared Memory TSR (SHARDMEM) is not loaded.&quot;,cr,lf
                byte    &quot;This program cannot continue execution.&quot;,cr,lf,0
                ExitPgm

; If the shared memory TSR is present, get the address of the shared segment
; into the ES register:

ItsThere:       mov     ah, cl          ;ID of our TSR.
                mov     al, 10h         ;Get shared segment address.
                int     2Fh

; Get the input line from the user:

                print
                byte    &quot;Enter a string: &quot;,0

                lea     di, InputLine   ;ES already points at proper seg.
                gets

                print
                byte    &quot;Entered '&quot;,0
                puts
                print
                byte    &quot;' into shared memory.&quot;,cr,lf,0


Quit:           ExitPgm                 ;DOS macro to quit program.
Main            endp

cseg            ends

sseg            segment para stack 'stack'
stk             db      1024 dup (&quot;stack &quot;)
sseg            ends

zzzzzzseg       segment para public 'zzzzzz'
LastBytes       db      16 dup (?)
zzzzzzseg       ends


; The shared memory segment must appear after &quot;zzzzzzseg&quot;.
; Note that this isn't the physical storage for the data in the
; shared segment. It's really just a place holder so we can declare
; variables and generate their offsets appropriately. The UCR Standard
; Library will reuse the memory associated with this segment for the
; heap. To access data in the shared segment, this application calls
; the shared memory TSR to obtain the true segment address of the
; shared memory segment. It can then access variables in the shared
; memory segment (where ever it happens to be) off the ES register.
;
; Note that all the variable declarations go into an include file.
; All applications that refer to the shared memory segment include
; this file in the SharedMemory segment. This ensures that all
; shared segments have the exact same variable layout.

SharedMemory    segment para public 'Shared'

                include shmvars.asm

SharedMemory    ends
                end     Main</font></pre>

<p><font face="Arial" size="2">The second application is very similar, here it is</font></p>

<pre><font face="Courier New" size="2">; SHMAPP2.ASM
;
; This is a shared memory application that uses the static shared memory
; TSR (SHARDMEM.ASM). This program assumes the user has already run the
; SHMAPP1 program to insert a string into shared memory. This program
; simply prints that string from shared memory.
;
                .xlist
                include         stdlib.a
                includelib      stdlib.lib
                .list

dseg            segment para public 'data'
ShmID           byte    0
dseg            ends

cseg            segment para public 'code'
                assume  cs:cseg, ds:dseg, es:SharedMemory

; SeeIfPresent Checks to see if the shared memory TSR is present in memory.
;              Sets the zero flag if it is, clears the zero flag if
;              it is not. This routine also returns the TSR ID in CL.

SeeIfPresent    proc    near
                push    es
                push    ds
                push    di
                mov     cx, 0ffh        ;Start with ID 0FFh.
IDLoop:         mov     ah, cl
                push    cx
                mov     al, 0           ;Verify presence call.
                int     2Fh
                pop     cx
                cmp     al, 0           ;Present in memory?
                je      TryNext
                strcmpl
                byte    &quot;Static Shared Memory TSR&quot;,0
                je      Success

TryNext:        dec     cl              ;Test USER IDs of 80h..FFh
                js      IDLoop
                cmp     cx, 0           ;Clear zero flag.
Success:        pop     di
                pop     ds
                pop     es
                ret
SeeIfPresent            endp



; The main program for application #1 links with the shared memory
; TSR and then reads a string from the user (storing the string into
; shared memory) and then terminates.

Main            proc
                assume  cs:cseg, ds:dseg, es:SharedMemory
                mov     ax, dseg
                mov     ds, ax
                meminit

                print
                byte    &quot;Shared memory application #2&quot;,cr,lf,0

; See if the shared memory TSR is around:

                call    SeeIfPresent
                je      ItsThere
                print
                byte    &quot;Shared Memory TSR (SHARDMEM) is not loaded.&quot;,cr,lf
                byte    &quot;This program cannot continue execution.&quot;,cr,lf,0
                ExitPgm

; If the shared memory TSR is present, get the address of the shared segment
; into the ES register:

ItsThere:       mov     ah, cl          ;ID of our TSR.
                mov     al, 10h         ;Get shared segment address.
                int     2Fh

; Print the string input in SHMAPP1:

                print
                byte    &quot;String from SHMAPP1 is '&quot;,0

                lea     di, InputLine   ;ES already points at proper seg.
                puts

                print
                byte    &quot;' from shared memory.&quot;,cr,lf,0


Quit:           ExitPgm                 ;DOS macro to quit program.
Main            endp

cseg            ends

sseg            segment para stack 'stack'
stk             db      1024 dup (&quot;stack &quot;)
sseg            ends

zzzzzzseg       segment para public 'zzzzzz'
LastBytes       db      16 dup (?)
zzzzzzseg       ends


; The shared memory segment must appear after &quot;zzzzzzseg&quot;.
; Note that this isn't the physical storage for the data in the
; shared segment. It's really just a place holder so we can declare
; variables and generate their offsets appropriately. The UCR Standard
; Library will reuse the memory associated with this segment for the
; heap. To access data in the shared segment, this application calls
; the shared memory TSR to obtain the true segment address of the
; shared memory segment. It can then access variables in the shared
; memory segment (where ever it happens to be) off the ES register.
;
; Note that all the variable declarations go into an include file.
; All applications that refer to the shared memory segment include
; this file in the SharedMemory segment. This ensures that all
; shared segments have the exact same variable layout.

SharedMemory    segment para public 'Shared'

                include shmvars.asm

SharedMemory    ends
                end     Main</font></pre>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF"><p align="left"><a href="CH19-3.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a> <font face="Arial" size="2"><strong><a href="CH19-3.html">Chapter Nineteen</a> (Part 3)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF"><font face="Arial" size="2"><strong><a href="../toc.html">Table of Content</a></strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF"><font face="Arial" size="2"><strong><p align="right"><a href="CH19-5.html">Chapter Nineteen</a> (Part 5) <a href="CH19-5.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></strong></font></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Nineteen: Processes,
Coroutines and Concurrency (Part 4)<br>
29 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_19/CH19-4.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:45 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
