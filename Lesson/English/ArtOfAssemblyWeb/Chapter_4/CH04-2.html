<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_4/CH04-2.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:25:44 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER FOUR: MEMORY LAYOUT AND ACCESS (Part 2)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING2"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH04-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH04-1.html">Chapter Four</a> (Part 1)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH04-3.html">Chapter Four</a> (Part 3) </strong></font><a href="CH04-3.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10" colspan="2"><a NAME="HEADING2-0"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0" colspan="2"><font face="Arial" size="4"><strong>CHAPTER
    FOUR:<br>
    MEMORY LAYOUT AND ACCESS (Part 2)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10" colspan="2"></td>
  </tr>
  <tr>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING2-1"><b>4.6 </b>-
    The 80x86 Addressing Modes</a> <br>
    <a HREF="#HEADING2-4"><b>4.6.1 </b>- 8086 Register Addressing Modes</a> <br>
    <a HREF="#HEADING2-23"><b>4.6.2 </b>- 8086 Memory Addressing Modes</a> <br>
    <a HREF="#HEADING2-26"><b>4.6.2.1 </b>- The Displacement Only Addressing Mode</a> <br>
    <a HREF="#HEADING2-35"><b>4.6.2.2 </b>- The Register Indirect Addressing Modes</a> <br>
    <a HREF="#HEADING2-54"><b>4.6.2.3 </b>- Indexed Addressing Modes</a> </font></td>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING2-73"><b>4.6.2.4
    </b>- Based Indexed Addressing Modes</a> <br>
    <a HREF="#HEADING2-91"><b>4.6.2.5 </b>- Based Indexed Plus Displacement Addressing Mode</a>
    <br>
    <a HREF="#HEADING2-105"><b>4.6.2.6 </b>- MASM Syntax for 8086 Memory Addressing Modes</a> <br>
    <a HREF="#HEADING2-114"><b>4.6.2.7 </b>- An Easy Way to Remember the 8086 Memory
    Addressing Modes</a> <br>
    <a HREF="#HEADING2-125"><b>4.6.2.8 </b>- Some Final Comments About 8086 Addressing Modes</a>
    </font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="20" colspan="2"></td>
  </tr>
  <tr>
    <td width="100%" colspan="2"><strong><font face="Arial" size="3"><a NAME="HEADING2-1"></a>4.6
    The 80x86 Addressing Modes</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="1" colspan="2" bgcolor="#000000"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">Like the x86 processors described in the previous chapter,
the 80x86 processors let you access memory in many different ways. The 80x86 memory
addressing modes provide flexible access to memory, allowing you to easily access
variables, arrays, records, pointers, and other complex data types. Mastery of the 80x86
addressing modes is the first step towards mastering 80x86 assembly language.</font></p>

<p><font face="Arial" size="2">When Intel designed the original 8086 processor, they
provided it with a flexible, though limited, set of memory addressing modes. Intel added
several new addressing modes when it introduced the 80386 microprocessor. Note that the
80386 retained all the modes of the previous processors; the new modes are just an added
bonus. If you need to write code that works on 80286 and earlier processors, you will not
be able to take advantage of these new modes. However, if you intend to run your code on
80386sx or higher processors, you can use these new modes. Since many programmers still
need to write programs that run on 80286 and earlier machines, it's important to separate
the discussion of these two sets of addressing modes to avoid confusing them.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-4"></a>4.6.1 8086 Register
Addressing Modes</font></strong></p>

<p><font face="Arial" size="2">Most 8086 instructions can operate on the 8086's general
purpose register set. By specifying the name of the register as an operand to the
instruction, you may access the contents of that register. Consider the 8086 <code>mov</code>
(move) instruction: </font></p>

<pre><font face="Courier New" size="2">		mov	destination, source</font></pre>

<p><font face="Arial" size="2">This instruction copies the data from the source operand to
the destination operand. The eight and 16 bit registers are certainly valid operands for
this instruction. The only restriction is that both operands must be the same size. Now
let's look at some actual 8086 <code>mov</code> instructions: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, bx  ;Copies the value from BX into AX
                mov     dl, al  ;Copies the value from AL into DL
                mov     si, dx  ;Copies the value from DX into SI
                mov     sp, bp  ;Copies the value from BP into SP
                mov     dh, cl  ;Copies the value from CL into DH
                mov     ax, ax  ;Yes, this is legal!</font></pre>

<p><font face="Arial" size="2">Remember, the registers are the best place to keep often
used variables. As you'll see a little later, instructions using the registers are shorter
and faster than those that access memory. Throughout this chapter you'll see the
abbreviated operands reg and r/m (register/memory) used wherever you may use one of the
8086's general purpose registers.</font></p>

<p><font face="Arial" size="2">In addition to the general purpose registers, many 8086
instructions (including the <code>mov</code> instruction) allow you to specify one of the
segment registers as an operand. There are two restrictions on the use of the segment
registers with the <code>mov</code> instruction. First of all, you may not specify <code>cs</code>
as the destination operand, second, only one of the operands can be a segment register.
You cannot move data from one segment register to another with a single <code>mov</code>
instruction. To copy the value of <code>cs</code> to <code>ds</code>, you'd have to use
some sequence like: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, cs
                mov     ds, ax</font></pre>

<p><font face="Arial" size="2">You should never use the segment registers as data
registers to hold arbitrary values. They should only contain segment addresses. But more
on that, later. Throughout this text you'll see the abbreviated operand sreg used wherever
segment register operands are allowed (or required).</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-23"></a>4.6.2 8086 Memory
Addressing Modes</font></strong></p>

<p><font face="Arial" size="2">The 8086 provides 17 different ways to access memory. This
may seem like quite a bit at first, but fortunately most of the address modes are simple
variants of one another so they're very easy to learn. And learn them you should! The key
to good assembly language programming is the proper use of memory addressing modes.</font></p>

<p><font face="Arial" size="2">The addressing modes provided by the 8086 family include
displacement-only, base, displacement plus base, base plus indexed, and displacement plus
base plus indexed. Variations on these five forms provide the 17 different addressing
modes on the 8086. See, from 17 down to five. It's not so bad after all! </font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-26"></a>4.6.2.1 The Displacement
Only Addressing Mode</font></strong></p>

<p><font face="Arial" size="2">The most common addressing mode, and the one that's easiest
to understand, is the displacement-only (or direct) addressing mode. The displacement-only
addressing mode consists of a 16 bit constant that specifies the address of the target
location. The instruction <code>mov al,ds:[8088h] </code>loads the <code>al</code>
register with a copy of the byte at memory location 8088h. Likewise, the instruction <code>mov
ds:[1234h],dl </code>stores the value in the <code>dl</code> register to memory location
1234h:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch04a7.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH04/ch04a7.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="232" HEIGHT="111"> </font></p>

<p><font face="Arial" size="2">The displacement-only addressing mode is perfect for
accessing simple variables. Of course, you'd probably prefer using names like
&quot;I&quot; or &quot;J&quot; rather than &quot;DS:[1234h]&quot; or
&quot;DS:[8088h]&quot;. Well, fear not, you'll soon see it's possible to do just that.</font></p>

<p><font face="Arial" size="2">Intel named this the displacement-only addressing mode
because a 16 bit constant (displacement) follows the<code> mov</code> opcode in memory. In
that respect it is quite similar to the direct addressing mode on the x86 processors (see
the previous chapter). There are some minor differences, however. First of all, a
displacement is exactly that- some distance from some other point. On the x86, a direct
address can be thought of as a displacement from address zero. On the 80x86 processors,
this displacement is an offset from the beginning of a segment (the data segment in this
example). Don't worry if this doesn't make a lot of sense right now. You'll get an
opportunity to study segments to your heart's content a little later in this chapter. For
now, you can think of the displacement-only addressing mode as a direct addressing mode.
The examples in this chapter will typically access bytes in memory. Don't forget, however,
that you can also access words on the 8086 processors:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch04a8.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH04/ch04a8.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="250" HEIGHT="101"> </font></p>

<p><font face="Arial" size="2">By default, all displacement-only values provide offsets
into the data segment. If you want to provide an offset into a different segment, you must
use a segment override prefix before your address. For example, to access location 1234h
in the extra segment (<code>es</code>) you would use an instruction of the form <code>mov
ax,es:[1234h]. </code>Likewise, to access this location in the code segment you would use
the instruction <code>mov ax, cs:[1234h].</code> The <code>ds:</code> prefix in the
previous examples is not a segment override. The CPU uses the data segment register by
default. These specific examples require <code>ds:</code> because of MASM's syntactical
limitations.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-35"></a>4.6.2.2 The Register
Indirect Addressing Modes</font></strong></p>

<p><font face="Arial" size="2">The 80x86 CPUs let you access memory indirectly through a
register using the register indirect addressing modes. There are four forms of this
addressing mode on the 8086, best demonstrated by the following instructions:</font> </p>

<pre><font face="Courier New" size="2">                mov     al, [bx]
                mov     al, [bp]
                mov     al, [si]
                mov     al, [di]</font></pre>

<p><font face="Arial" size="2">As with the x86 <code>[bx]</code> addressing mode, these
four addressing modes reference the byte at the offset found in the <code>bx, bp, si,</code>
or <code>di</code> register, respectively. The<code> [bx], [si],</code> and<code> [di] </code>modes
use the <code>ds</code> segment by default. The<code> [bp] </code>addressing mode uses the
stack segment (<code>ss</code>) by default.</font></p>

<p><font face="Arial" size="2">You can use the segment override prefix symbols if you wish
to access data in different segments. The following instructions demonstrate the use of
these overrides: </font></p>

<pre><font face="Courier New" size="2">                mov     al, cs:[bx]
                mov     al, ds:[bp]
                mov     al, ss:[si]
                mov     al, es:[di]</font></pre>

<p><font face="Arial" size="2">Intel refers to<code> [bx] </code>and<code> [bp]</code> as
base addressing modes and <code>bx</code> and <code>bp</code> as base registers (in fact, <code>bp</code>
stands for base pointer). Intel refers to the<code> [si] </code>and<code> [di]</code>
addressing modes as indexed addressing modes (<code>si</code> stands for source index, <code>di</code>
stands for destination index). However, these addressing modes are functionally
equivalent. This text will call these forms register indirect modes to be consistent.</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch04a9.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH04/ch04a9.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="288" HEIGHT="103"><br>
<br>
<img SRC="images/ch04a10.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH04/ch04a10.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="288" HEIGHT="103"> </font></p>

<p><font face="Arial" size="2">Note: the<code> [si]</code> and<code> [di]</code>
addressing modes work exactly the same way, just substitute <code>si</code> and <code>di</code>
for <code>bx</code> above.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-54"></a>4.6.2.3 Indexed
Addressing Modes</font></strong></p>

<p><font face="Arial" size="2">The indexed addressing modes use the following syntax: </font></p>

<pre><font face="Courier New" size="2">                mov     al, disp[bx]
                mov     al, disp[bp]
                mov     al, disp[si]
                mov     al, disp[di]</font></pre>

<p><font face="Arial" size="2">If <code>bx</code> contains 1000h, then the instruction<code>
mov cl,20h[bx] </code>will load <code>cl</code> from memory location ds:1020h. Likewise,
if <code>bp</code> contains 2020h,<code> mov dh,1000h[bp]</code> will load <code>dh</code>
from location ss:3020.</font></p>

<p><font face="Arial" size="2">The offsets generated by these addressing modes are the sum
of the constant and the specified register. The addressing modes involving <code>bx, si,</code>
and <code>di</code> all use the data segment, the <code>disp[bp]</code> addressing mode
uses the stack segment by default. As with the register indirect addressing modes, you can
use the segment override prefixes to specify a different segment: </font></p>

<pre><font face="Courier New" size="2">                mov     al, ss:disp[bx]
                mov     al, es:disp[bp]
                mov     al, cs:disp[si]
                mov     al, ss:disp[di]</font></pre>
<div align="center"><center>

<pre><img SRC="images/ch04a11.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH04/ch04a11.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="291" HEIGHT="103">
<img SRC="images/ch04a12.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH04/ch04a12.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="291" HEIGHT="103"></pre>
</center></div>

<p><font face="Arial" size="2">You may substitute <code>si</code> or <code>di</code> in
the figure above to obtain the <code>[si+disp] </code>and<code> [di+disp]</code>
addressing modes.</font></p>

<p><font face="Arial" size="2">Note that Intel still refers to these addressing modes as
based addressing and indexed addressing. Intel's literature does not differentiate between
these modes with or without the constant. If you look at how the hardware works, this is a
reasonable definition. From the programmer's point of view, however, these addressing
modes are useful for entirely different things. Which is why this text uses different
terms to describe them. Unfortunately, there is very little consensus on the use of these
terms in the 80x86 world. </font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-73"></a>4.6.2.4 Based Indexed
Addressing Modes</font></strong></p>

<p><font face="Arial" size="2">The based indexed addressing modes are simply combinations
of the register indirect addressing modes. These addressing modes form the offset by
adding together a base register (<code>bx</code> or <code>bp</code>) and an index register
(<code>si</code> or <code>di</code>). The allowable forms for these addressing modes are </font></p>

<pre><font face="Courier New" size="2">                mov     al, [bx][si]
                mov     al, [bx][di]
                mov     al, [bp][si]
                mov     al, [bp][di]</font></pre>

<p><font face="Arial" size="2">Suppose that <code>bx</code> contains 1000h and <code>si</code>
contains 880h. Then the instruction </font></p>

<pre><font face="Courier New" size="2"><code>		mov	al,[bx][si]</code></font></pre>

<p><font face="Arial" size="2">would load <code>al</code> from location DS:1880h.
Likewise, if <code>bp</code> contains 1598h and <code>di</code> contains 1004,<code> mov
ax,[bp+di] </code>will load the 16 bits in <code>ax</code> from locations SS:259C and
SS:259D.</font></p>

<p><font face="Arial" size="2">The addressing modes that do not involve <code>bp</code>
use the data segment by default. Those that have <code>bp</code> as an operand use the
stack segment by default.</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch04a13.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH04/ch04a13.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="292" HEIGHT="103"> </font></p>

<p><font face="Arial" size="2">You substitute <code>di</code> in the figure above to
obtain the<code> [bx+di] </code>addressing mode.</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch04a14.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH04/ch04a14.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="292" HEIGHT="103"> </font></p>

<p><font face="Arial" size="2">You substitute <code>di</code> in the figure above for the<code>
[bp+di] </code>addressing mode.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-91"></a>4.6.2.5 Based Indexed
Plus Displacement Addressing Mode</font></strong></p>

<p><font face="Arial" size="2">These addressing modes are a slight modification of the
base/indexed addressing modes with the addition of an eight bit or sixteen bit constant.
The following are some examples of these addressing modes:</font></p>

<p align="center"><img SRC="images/ch04a15.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH04/ch04a15.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="296" HEIGHT="103"> </p>

<pre><font face="Courier New" size="2">                mov     al, disp[bx][si]
                mov     al, disp[bx+di]
                mov     al, [bp+si+disp]
                mov     al, [bp][di][disp]</font></pre>

<p><font face="Arial" size="2">You may substitute <code>di</code> in the figure above to
produce the<code> [bx+di+disp] </code>addressing mode.</font></p>

<p align="center"><img SRC="images/ch04a16.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH04/ch04a16.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="296" HEIGHT="103"> </p>

<p><font face="Arial" size="2">You may substitute <code>di</code> in the figure above to
produce the<code> [bp+di+disp] </code>addressing mode.</font></p>

<p><font face="Arial" size="2">Suppose <code>bp</code> contains 1000h, <code>bx</code>
contains 2000h, <code>si</code> contains 120h, and <code>di</code> contains 5. Then <code>mov
al,10h[bx+si] </code>loads <code>al </code>from address DS:2130;<code> mov ch,125h[bp+di]</code>
loads <code>ch</code> from location SS:112A; and<code> mov bx,cs:2[bx][di]</code> loads <code>bx</code>
from location CS:2007.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-105"></a>4.6.2.6 MASM Syntax for
8086 Memory Addressing Modes</font></strong></p>

<p><font face="Arial" size="2">Microsoft's assembler uses several different variations to
denote indexed, based/indexed, and displacement plus based/indexed addressing modes. You
will see all of these forms used interchangeably throughout this text. The following list
some of the possible combinations that are legal for the various 80x86 addressing modes: </font></p>

<p><font face="Courier New" size="2">disp[bx], [bx][disp], [bx+disp], [disp][bx], and
[disp+bx]</font></p>

<p><font face="Courier New" size="2">[bx][si], [bx+si], [si][bx], and [si+bx]</font></p>

<p><font face="Courier New" size="2">disp[bx][si], disp[bx+si], [disp+bx+si],
[disp+bx][si], disp[si][bx], [disp+si][bx], [disp+si+bx], [si+disp+bx], [bx+disp+si], etc.</font></p>

<p><font face="Arial" size="2">MASM treats the &quot;[ ]&quot; symbols just like the
&quot;+&quot; operator. This operator is commutative, just like the &quot;+&quot;
operator. Of course, this discussion applies to all the 8086 addressing modes, not just
those involving BX and SI. You may substitute any legal registers in the addressing modes
above.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-114"></a>4.6.2.7 An Easy Way to
Remember the 8086 Memory Addressing Modes</font></strong></p>

<p><font face="Arial" size="2">There are a total of 17 different legal memory addressing
modes on the 8086: disp, [bx], [bp], [si], [di], disp[bx], disp[bp], disp[si], disp[di],
[bx][si], [bx][di], [bp][si], [bp][di], disp[bx][si], disp [bx][di], disp[bp][si], and
disp[bp][di]. You could memorize all these forms so that you know which are valid (and, by
omission, which forms are invalid). However, there is an easier way besides memorizing
these 17 forms. Consider the chart:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch04a17.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH04/ch04a17.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="305" HEIGHT="158"> </font></p>

<p><font face="Arial" size="2">If you choose zero or one items from each of the columns
and wind up with at least one item, you've got a valid 8086 memory addressing mode. Some
examples: </font>

<ul>
  <li><font face="Arial" size="2">Choose <code>disp</code> from column one, nothing from
    column two, <code>[di]</code> from column 3, you get <code>disp[di]</code>. </font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Choose <code>disp, [bx], </code>and<code> [di]</code>. You
    get <code>disp[bx][di]</code>. </font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Skip column one &amp; two, choose <code>[si]</code>. You get
    <code>[si]</code> </font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Skip column one, choose<code> [bx]</code>, then choose <code>[di]</code>.
    You get<code> [bx][di]</code></font></li>
</ul>

<p><font face="Arial" size="2">Likewise, if you have an addressing mode that you cannot
construct from this table, then it is not legal. For example, <code>disp[dx][si] </code>is
illegal because you cannot obtain<code> [dx] </code>from any of the columns above.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-125"></a>4.6.2.8 Some Final
Comments About 8086 Addressing Modes</font></strong></p>

<p><font face="Arial" size="2">The effective address is the final offset produced by an
addressing mode computation. For example, if <code>bx</code> contains 10h, the effective
address for <code>10h[bx] </code>is 20h. You will see the term effective address in almost
any discussion of the 8086's addressing mode. There is even a special instruction load
effective address (<code>lea</code>) that computes effective addresses.</font></p>

<p><font face="Arial" size="2">Not all addressing modes are created equal! Different
addressing modes may take differing amounts of time to compute the effective address. The
exact difference varies from processor to processor. Generally, though, the more complex
an addressing mode is, the longer it takes to compute the effective address. Complexity of
an addressing mode is directly related to the number of terms in the addressing mode. For
example, <code>disp[bx][si] </code>is more complex than<code> [bx]</code>. See the
instruction set reference in the appendices for information regarding the cycle times of
various addressing modes on the different 80x86 processors.</font></p>

<p><font face="Arial" size="2">The displacement field in all addressing modes except
displacement-only can be a signed eight bit constant or a signed 16 bit constant. If your
offset is in the range -128...+127 the instruction will be shorter (and therefore faster)
than an instruction with a displacement outside that range. The size of the value in the
register does not affect the execution time or size. So if you can arrange to put a large
number in the register(s) and use a small displacement, that is preferable over a large
constant and small values in the register(s).</font></p>

<p><font face="Arial" size="2">If the effective address calculation produces a value
greater than 0FFFFh, the CPU ignores the overflow and the result wraps around back to
zero. For example, if <code>bx</code> contains 10h, then the instruction<code> mov
al,0FFFFh[bx] </code>will load the <code>al </code>register from location ds:0Fh, not from
location ds:1000Fh.</font></p>

<p><font face="Arial" size="2">In this discussion you've seen how these addressing modes
operate. The preceding discussion didn't explain what you use them for. That will come a
little later. As long as you know how each addressing mode performs its effective address
calculation, you'll be fine. </font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH04-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH04-1.html">Chapter Four</a> (Part 1)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH04-3.html">Chapter Four</a> (Part 3) </strong></font><a href="CH04-3.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Four: Memory Layout and
Access (Part 2)<br>
26 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_4/CH04-2.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:25:58 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
