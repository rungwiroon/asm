<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_9/CH09-2.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:39 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER NINE: ARITHMETIC AND LOGICAL OPERATIONS (Part 2)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING2"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH09-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH09-1.html">Chapter Nine</a> (Part 1)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH09-3.html">Chapter Nine</a> (Part 3) </strong></font><a href="CH09-3.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10"><a NAME="HEADING2-0"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0"><font face="Arial" size="4"><strong>CHAPTER NINE:<br>
    ARITHMETIC AND LOGICAL OPERATIONS (Part 2)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10"></td>
  </tr>
  <tr>
    <td width="100%"><font face="Arial" size="2"><a HREF="#HEADING2-1"><b>9.2 </b>- Logical
    (Boolean) Expressions</a> </font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="20"></td>
  </tr>
  <tr>
    <td width="100%"><h2><strong><font face="Arial" size="3">9.2 Logical (Boolean) Expressions</font></strong></h2>
    </td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">Consider the following expression from a Pascal program: </font></p>

<pre><font face="Courier New" size="2">	B := ((X=Y) and (A &lt;= C)) or ((Z-A) &lt;&gt; 5);</font></pre>

<p><font face="Arial" size="2"><code>B</code> is a boolean variable and the remaining
variables are all integers. </font></p>

<p><font face="Arial" size="2">How do we represent boolean variables in assembly language?
Although it takes only a single bit to represent a boolean value, most assembly language
programmers allocate a whole byte or word for this purpose. With a byte, there are 256
possible values we can use to represent the two values true and false. So which two values
(or which two sets of values) do we use to represent these boolean values? Because of the
machine's architecture, it's much easier to test for conditions like zero or not zero and
positive or negative rather than to test for one of two particular boolean values. Most
programmers (and, indeed, some programming languages like &quot;C&quot;) choose zero to
represent false and anything else to represent true. Some people prefer to represent true
and false with one and zero (respectively) and not allow any other values. Others select
0FFFFh for true and 0 for false. You could also use a positive value for true and a
negative value for false. All these mechanisms have their own advantages and drawbacks. </font></p>

<p><font face="Arial" size="2">Using only zero and one to represent false and true offers
one very big advantage: the 80x86 logical instructions (<code>and, or, xor </code>and, to
a lesser extent, <code>not</code>) operate on these values exactly as you would expect.
That is, if you have two boolean variables <code>A</code> and <code>B</code>, then the
following instructions perform the basic logical operations on these two variables: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, A
                and     ax, B
                mov     C, ax           ;C := A and B;

                mov     ax, A 
                or      ax, B 
                mov     C, ax           ;C := A or B;

                mov     ax, A
                xor     ax, B
                mov     C, ax           ;C := A xor B;

                mov     ax, A           ;Note that the NOT instruction does not
                not     ax              ; properly compute B := not A by itself.
                and     ax, 1           ; I.e., (NOT 0)does not equal one.
                mov     B, ax           ;B := not A;

                mov     ax, A           ;Another way to do B := NOT A;
                xor     ax, 1
                mov     B, ax           ;B := not A;</font></pre>

<p><font face="Arial" size="2">Note, as pointed out above, that the <code>not</code>
instruction will not properly compute logical negation. The bitwise not of zero is 0FFh
and the bitwise not of one is 0FEh. Neither result is zero or one. However, by anding the
result with one you get the proper result. Note that you can implement the not<code> </code>operation
more efficiently using the <code>xor ax, 1 </code>instruction since it only affects the
L.O. bit. </font></p>

<p><font face="Arial" size="2">As it turns out, using zero for false and anything else for
true has a lot of subtle advantages. Specifically, the test for true or false is often
implicit in the execution of any logical instruction. However, this mechanism suffers from
a very big disadvantage: you cannot use the 80x86 <code>and, or, xor, </code>and <code>not
</code>instructions to implement the boolean operations of the same name. Consider the two
values 55h and 0AAh. They're both non-zero so they both represent the value true. However,
if you logically and 55h and 0AAh together using the 80x86 <code>and </code>instruction,
the result is zero. (True and true) should produce true, not false. A system that uses
non-zero values to represent true and zero to represent false is an arithmetic logical
system. A system that uses the two distinct values like zero and one to represent false
and true is called a boolean logical system, or simply a boolean system. You can use
either system, as convenient. Consider again the boolean expression: </font></p>

<pre><font face="Courier New" size="2">	B := ((X=Y) and (A &lt;= D)) or ((Z-A) &lt;&gt; 5);</font></pre>

<p><font face="Arial" size="2">The simple expressions resulting from this expression might
be: </font></p>

<pre><font face="Courier New" size="2">        Temp2 := X = Y
        Temp := A &lt;= D
        Temp := Temp and Temp2
        Temp2 := Z-A
        Temp2 := Temp2 &lt;&gt; 5
        B := Temp or Temp2</font></pre>

<p><font face="Arial" size="2">The assembly language code for these expressions could be: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, x           ;See if X = Y and load zero or
                cmp     ax, y           ; one into AX to denote the result
                jnz     L1              ; of this comparison.
                mov     al, 1           ;X = Y
                jmp     L2
L1:             mov     al, 0           ;X &lt;&gt; Y
L2:
                mov     bx, A           ;See if A &lt;= D and load zero or one
                cmp     bx, D           ; into BX to denote the result of
                jle     ST1             ; this comparison.
                mov     bl, 0
                jmp     L3
ST1:            mov     bl, 1 
L3:
                and     bl, al          ;Temp := Temp and Temp2

                mov     ax, Z           ;See if (Z-A) &lt;&gt; 5.
                sub     ax, A           ;Temp2 := Z-A;
                cmp     ax, 5           ;Temp2 := Temp2 &lt;&gt; 5;
                jnz     ST2
                mov     al, 0
                jmp     short L4
ST2:            mov     al, 1 
L4:
                or      al, bl          ;Temp := Temp or Temp2;
                mov     B, al           ;B := Temp;</font></pre>

<p><font face="Arial" size="2">As you can see, this is a rather unwieldy sequence of
statements. One slight optimization you can use is to assume a result is going to be true
or false and initialize the corresponding boolean result ahead of time: </font></p>

<pre><font face="Courier New" size="2">                mov     bl, 0           ;Assume X &lt;&gt; Y
                mov     ax, x
                cmp     ax, Y
                jne     L1
                mov     bl, 1           ;X is equal to Y, so make this true.
L1:
                mov     bh, 0           ;Assume not (A &lt;= D)
                mov     ax, A
                cmp     ax, D
                jnle    L2
                mov     bh, 1           ;A &lt;= D so make this true
L2:
                and     bl, bh          ;Compute logical AND of results.

                mov     bh, 0           ;Assume (Z-A) = 5
                mov     ax, Z
                sub     ax, A
                cmp     ax, 5
                je      L3:
                mov     bh, 1           ;(Z-A) &lt;&gt; 5
L3:
                or      bl, bh          ;Logical OR of results.
                mov     B, bl           ;Save boolean result.</font></pre>

<p><font face="Arial" size="2">Of course, if you have an 80386 or later processor, you can
use the setcc instructions to simplify this a bit: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, x
                cmp     ax, y
                sete    al              ;TEMP2 := X = Y

                mov     bx, A
                cmp     bx, D
                setle   bl              ;TEMP := A &lt;= D
                and     bl, al          ;Temp := Temp and Temp2
                mov     ax, Z 
                sub     ax, A           ;Temp2 := Z-A;
                cmp     ax, 5           ;Temp2 := Temp2 &lt;&gt; 5;
                setne   al
                or      bl, al          ;Temp := Temp or Temp2;
                mov     B, bl           ;B := Temp;</font></pre>

<p><font face="Arial" size="2">This code sequence is obviously much better than the
previous one, but it will only execute on 80386 and later processors.</font></p>

<p><font face="Arial" size="2">Another way to handle boolean expressions is to represent
boolean values by states within your code. The basic idea is to forget maintaining a
boolean variable throughout the execution of a code sequence and use the position within
the code to determine the boolean result. Consider the following implementation of the
above expression. First, let's rearrange the expression to be </font></p>

<pre><font face="Courier New" size="2">        B := ((Z-A) &lt;&gt; 5) or ((X=Y) and (A &lt;= D));</font></pre>

<p><font face="Arial" size="2">This is perfectly legal since the or operation is
commutative. Now consider the following implementation: </font></p>

<pre><font face="Courier New" size="2">                mov     B, 1            ;Assume the result is true.
                mov     ax, Z           ;See if (Z-A) &lt;&gt; 5
                sub     ax, A           ;If this condition is true, the
                cmp     ax, 5           ; result is always true so there
                jne     Done            ; is no need to check the rest.

                mov     ax, X           ;If X &lt;&gt; Y, the result is false,
                cmp     ax, Y           ; no matter what A and D contain
                jne     SetBtoFalse

                mov     ax, A           ;Now see if A &lt;= D.
                cmp     ax, D
                jle     Done            ;If so, quit.
SetBtoFalse:            mov     B, 0            ;If B is false, handle that here.
Done:</font></pre>

<p><font face="Arial" size="2">Notice that this section of code is a lot shorter than the
first version above (and it runs on all processors). The previous translations did
everything computationally. This version uses program flow logic to improve the code. It
begins by assuming a true result and sets the <code>B</code> variable to true. It then
checks to see if<code> (Z-A) &lt;&gt; 5</code>. If this is true the code branches to the
done table because <code>B</code> is true no matter what else happens. If the program
falls through to the <code>mov ax, X</code> instruction, we know that the result of the
previous comparison is false. There is no need to save this result in a temporary since we
implicitly know its value by the fact that we're executing the <code>mov ax, X</code>
instruction. Likewise, the second group of statements above checks to see if <code>X</code>
is equal to <code>Y</code>. If it is not, we already know the result is false so this code
jumps to the <code>SetBtoFalse</code> label. If the program begins executing the third set
of statements above, we know that the first result was false and the second result was
true; the position of the code guarantees this. Therefore, there is no need to maintain
temporary boolean variables that keep track of the state of this computation.</font></p>

<p><font face="Arial" size="2">Consider another example: </font></p>

<pre><font face="Courier New" size="2">	B := ((A = E) or (F &lt;&gt; D)) and ((A&lt;&gt;B) or (F = D));</font></pre>

<p><font face="Arial" size="2">Computationally, this expression would yield a considerable
amount of code. However, by using flow control you can reduce it to the following: </font></p>

<pre><font face="Courier New" size="2">                mov     b, 0            ;Assume result is false.
                mov     ax, a           ;See if A = E.
                cmp     ax, e
                je      test2           ;If so, 1st subexpression is true.

                mov     ax, f           ;If not, check 2nd subexpression
                cmp     ax, d           ; to see if F &lt;&gt; D.
                je      Done            ;If so, we're done, else fall
                                        ; through to next tests.
Test2:          mov     ax, a           ;Does A &lt;&gt; B?
                cmp     ax, b
                jne     SetBto1         ;If so, we're done.

                mov     ax, f           ;If not, see if F = D.
                cmp     ax, d
                jne     Done

SetBto1:        mov     b, 1
Done:</font></pre>

<p><font face="Arial" size="2">There is one other difference between using control flow
vs. computation logic: when using control flow methods, you may skip the majority of the
instructions that implement the boolean formula. This is known as short-circuit
evaluation. When using the computation model, even with the <code>setcc </code>instruction,
you wind up executing most of the statements. Keep in mind that this is not necessarily a
disadvantage. On pipelined processors it may be much faster to execute several additional
instructions rather than flush the pipeline and prefetch queue. You may need to experiment
with your code to determine the best solution.</font></p>

<p><font face="Arial" size="2">When working with boolean expressions don't forget the that
you might be able to optimize your code by simplifying those boolean expressions (See
Chapter Two). You can use algebraic transformations (especially DeMorgan's theorems) and
the mapping method to help reduce the complexity of an expression.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH09-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH09-1.html">Chapter Nine</a> (Part 1)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH09-3.html">Chapter Nine</a> (Part 3) </strong></font><a href="CH09-3.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Nine: Arithmetic And Logical
Operations (Part 2)<br>
27 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_9/CH09-2.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:39 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
