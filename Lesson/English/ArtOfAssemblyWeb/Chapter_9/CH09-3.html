<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_9/CH09-3.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:39 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER NINE: ARITHMETIC AND LOGICAL OPERATIONS (Part 3)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING3"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH09-2.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH09-2.html">Chapter Nine</a> (Part 2)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH09-4.html">Chapter Nine</a> (Part 4) </strong></font><a href="CH09-4.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10"><a NAME="HEADING3-1"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0"><font face="Arial" size="4"><strong>CHAPTER NINE:<br>
    ARITHMETIC AND LOGICAL OPERATIONS (Part 3)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10"></td>
  </tr>
  <tr>
    <td width="100%"><font face="Arial" size="2"><a HREF="#HEADING3-1"><b>9.3 </b>-
    Multiprecision Operations</a> <br>
    <a HREF="#HEADING3-3"><b>9.3.1 </b>- Multiprecision Addition Operations</a> <br>
    <a HREF="#HEADING3-65"><b>9.3.2 </b>- Multiprecision Subtraction Operations</a> <br>
    <a HREF="#HEADING3-100"><b>9.3.3 </b>- Extended Precision Comparisons</a> </font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="20"></td>
  </tr>
  <tr>
    <td width="100%"><h2><font face="Arial" size="3"><strong>9.3 Multiprecision Operations</strong></font></h2>
    </td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">One big advantage of assembly language over HLLs is that
assembly language does not limit the size of integers. For example, the C programming
language defines a maximum of three different integer sizes: <code>short int, int,</code>
and<code> long int</code>. On the PC, these are often 16 or 32 bit integers. Although the
80x86 machine instructions limit you to processing eight, sixteen, or thirty-two bit
integers with a single instruction, you can always use more than one instruction to
process integers of any size you desire. If you want 256 bit integer values, no problem.
The following sections describe how extended various arithmetic and logical operations
from 16 or 32 bits to as many bits as you please.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-3"></a>9.3.1 Multiprecision
Addition Operations </font></strong></p>

<p><font face="Arial" size="2">The 80x86 <code>add </code>instruction adds two 8, 16, or
32 bit numbers<a HREF="#FOOTNOTE-1">[1]</a>. After the execution of the <code>add </code>instruction,
the 80x86 carry flag is set if there is an overflow out of the H.O. bit of the sum. You
can use this information to do multiprecision addition operations. Consider the way you
manually perform a multidigit (multiprecision) addition operation:</font></p>

<p><font face="Arial" size="2">Step 1: Add the least significant digits together: </font></p>

<pre><font face="Courier New" size="2">         289                             289
        +456      produces              +456
        ----                            ----
                                           5 with carry 1.</font></pre>

<p><font face="Arial" size="2">Step 2: Add the next significant digits plus the carry: </font></p>

<pre><font face="Courier New" size="2">          1 (previous carry)
         289                             289
        +456            produces        +456
        ----                            ----
           5                              45 with carry 1.</font></pre>

<p><font face="Arial" size="2">Step 3: Add the most significant digits plus the carry: </font></p>

<pre><font face="Courier New" size="2">                                         1 (previous carry)
         289                             289
        +456            produces        +456
        ----                            ----
          45                             745</font></pre>

<p><font face="Arial" size="2">The 80x86 handles extended precision arithmetic in an
identical fashion, except instead of adding the numbers a digit at a time, it adds them a
byte or a word at a time. Consider the three-word (48 bit) addition operation shown below:</font></p>

<p align="center"><img SRC="images/ch09a.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH09/ch09a.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="407" HEIGHT="344"> </p>

<p><font face="Arial" size="2">The <code>add</code> instruction adds the L.O. words
together. The <code>adc</code> (add with carry) instruction adds all other word pairs
together. The <code>adc</code> instruction adds two operands plus the carry flag together
producing a word value and (possibly) a carry. </font></p>

<p><font face="Arial" size="2">For example, suppose that you have two thirty-two bit
values you wish to add together, defined as follows: </font></p>

<pre><font face="Courier New" size="2">X               dword   ?
Y               dword   ?</font></pre>

<p><font face="Arial" size="2">Suppose, also, that you want to store the sum in a third
variable, Z, that is likewise defined with the <code>dword </code>directive. The following
80x86 code will accomplish this task: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, word ptr X
                add     ax, word ptr Y
                mov     word ptr Z, ax
                mov     ax, word ptr X+2
                adc     ax, word ptr Y+2
                mov     word ptr Z+2, ax</font></pre>

<p><font face="Arial" size="2">Remember, these variables are declared with the <code>dword
</code>directive. Therefore the assembler will not accept an instruction of the form <code>mov
ax, X </code>because this instruction would attempt to load a 32 bit value into a 16 bit
register. Therefore this code uses the word ptr coercion operator to coerce symbols <code>X</code>,
<code>Y</code>, and <code>Z</code> to 16 bits. The first three instructions add the L.O.
words of <code>X</code> and <code>Y</code> together and store the result at the L.O. word
of <code>Z</code>. The last three instructions add the H.O. words of <code>X</code> and <code>Y</code>
together, along with the carry out of the L.O. word, and store the result in the H.O. word
of <code>Z</code>. Remember, address expressions of the form &quot;X+2&quot; access the
H.O. word of a 32 bit entity. This is due to the fact that the 80x86 address space
addresses bytes and it takes two consecutive bytes to form a word.</font></p>

<p><font face="Arial" size="2">Of course, if you have an 80386 or later processor you
needn't go through all this just to add two 32 bit values together, since the 80386
directly supports 32 bit operations. However, if you wanted to add two 64 bit integers
together on the 80386, you would still need to use this technique.</font></p>

<p><font face="Arial" size="2">You can extend this to any number of bits by using the <code>adc</code>
instruction to add in the higher order words in the values. For example, to add together
two 128 bit values, you could use code that looks something like the following: </font></p>

<pre><font face="Courier New" size="2">BigVal1         dword   0,0,0,0         ;Four double words in 128 bits!
BigVal2         dword   0,0,0,0
BigVal3         dword   0,0,0,0
                 .
                 .
                 .
                mov     eax, BigVal1    ;No need for dword ptr operator since
                add     eax, BigVal2    ; these are dword variables.
                mov     BigVal3, eax

                mov     eax, BigVal1+4  ;Add in the values from the L.O.
                adc     eax, BigVal2+4  ; entity to the H.O. entity using
                mov     BigVal3+4, eax  ; the ADC instruction.

                mov     eax, BigVal1+8
                adc     eax, BigVal2+8
                mov     BigVal3+8, eax

                mov     eax, BigVal1+12
                adc     eax, BigVal2+12
                mov     BigVal3+12, eax</font></pre>

<h3><strong><font face="Arial" size="3">9.3.2 Multiprecision Subtraction Operations</font></strong></h3>

<p><font face="Arial" size="2">Like addition, the 80x86 performs multi-byte subtraction
the same way you would manually, except it subtracts whole bytes , words, or double words
at a time rather than decimal digits. The mechanism is similar to that for the <code>add </code>operation,
You use the sub instruction on the L.O. byte/word/double word and the sbb instruction on
the high order values. The following example demonstrates a 32 bit subtraction using the
16 bit registers on the 8086: </font></p>

<pre><font face="Courier New" size="2">var1            dword   ?
var2            dword   ?
diff            dword   ?

                mov     ax, word ptr var1
                sub     ax, word ptr var2
                mov     word ptr diff, ax
                mov     ax, word ptr var1+2
                sbb     ax, word ptr var2+2
                mov     word ptr diff+2, ax</font></pre>

<p><font face="Arial" size="2">The following example demonstrates a 128-bit subtraction
using the 80386 32 bit register set: </font></p>

<pre><font face="Courier New" size="2">BigVal1         dword   0,0,0,0         ;Four double words in 128 bits!
BigVal2         dword   0,0,0,0
BigVal3         dword   0,0,0,0
                .
                .
                .
                mov     eax, BigVal1    ;No need for dword ptr operator since
                sub     eax, BigVal2    ; these are dword variables.
                mov     BigVal3, eax

                mov     eax, BigVal1+4  ;Subtract the values from the L.O.
                sbb     eax, BigVal2+4  ; entity to the H.O. entity using
                mov     BigVal3+4, eax  ; the SUB and SBB instructions.

                mov     eax, BigVal1+8
                sbb     eax, BigVal2+8
                mov     BigVal3+8, eax

                mov     eax, BigVal1+12
                sbb     eax, BigVal2+12
                mov     BigVal3+12, eax</font></pre>

<h3><font face="Arial" size="3">9.3.3 Extended Precision Comparisons</font></h3>

<p><font face="Arial" size="2">Unfortunately, there isn't a &quot;compare with
borrow&quot; instruction that can be used to perform extended precision comparisons. Since
the <code>cmp </code>and <code>sub </code>instructions perform the same operation, at
least as far as the flags are concerned, you'd probably guess that you could use the <code>sbb
</code>instruction to synthesize an extended precision comparison; however, you'd only be
partly right. There is, however, a better way.</font></p>

<p><font face="Arial" size="2">Consider the two unsigned values 2157h and 1293h. The L.O.
bytes of these two values do not affect the outcome of the comparison. Simply comparing
21h with 12h tells us that the first value is greater than the second. In fact, the only
time you ever need to look at both bytes of these values is if the H.O. bytes are equal.
In all other cases comparing the H.O. bytes tells you everything you need to know about
the values. Of course, this is true for any number of bytes, not just two. The following
code compares two signed 64 bit integers on an 80386 or later processor: </font></p>

<pre><font face="Courier New" size="2">; This sequence transfers control to location &quot;IsGreater&quot; if
; QwordValue &gt; QwordValue2. It transfers control to &quot;IsLess&quot; if
; QwordValue &lt; QwordValue2. It falls though to the instruction
; following this sequence if QwordValue = QwordValue2. To test for
; inequality, change the &quot;IsGreater&quot; and &quot;IsLess&quot; operands to &quot;NotEqual&quot;
; in this code.

                mov     eax, dword ptr QWordValue+4                             ;Get H.O. dword
                cmp     eax, dword ptr QWordValue2+4
                jg      IsGreater
                jl      IsLess
                mov     eax, dword ptr QWordValue
                cmp     eax, dword ptr QWordValue2
                jg      IsGreater
                jl      IsLess</font></pre>

<p><font face="Arial" size="2">To compare unsigned values, simply use the ja and jb
instructions in place of jg and jl.</font></p>

<p><font face="Arial" size="2">You can easily synthesize any possible comparison from the
sequence above, the following examples show how to do this. These examples do signed
comparisons, substitute ja, jae, jb, and jbe for jg, jge, jl, and jle (respectively) to do
unsigned comparisons. </font></p>

<pre><font face="Courier New" size="2">QW1             qword   ?
QW2             qword   ?

dp              textequ &lt;dword ptr&gt;

; 64 bit test to see if QW1 &lt; QW2 (signed).
; Control transfers to &quot;IsLess&quot; label if QW1 &lt; QW2. Control falls
; through to the next statement if this is not true.

                mov     eax, dp QW1+4           ;Get H.O. dword
                cmp     eax, dp QW2+4
                jg      NotLess
                jl      IsLess
                mov     eax, dp QW1             ;Fall through to here if H.O. 
                cmp     eax, dp QW2             ; dwords are equal.
                jl      IsLess
NotLess:

; 64 bit test to see if QW1 &lt;= QW2 (signed).

                mov     eax, dp QW1+4           ;Get H.O. dword
                cmp     eax, dp QW2+4
                jg      NotLessEq
                jl      IsLessEq
                mov     eax, dp QW1
                cmp     eax, dword ptr QW2
                jle     IsLessEq
NotLessEQ:

; 64 bit test to see if QW1 &gt;QW2 (signed).

                mov     eax, dp QW1+4           ;Get H.O. dword
                cmp     eax, dp QW2+4
                jg      IsGtr
                jl      NotGtr
                mov     eax, dp QW1             ;Fall through to here if H.O. 
                cmp     eax, dp QW2             ; dwords are equal.
                jg      IsGtr
NotGtr:

; 64 bit test to see if QW1 &gt;= QW2 (signed).

                mov     eax, dp QW1+4           ;Get H.O. dword
                cmp     eax, dp QW2+4
                jg      IsGtrEq
                jl      NotGtrEq
                mov     eax, dp QW1
                cmp     eax, dword ptr QW2
                jge     IsGtrEq
NotGtrEq:

; 64 bit test to see if QW1 = QW2 (signed or unsigned). This code branches
; to the label &quot;IsEqual&quot; if QW1 = QW2. It falls through to the next instruction
; if they are not equal.

                mov     eax, dp QW1+4           ;Get H.O. dword
                cmp     eax, dp QW2+4
                jne     NotEqual
                mov     eax, dp QW1
                cmp     eax, dword ptr QW2
                je      IsEqual
NotEqual:

; 64 bit test to see if QW1 &lt;&gt; QW2 (signed or unsigned). This code branches
; to the label &quot;NotEqual&quot; if QW1 &lt;&gt; QW2. It falls through to the next 
; instruction if they are equal.

                mov     eax, dp QW1+4           ;Get H.O. dword
                cmp     eax, dp QW2+4
                jne     NotEqual
                mov     eax, dp QW1
                cmp     eax, dword ptr QW2
                jne     NotEqual</font></pre>

<hr noshade size="1" color="#000000">

<p><font face="Arial" size="2"><a NAME="FOOTNOTE-1"></a><strong>[1]</strong> As usual, 32
bit arithmetic is available only on the 80386 and later processors.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH09-2.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH09-2.html">Chapter Nine</a> (Part 2)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH09-4.html">Chapter Nine</a> (Part 4) </strong></font><a href="CH09-4.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Nine: Arithmetic And Logical
Operations (Part 3)<br>
27 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_9/CH09-3.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:41 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
