<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_9/CH09-6.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:54 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER NINE: ARITHMETIC AND LOGICAL OPERATIONS (Part 6)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING6"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH09-5.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH09-5.html">Chapter Nine</a> (Part 5)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH09-7.html">Chapter Nine</a> (Part 7) </strong></font><a href="CH09-7.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10" colspan="2"><a NAME="HEADING6-1"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0" colspan="2"><font face="Arial" size="4"><strong>CHAPTER
    NINE:<br>
    ARITHMETIC AND LOGICAL OPERATIONS (Part 6)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10" colspan="2"></td>
  </tr>
  <tr>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING6-1"><b>9.5 </b>-
    Machine and Arithmetic Idioms</a> <br>
    <a HREF="#HEADING6-3"><b>9.5.1 </b>- Multiplying Without MUL and IMUL</a> <br>
    <a HREF="#HEADING6-39"><b>9.5.2 </b>- Division Without DIV and IDIV</a> <br>
    <a HREF="#HEADING6-49"><b>9.5.3 </b>- Using AND to Compute Remainders</a> </font></td>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING6-64"><b>9.5.4 </b>-
    Implementing Modulo-n Counters with AND</a> <br>
    <a HREF="#HEADING6-72"><b>9.5.5 </b>- Testing an Extended Precision Value for 0FFFF..FFh</a>
    <br>
    <a HREF="#HEADING6-83"><b>9.5.6 </b>- TEST Operations</a> <br>
    <a HREF="#HEADING6-106"><b>9.5.7 </b>- Testing Signs with the XOR Instruction</a> </font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="20" colspan="2"></td>
  </tr>
  <tr>
    <td width="100%" colspan="2"><strong><font face="Arial" size="3">9.5 Machine and
    Arithmetic Idioms</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="1" colspan="2" bgcolor="#000000"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">An idiom is an idiosyncrasy. Several arithmetic operations
and 80x86 instructions have idiosyncracies that you can take advantage of when writing
assembly language code. Some people refer to the use of machine and arithmetic idioms as
&quot;tricky programming&quot; that you should always avoid in well written programs.
While it is wise to avoid tricks just for the sake of tricks, many machine and arithmetic
idioms are well-known and commonly found in assembly language programs. Some of them can
be really tricky, but a good number of them are simply &quot;tricks of the trade.&quot;
This text cannot even begin to present all of the idioms in common use today; they are too
numerous and the list is constantly changing. Nevertheless, there are some very important
idioms that you will see all the time, so it makes sense to discuss those.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING6-3"></a>9.5.1 Multiplying Without
MUL and IMUL</font></strong></p>

<p><font face="Arial" size="2">If you take a quick look at the timing for the multiply
instruction, you'll notice that the execution time for this instruction is rather long.
Only the <code>div </code>and <code>idiv </code>instructions take longer on the 8086. When
multiplying by a constant, you can avoid the performance penalty of the <code>mul </code>and
<code>imul </code>instructions by using shifts, additions, and subtractions to perform the
multiplication. </font></p>

<p><font face="Arial" size="2">Remember, a <code>shl </code>operation performs the same
operation as multiplying the specified operand by two. Shifting to the left two bit
positions multiplies the operand by four. Shifting to the left three bit positions
multiplies the operand by eight. In general, shifting an operand to the left n bits
multiplies it by 2n. Any value can be multiplied by some constant using a series of shifts
and adds or shifts and subtractions. For example, to multiply the <code>ax </code>register
by ten, you need only multiply it by eight and then add in two times the original value.
That is, <code>10*ax = 8*ax + 2*ax</code>. The code to accomplish this is </font></p>

<pre><font face="Courier New" size="2">                shl     ax, 1           ;Multiply AX by two
                mov     bx, ax          ;Save 2*AX for later
                shl     ax, 1           ;Multiply AX by four
                shl     ax, 1           ;Multiply AX by eight
                add     ax, bx          ;Add in 2*AX to get 10*AX</font></pre>

<p><font face="Arial" size="2">The <code>ax </code>register (or just about any register,
for that matter) can be multiplied by most constant values much faster using <code>shl </code>than
by using the <code>mul </code>instruction. This may seem hard to believe since it only
takes two instructions to compute this product: </font></p>

<pre><font face="Courier New" size="2">                mov     bx, 10
                mul     bx</font></pre>

<p><font face="Arial" size="2">However, if you look at the timings, the shift and add
example above requires fewer clock cycles on most processors in the 80x86 family than the <code>mul
</code>instruction. Of course, the code is somewhat larger (by a few bytes), but the
performance improvement is usually worth it. Of course, on the later 80x86 processors, the
<code>mul </code>instruction is quite a bit faster than the earlier processors, but the
shift and add scheme is generally faster on these processors as well.</font></p>

<p><font face="Arial" size="2">You can also use subtraction with shifts to perform a
multiplication operation. Consider the following multiplication by seven: </font></p>

<pre><font face="Courier New" size="2">                mov     bx, ax          ;Save AX*1
                shl     ax, 1           ;AX := AX*2
                shl     ax, 1           ;AX := AX*4
                shl     ax, 1           ;AX := AX*8
                sub     ax, bx          ;AX := AX*7</font></pre>

<p><font face="Arial" size="2">This follows directly from the fact that <code>ax*7 =
(ax*8)-ax</code>.</font></p>

<p><font face="Arial" size="2">A common error made by beginning assembly language students
is subtracting or adding one or two rather than <code>ax*1</code> or <code>ax*2</code>.
The following does not compute <code>ax*7</code>: </font></p>

<pre><font face="Courier New" size="2">                shl     ax, 1
                shl     ax, 1
                shl     ax, 1
                sub     ax, 1</font></pre>

<p><font face="Arial" size="2">It computes (8*ax)-1, something entirely different (unless,
of course, ax = 1). Beware of this pitfall when using shifts, additions, and subtractions
to perform multiplication operations.</font></p>

<p><font face="Arial" size="2">You can also use the lea instruction to compute certain
products on 80386 and later processors. The trick is to use the 80386 scaled index mode.
The following examples demonstrate some simple cases: </font></p>

<pre><font face="Courier New" size="2">                lea     eax, [ecx][ecx]         ;EAX := ECX * 2
                lea     eax, [eax]eax*2]        ;EAX := EAX * 3
                lea     eax, [eax*4]            ;EAX := EAX * 4
                lea     eax, [ebx][ebx*4]       ;EAX := EBX * 5
                lea     eax, [eax*8]            ;EAX := EAX * 8
                lea     eax, [edx][edx*8]       ;EAX := EDX * 9</font></pre>

<h3><a name="HEADING6-39"></a><strong><font face="Arial" size="3">9.5.2 Division Without
DIV and IDIV</font></strong></h3>

<p><font face="Arial" size="2">Much as the <code>shl </code>instruction can be used for
simulating a multiplication by some power of two, the <code>shr </code>and <code>sar </code>instructions
can be used to simulate a division by a power of two. Unfortunately, you cannot use
shifts, additions, and subtractions to perform a division by an arbitrary constant as
easily as you can use these instructions to perform a multiplication operation. </font></p>

<p><font face="Arial" size="2">Another way to perform division is to use the multiply
instructions. You can divide by some value by multiplying by its reciprocal. The multiply
instruction is marginally faster than the divide instruction; multiplying by a reciprocal
is almost always faster than division.</font></p>

<p><font face="Arial" size="2">Now you're probably wondering &quot;how does one multiply
by a reciprocal when the values we're dealing with are all integers?&quot; The answer, of
course, is that we must cheat to do this. If you want to multiply by one tenth, there is
no way you can load the value 1/10th into an 80x86 register prior to performing the
division. However, we could multiply 1/10th by 10, perform the multiplication, and then
divide the result by ten to get the final result. Of course, this wouldn't buy you
anything at all, in fact it would make things worse since you're now doing a
multiplication by ten as well as a division by ten. However, suppose you multiply 1/10th
by 65,536 (6553), perform the multiplication, and then divide by 65,536. This would still
perform the correct operation and, as it turns out, if you set up the problem correctly,
you can get the division operation for free. Consider the following code that divides <code>ax
</code>by ten: </font></p>

<pre><font face="Courier New" size="2">                mov     dx, 6554        ;Round (65,536/10)
                mul     dx</font></pre>

<p><font face="Arial" size="2">This code leaves <code>ax</code>/10 in the <code>dx </code>register.
</font></p>

<p><font face="Arial" size="2">To understand how this works, consider what happens when
you multiply <code>ax </code>by 65,536 (10000h). This simply moves <code>ax </code>into <code>dx
</code>and sets <code>ax </code>to zero. Multiplying by 6,554 (65,536 divided by ten) puts
<code>ax </code>divided by ten into the <code>dx </code>register. Since <code>mul </code>is
marginally faster than <code>div </code>, this technique runs a little faster than using a
straight division.</font></p>

<p><font face="Arial" size="2">Multiplying by the reciprocal works well when you need to
divide by a constant. You could even use it to divide by a variable, but the overhead to
compute the reciprocal only pays off if you perform the division many, many times (by the
same value).</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING6-49"></a>9.5.3 Using AND to
Compute Remainders</font></strong></p>

<p><font face="Arial" size="2">The <code>and </code>instruction can be used to quickly
compute remainders of the form: </font></p>

<pre><font face="Courier New" size="2">		dest := dest MOD 2n</font></pre>

<p><font face="Arial" size="2">To compute a remainder using the <code>and </code>instruction,
simply and the operand with the value 2n-1. For example, to compute <code>ax = ax mod 8 </code>simply
use the instruction: </font></p>

<pre><font face="Courier New" size="2">                and     ax, 7</font></pre>

<p><font face="Arial" size="2">Additional examples: </font></p>

<pre><font face="Courier New" size="2">                and     ax, 3           ;AX := AX mod 4
                and     ax, 0Fh         ;AX := AX mod 16
                and     ax, 1Fh         ;AX := AX mod 32
                and     ax, 3Fh         ;AX := AX mod 64
                and     ax, 7Fh         ;AX := AX mod 128
                mov     ah, 0           ;AX := AX mod 256
                                        ; (Same as ax and 0FFh)</font></pre>

<h3><strong><font face="Arial" size="3"><a name="HEADING6-64"></a>9.5.4 Implementing
Modulo-n Counters with AND</font></strong></h3>

<p><font face="Arial" size="2">If you want to implement a counter variable that counts up
to 2n-1 and then resets to zero, simply using the following code: </font></p>

<pre><font face="Courier New" size="2">                inc     CounterVar
                and     CounterVar, nBits</font></pre>

<p><font face="Arial" size="2">where nBits is a binary value containing n one bits right
justified in the number. For example, to create a counter that cycles between zero and
fifteen, you could use the following: </font></p>

<pre><font face="Courier New" size="2">                inc     CounterVar
                and     CounterVar, 00001111b</font></pre>

<h3><strong><font face="Arial" size="3"><a name="HEADING6-72"></a>9.5.5 Testing an
Extended Precision Value for 0FFFF..FFh</font></strong></h3>

<p><font face="Arial" size="2">The <code>and </code>instruction can be used to quickly
check a multi-word value to see if it contains ones in all its bit positions. Simply load
the first word into the <code>ax </code>register and then logically and the <code>ax </code>register
with all the remaining words in the data structure. When the and operation is complete,
the <code>ax </code>register will contain 0FFFFh if and only if all the words in that
structure contained 0FFFFh. E.g.,</font> </p>

<pre><font face="Courier New" size="2">                mov     ax, word ptr var
                and     ax, word ptr var+2
                and     ax, word ptr var+4
                 . 
                 . 
                 . 
                and     ax, word ptr var+n
                cmp     ax, 0FFFFh
                je      Is0FFFFh</font></pre>

<h3><strong><font face="Arial" size="3"><a name="HEADING6-83"></a>9.5.6 TEST Operations</font></strong></h3>

<p><font face="Arial" size="2">Remember, the <code>test </code>instruction is an <code>and
</code>instruction that doesn't retain the results of the and operation (other than the
flag settings). Therefore, many of the comments concerning the and operation (particularly
with respect to the way it affects the flags) also hold for the <code>test </code>instruction.
However, since the <code>test </code>instruction doesn't affect the destination operand,
multiple bit tests may be performed on the same value. Consider the following code: </font></p>

<pre><font face="Courier New" size="2">                test    ax, 1 
                jnz     Bit0 
                test    ax, 2
                jnz     Bit1
                test    ax, 4
                jnz     Bit3
                etc.</font></pre>

<p><font face="Arial" size="2">This code can be used to successively test each bit in the <code>ax
</code>register (or any other operand for that matter). Note that you cannot use the <code>test/cmp
</code>instruction pair to test for a specific value within a string of bits (as you can
with the <code>and/cmp </code>instructions). Since <code>test </code>doesn't strip out any
unwanted bits, the <code>cmp </code>instruction would actually be comparing the original
value rather than the stripped value. For this reason, you'll normally use the <code>test </code>instruction
to see if a single bit is set or if one or more bits out of a group of bits are set. Of
course, if you have an 80386 or later processor, you can also use the <code>bt</code>
instruction to test individual bits in an operand.</font></p>

<p><font face="Arial" size="2">Another important use of the <code>test </code>instruction
is to efficiently compare a register against zero. The following test instruction sets the
zero flag if and only if <code>ax </code>contains zero (anything anded with itself
produces its original value; this sets the zero flag only if that value is zero): </font></p>

<pre><font face="Courier New" size="2">                test ax, ax </font></pre>

<p><font face="Arial" size="2">The test instruction is shorter than </font></p>

<pre><font face="Courier New" size="2">                cmp     ax, 0 
</font><font face="Arial" size="2">or </font></pre>

<pre><font face="Courier New" size="2">                cmp     eax, 0 </font></pre>

<p><font face="Arial" size="2">though it is no better than </font></p>

<pre><font face="Courier New" size="2">                cmp     al, 0</font></pre>

<p><font face="Arial" size="2">Note that you can use the <code>and </code>and <code>or </code>instructions
to test for zero in a fashion identical to <code>test</code>. However, on pipelined
processors like the 80486 and Pentium chips, the <code>test </code>instruction is less
likely to create a hazard since it does not store a result back into its destination
register.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING6-106"></a>9.5.7 Testing Signs with
the XOR Instruction</font></strong></p>

<p><font face="Arial" size="2">Remember the pain associated with a multi-precision signed
multiplication operation? You need to determine the sign of the result, take the absolute
value of the operands, multiply them, and then adjust the sign of the result as determined
before the multiplication operation. The sign of the product of two numbers is simply the
exclusive-or of their signs before performing the multiplication. Therefore, you can use
the <code>xor </code>instruction to determine the sign of the product of two extended
precision numbers. E.g.,</font> </p>

<pre><font face="Courier New" size="2">32x32 Multiply:
                mov     al, byte ptr Oprnd1+3
                xor     al, byte ptr Oprnd2+3
                mov     cl, al                  ;Save sign

; Do the multiplication here (don't forget to take the absolute
; value of the two operands before performing the multiply).

                 .
                 .
                 .

; Now fix the sign.

                cmp     cl, 0                   ;Check sign bit
                jns     ResultIsPos

; Negate the product here.

                 .
                 .
                 .

ResultIsPos:</font></pre>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH09-5.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH09-5.html">Chapter Nine</a> (Part 5)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH09-7.html">Chapter Nine</a> (Part 7) </strong></font><a href="CH09-7.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Nine: Arithmetic And Logical
Operations (Part 6)<br>
27 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_9/CH09-6.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:54 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
