<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_9/CH09-1.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:38 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER NINE: ARITHMETIC AND LOGICAL OPERATIONS (Part 1)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING1"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="../Chapter_8/CH08-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="../Chapter_8/CH08-1.html">Chapter
    Eight</a></strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH09-2.html">Chapter Nine</a> (Part 2) </strong></font><a href="CH09-2.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3" bgcolor="#FFFFFF" nowrap height="10"><a NAME="HEADING1-0"></a></td>
  </tr>
  <tr>
    <td width="100%" colspan="3" bgcolor="#F0F0F0"><font face="Arial" size="4"><strong>CHAPTER
    NINE:<br>
    ARITHMETIC AND LOGICAL OPERATIONS (Part 1)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" colspan="3" nowrap height="10"></td>
  </tr>
  <tr>
    <td width="40%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING1-2"><b>9.0 </b>-
    Chapter Overview</a> <br>
    <a HREF="#HEADING1-34"><b>9.1 </b>- Arithmetic Expressions</a> <br>
    <a HREF="#HEADING1-45"><b>9.1.1 </b>- Simple Assignments</a> <br>
    <a HREF="#HEADING1-64"><b>9.1.2 </b>- Simple Expressions</a> <br>
    <a HREF="#HEADING1-154"><b>9.1.3 </b>- Complex Expressions</a> <br>
    <a HREF="#HEADING1-309"><b>9.1.4 </b>- Commutative Operators</a> <br>
    <a HREF="CH09-2.html#HEADING2-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH09/CH09-2.html#HEADING2-1"><b>9.2 </b>-
    Logical (Boolean) Expressions</a> <br>
    <a HREF="CH09-3.html#HEADING3-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH09/CH09-3.html#HEADING3-1"><b>9.3 </b>-
    Multiprecision Operations</a> <br>
    <a HREF="CH09-3.html#HEADING3-3" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH09/CH09-3.html#HEADING3-3"><b>9.3.1 </b>-
    Multiprecision Addition Operations </a><br>
    <a HREF="CH09-3.html#HEADING3-65" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH09/CH09-3.html#HEADING3-65"><b>9.3.2
    </b>- Multiprecision Subtraction Operations</a> <br>
    <a HREF="CH09-3.html#HEADING3-100" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH09/CH09-3.html#HEADING3-100"><b>9.3.3
    </b>- Extended Precision Comparisons</a> <br>
    <a HREF="CH09-4.html#HEADING4-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH09/CH09-4.html#HEADING4-1"><b>9.3.4 </b>-
    Extended Precision Multiplication</a> <br>
    <a HREF="CH09-4.html#HEADING4-99" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH09/CH09-4.html#HEADING4-99"><b>9.3.5
    </b>- Extended Precision Division</a> <br>
    <a HREF="CH09-5.html#HEADING5-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH09/CH09-5.html#HEADING5-1"><b>9.3.6 </b>-
    Extended Precision NEG Operations</a> <br>
    <a HREF="CH09-5.html#HEADING5-44" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH09/CH09-5.html#HEADING5-44"><b>9.3.7
    </b>- Extended Precision AND Operations</a> <br>
    <a HREF="CH09-5.html#HEADING5-54" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH09/CH09-5.html#HEADING5-54"><b>9.3.8
    </b>- Extended Precision OR Operations</a> <br>
    <a HREF="CH09-5.html#HEADING5-65" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH09/CH09-5.html#HEADING5-65"><b>9.3.9
    </b>- Extended Precision XOR Operations</a> <br>
    <a HREF="CH09-5.html#HEADING5-73" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH09/CH09-5.html#HEADING5-73"><b>9.3.10
    </b>- Extended Precision NOT Operations</a> <br>
    <a HREF="CH09-5.html#HEADING5-79" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH09/CH09-5.html#HEADING5-79"><b>9.3.11
    </b>- Extended Precision Shift Operations</a> <br>
    <a HREF="CH09-5.html#HEADING5-128" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH09/CH09-5.html#HEADING5-128"><b>9.3.12
    </b>- Extended Precision Rotate Operations</a> <br>
    <a HREF="CH09-5.html#HEADING5-148" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH09/CH09-5.html#HEADING5-148"><b>9.4 </b>-
    Operating on Different Sized Operands</a> <br>
    <a HREF="CH09-6.html#HEADING6-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH09/CH09-6.html#HEADING6-1"><b>9.5 </b>-
    Machine and Arithmetic Idioms</a> <br>
    <a HREF="CH09-6.html#HEADING6-3" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH09/CH09-6.html#HEADING6-3"><b>9.5.1 </b>-
    Multiplying Without MUL and IMUL</a> <br>
    <a HREF="CH09-6.html#HEADING6-39" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH09/CH09-6.html#HEADING6-39"><b>9.5.2
    </b>- Division Without DIV and IDIV</a> <br>
    <a HREF="CH09-6.html#HEADING6-49" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH09/CH09-6.html#HEADING6-49"><b>9.5.3
    </b>- Using AND to Compute Remainders</a> <br>
    <a HREF="CH09-6.html#HEADING6-64" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH09/CH09-6.html#HEADING6-64"><b>9.5.4
    </b>- Implementing Modulo-n Counters with AND</a> <br>
    <a HREF="CH09-6.html#HEADING6-72" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH09/CH09-6.html#HEADING6-72"><b>9.5.5
    </b>- Testing an Extended Precision Value for 0FFFF..FFh</a> <br>
    <a HREF="CH09-6.html#HEADING6-83" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH09/CH09-6.html#HEADING6-83"><b>9.5.6
    </b>- TEST Operations</a> <br>
    <a HREF="CH09-6.html#HEADING6-106" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH09/CH09-6.html#HEADING6-106"><b>9.5.7
    </b>- Testing Signs with the XOR Instruction</a> <br>
    <a HREF="CH09-7.html#HEADING7-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH09/CH09-7.html#HEADING7-1"><b>9.6 </b>-
    Masking Operations</a> <br>
    <a HREF="CH09-7.html#HEADING7-3" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH09/CH09-7.html#HEADING7-3"><b>9.6.1 </b>-
    Masking Operations with the AND Instruction</a> <br>
    <a HREF="CH09-7.html#HEADING7-6" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH09/CH09-7.html#HEADING7-6"><b>9.6.2 </b>-
    Masking Operations with the OR Instruction</a> <br>
    <a HREF="CH09-7.html#HEADING7-9" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH09/CH09-7.html#HEADING7-9"><b>9.7 </b>-
    Packing and Unpacking Data Types</a> <br>
    <a HREF="CH09-7.html#HEADING7-65" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH09/CH09-7.html#HEADING7-65"><b>9.8 </b>-
    Tables</a> <br>
    <a HREF="CH09-7.html#HEADING7-68" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH09/CH09-7.html#HEADING7-68"><b>9.8.1
    </b>- Function Computation via Table Look Up</a> <br>
    <a HREF="CH09-7.html#HEADING7-162" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH09/CH09-7.html#HEADING7-162"><b>9.8.2
    </b>- Domain Conditioning</a> <br>
    <a HREF="CH09-7.html#HEADING7-190" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH09/CH09-7.html#HEADING7-190"><b>9.8.3
    </b>- Generating Tables</a> <br>
    <a HREF="CH09-8.html#HEADING8-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH09/CH09-8.html#HEADING8-1"><b>9.9 </b>-
    Sample Programs</a> <br>
    <a HREF="CH09-8.html#HEADING8-3" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH09/CH09-8.html#HEADING8-3"><b>9.9.1 </b>-
    Converting Arithmetic Expressions to Assembly Language</a> <br>
    <a HREF="CH09-8.html#HEADING8-151" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH09/CH09-8.html#HEADING8-151"><b>9.9.2
    </b>- Boolean Operations Example</a> <br>
    <a HREF="CH09-8.html#HEADING8-327" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH09/CH09-8.html#HEADING8-327"><b>9.9.3
    </b>- 64-bit Integer I/O</a> <br>
    <a HREF="CH09-8.html#HEADING8-558" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH09/CH09-8.html#HEADING8-558"><b>9.9.4
    </b>- Packing and Unpacking Date Data Types</a> </font></td>
    <td width="20" nowrap valign="top"></td>
    <td width="60%" valign="top"><font size="1" face="Arial">Copyright 1996 by Randall Hyde
    All rights reserved. <br>
    <br>
    Duplication other than for immediate display through a browser is prohibited by U.S.
    Copyright Law. <br>
    This material is provided on-line as a beta-test of this text. It is for the personal use
    of the reader only. If you are interested in using this material as part of a course,
    please contact rhyde@cs.ucr.edu <br>
    <br>
    Supporting software and other materials are available via anonymous ftp from
    ftp.cs.ucr.edu. See the &quot;/pub/pc/ibmpcdir&quot; directory for details. You may also
    download the material from &quot;Randall Hyde's Assembly Language Page&quot; at URL:
    http://webster.ucr.edu<br>
    <br>
    Notes: <br>
    This document does not contain the laboratory exercises, programming assignments,
    exercises, or chapter summary. These portions were omitted for several reasons: either
    they wouldn't format properly, they contained hyperlinks that were too much work to
    resolve, they were under constant revision, or they were not included for security
    reasons. Such omission should have very little impact on the reader interested in learning
    this material or evaluating this document. <br>
    <br>
    This document was prepared using Harlequin's Web Maker 2.2 and Quadralay's Webworks
    Publisher. Since HTML does not support the rich formatting options available in
    Framemaker, this document is only an approximation of the actual chapter from the
    textbook. <br>
    <br>
    If you are absolutely dying to get your hands on a version other than HTML, you might
    consider having the UCR Printing a Reprographics Department run you off a copy on their
    Xerox machines. For details, please read the following EMAIL message I received from the
    Printing and Reprographics Department: </font><blockquote>
      <p><font size="1" face="Arial">Hello Again Professor Hyde,<br>
      <br>
      Dallas gave me permission to take orders for the Computer Science 13 Manuals. We would
      need to take charge card orders. The only cards we take are: Master Card, Visa, and
      Discover. They would need to send the name, numbers, expiration date, type of card, and
      authorization to charge $95.00 for the manual and shipping, also we should have their
      phone number in case the company has any trouble delivery. They can use my e-mail address
      for the orders and I will process them as soon as possible. I would assume that two weeks
      would be sufficient for printing, packages and delivery time.<br>
      <br>
      I am open to suggestions if you can think of any to make this as easy as possible.<br>
      <br>
      Thank You for your business,<br>
      Kathy Chapman, Assistant<br>
      Printing and Reprographics University of California Riverside (909) 787-4443/4444 </font></p>
    </blockquote>
    <p><font size="1" face="Arial">We are currently working on ways to publish this text in a
    form other than HTML (e.g., Postscript, PDF, Frameviewer, hard copy, etc.). This, however,
    is a low-priority project. Please do not contact Randall Hyde concerning this effort. When
    something happens, an announcement will appear on &quot;Randall Hyde's Assembly Language
    Page.&quot; Please visit this WEB site at http://webster.ucr.edu for the latest scoop.</font></p>
    <p><font size="1" face="Arial">Redesigned 10/2000 with &quot;MS FrontPage 98&quot; using
    17&quot; monitor 1024x768<br>
    (c)&nbsp; 2000 <a href="mail%20to_%20bircom_yanoo.html">BIRCOM Entertainment'95</a></font></td>
  </tr>
</table>
</center></div>

<hr noshade size="1" color="#000000">

<p><font face="Arial" size="2">There is a lot more to assembly language than knowing the
operations of a handful of machine instructions. You've got to know how to use them and
what they can do. Many instructions are useful for operations that have little to do with
their mathematical or obvious functions. This chapter discusses how to convert expressions
from a high level language into assembly language. It also discusses advanced arithmetic
and logical operations including multiprecision operations and tricks you can play with
various instructions.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING1-2"></a>9.0 Chapter
    Overview</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">This chapter discusses six main subjects: converting HLL
arithmetic expressions into assembly language, logical expressions, extended precision
arithmetic and logical operations, operating on different sized operands, machine and
arithmetic idioms, and masking operations. Like the preceding chapters, this chapter
contains considerable material that you may need to learn immediately if you're a
beginning assembly language programmer. The sections below that have a &quot;*&quot;
prefix are essential. Those sections with a &quot;o&quot; discuss advanced topics that you
may want to put off for a while. </font>

<dl>
  <dd><font face="Arial" size="2">* Arithmetic expressions </font></dd>
  <dd><font face="Arial" size="2">* Simple assignments </font></dd>
  <dd><font face="Arial" size="2">* Simple expressions </font></dd>
  <dd><font face="Arial" size="2">* Complex expressions </font></dd>
  <dd><font face="Arial" size="2">* Commutative operators </font></dd>
  <dd><font face="Arial" size="2">* Logical expressions </font></dd>
  <dd><font face="Arial" size="2">* Multiprecision operations </font></dd>
  <dd><font face="Arial" size="2">* Multiprecision addition operations </font></dd>
  <dd><font face="Arial" size="2">* Multiprecision subtraction operations </font></dd>
  <dd><font face="Arial" size="2">* Extended precision comparisons </font></dd>
  <dd><font face="Arial" size="2">&nbsp;&nbsp;&nbsp; o Extended precision multiplication </font></dd>
  <dd><font face="Arial" size="2">&nbsp;&nbsp;&nbsp; o Extended precision division </font></dd>
  <dd><font face="Arial" size="2">&nbsp;&nbsp;&nbsp; o Extended precision negation </font></dd>
  <dd><font face="Arial" size="2">* Extended precision AND, OR, XOR, and NOT </font></dd>
  <dd><font face="Arial" size="2">&nbsp;&nbsp;&nbsp; o Extended precision shift and rotate
    operations </font></dd>
  <dd><font face="Arial" size="2">&nbsp;&nbsp;&nbsp; o Operating on different sized operands </font></dd>
  <dd><font face="Arial" size="2">* Multiplying without MUL and IMUL </font></dd>
  <dd><font face="Arial" size="2">&nbsp;&nbsp;&nbsp; o Division without DIV and IDIV </font></dd>
  <dd><font face="Arial" size="2">&nbsp;&nbsp;&nbsp; o Using AND to compute remainders </font></dd>
  <dd><font face="Arial" size="2">&nbsp;&nbsp;&nbsp; o Modulo-n Counters with AND </font></dd>
  <dd><font face="Arial" size="2">&nbsp;&nbsp;&nbsp; o Testing for 0FFFFF...FFFh </font></dd>
  <dd><font face="Arial" size="2">* Test operations </font></dd>
  <dd><font face="Arial" size="2">&nbsp;&nbsp;&nbsp; o Testing signs with the XOR instructions
    </font></dd>
  <dd><font face="Arial" size="2">&nbsp;&nbsp;&nbsp; o Masking operations </font></dd>
  <dd><font face="Arial" size="2">&nbsp;&nbsp;&nbsp; o Masking with the AND instructions </font></dd>
  <dd><font face="Arial" size="2">&nbsp;&nbsp;&nbsp; o Masking with the OR instruction </font></dd>
  <dd><font face="Arial" size="2">&nbsp;&nbsp;&nbsp; o Packing and unpacking data types </font></dd>
  <dd><font face="Arial" size="2">&nbsp;&nbsp;&nbsp; o Table lookups </font></dd>
</dl>

<p><font face="Arial" size="2">None of this material is particularly difficult to
understand. However, there are a lot of new topics here and taking them a few at a time
will certain help you absorb the material better. Those topics with the &quot;*&quot;
prefix are ones you will frequently use; hence it is a good idea to study these first.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING1-34"></a>9.1
    Arithmetic Expressions</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">Probably the biggest shock to beginners facing assembly
language for the very first time is the lack of familiar arithmetic expressions.
Arithmetic expressions, in most high level languages, look similar to their algebraic
equivalents: </font></p>

<pre><font face="Courier New" size="2">		X:=Y*Z;</font></pre>

<p><font face="Arial" size="2">In assembly language, you'll need several statements to
accomplish this same task, e.g., </font></p>

<pre><font face="Courier New" size="2">                mov     ax, y
                imul    z
                mov     x, ax</font></pre>

<p><font face="Arial" size="2">Obviously the HLL version is much easier to type, read, and
understand. This point, more than any other, is responsible for scaring people away from
assembly language. </font></p>

<p><font face="Arial" size="2">Although there is a lot of typing involved, converting an
arithmetic expression into assembly language isn't difficult at all. By attacking the
problem in steps, the same way you would solve the problem by hand, you can easily break
down any arithmetic expression into an equivalent sequence of assembly language
statements. By learning how to convert such expressions to assembly language in three
steps, you'll discover there is little difficulty to this task.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING1-45"></a>9.1.1 Simple Assignments</font></strong></p>

<p><font face="Arial" size="2">The easiest expressions to convert to assembly language are
the simple assignments. Simple assignments copy a single value into a variable and take
one of two forms: </font></p>

<pre><font face="Courier New" size="2">		variable := constant </font></pre>

<p><font face="Arial" size="2">or </font></p>

<pre><font face="Courier New" size="2">		variable := variable</font></pre>

<p><font face="Arial" size="2">If variable appears in the current data segment (e.g., <code>DSEG</code>),
converting the first form to assembly language is easy, just use the assembly language
statement: </font></p>

<pre><font face="Courier New" size="2">                  mov    variable, constant</font></pre>

<p><font face="Arial" size="2">This move immediate instruction copies the constant into
the variable.</font></p>

<p><font face="Arial" size="2">The second assignment above is somewhat complicated since
the 80x86 doesn't provide a memory-to-memory <code>mov </code>instruction. Therefore, to
copy one memory variable into another, you must move the data through a register. If
you'll look at the encoding for the <code>mov </code>instruction in the appendix, you'll
notice that the <code>mov ax, memory</code> and <code>mov memory, ax </code>instructions
are shorter than moves involving other registers. Therefore, if the <code>ax</code>
register is available, you should use it for this operation. For example, </font></p>

<pre><font face="Courier New" size="2">		var1 := var2; </font></pre>

<p><font face="Arial" size="2">becomes </font></p>

<pre><font face="Courier New" size="2">                mov     ax, var2
                mov     var1, ax</font></pre>

<p><font face="Arial" size="2">Of course, if you're using the <code>ax </code>register for
something else, one of the other registers will suffice. Regardless, you must use a
register to transfer one memory location to another.</font></p>

<p><font face="Arial" size="2">This discussion, of course, assumes that both variables are
in memory. If possible, you should try to use a register to hold the value of a variable. </font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING1-64"></a>9.1.2 Simple Expressions</font></strong></p>

<p><font face="Arial" size="2">The next level of complexity up from a simple assignment is
a simple expression. A simple expression takes the form: </font></p>

<pre><font face="Courier New" size="2">		var := term1 op term2;</font></pre>

<p><font face="Arial" size="2"><code>Var</code> is a variable, <code>term1 </code>and<code>
term2</code> are variables or constants, and <code>op </code>is some arithmetic operator
(addition, subtraction, multiplication, etc.). </font></p>

<p><font face="Arial" size="2">As simple as this expression appears, most expressions take
this form. It should come as no surprise then, that the 80x86 architecture was optimized
for just this type of expression.</font></p>

<p><font face="Arial" size="2">A typical conversion for this type of expression takes the
following form: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, term1
                op      ax, term2
                mov     var, ax</font></pre>

<p><font face="Arial" size="2"><code>Op</code> is the mnemonic that corresponds to the
specified operation (e.g., &quot;+&quot; = <code>add</code>, &quot;-&quot; = <code>sub</code>,
etc.).</font></p>

<p><font face="Arial" size="2">There are a few inconsistencies you need to be aware of.
First, the 80x86's <code>{i}mul</code> instructions do not allow immediate operands on
processors earlier than the 80286. Further, none of the processors allow immediate
operands with <code>{i}div</code>. Therefore, if the operation is multiplication or
division and one of the terms is a constant value, you may need to load this constant into
a register or memory location and then multiply or divide <code>ax </code>by that value.
Of course, when dealing with the multiply and divide instructions on the 8086/8088, you
must use the <code>ax </code>and <code>dx </code>registers. You cannot use arbitrary
registers as you can with other operations. Also, don't forget the sign extension
instructions if you're performing a division operation and you're dividing one 16/32 bit
number by another. Finally, don't forget that some instructions may cause overflow. You
may want to check for an overflow (or underflow) condition after an arithmetic operation. </font></p>

<p><font face="Arial" size="2">Examples of common simple expressions: </font></p>

<pre><font face="Courier New" size="2">X := Y + Z;

                mov     ax, y
                add     ax, z
                mov     x, ax

X := Y - Z;

                mov     ax, y
                sub     ax, z
                mov     x, ax

X := Y * Z; {unsigned}

                mov     ax, y
                mul     z               ;Use IMUL for signed arithmetic.
                mov     x, ax           ;Don't forget this wipes out DX.

X := Y div Z; {unsigned div}

                mov     ax, y
                mov     dx, 0           ;Zero extend AX into DX
                div     z
                mov     x, ax

X := Y div Z; {signed div}

                mov     ax, y
                cwd                     ;Sign extend AX into DX
                idiv    z
                mov     x, ax

X := Y mod Z; {unsigned remainder}

                mov     ax, y
                mov     dx, 0           ;Zero extend AX into DX
                div     z
                mov     x, dx           ;Remainder is in DX

X := Y mod Z; {signed remainder}

                mov     ax, y
                cwd                     ;Sign extend AX into DX
                idiv    z
                mov     x, dx           ;Remainder is in DX</font></pre>

<p><font face="Arial" size="2">Since it is possible for an arithmetic error to occur, you
should generally test the result of each expression for an error before or after
completing the operation. For example, unsigned addition, subtraction, and multiplication
set the carry flag if an overflow occurs. You can use the <code>jc</code> or <code>jnc</code>
instructions immediately after the corresponding instruction sequence to test for
overflow. Likewise, you can use the <code>jo</code> or <code>jno</code> instructions after
these sequences to test for signed arithmetic overflow. The next two examples demonstrate
how to do this for the <code>add</code> instruction: </font></p>

<pre><font face="Courier New" size="2">X := Y + Z; {unsigned}

                mov     ax, y
                add     ax, z
                mov     x, ax
                jc      uOverflow

X := Y + Z; {signed}

                mov     ax, y
                add     ax, z
                mov     x, ax
                jo      sOverflow</font></pre>

<p><font face="Arial" size="2">Certain unary operations also qualify as simple
expressions. A good example of a unary operation is negation. In a high level language
negation takes one of two possible forms: </font></p>

<pre><font face="Courier New" size="2">var := -var			or		var1 := -var2</font></pre>

<p><font face="Arial" size="2">Note that <code>var := -constant</code> is really a simple
assignment, not a simple expression. You can specify a negative constant as an operand to
the <code>mov</code> instruction: </font></p>

<pre><font face="Courier New" size="2">                 mov      var, -14</font></pre>

<p><font face="Arial" size="2">To handle the first form of the negation operation above
use the single assembly language statement: </font></p>

<pre><font face="Courier New" size="2">                 neg      var</font></pre>

<p><font face="Arial" size="2">If two different variables are involved, then use the
following: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, var2
                neg     ax
                mov     var1, ax</font></pre>

<p><font face="Arial" size="2">Overflow only occurs if you attempt to negate the most
negative value (-128 for eight bit values, -32768 for sixteen bit values, etc.). In this
instance the 80x86 sets the overflow flag, so you can test for arithmetic overflow using
the <code>jo</code> or <code>jno</code> instructions. In all other cases the80x86 clears
the overflow flag. The carry flag has no meaning after executing the <code>neg</code>
instruction since <code>neg</code> (obviously) does not apply to unsigned operands.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING1-154"></a>9.1.3 Complex
Expressions</font></strong></p>

<p><font face="Arial" size="2">A complex expression is any arithmetic expression involving
more than two terms and one operator. Such expressions are commonly found in programs
written in a high level language. Complex expressions may include parentheses to override
operator precedence, function calls, array accesses, etc. While the conversion of some
complex expressions to assembly language is fairly straight-forward, others require some
effort. This section outlines the rules you use to convert such expressions.</font></p>

<p><font face="Arial" size="2">A complex function that is easy to convert to assembly
language is one that involves three terms and two operators, for example: </font></p>

<pre><font face="Courier New" size="2">		W := W - Y - Z;</font></pre>

<p><font face="Arial" size="2">Clearly the straight-forward assembly language conversion
of this statement will require two <code>sub</code> instructions. However, even with an
expression as simple as this one, the conversion is not trivial. There are actually two
ways to convert this from the statement above into assembly language: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, w
                sub     ax, y
                sub     ax, z
                mov     w, ax</font></pre>

<pre><font face="Arial" size="2">and</font></pre>

<pre><font face="Courier New" size="2">                mov     ax, y
                sub     ax, z
                sub     w, ax</font></pre>

<p><font face="Arial" size="2">The second conversion, since it is shorter, looks better.
However, it produces an incorrect result (assuming Pascal-like semantics for the original
statement). Associativity is the problem. The second sequence above computes W := W - (Y -
Z) which is not the same as W := (W - Y) - Z. How we place the parentheses around the
subexpressions can affect the result. Note that if you are interested in a shorter form,
you can use the following sequence: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, y
                add     ax, z
                sub     w, ax</font></pre>

<p><font face="Arial" size="2">This computes W:=W-(Y+Z). This is equivalent to W := (W -
Y) - Z.</font></p>

<p><font face="Arial" size="2">Precedence is another issue. Consider the Pascal
expression: </font></p>

<pre><font face="Courier New" size="2">		X := W * Y + Z;</font></pre>

<p><font face="Arial" size="2">Once again there are two ways we can evaluate this
expression: </font></p>

<pre><font face="Courier New" size="2">		X := (W * Y) + Z;
</font><font face="Arial" size="2">or</font>
<font face="Courier New" size="2">		X := W * (Y + Z);</font></pre>

<p><font face="Arial" size="2">By now, you're probably thinking that this text is crazy.
Everyone knows the correct way to evaluate these expressions is the second form provided
in these two examples. However, you're wrong to think that way. The APL programming
language, for example, evaluates expressions solely from right to left and does not give
one operator precedence over another.</font></p>

<p><font face="Arial" size="2">Most high level languages use a fixed set of precedence
rules to describe the order of evaluation in an expression involving two or more different
operators. Most programming languages, for example, compute multiplication and division
before addition and subtraction. Those that support exponentiation (e.g., FORTRAN and
BASIC) usually compute that before multiplication and division. These rules are intuitive
since almost everyone learns them before high school. Consider the expression: </font></p>

<pre><font face="Courier New" size="2">		X op1 Y op2 Z</font></pre>

<p><font face="Arial" size="2">If op1 takes precedence over op2 then this evaluates to (X
op1 Y) op2 Z otherwise if op2 takes precedence over op1 then this evaluates to X op1 (Y
op2 Z ). Depending upon the operators and operands involved, these two computations could
produce different results.</font></p>

<p><font face="Arial" size="2">When converting an expression of this form into assembly
language, you must be sure to compute the subexpression with the highest precedence first.
The following example demonstrates this technique: </font></p>

<pre><font face="Courier New" size="2">; W := X + Y * Z;

                mov     bx, x
                mov     ax, y           ;Must compute Y * Z first since
                mul     z               ; &quot;*&quot; has the highest precedence.
                add     bx, ax          ;Now add product with X's value.
                mov     w, bx           ;Save away result.</font></pre>

<p><font face="Arial" size="2">Since addition is a commutative operation, we could
optimize the above code to produce: </font></p>

<pre><font face="Courier New" size="2">; W := X + Y * Z;

                mov     ax, y           ;Must compute Y * Z first since
                mul     z               ; &quot;*&quot; has the highest precedence.
                add     ax, x           ;Now add product with X's value.
                mov     w, ax           ;Save away result.</font></pre>

<p><font face="Arial" size="2">If two operators appearing within an expression have the
same precedence, then you determine the order of evaluation using associativity rules.
Most operators are left associative meaning that they evaluate from left to right.
Addition, subtraction, multiplication, and division are all left associative. A right
associative operator evaluates from right to left. The exponentiation operator in FORTRAN
and BASIC is a good example of a right associative operator: </font></p>

<pre><font face="Courier New" size="2">		2^2^3 is equal to 2^(2^3) not (2^2)^3</font></pre>

<p><font face="Arial" size="2">The precedence and associativity rules determine the order
of evaluation. Indirectly, these rules tell you where to place parentheses in an
expression to determine the order of evaluation. Of course, you can always use parentheses
to override the default precedence and associativity. However, the ultimate point is that
your assembly code must complete certain operations before others to correctly compute the
value of a given expression. The following examples demonstrate this principle: </font></p>

<pre><font face="Courier New" size="2">; W := X - Y - Z

                mov     ax, x           ;All the same operator, so we need
                sub     ax, y           ; to evaluate from left to right
                sub     ax, z           ; because they all have the same
                mov     w, ax           ; precedence.

; W := X + Y * Z

                mov     ax, y           ;Must compute Y * Z first since
                imul    z               ; multiplication has a higher
                add     ax, x           ; precedence than addition.
                mov     w, ax

; W := X / Y - Z

                mov     ax, x           ;Here we need to compute division
                cwd                     ; first since it has the highest
                idiv    y               ; precedence.
                sub     ax, z
                mov     w, ax

; W := X * Y * Z

                mov     ax, y           ;Addition and multiplication are
                imul    z               ; commutative, therefore the order
                imul    x               ; of evaluation does not matter
                mov     w, ax</font></pre>

<p><font face="Arial" size="2">There is one exception to the associativity rule. If an
expression involves multiplication and division it is always better to perform the
multiplication first. For example, given an expression of the form: </font></p>

<pre><font face="Courier New" size="2">		W := X/Y * Z</font></pre>

<p><font face="Arial" size="2">It is better to compute <code>X*Z</code> and then divide
the result by <code>Y</code> rather than divide <code>X</code> by <code>Y</code> and
multiply the quotient by <code>Z</code>. There are two reasons this approach is better.
First, remember that the<code> imul</code> instruction always produces a 32 bit result
(assuming 16 bit operands). By doing the multiplication first, you automatically sign
extend the product into the <code>dx</code> register so you do not have to sign extend <code>ax</code>
prior to the division. This saves the execution of the <code>cwd</code> instruction. A
second reason for doing the multiplication first is to increase the accuracy of the
computation. Remember, (integer) division often produces an inexact result. For example,
if you compute 5/2 you will get the value two, not 2.5. Computing (5/2)*3 produces six.
However, if you compute (5*3)/2 you get the value seven which is a little closer to the
real quotient (7.5). Therefore, if you encounter an expression of the form: </font></p>

<pre><font face="Courier New" size="2">		W := X/Y*Z;</font></pre>

<p><font face="Arial" size="2">You can usually convert this to assembly code: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, x
                imul    z
                idiv    z
                mov     w, ax</font></pre>

<p><font face="Arial" size="2">Of course, if the algorithm you're encoding depends on the
truncation effect of the division operation, you cannot use this trick to improve the
algorithm. Moral of the story: always make sure you fully understand any expression you
are converting to assembly language. Obviously if the semantics dictate that you must
perform the division first, do so.</font></p>

<p><font face="Arial" size="2">Consider the following Pascal statement: </font></p>

<pre><font face="Courier New" size="2">		W := X - Y * Z;</font></pre>

<p><font face="Arial" size="2">This is similar to a previous example except it uses
subtraction rather than addition. Since subtraction is not commutative, you cannot compute
Y * Z and then subtract X from this result. This tends to complicate the conversion a tiny
amount. Rather than a straight forward multiply and addition sequence, you'll have to load
X into a register, multiply Y and Z leaving their product in a different register, and
then subtract this product from X, e.g., </font></p>

<pre><font face="Courier New" size="2">                mov     bx, x
                mov     ax, y
                imul    z
                sub     bx, ax
                mov     w, bx</font></pre>

<p><font face="Arial" size="2">This is a trivial example that demonstrates the need for
temporary variables in an expression. The code uses the <code>bx</code> register to
temporarily hold a copy of <code>X</code> until it computes the product of <code>Y</code>
and <code>Z</code>. As your expression increase in complexity, the need for temporaries
grows. Consider the following Pascal statement: </font></p>

<pre><font face="Courier New" size="2">		W := (A + B) * (Y + Z);</font></pre>

<p><font face="Arial" size="2">Following the normal rules of algebraic evaluation, you
compute the subexpressions inside the parentheses (i.e., the two subexpressions with the
highest precedence) first and set their values aside. When you computed the values for
both subexpressions you can compute their sum. One way to deal with complex expressions
like this one is to reduce it to a sequence of simple expressions whose results wind up in
temporary variables. For example, we can convert the single expression above into the
following sequence: </font></p>

<pre><font face="Courier New" size="2">		Temp1 := A + B;
		Temp2 := Y + Z;
		W := Temp1 * Temp2;</font></pre>

<p><font face="Arial" size="2">Since converting simple expressions to assembly language is
quite easy, it's now a snap to compute the former, complex, expression in assembly. The
code is </font></p>

<pre><font face="Courier New" size="2">                mov     ax, a
                add     ax, b
                mov     Temp1, ax
                mov     ax, y
                add     ax, z
                mov     temp2, ax
                mov     ax, temp1,
                imul    temp2
                mov     w, ax</font></pre>

<p><font face="Arial" size="2">Of course, this code is grossly inefficient and it requires
that you declare a couple of temporary variables in your data segment. However, it is very
easy to optimize this code by keeping temporary variables, as much as possible, in 80x86
registers. By using 80x86 registers to hold the temporary results this code becomes: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, a
                add     ax, b
                mov     bx, y
                add     bx, z
                imul    bx
                mov     w, ax</font></pre>

<p><font face="Arial" size="2">Yet another example: </font></p>

<pre><font face="Courier New" size="2">                X := (Y+Z) * (A-B) / 10;</font></pre>

<p><font face="Arial" size="2">This can be converted to a set of four simple expressions: </font></p>

<pre><font face="Courier New" size="2">                Temp1 := (Y+Z)
                Temp2 := (A-B)
                Temp1 := Temp1 * Temp2
                X := Temp1 / 10</font></pre>

<p><font face="Arial" size="2">You can convert these four simple expressions into the
assembly language statements: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, y           ;Compute AX := Y+Z
                add     ax, z
                mov     bx, a           ;Compute BX := A-B
                sub     bx, b
                mul     bx              ;Compute AX := AX * BX, this also sign
                mov     bx, 10          ; extends AX into DX for idiv.
                idiv    bx              ;Compute AX := AX / 10
                mov     x, ax           ;Store result into X</font></pre>

<p><font face="Arial" size="2">The most important thing to keep in mind is that temporary
values, if possible, should be kept in registers. Remember, accessing an 80x86 register is
much more efficient than accessing a memory location. Use memory locations to hold
temporaries only if you've run out of registers to use.</font></p>

<p><font face="Arial" size="2">Ultimately, converting a complex expression to assembly
language is little different than solving the expression by hand. Instead of actually
computing the result at each stage of the computation, you simply write the assembly code
that computes the results. Since you were probably taught to compute only one operation at
a time, this means that manual computation works on &quot;simple expressions&quot; that
exist in a complex expression. Of course, converting those simple expressions to assembly
is fairly trivial. Therefore, anyone who can solve a complex expression by hand can
convert it to assembly language following the rules for simple expressions.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING1-309"></a>9.1.4 Commutative
Operators</font></strong></p>

<p><font face="Arial" size="2">If &quot;@&quot; represents some operator, that operator is
commutative if the following relationship is always true: </font></p>

<pre><font face="Courier New" size="2">		(A @ B) = (B @ A)</font></pre>

<p><font face="Arial" size="2">As you saw in the previous section, commutative operators
are nice because the order of their operands is immaterial and this lets you rearrange a
computation, often making that computation easier or more efficient. Often, rearranging a
computation allows you to use fewer temporary variables. Whenever you encounter a
commutative operator in an expression, you should always check to see if there is a better
sequence you can use to improve the size or speed of your code. The following tables list
the commutative and non-commutative operators you typically find in high level languages: </font></p>
<div align="center"><center>

<table BORDER="1" bordercolor="#C0C0C0" cellspacing="0" cellpadding="0" width="40%">
  <caption><strong><font face="Arial" size="2">Some Common Commutative Binary Operators</font></strong></caption>
  <tr>
    <th bgcolor="#F0F0F0" align="center"><font face="Arial" size="2">Pascal</font></th>
    <th bgcolor="#F0F0F0" align="center"><font face="Arial" size="2">C/C++</font></th>
    <th bgcolor="#F0F0F0"><font face="Arial" size="2">Description</font></th>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">+</font></td>
    <td align="center"><font face="Arial" size="2">+</font></td>
    <td><font face="Arial" size="2">Addition</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">*</font></td>
    <td align="center"><font face="Arial" size="2">*</font></td>
    <td><font face="Arial" size="2">Multiplication</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">AND</font></td>
    <td align="center"><font face="Arial" size="2">&amp;&amp; or &amp;</font></td>
    <td><font face="Arial" size="2">Logical or bitwise AND</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">OR</font></td>
    <td align="center"><font face="Arial" size="2">|| or |</font></td>
    <td><font face="Arial" size="2">Logical or bitwise OR</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">XOR</font></td>
    <td align="center"><font face="Arial" size="2">^</font></td>
    <td><font face="Arial" size="2">(Logical or) Bitwise exclusive-OR</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">=</font></td>
    <td align="center"><font face="Arial" size="2">==</font></td>
    <td><font face="Arial" size="2">Equality</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">&lt;&gt;</font></td>
    <td align="center"><font face="Arial" size="2">!=</font></td>
    <td><font face="Arial" size="2">Inequality</font></td>
  </tr>
</table>
</center></div>

<p>&nbsp;</p>
<div align="center"><center>

<table BORDER="1" bordercolor="#C0C0C0" cellspacing="0" cellpadding="0" width="50%">
  <caption><strong><font face="Arial" size="2">Some Common Noncommutative Binary Operators</font></strong></caption>
  <tr>
    <th bgcolor="#F0F0F0" align="center"><font face="Arial" size="2">Pascal</font></th>
    <th bgcolor="#F0F0F0" align="center"><font face="Arial" size="2">C/C++</font></th>
    <th bgcolor="#F0F0F0"><font face="Arial" size="2">Description</font></th>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td><font face="Arial" size="2">Subtraction</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">/ or DIV</font></td>
    <td align="center"><font face="Arial" size="2">/</font></td>
    <td><font face="Arial" size="2">Division</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">MOD</font></td>
    <td align="center"><font face="Arial" size="2">%</font></td>
    <td><font face="Arial" size="2">Modulo or remainder</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">&lt;</font></td>
    <td align="center"><font face="Arial" size="2">&lt;</font></td>
    <td><font face="Arial" size="2">Less than</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">&lt;=</font></td>
    <td align="center"><font face="Arial" size="2">&lt;=</font></td>
    <td><font face="Arial" size="2">Less than or equal</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">&gt;</font></td>
    <td align="center"><font face="Arial" size="2">&gt;</font></td>
    <td><font face="Arial" size="2">Greater than</font></td>
  </tr>
  <tr>
    <td align="center"><font face="Arial" size="2">&gt;=</font></td>
    <td align="center"><font face="Arial" size="2">&gt;=</font></td>
    <td><font face="Arial" size="2">Greater than or equal</font></td>
  </tr>
</table>
</center></div>

<p>&nbsp;</p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="../Chapter_8/CH08-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="../Chapter_8/CH08-1.html">Chapter
    Eight</a></strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH09-2.html">Chapter Nine</a> (Part 2) </strong></font><a href="CH09-2.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Nine: Arithmetic And Logical
Operations (Part 1)<br>
27 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_9/CH09-1.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:39 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
