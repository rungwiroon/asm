<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_10/CH10-6.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:27:03 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER TEN: CONTROL STRUCTURES (Part 6)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING6"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH10-5.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH10-5.html">Chapter Ten</a> (Part 5)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="../Chapter_11/CH11-1.html">Chapter Eleven</a>
    &nbsp; </strong></font><a href="../Chapter_11/CH11-1.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10"><a NAME="HEADING6-1"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0"><font face="Arial" size="4"><strong>CHAPTER TEN:<br>
    CONTROL STRUCTURES (Part 6)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10"></td>
  </tr>
  <tr>
    <td width="100%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING6-1"><b>10.11 </b>-
    Sample Program</a> </font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="20"></td>
  </tr>
  <tr>
    <td width="100%"><strong><font face="Arial" size="3">10.11 Sample Program</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="1" bgcolor="#000000"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">This chapter's sample program is a simple moon lander game.
While the simulation isn't terribly realistic, this program does demonstrate the use and
optimization of several different control structures including loops, if..then..else
statements, and so on. </font></p>

<pre><font face="Courier New" size="2">; Simple &quot;Moon Lander&quot; game.
;
; Randall Hyde
; 2/8/96
;
; This program is an example of a trivial little &quot;moon lander&quot;
; game that simulates a Lunar Module setting down on the Moon's
; surface.  At time T=0 the spacecraft's velocity is 1000 ft/sec
; downward, the craft has 1000 units of fuel, and the craft is
; 10,000 ft above the moon's surface.  The pilot (user) can 
; specify how much fuel to burn at each second.
;
; Note that all calculations are approximate since everything is
; done with integer arithmetic.


; Some important constants

InitialVelocity =       1000
InitialDistance =       10000
InitialFuel     =       250
MaxFuelBurn     =       25

MoonsGravity    =       5               ;Approx 5 ft/sec/sec
AccPerUnitFuel  =       -5              ;-5 ft/sec/sec for each fuel unit.


                .xlist
                include         stdlib.a
                includelib      stdlib.lib
                .list

                .386                    ;Comment out these two statements
                option  segment:use16   ; if you are not using an 80386.

dseg            segment para public 'data'

; Current distance from the Moon's Surface:

CurDist         word    InitialDistance

; Current Velocity:

CurVel          word    InitialVelocity

; Total fuel left to burn:

FuelLeft        word    InitialFuel


; Amount of Fuel to use on current burn.

Fuel            word    ?

; Distance travelled in the last second.

Dist            word    ?

dseg            ends

cseg            segment para public 'code'
                assume  cs:cseg, ds:dseg

; GETI- Reads an integer variable from the user and returns its
;       its value in the AX register.  If the user entered garbage,
;       this code will make the user re-enter the value.

geti            textequ &lt;call _geti&gt;
_geti           proc
                push    es
                push    di
                push    bx

; Read a string of characters from the user.
;
; Note that there are two (nested) loops here.  The outer loop
; (GetILp) repeats the getsm operation as long as the user 
; keeps entering an invalid number.  The innermost loop (ChkDigits)
; checks the individual characters in the input string to make
; sure they are all decimal digits.

GetILp:         getsm

; Check to see if this string contains any non-digit characters:
;
; while (([bx] &gt;= '0') and ([bx] &lt;= '9')  bx := bx + 1;
;
; Note the sneaky way of turning the while loop into a
; repeat..until loop.

                mov     bx, di          ;Pointer to start of string.
                dec     bx
ChkDigits:      inc     bx
                mov     al, es:[bx]     ;Fetch next character.
                IsDigit                 ;See if it's a decimal digit.
                je      ChkDigits       ;Repeat if it is.

                cmp     al, 0           ;At end of string?
                je      GotNumber

; Okay, we just ran into a non-digit character.  Complain and make
; the user reenter the value.

                free                    ;Free space malloc'd by getsm.
                print
                byte    cr,lf
                byte    &quot;Illegal unsigned integer value, &quot;
                byte    &quot;please reenter.&quot;,cr,lf
                byte    &quot;(no spaces, non-digit chars, etc.):&quot;,0
                jmp     GetILp


; Okay, ES:DI is pointing at something resembling a number.  Convert
; it to an integer.

GotNumber:      atoi
                free                    ;Free space malloc'd by getsm.

                pop     bx
                pop     di
                pop     es
                ret
_geti           endp





; InitGame-     Initializes global variables this game uses.

InitGame        proc
                mov     CurVel, InitialVelocity
                mov     CurDist, InitialDistance
                mov     FuelLeft, InitialFuel
                mov     Dist, 0
                ret
InitGame        endp


; DispStatus-   Displays important information for each
;               cycle of the game (a cycle is one second).

DispStatus      proc
                printf
                byte    cr,lf
                byte    &quot;Distance from surface: %5d&quot;,cr,lf
                byte    &quot;Current velocity:      %5d&quot;,cr,lf
                byte    &quot;Fuel left:             %5d&quot;,cr,lf
                byte    lf
                byte    &quot;Dist travelled in the last second: %d&quot;,cr,lf
                byte    lf,0
                dword   CurDist, CurVel, FuelLeft, Dist
                ret
DispStatus      endp


; GetFuel-      Reads an integer value representing the amount of fuel
;               to burn from the user and checks to see if this value
;               is reasonable.  A reasonable value must:
;
;               * Be an actual number (GETI handles this).
;               * Be greater than or equal to zero (no burning
;                 negative amounts of fuel, GETI handles this).
;               * Be less than MaxFuelBurn (any more than this and
;                 you have an explosion, not a burn).
;               * Be less than the fuel left in the Lunar Module.

GetFuel         proc
                push    ax

; Loop..endloop structure that reads an integer input and terminates
; if the input is reasonable.  It prints a message an repeats if
; the input is not reasonable.
;
; loop
;       get fuel;
;       if (fuel &lt; MaxFuelBurn) then break;
;       print error message.
; endloop
;
; if (fuel &gt; FuelLeft) then
;
;       fuel = fuelleft;
;       print appropriate message.
;
; endif

GetFuelLp:      print
                byte    &quot;Enter amount of fuel to burn: &quot;,0
                geti
                cmp     ax, MaxFuelBurn
                jbe     GoodFuel

                print
                byte    &quot;The amount you've specified exceeds the &quot;
                byte    &quot;engine rating,&quot;, cr, lf
                byte    &quot;please enter a smaller value&quot;,cr,lf,lf,0
                jmp     GetFuelLp

GoodFuel:       mov     Fuel, ax
                cmp     ax, FuelLeft
                jbe     HasEnough
                printf
                byte    &quot;There are only %d units of fuel left.&quot;,cr,lf
                byte    &quot;The Lunar module will burn this rather than %d&quot;
                byte    cr,lf,0
                dword   FuelLeft, Fuel

                mov     ax, FuelLeft
                mov     Fuel, ax

HasEnough:      mov     ax, FuelLeft
                sub     ax, Fuel
                mov     FuelLeft, ax
                pop     ax
                ret
GetFuel         endp



; ComputeStatus-
;
;       This routine computes the new velocity and new distance based on the
;       current distance, current velocity, fuel burnt, and the moon's
;       gravity.  This routine is called for every &quot;second&quot; of flight time.
;
; note:
;
;       Distance Travelled = Acc*T*T/2 + Vel*T  (note: T=1, so it goes away).
;       Acc = MoonsGravity + Fuel * AccPerUnitFuel
;
;       New Velocity = Acc*T + Prev Velocity
;
;       This code should really average these values over the one second
;       time period, but the simulation is so crude anyway, there's no
;       need to really bother.

ComputeStatus   proc
                push    ax
                push    bx
                push    dx

; First, compute the acceleration value based on the fuel burnt
; during this second (Acc = Moon's Gravity + Fuel * AccPerUnitFuel).

                mov     ax, Fuel                ;Compute
                mov     dx, AccPerUnitFuel      ; Fuel*AccPerUnitFuel
                imul    dx

                add     ax, MoonsGravity        ;Add in Moon's gravity.
                mov     bx, ax                  ;Save Acc value.

; Now compute the new velocity (V=AT+V)

                add     ax, CurVel              ;Compute new velocity
                mov     CurVel, ax

; Next, compute the distance travelled (D = 1/2 * A * T^2 + VT +D)

                sar     bx, 1                   ;Acc/2
                add     ax, bx                  ;Acc/2 + V (T=1!)
                mov     Dist, ax                ;Distance Travelled.
                neg     ax
                add     CurDist, ax             ;New distance.
                
                pop     dx
                pop     bx
                pop     ax
                ret
ComputeStatus   endp


; GetYorN-      Reads a yes or no answer from the user (Y, y, N, or n).
;               Returns the character read in the al register (Y or N,
;               converted to upper case if necessary).

GetYorN         proc
                getc
                ToUpper
                cmp     al, 'Y'
                je      GotIt
                cmp     al, 'N'
                jne     GetYorN
GotIt:          ret
GetYorN         endp

                


Main            proc
                mov     ax, dseg
                mov     ds, ax
                mov     es, ax
                meminit

MoonLoop:       print
                byte    cr,lf,lf
                byte    &quot;Welcome to the moon lander game.&quot;,cr,lf,lf
                byte    &quot;You must manuever your craft so that you touch&quot;
                byte    &quot;down at less than 10 ft/sec&quot;,cr,lf
                byte    &quot;for a soft landing.&quot;,cr,lf,lf,0

                call    InitGame

; The following loop repeats while the distance to the surface is greater
; than zero.

WhileStillUp:   mov     ax, CurDist
                cmp     ax, 0
                jle     Landed

                call    DispStatus
                call    GetFuel
                call    ComputeStatus
                jmp     WhileStillUp

Landed:         cmp     CurVel, 10
                jle     SoftLanding

                printf
                byte    &quot;Your current velocity is %d.&quot;,cr,lf
                byte    &quot;That was just a little too fast.  However, as a &quot;
                byte    &quot;consolation prize,&quot;,cr,lf
                byte    &quot;we will name the new crater you just created &quot;
                byte    &quot;after you.&quot;,cr,lf,0
                dword   CurVel

                jmp     TryAgain

SoftLanding:    printf
                byte    &quot;Congrats!  You landed the Lunar Module safely at &quot;
                byte    &quot;%d ft/sec.&quot;,cr,lf
                byte    &quot;You have %d units of fuel left.&quot;,cr,lf
                byte    &quot;Good job!&quot;,cr,lf,0
                dword   CurVel, FuelLeft

TryAgain:       print
                byte    &quot;Do you want to try again (Y/N)? &quot;,0
                call    GetYorN
                cmp     al, 'Y'
                je      MoonLoop

                print
                byte    cr,lf
                byte    &quot;Thanks for playing!  Come back to the moon again sometime&quot;
                byte    cr,lf,lf,0
        

Quit:           ExitPgm                 ;DOS macro to quit program.
Main            endp

cseg            ends

sseg            segment para stack 'stack'
stk             byte    1024 dup (&quot;stack   &quot;)
sseg            ends

zzzzzzseg       segment para public 'zzzzzz'
LastBytes       byte    16 dup (?)
zzzzzzseg       ends
                end     Main</font></pre>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH10-5.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH10-5.html">Chapter Ten</a> (Part 5)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="../Chapter_11/CH11-1.html">Chapter Eleven</a>
    &nbsp; </strong></font><a href="../Chapter_11/CH11-1.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Ten: Control Structures (Part
6)<br>
27 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_10/CH10-6.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:27:03 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
