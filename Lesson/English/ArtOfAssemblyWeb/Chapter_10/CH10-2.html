<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_10/CH10-2.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:27:01 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER TEN: CONTROL STRUCTURES (Part 2)</title>
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000" alink="#FF0000"
topmargin="10">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1"
    face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1"
    colspan="3"><a NAME="HEADING2"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a
    href="CH10-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0"
    WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH10-1.html">Chapter
    Ten</a> (Part 1)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a
    href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font
    face="Arial" size="2"><strong><a href="CH10-3.html">Chapter Ten</a> (Part 3) </strong></font><a
    href="CH10-3.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0"
    WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10"><a NAME="HEADING2-1"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0"><font face="Arial" size="4"><strong>CHAPTER TEN:<br>
    CONTROL STRUCTURES (Part 2)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10"></td>
  </tr>
  <tr>
    <td width="100%"><font face="Arial" size="2"><a HREF="#HEADING2-1"><b>10.3 </b>- CASE
    Statements</a> <br>
    <a HREF="#HEADING2-187"><b>10.4 </b>- State Machines and Indirect Jumps</a> <br>
    <a HREF="#HEADING2-270"><b>10.5 </b>- Spaghetti Code</a> </font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="20"></td>
  </tr>
  <tr>
    <td width="100%"><strong><font face="Arial" size="3">10.3 CASE Statements</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="1" bgcolor="#000000"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">The Pascal <code>case </code>statement takes the following
form : </font></p>

<pre><font face="Courier New" size="2">        CASE variable OF
                const1:stmt1;
                const2:stmt2;
                 .
                 .
                 .
                constn:stmtn
        END;</font></pre>

<p><font face="Arial" size="2">When this statement executes, it checks the value of
variable against the constants <code>const1 ... constn</code>. If a match is found then
the corresponding statement executes. Standard Pascal places a few restrictions on the <code>case</code>
statement. First, if the value of variable isn't in the list of constants, the result of
the <code>case</code> statement is undefined. Second, all the constants appearing as <code>case</code>
labels must be unique. The reason for these restrictions will become clear in a moment. </font></p>

<p><font face="Arial" size="2">Most introductory programming texts introduce the <code>case</code>
statement by explaining it as a sequence of <code>if..then..else </code>statements. They
might claim that the following two pieces of Pascal code are equivalent: </font></p>

<pre><font face="Courier New" size="2">        CASE I OF 
                0: WriteLn('I=0');
                1: WriteLn('I=1');
                2: WriteLn('I=2');
        END;

        IF I = 0 THEN WriteLn('I=0')
        ELSE IF I = 1 THEN WriteLn('I=1')
        ELSE IF I = 2 THEN WriteLn('I=2');</font></pre>

<p><font face="Arial" size="2">While semantically these two code segments may be the same,
their implementation is usually different<a HREF="#FOOTNOTE-1">[1]</a>. Whereas the <code>if..then..else
if </code>chain does a comparison for each conditional statement in the sequence, the <code>case</code>
statement normally uses an indirect jump to transfer control to any one of several
statements with a single computation. Consider the two examples presented above, they
could be written in assembly language with the following code: </font></p>

<pre><font face="Courier New" size="2">                mov     bx, I
                shl     bx, 1           ;Multiply BX by two
                jmp     cs:JmpTbl[bx] 

JmpTbl          word    stmt0, stmt1, stmt2 

Stmt0:          print
                byte    &quot;I=0&quot;,cr,lf,0
                jmp     EndCase 

Stmt1:          print
                byte    &quot;I=1&quot;,cr,lf,0
                jmp     EndCase 

Stmt2:          print
                byte    &quot;I=2&quot;,cr,lf,0 

EndCase: 

; IF..THEN..ELSE form: 

                mov     ax, I
                cmp     ax, 0
                jne     Not0
                print
                byte    &quot;I=0&quot;,cr,lf,0
                jmp     EndOfIF 

Not0:           cmp     ax, 1
                jne     Not1
                print
                byte    &quot;I=1&quot;,cr,lf,0
                jmp     EndOfIF 

Not1:           cmp     ax, 2
                jne     EndOfIF
                Print
                byte    &quot;I=2&quot;,cr,lf,0
EndOfIF: </font></pre>

<p><font face="Arial" size="2">Two things should become readily apparent: the more
(consecutive) cases you have, the more efficient the jump table implementation becomes
(both in terms of space and speed). Except for trivial cases, the <code>case</code>
statement is almost always faster and usually by a large margin. As long as the <code>case</code>
labels are consecutive values, the <code>case</code> statement version is usually smaller
as well. </font></p>

<p><font face="Arial" size="2">What happens if you need to include non-consecutive <code>case</code>
labels or you cannot be sure that the <code>case</code> variable doesn't go out of range?
Many Pascals have extended the definition of the <code>case</code> statement to include an
<code>otherwise </code>clause. Such a <code>case</code> statement takes the following
form: </font></p>

<pre><font face="Courier New" size="2">         CASE variable OF
                const:stmt;
                const:stmt;
                 . . 
                 . . 
                 . . 
                const:stmt;
                OTHERWISE stmt
        END; </font></pre>

<p><font face="Arial" size="2">If the value of variable matches one of the constants
making up the <code>case</code> labels, then the associated statement executes. If the
variable's value doesn't match any of the <code>case</code> labels, then the statement
following the <code>otherwise </code>clause executes. The <code>otherwise </code>clause is
implemented in two phases. First, you must choose the minimum and maximum values that
appear in a <code>case</code> statement. In the following <code>case</code> statement, the
smallest <code>case</code> label is five, the largest is 15: </font></p>

<pre><font face="Courier New" size="2">         CASE I OF
                5:stmt1;
                8:stmt2;
                10:stmt3;
                12:stmt4; 
                15:stmt5;
                OTHERWISE stmt6
        END; </font></pre>

<p><font face="Arial" size="2">Before executing the jump through the jump table, the 80x86
implementation of this <code>case</code> statement should check the <code>case</code>
variable to make sure it's in the range 5..15. If not, control should be immediately
transferred to stmt6: </font></p>

<pre><font face="Courier New" size="2">                mov     bx, I
                cmp     bx, 5
                jl      Otherwise
                cmp     bx, 15 
                jg      Otherwise 
                shl     bx, 1 
                jmp     cs:JmpTbl-10[bx] </font></pre>

<p><font face="Arial" size="2">The only problem with this form of the <code>case</code>
statement as it now stands is that it doesn't properly handle the situation where I is
equal to 6, 7, 9, 11, 13, or 14. Rather than sticking extra code in front of the
conditional jump, you can stick extra entries in the jump table as follows: </font></p>

<pre><font face="Courier New" size="2">                mov     bx, I 
                cmp     bx, 5
                jl      Otherwise
                cmp     bx, 15
                jg      Otherwise
                shl     bx, 1
                jmp     cs:JmpTbl-10[bx] 

Otherwise:      {put stmt6 here} 
                jmp     CaseDone 

JmpTbl          word    stmt1, Otherwise, Otherwise, stmt2, Otherwise
                word    stmt3, Otherwise, stmt4, Otherwise, Otherwise
                word    stmt5 
                etc.</font></pre>

<p><font face="Arial" size="2">Note that the value 10 is subtracted from the address of
the jump table. The first entry in the table is always at offset zero while the smallest
value used to index into the table is five (which is multiplied by two to produce 10). The
entries for 6, 7, 9, 11, 13, and 14 all point at the code for the Otherwise clause, so if
I contains one of these values, the Otherwise clause will be executed. </font></p>

<p><font face="Arial" size="2">There is a problem with this implementation of the <code>case</code>
statement. If the <code>case</code> labels contain non-consecutive entries that are widely
spaced, the following <code>case</code> statement would generate an extremely large code
file: </font></p>

<pre><font face="Courier New" size="2">        CASE I OF
                0: stmt1;
                100: stmt2;
                1000: stmt3;
                10000: stmt4;
                Otherwise stmt5
        END; </font></pre>

<p><font face="Arial" size="2">In this situation, your program will be much smaller if you
implement the <code>case</code> statement with a sequence of <code>if </code>statements
rather than using a jump statement. However, keep one thing in mind- the size of the jump
table does not normally affect the execution speed of the program. If the jump table
contains two entries or two thousand, the <code>case</code> statement will execute the
multi-way branch in a constant amount of time. The <code>if </code>statement
implementation requires a linearly increasing amount of time for each <code>case</code>
label appearing in the <code>case</code> statement.</font></p>

<p><font face="Arial" size="2">Probably the biggest advantage to using assembly language
over a HLL like Pascal is that you get to choose the actual implementation. In some
instances you can implement a <code>case</code> statement as a sequence of<code>if..then..else
</code>statements, or you can implement it as a jump table, or you can use a hybrid of the
two: </font></p>

<pre><font face="Courier New" size="2">        CASE I OF
                0:stmt1;
                1:stmt2;
                2:stmt3;
                100:stmt4;
                Otherwise stmt5
        END;</font></pre>

<p><font face="Arial" size="2">could become: </font></p>

<pre><font face="Courier New" size="2">                mov     bx, I
                cmp     bx, 100
                je      Is100
                cmp     bx, 2 
                ja      Otherwise 
                shl     bx, 1 
                jmp     cs:JmpTbl[bx]
                etc. </font></pre>

<p><font face="Arial" size="2">Of course, you could do this in Pascal with the following
code: </font></p>

<pre><font face="Courier New" size="2">        IF I = 100 then stmt4 
        ELSE CASE I OF
                0:stmt1;
                1:stmt2;
                2:stmt3;
                Otherwise stmt5
        END; </font></pre>

<p><font face="Arial" size="2">But this tends to destroy the readability of the Pascal
program. On the other hand, the extra code to test for 100 in the assembly language code
doesn't adversely affect the readability of the program (perhaps because it's so hard to
read already). Therefore, most people will add the extra code to make their program more
efficient.</font></p>

<p><font face="Arial" size="2">The C/C++ <code>switch</code> statement is very similar to
the Pascal <code>case</code> statement. There is only one major semantic difference: the
programmer must explicitly place a <code>break</code> statement in each <code>case</code>
clause to transfer control to the first statement beyond the <code>switch</code>. This <code>break</code>
corresponds to the <code>jmp</code> instruction at the end of each <code>case</code>
sequence in the assembly code above. If the corresponding <code>break</code> is not
present, C/C++ transfers control into the code of the following <code>case</code>. This is
equivalent to leaving off the <code>jmp</code> at the end of the <code>case</code>'s
sequence: </font></p>

<pre><font face="Courier New" size="2">        switch (i) 
        {
        case 0: stmt1;
        case 1: stmt2;
        case 2: stmt3;
                break;
        case 3: stmt4;
                break;
        default:stmt5;
        }</font></pre>

<p><font face="Arial" size="2">This translates into the following 80x86 code: </font></p>

<pre><font face="Courier New" size="2">                mov     bx, i
                cmp     bx, 3
                ja      DefaultCase

                shl     bx, 1
                jmp     cs:JmpTbl[bx]
JmpTbl          word    case0, case1, case2, case3

case0:          &lt;stmt1's code&gt;

case1:          &lt;stmt2's code&gt;

case2:          &lt;stmt3's code&gt;

                jmp     EndCase         ;Emitted for the break stmt.

case3:          &lt;stmt4's code&gt;
                jmp     EndCase         ;Emitted for the break stmt.

DefaultCase:    &lt;stmt5's code&gt;
EndCase:</font></pre>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3">10.4 State Machines and Indirect
    Jumps</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">Another control structure commonly found in assembly
language programs is the state machine. A state machine uses a state variable to control
program flow. The FORTRAN programming language provides this capability with the assigned
goto statement. Certain variants of C (e.g., GNU's GCC from the Free Software Foundation)
provide similar features. In assembly language, the indirect jump provides a mechanism to
easily implement state machines.</font></p>

<p><font face="Arial" size="2">So what is a state machine? In very basic terms, it is a
piece of code<a HREF="#FOOTNOTE-2">[2]</a> which keeps track of its execution history by
entering and leaving certain &quot;states&quot;. For the purposes of this chapter, we'll
not use a very formal definition of a state machine. We'll just assume that a state
machine is a piece of code which (somehow) remembers the history of its execution (its
state) and executes sections of code based upon that history.</font></p>

<p><font face="Arial" size="2">In a very real sense, all programs are state machines. The
CPU registers and values in memory constitute the &quot;state&quot; of that machine.
However, we'll use a much more constrained view. Indeed, for most purposes only a single
variable (or the value in the IP register) will denote the current state.</font></p>

<p><font face="Arial" size="2">Now let's consider a concrete example. Suppose you have a
procedure which you want to perform one operation the first time you call it, a different
operation the second time you call it, yet something else the third time you call it, and
then something new again on the fourth call. After the fourth call it repeats these four
different operations in order. For example, suppose you want the procedure to add <code>ax
</code>and <code>bx </code>the first time, subtract them on the second call, multiply them
on the third, and divide them on the fourth. You could implement this procedure as
follows:</font> </p>

<pre><font face="Courier New" size="2">State           byte    0
StateMach       proc
                cmp     state,0
                jne     TryState1

; If this is state 0, add BX to AX and switch to state 1:

                add     ax, bx
                inc     State           ;Set it to state 1
                ret

; If this is state 1, subtract BX from AX and switch to state 2

TryState1:      cmp     State, 1
                jne     TryState2
                sub     ax, bx
                inc     State
                ret

; If this is state 2, multiply AX and BX and switch to state 3:

TryState2:      cmp     State, 2
                jne     MustBeState3
                push    dx
                mul     bx
                pop     dx
                inc     State
                ret

; If none of the above, assume we're in State 4. So divide
; AX by BX.

MustBeState3:
                push    dx
                xor     dx, dx          ;Zero extend AX into DX.
                div     bx
                pop     dx
                mov     State, 0        ;Switch back to State 0
                ret
StateMach       endp</font></pre>

<p><font face="Arial" size="2">Technically, this procedure is not the state machine.
Instead, it is the variable <code>State</code> and the <code>cmp/jne</code> instructions
which constitute the state machine.</font></p>

<p><font face="Arial" size="2">There is nothing particularly special about this code. It's
little more than a <code>case</code> statement implemented via the<code>if..then..else </code>construct.
The only thing special about this procedure is that it remembers how many times it has
been called<a HREF="#FOOTNOTE-3">[3]</a> and behaves differently depending upon the number
of calls. While this is a correct implementation of the desired state machine, it is not
particularly efficient. The more common implementation of a state machine in assembly
language is to use an indirect jump. Rather than having a state variable which contains a
value like zero, one, two, or three, we could load the state variable with the address of
the code to execute upon entry into the procedure. By simply jumping to that address, the
state machine could save the tests above needed to execute the proper code fragment.
Consider the following implementation using the indirect jump: </font></p>

<pre><font face="Courier New" size="2">State           word    State0
StateMach       proc
                jmp     State

; If this is state 0, add BX to AX and switch to state 1:

State0:         add     ax, bx
                mov     State, offset State1    ;Set it to state 1
                ret

; If this is state 1, subtract BX from AX and switch to state 2

State1:         sub     ax, bx
                mov     State, offset State2    ;Switch to State 2
                ret

; If this is state 2, multiply AX and BX and switch to state 3:

State2:         push    dx
                mul     bx
                pop     dx
                mov     State, offset State3    ;Switch to State 3
                ret

; If in State 3, do the division and switch back to State 0:

State3:         push    dx
                xor     dx, dx                  ;Zero extend AX into DX.
                div     bx
                pop     dx
                mov     State, offset State0    ;Switch to State 0
                ret
StateMach       endp</font></pre>

<p><font face="Arial" size="2">The <code>jmp </code>instruction at the beginning of the <code>StateMach</code>
procedure transfers control to the location pointed at by the <code>State</code> variable.
The first time you call <code>StateMach</code> it points at the <code>State0</code> label.
Thereafter, each subsection of code sets the <code>State</code> variable to point at the
appropriate successor code.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING2-270"></a>10.5
    Spaghetti Code</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">One major problem with assembly language is that it takes
several statements to realize a simple idea encapsulated by a single HLL statement. All
too often an assembly language programmer will notice that s/he can save a few bytes or
cycles by jumping into the middle of some programming structure. After a few such
observations (and corresponding modifications) the code contains a whole sequence of jumps
in and out of portions of the code. If you were to draw a line from each jump to its
destination, the resulting listing would end up looking like someone dumped a bowl of
spaghetti on your code, hence the term &quot;spaghetti code&quot;. </font></p>

<p><font face="Arial" size="2">Spaghetti code suffers from one major drawback- it's
difficult (at best) to read such a program and figure out what it does. Most programs
start out in a &quot;structured&quot; form only to become spaghetti code at the altar of
efficiency. Alas, spaghetti code is rarely efficient. Since it's difficult to figure out
exactly what's going on, it's very difficult to determine if you can use a better
algorithm to improve the system. Hence, spaghetti code may wind up less efficient. </font></p>

<p><font face="Arial" size="2">While it's true that producing some spaghetti code in your
programs may improve its efficiency, doing so should always be a last resort (when you've
tried everything else and you still haven't achieved what you need), never a matter of
course. Always start out writing your programs with straight-forward <code>if</code>s and <code>case</code>
statements. Start combining sections of code (via <code>jmp </code>instructions) once
everything is working and well understood. Of course, you should never obliterate the
structure of your code unless the gains are worth it. </font></p>

<p><font face="Arial" size="2">A famous saying in structured programming circles is
&quot;After <code>goto</code>s, pointers are the next most dangerous element in a
programming language.&quot; A similar saying is &quot;Pointers are to data structures what
<code>goto</code>s are to control structures.&quot; In other words, avoid excessive use of
pointers. If pointers and <code>goto</code>s are bad, then the indirect jump must be the
worst construct of all since it involves both <code>goto</code>s and pointers! Seriously
though, the indirect jump instructions should be avoided for casual use. They tend to make
a program harder to read. After all, an indirect jump can (theoretically) transfer control
to any label within a program. Imagine how hard it would be to follow the flow through a
program if you have no idea what a pointer contains and you come across an indirect jump
using that pointer. Therefore, you should always exercise care when using jump indirect
instructions. </font></p>

<hr noshade size="1" color="#000000">

<p><font face="Arial" size="2"><a NAME="FOOTNOTE-1"></a><strong>[1]</strong> Versions of
Turbo Pascal, sadly, treat the <code>case </code>statement as a form of the <code>if..then..else
</code>statement. </font></p>

<p><font face="Arial" size="2"><a NAME="FOOTNOTE-2"></a><strong>[2]</strong> Note that
state machines need not be software based. Many state machines' implementation are
hardware based. </font></p>

<p><font face="Arial" size="2"><a NAME="FOOTNOTE-3"></a><strong>[3]</strong> Actually, it
remembers how many times, MOD 4, that it has been called. </font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1"
    colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a
    href="CH10-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0"
    WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH10-1.html">Chapter
    Ten</a> (Part 1)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a
    href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font
    face="Arial" size="2"><strong><a href="CH10-3.html">Chapter Ten</a> (Part 3) </strong></font><a
    href="CH10-3.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0"
    WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Ten: Control Structures (Part
2)<br>
27 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_10/CH10-2.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:27:01 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
