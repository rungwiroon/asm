<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_10/CH10-3.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:27:01 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER TEN: CONTROL STRUCTURES (Part 3)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING3"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH10-2.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH10-2.html">Chapter Ten</a> (Part 2)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH10-4.html">Chapter Ten</a> (Part 4) </strong></font><a href="CH10-4.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10" colspan="2"><a NAME="HEADING3-1"><strong><font face="Arial" size="3"></font></strong></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0" colspan="2"><font face="Arial" size="4"><strong>CHAPTER
    TEN:<br>
    CONTROL STRUCTURES (Part 3)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10" colspan="2"></td>
  </tr>
  <tr>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING3-1"><b>10.6 </b>-
    Loops</a> <br>
    <a HREF="#HEADING3-4"><b>10.6.1 </b>- While Loops</a> <br>
    <a HREF="#HEADING3-37"><b>10.6.2 </b>- Repeat..Until Loops</a> <br>
    </font></td>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING3-51"><b>10.6.3 </b>-
    LOOP..ENDLOOP Loops</a> <br>
    <a HREF="#HEADING3-80"><b>10.6.4 </b>- FOR Loops</a> <br>
    <a HREF="#HEADING3-135"><b>10.7 </b>- Register Usage and Loops</a> </font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="20" colspan="2"></td>
  </tr>
  <tr>
    <td width="100%" colspan="2"><strong><font face="Arial" size="3">10.6 Loops</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="1" bgcolor="#000000" colspan="2"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">Loops represent the final basic control structure
(sequences, decisions, and loops) which make up a typical program. Like so many other
structures in assembly language, you'll find yourself using loops in places you've never
dreamed of using loops. Most HLLs have implied loop structures hidden away. For example,
consider the BASIC statement <code>IF A$ = B$ THEN 100</code>. This <code>if </code>statement
compares two strings and jumps to statement 100 if they are equal. In assembly language,
you would need to write a loop to compare each character in <code>A$</code> to the
corresponding character in <code>B$</code> and then jump to statement 100 if and only if
all the characters matched. In BASIC, there is no loop to be seen in the program. In
assembly language, this very simple <code>if </code>statement requires a loop. This is but
a small example which shows how loops seem to pop up everywhere. </font></p>

<p><font face="Arial" size="2">Program loops consist of three components: an optional
initialization component, a loop termination test, and the body of the loop. The order
with which these components are assembled can dramatically change the way the loop
operates. Three permutations of these components appear over and over again. Because of
their frequency, these loop structures are given special names in HLLs: <code>while </code>loops,
<code>repeat..until </code>loops (<code>do..while</code> in C/C++), and <code>loop..endloop
</code>loops. </font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-4"></a>10.6.1 While Loops</font></strong></p>

<p><font face="Arial" size="2">The most general loop is the while loop. It takes the
following form: </font></p>

<pre><font face="Courier New" size="2">	WHILE boolean expression DO statement;</font></pre>

<p><font face="Arial" size="2">There are two important points to note about the while
loop. First, the test for termination appears at the beginning of the loop. Second as a
direct consequence of the position of the termination test, the body of the loop may never
execute. If the termination condition always exists, the loop body will always be skipped
over. </font></p>

<p><font face="Arial" size="2">Consider the following Pascal while loop: </font></p>

<pre><font face="Courier New" size="2">	I := 0; 
	WHILE (I&lt;100) do I := I + 1;</font></pre>

<p><font face="Arial" size="2"><code>I := 0; </code>is the initialization code for this
loop. I is a loop control variable, because it controls the execution of the body of the
loop.<code> (I&lt;100)</code> is the loop termination condition. That is, the loop will
not terminate as long as I is less than 100.<code> I:=I+1;</code> is the loop body. This
is the code that executes on each pass of the loop. You can convert this to 80x86 assembly
language as follows: </font></p>

<pre><font face="Courier New" size="2">                mov     I, 0 
WhileLp:        cmp     I, 100
                jge     WhileDone
                inc     I
                jmp     WhileLp

WhileDone:</font></pre>

<p><font face="Arial" size="2">Note that a Pascal while loop can be easily synthesized
using an if and a goto statement. For example, the Pascal while loop presented above can
be replaced by: </font></p>

<pre><font face="Courier New" size="2">        I := 0; 
        1:      IF (I&lt;100) THEN BEGIN
                I := I + 1;
                GOTO 1;
        END;</font></pre>

<p><font face="Arial" size="2">More generally, any while loop can be built up from the
following: </font></p>

<pre><font face="Courier New" size="2">        optional initialization code 
1:      IF not termination condition THEN BEGIN
                loop body       
                GOTO 1;
        END;</font></pre>

<p><font face="Arial" size="2">Therefore, you can use the techniques from earlier in this
chapter to convert <code>if </code>statements to assembly language. All you'll need is an
additional <code>jmp </code>(<code>goto</code>) instruction.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-37"></a>10.6.2 Repeat..Until
Loops</font></strong></p>

<p><font face="Arial" size="2">The <code>repeat..until (do..while) </code>loop tests for
the termination condition at the end of the loop rather than at the beginning. In Pascal,
the <code>repeat..until</code> loop takes the following form: </font></p>

<pre><font face="Courier New" size="2">        optional initialization code 
        REPEAT
                loop body
        UNTIL termination condition</font></pre>

<p><font face="Arial" size="2">This sequence executes the initialization code, the loop
body, then tests some condition to see if the loop should be repeated. If the boolean
expression evaluates to false, the loop repeats; otherwise the loop terminates. The two
things to note about the <code>repeat..until</code> loop is that the termination test
appears at the end of the loop and, as a direct consequence of this, the loop body
executes at least once. </font></p>

<p><font face="Arial" size="2">Like the <code>while </code>loop, the <code>repeat..until</code>
loop can be synthesized with an <code>if </code>statement and a <code>goto </code>. You
would use the following: </font></p>

<pre><font face="Courier New" size="2">        initialization code 
1:              loop body
        IF NOT termination condition THEN GOTO 1</font></pre>

<p><font face="Arial" size="2">Based on the material presented in the previous sections,
you can easily synthesize <code>repeat..until</code> loops in assembly language.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-51"></a>10.6.3 LOOP..ENDLOOP
Loops</font></strong></p>

<p><font face="Arial" size="2">If <code>while </code>loops test for termination at the
beginning of the loop and <code>repeat..until </code>loops check for termination at the
end of the loop, the only place left to test for termination is in the middle of the loop.
Although Pascal and C/C++<a HREF="#FOOTNOTE-4">[4]</a> don't directly support such a loop,
the <code>loop..endloop </code>structure can be found in HLL languages like Ada. The <code>loop..endloop</code>
loop takes the following form: </font></p>

<pre><font face="Courier New" size="2">        LOOP
                loop body
        ENDLOOP;</font></pre>

<p><font face="Arial" size="2">Note that there is no explicit termination condition.
Unless otherwise provided for, the <code>loop..endloop</code> construct simply forms an
infinite loop. Loop termination is handled by an <code>if </code>and <code>goto </code>statement<a HREF="#FOOTNOTE-5">[5]</a>. Consider the following (pseudo) Pascal code which employs a <code>loop..endloop</code>
construct: </font></p>

<pre><font face="Courier New" size="2">        LOOP
                READ(ch)
                IF ch = '.' THEN BREAK;
                WRITE(ch);
        ENDLOOP;</font></pre>

<p><font face="Arial" size="2">In real Pascal, you'd use the following code to accomplish
this: </font></p>

<pre><font face="Courier New" size="2">1: 
        READ(ch); 
        IF ch = '.' THEN GOTO 2; (* Turbo Pascal supports BREAK! *)
        WRITE(ch);
        GOTO 1
2:</font></pre>

<p><font face="Arial" size="2">In assembly language you'd end up with something like: </font></p>

<pre><font face="Courier New" size="2">LOOP1:  getc 
        cmp     al, '.' 
        je      EndLoop 
        putc 
        jmp     LOOP1
EndLoop:</font></pre>

<pre><strong><font face="Arial" size="3">10.6.4 FOR Loops</font></strong></pre>

<p><font face="Arial" size="2">The <code>for </code>loop is a special form of the <code>while
</code>loop which repeats the loop body a specific number of times. In Pascal, the <code>for
</code>loop looks something like the following:</font> </p>

<pre><font face="Courier New" size="2">	FOR var := initial TO final DO stmt 
or
	FOR var := initial DOWNTO final DO stmt</font></pre>

<p><font face="Arial" size="2">Traditionally, the <code>for </code>loop in Pascal has been
used to process arrays and other objects accessed in sequential numeric order. These loops
can be converted directly into assembly language as follows: </font></p>

<p><font face="Arial" size="2">In Pascal:</font></p>

<p><font face="Arial" size="2">FOR var := start TO stop DO stmt;</font></p>

<p><font face="Arial" size="2">In Assembly: </font></p>

<pre><font face="Courier New" size="2">                mov     var, start
FL:             mov     ax, var
                cmp     ax, stop
                jg      EndFor

; code corresponding to stmt goes here.

                inc     var
                jmp     FL
EndFor:</font></pre>

<p><font face="Arial" size="2">Fortunately, most for loops repeat some statement(s) a
fixed number of times. For example, </font></p>

<pre><font face="Courier New" size="2">        FOR I := 0 to 7 do write(ch);</font></pre>

<p><font face="Arial" size="2">In situations like this, it's better to use the 80x86 loop
instruction (or corresponding dec cx/jne sequence) rather than simulate a for loop: </font></p>

<pre><font face="Courier New" size="2">                mov     cx, 7
LP:             mov     al, ch
                call    putc
                loop    LP</font></pre>

<p><font face="Arial" size="2">Keep in mind that the loop instruction normally appears at
the end of a loop whereas the for loop tests for termination at the beginning of the loop.
Therefore, you should take precautions to prevent a runaway loop in the event cx is zero
(which would cause the loop instruction to repeat the loop 65,536 times) or the stop value
is less than the start value. In the case of </font></p>

<pre><font face="Courier New" size="2">        FOR var := start TO stop DO stmt;</font></pre>

<p><font face="Arial" size="2">assuming you don't use the value of var within the loop,
you'd probably want to use the assembly code: </font></p>

<pre><font face="Courier New" size="2">                mov     cx, stop
                sub     cx, start
                jl      SkipFor
                inc     cx
LP:             stmt
                loop    LP
SkipFor:</font></pre>

<p><font face="Arial" size="2">Remember, the sub and cmp instructions set the flags in an
identical fashion. Therefore, this loop will be skipped if stop is less than start. It
will be repeated (stop-start)+1 times otherwise. If you need to reference the value of var
within the loop, you could use the following code: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, start
                mov     var, ax
                mov     cx, stop
                sub     cx, ax
                jl      SkipFor
                inc     cx
LP:             stmt
                inc     var
                loop    LP
SkipFor:</font></pre>

<p><font face="Arial" size="2">The <code>downto </code>version appears in the exercises.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING3-135"></a>10.7
    Register Usage and Loops</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">Given that the 80x86 accesses registers much faster than
memory locations, registers are the ideal spot to place loop control variables (especially
for small loops). This point is amplified since the <code>loop </code>instruction requires
the use of the <code>cx </code>register. However, there are some problems associated with
using registers within a loop. The primary problem with using registers as loop control
variables is that registers are a limited resource. In particular, there is only one <code>cx
</code>register. Therefore, the following will not work properly: </font></p>

<pre><font face="Courier New" size="2">                mov     cx, 8
Loop1:          mov     cx, 4
Loop2:          stmts
                loop    Loop2
                stmts
                loop    Loop1</font></pre>

<p><font face="Arial" size="2">The intent here, of course, was to create a set of nested
loops, that is, one loop inside another. The inner loop (<code>Loop2</code>) should repeat
four times for each of the eight executions of the outer loop (<code>Loop1</code>).
Unfortunately, both loops use the <code>loop </code>instruction. Therefore, this will form
an infinite loop since <code>cx </code>will be set to zero (which <code>loop</code> treats
like 65,536) at the end of the first <code>loop</code> instruction. Since <code>cx </code>is
always zero upon encountering the second <code>loop</code> instruction, control will
always transfer to the <code>Loop1</code> label. The solution here is to save and restore
the <code>cx </code>register or to use a different register in place of <code>cx </code>for
the outer loop: </font></p>

<pre><font face="Courier New" size="2">                mov     cx, 8
Loop1:          push    cx
                mov     cx, 4
Loop2:          stmts
                loop    Loop2
                pop     cx
                stmts
                loop    Loop1

or:
                mov     bx, 8
Loop1:          mov     cx, 4
Loop2:          stmts
                loop    Loop2
                stmts
                dec     bx
                jnz     Loop1</font></pre>

<p><font face="Arial" size="2">Register corruption is one of the primary sources of bugs
in loops in assembly language programs, always keep an eye out for this problem.</font></p>

<hr noshade size="1" color="#000000">

<p><font face="Arial" size="2"><a NAME="FOOTNOTE-4"></a><strong>[4]</strong> Technically,
C/C++ does support such a loop. &quot;for(;;)&quot; along with break provides this
capability. </font></p>

<p><font face="Arial" size="2"><a NAME="FOOTNOTE-5"></a><strong>[5]</strong> Many high
level languages use statements like NEXT, BREAK, CONTINUE, EXIT, and CYCLE rather than
GOTO; but they're all forms of the GOTO statement. </font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH10-2.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH10-2.html">Chapter Ten</a> (Part 2)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH10-4.html">Chapter Ten</a> (Part 4) </strong></font><a href="CH10-4.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Ten: Control Structures (Part
3)<br>
27 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_10/CH10-3.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:27:01 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
