<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_5/CH05-1.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:00 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER FIVE: VARIABLES AND DATA STRUCTURES (Part 1)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING1"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="../Chapter_4/CH04-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="../Chapter_4/CH04-1.html">Chapter
    Four</a></strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH05-2.html">Chapter Five</a> (Part 2) </strong></font><a href="CH05-2.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3" bgcolor="#FFFFFF" nowrap height="10"><a NAME="HEADING1-0"></a></td>
  </tr>
  <tr>
    <td width="100%" colspan="3" bgcolor="#F0F0F0"><font face="Arial" size="4"><strong>CHAPTER
    FIVE:<br>
    VARIABLES AND DATA STRUCTURES (Part 1)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" colspan="3" nowrap height="10"></td>
  </tr>
  <tr>
    <td width="40%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING1-2"><b>5.0 </b>-
    Chapter Overview</a> <br>
    <a HREF="#HEADING1-4"><b>5.1 </b>- Some Additional Instructions: LEA, LES, ADD, and MUL</a>
    <br>
    <a HREF="#HEADING1-28"><b>5.2 </b>- Declaring Variables in an Assembly Language Program</a>
    <br>
    <a HREF="#HEADING1-61"><b>5.3 </b>- Declaring and Accessing Scalar Variables</a> <br>
    <a HREF="#HEADING1-79"><b>5.3.1 </b>- Declaring and using BYTE Variables</a> <br>
    <a HREF="#HEADING1-138"><b>5.3.2 </b>- Declaring and using WORD Variables</a> <br>
    <a HREF="#HEADING1-151"><b>5.3.3 </b>- Declaring and using DWORD Variables </a><br>
    <a HREF="#HEADING1-163"><b>5.3.4 </b>- Declaring and using FWORD, QWORD, and TBYTE
    Variables</a> <br>
    <a HREF="#HEADING1-168"><b>5.3.5 </b>- Declaring Floating Point Variables with REAL4,
    REAL8, and REAL10</a> <br>
    <a HREF="#HEADING1-180"><b>5.4 </b>- Creating Your Own Type Names with TYPEDEF</a> <br>
    <a HREF="#HEADING1-197"><b>5.5 </b>- Pointer Data Types</a> <br>
    <a HREF="CH05-2.html#HEADING2-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH05/CH05-2.html#HEADING2-1"><b>5.6 </b>-
    Composite Data Types</a> <br>
    <a HREF="CH05-2.html#HEADING2-4" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH05/CH05-2.html#HEADING2-4"><b>5.6.1 </b>-
    Arrays</a> <br>
    <a HREF="CH05-2.html#HEADING2-16" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH05/CH05-2.html#HEADING2-16"><b>5.6.1.1
    </b>- Declaring Arrays in Your Data Segment</a> <br>
    <a HREF="CH05-2.html#HEADING2-55" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH05/CH05-2.html#HEADING2-55"><b>5.6.1.2
    </b>- Accessing Elements of a Single Dimension Array</a> <br>
    <a HREF="CH05-2.html#HEADING2-97" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH05/CH05-2.html#HEADING2-97"><b>5.6.2
    </b>- Multidimensional Arrays</a> <br>
    <a HREF="CH05-2.html#HEADING2-105" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH05/CH05-2.html#HEADING2-105"><b>5.6.2.1
    </b>- Row Major Ordering</a> <br>
    <a HREF="CH05-2.html#HEADING2-200" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH05/CH05-2.html#HEADING2-200"><b>5.6.2.2
    </b>- Column Major Ordering</a> <br>
    <a HREF="CH05-2.html#HEADING2-224" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH05/CH05-2.html#HEADING2-224"><b>5.6.2.3
    </b>- Allocating Storage for Multidimensional Arrays</a> <br>
    <a HREF="CH05-2.html#HEADING2-250" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH05/CH05-2.html#HEADING2-250"><b>5.6.2.4
    </b>- Accessing Multidimensional Array Elements in Assembly Language</a> <br>
    <a HREF="CH05-3.html#HEADING3-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH05/CH05-3.html#HEADING3-1"><b>5.6.3 </b>-
    Structures</a> <br>
    <a HREF="CH05-3.html#HEADING3-59" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH05/CH05-3.html#HEADING3-59"><b>5.6.4
    </b>- Arrays of Structures and Arrays/Structures as Structure Fields</a> <br>
    <a HREF="CH05-3.html#HEADING3-109" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH05/CH05-3.html#HEADING3-109"><b>5.6.5
    </b>- Pointers to Structures</a> <br>
    <a HREF="CH05-4.html#HEADING4-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH05/CH05-4.html#HEADING4-1"><b>5.7 </b>-
    Sample Programs</a> <br>
    <a HREF="CH05-4.html#HEADING4-3" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH05/CH05-4.html#HEADING4-3"><b>5.7.1 </b>-
    Simple Variable Declarations</a> <br>
    <a HREF="CH05-4.html#HEADING4-115" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH05/CH05-4.html#HEADING4-115"><b>5.7.2
    </b>- Using Pointer Variables</a> <br>
    <a HREF="CH05-4.html#HEADING4-225" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH05/CH05-4.html#HEADING4-225"><b>5.7.3
    </b>- Single Dimension Array Access</a> <br>
    <a HREF="CH05-4.html#HEADING4-343" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH05/CH05-4.html#HEADING4-343"><b>5.7.4
    </b>- Multidimensional Array Access</a> <br>
    <a HREF="CH05-4.html#HEADING4-465" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH05/CH05-4.html#HEADING4-465"><b>5.7.5
    </b>- Simple Structure Access</a> <br>
    <a HREF="CH05-4.html#HEADING4-556" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH05/CH05-4.html#HEADING4-556"><b>5.7.6
    </b>- Arrays of Structures</a> <br>
    <a HREF="CH05-4.html#HEADING4-685" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH05/CH05-4.html#HEADING4-685"><b>5.7.7
    </b>- Structures and Arrays as Fields of Another Structure</a> <br>
    <a HREF="CH05-4.html#HEADING4-813" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH05/CH05-4.html#HEADING4-813"><b>5.7.8
    </b>- Pointers to Structures and Arrays of Structures</a> </font></td>
    <td width="20" nowrap valign="top"></td>
    <td width="60%" valign="top"><font size="1" face="Arial">Copyright 1996 by Randall Hyde
    All rights reserved. <br>
    <br>
    Duplication other than for immediate display through a browser is prohibited by U.S.
    Copyright Law. <br>
    This material is provided on-line as a beta-test of this text. It is for the personal use
    of the reader only. If you are interested in using this material as part of a course,
    please contact rhyde@cs.ucr.edu <br>
    <br>
    Supporting software and other materials are available via anonymous ftp from
    ftp.cs.ucr.edu. See the &quot;/pub/pc/ibmpcdir&quot; directory for details. You may also
    download the material from &quot;Randall Hyde's Assembly Language Page&quot; at URL:
    http://webster.ucr.edu<br>
    <br>
    Notes: <br>
    This document does not contain the laboratory exercises, programming assignments,
    exercises, or chapter summary. These portions were omitted for several reasons: either
    they wouldn't format properly, they contained hyperlinks that were too much work to
    resolve, they were under constant revision, or they were not included for security
    reasons. Such omission should have very little impact on the reader interested in learning
    this material or evaluating this document. <br>
    <br>
    This document was prepared using Harlequin's Web Maker 2.2 and Quadralay's Webworks
    Publisher. Since HTML does not support the rich formatting options available in
    Framemaker, this document is only an approximation of the actual chapter from the
    textbook. <br>
    <br>
    If you are absolutely dying to get your hands on a version other than HTML, you might
    consider having the UCR Printing a Reprographics Department run you off a copy on their
    Xerox machines. For details, please read the following EMAIL message I received from the
    Printing and Reprographics Department: </font><blockquote>
      <p><font size="1" face="Arial">Hello Again Professor Hyde,<br>
      <br>
      Dallas gave me permission to take orders for the Computer Science 13 Manuals. We would
      need to take charge card orders. The only cards we take are: Master Card, Visa, and
      Discover. They would need to send the name, numbers, expiration date, type of card, and
      authorization to charge $95.00 for the manual and shipping, also we should have their
      phone number in case the company has any trouble delivery. They can use my e-mail address
      for the orders and I will process them as soon as possible. I would assume that two weeks
      would be sufficient for printing, packages and delivery time.<br>
      <br>
      I am open to suggestions if you can think of any to make this as easy as possible.<br>
      <br>
      Thank You for your business,<br>
      Kathy Chapman, Assistant<br>
      Printing and Reprographics University of California Riverside (909) 787-4443/4444 </font></p>
    </blockquote>
    <p><font size="1" face="Arial">We are currently working on ways to publish this text in a
    form other than HTML (e.g., Postscript, PDF, Frameviewer, hard copy, etc.). This, however,
    is a low-priority project. Please do not contact Randall Hyde concerning this effort. When
    something happens, an announcement will appear on &quot;Randall Hyde's Assembly Language
    Page.&quot; Please visit this WEB site at http://webster.ucr.edu for the latest scoop.</font></p>
    <p><font size="1" face="Arial">Redesigned 10/2000 with &quot;MS FrontPage 98&quot; using
    17&quot; monitor 1024x768<br>
    (c)&nbsp; 2000 <a href="mail%20to_%20bircom_yanoo.html">BIRCOM Entertainment'95</a></font></td>
  </tr>
</table>
</center></div>

<hr noshade size="1" color="#000000">

<p><font face="Arial" size="2">Chapter One discussed the basic format for data in memory.
Chapter Three covered how a computer system physically organizes that data. This chapter
finishes this discussion by connecting the concept of data representation to its actual
physical representation. As the title implies, this chapter concerns itself with two main
topics: variables and data structures. This chapter does not assume that you've had a
formal course in data structures, though such experience would be useful.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING1-2"></a>5.0 Chapter
    Overview</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">This chapter discusses how to declare and access scalar
variables, integers, reals, data types, pointers, arrays, and structures. You must master
these subjects before going on to the next chapter. Declaring and accessing arrays, in
particular, seems to present a multitude of problems to beginning assembly language
programmers. However, the rest of this text depends on your understanding of these data
structures and their memory representation. Do not try to skim over this material with the
expectation that you will pick it up as you need it later. You will need it right away and
trying to learn this material along with later material will only confuse you more.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING1-4"></a>5.1 Some
    Additional Instructions: LEA, LES, ADD, and MUL</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">The purpose of this chapter is not to present the 80x86
instruction set. However, there are four additional instructions (above and beyond <code>mov</code>)
that will prove handy in the discussion throughout the rest of this chapter. These are the
load effective address (<code>lea</code>), load <code>es</code> and general purpose
register (<code>les</code>), addition (<code>add</code>), and multiply (<code>mul</code>).
These instructions, along with the <code>mov</code> instruction, provide all the necessary
power to access the different data types this chapter discusses.</font></p>

<p><font face="Arial" size="2">The <code>lea </code>instruction takes the form: </font></p>

<pre><font face="Courier New" size="2">		lea	reg<em>16</em>, memory</font></pre>

<p><font face="Arial" size="2">reg<em>16</em> is a 16 bit general purpose register. Memory
is a memory location represented by a mod/reg/rm byte (except it must be a memory
location, it cannot be a register). </font></p>

<p><font face="Arial" size="2">This instruction loads the 16 bit register with the offset
of the location specified by the memory operand. <code>lea ax,1000h[bx][si],</code> for
example, would load <code>ax</code> with the address of the memory location pointed at by <code>1000h[bx][si].</code>
This, of course, is the value<code> 1000h+bx+si. Lea</code> is also quite useful for
obtaining the address of a variable. If you have a variable I somewhere in memory,<code>
lea bx,I </code>will load the <code>bx</code> register with the address (offset) of I. </font></p>

<p><font face="Arial" size="2">The <code>les</code> instruction takes the form </font></p>

<pre><font face="Courier New" size="2">		les	reg<em>16</em>, memory<em>32</em></font></pre>

<p><font face="Arial" size="2">This instruction loads the <code>es</code> register and one
of the 16 bit general purpose registers from the specified memory address. Note that any
memory address you can specify with a mod/reg/rm byte is legal but like the <code>lea</code>
instruction it must be a memory location, not a register.</font></p>

<p><font face="Arial" size="2">The <code>les</code> instruction loads the specified
general purpose register from the word at the given address, it loads the <code>es</code>
register from the following word in memory. This instruction, and it's companion <code>lds</code>
(which loads <code>ds</code>) are the only instructions on pre-80386 machines that
manipulate 32 bits at a time.</font></p>

<p><font face="Arial" size="2">The <code>add</code> instruction, like it's x86
counterpart, adds two values on the 80x86. This instruction takes several forms. There are
five forms that concern us here. They are </font></p>

<pre><font face="Courier New" size="2">                add     reg, reg
                add     reg, memory
                add     memory, reg
                add     reg, constant
                add     memory, constant</font></pre>

<p><font face="Arial" size="2">All these instructions add the second operand to the first
leaving the sum in the first operand. For example, <code>add bx,5 </code>computes<code> bx
:= bx + 5.</code></font></p>

<p><font face="Arial" size="2">The last instruction to look at is the <code>mul</code>
(multiply) instruction. This instruction has only a single operand and takes the form: </font></p>

<pre><font face="Courier New" size="2">                mul     reg/memory</font></pre>

<p><font face="Arial" size="2">There are many important details concerning <code>mul</code>
that this chapter ignores. For the sake of the discussion that follows, assume that the
register or memory location is a 16 bit register or memory location. In such a case this
instruction computes<code> dx:ax :=ax*reg/mem</code>. Note that there is no immediate mode
for this instruction.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING1-28"></a>5.2
    Declaring Variables in an Assembly Language Program</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">Although you've probably surmised that memory locations and
variables are somewhat related, this chapter hasn't gone out of its way to draw strong
parallels between the two. Well, it's time to rectify that situation. Consider the
following short (and useless) Pascal program: </font></p>

<pre><font face="Courier New" size="2">program useless(input,output);
var i,j:integer;
begin</font></pre>

<pre><font face="Courier New" size="2">        i := 10;
        write('Enter a value for j:');
        readln(j);
        i := i*j + j*j;
        writeln('The result is ',i);</font></pre>

<pre><font face="Courier New" size="2">end.</font></pre>

<p><font face="Arial" size="2">When the computer executes the statement<code> i:=10;</code>
it makes a copy of the value 10 and somehow remembers this value for use later on. To
accomplish this, the compiler sets aside a memory location specifically for the exclusive
use of the variable <code>i.</code> Assuming the compiler arbitrarily assigned location
DS:10h for this purpose it could use the instruction <code>mov ds:[10h],10 </code>to
accomplish this. If<code> i </code>is a 16 bit word, the compiler would probably assign
the variable<code> j </code>to the word starting at location 12h or 0Eh. Assuming it's
location 12h, the second assignment statement in the program might wind up looking like
the following: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, ds:[10h]    ;Fetch value of I
                mul     ds:[12h]        ;Multiply by J
                mov     ds:[10h], ax    ;Save in I (ignore overflow)
                mov     ax, ds:[12h]    ;Fetch J
                mul     ds:[12h]        ;Compute J*J
                add     ds:[10h], ax    ;Add I*J + J*J, store into I</font></pre>

<p><font face="Arial" size="2">Although there are a few details missing from this code, it
is fairly straightforward and you can easily see what is going on in this program.</font></p>

<p><font face="Arial" size="2">Now imagine a 5,000 line program like this one using
variables like ds:[10h], ds:[12h], ds:[14h], etc. Would you want to locate the statement
where you accidentally stored the result of a computation into<code> j </code>rather than<code>
i</code>? Indeed, why should you even care that the variable<code> i </code>is at location
10h and<code> j </code>is at location 12h? Why shouldn't you be able to use names like<code>
i </code>and<code> j</code> rather than worrying about these numerical addresses? It seems
reasonable to rewrite the code above as: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, i
                mul     j
                mov     i, ax
                mov     ax, j
                mul     j
                add     i, ax</font></pre>

<p><font face="Arial" size="2">Of course you can do this in assembly language! Indeed, one
of the primary jobs of an assembler like MASM is to let you use symbolic names for memory
locations. Furthermore, the assembler will even assign locations to the names
automatically for you. You needn't concern yourself with the fact that variable<code> i </code>is
really the word at memory location DS:10h unless you're curious.</font></p>

<p><font face="Arial" size="2">It should come as no surprise that <code>ds</code> will
point to the dseg segment in the SHELL.ASM file. Indeed, setting up <code>ds</code> so
that it points at dseg is one of the first things that happens in the SHELL.ASM main
program. Therefore, all you've got to do is tell the assembler to reserve some storage for
your variables in dseg and attach the offset of said variables with the names of those
variables. This is a very simple process and is the subject of the next several sections.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING1-61"></a>5.3
    Declaring and Accessing Scalar Variables</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">Scalar variables hold single values. The variables<code> i </code>and<code>
j </code>in the preceding section are examples of scalar variables. Examples of data
structures that are not scalars include arrays, records, sets, and lists. These latter
data types are made up from scalar values. They are the composite types. You'll see the
composite types a little later; first you need to learn to deal with the scalar types.</font></p>

<p><font face="Arial" size="2">To declare a variable in dseg, you would use a statement
something like the following: </font></p>

<pre><font face="Courier New" size="2">ByteVar		byte	?</font></pre>
<code>

<p><font face="Arial" size="2">ByteVar</code> is a label. It should begin at column one on
the line somewhere in the dseg segment (that is, between the <code>dseg segment </code>and
<code>dseg ends </code>statements). You'll find out all about labels in a few chapters,
for now you can assume that most legal Pascal/C/Ada identifiers are also valid assembly
language labels.</font></p>

<p><font face="Arial" size="2">If you need more than one variable in your program, just
place additional lines in the dseg segment declaring those variables. MASM will
automatically allocate a unique storage location for the variable (it wouldn't be too good
to have<code> i </code>and<code> j </code>located at the same address now, would it?).
After declaring said variable, MASM will allow you to refer to that variable by name
rather than by location in your program. For example, after inserting the above statement
into the data segment (dseg), you could use instructions like <code>mov ByteVar,al</code>
in your program.</font></p>

<p><font face="Arial" size="2">The first variable you place in the data segment gets
allocated storage at location DS:0. The next variable in memory gets allocated storage
just beyond the previous variable. For example, if the variable at location zero was a
byte variable, the next variable gets allocated storage at DS:1. However, if the first
variable was a word, the second variable gets allocated storage at location DS:2. MASM is
always careful to allocate variables in such a manner that they do not overlap. Consider
the following dseg definition: </font></p>

<pre><font face="Courier New" size="2">dseg            segment para public 'data'
bytevar         byte    ?               ;byte allocates bytes
wordvar         word    ?               ;word allocates words
dwordvar        dword   ?               ;dword allocs dbl words
byte2           byte    ?
word2           word    ?
dseg            ends</font></pre>

<p><font face="Arial" size="2">MASM allocates storage for bytevar at location DS:0.
Because bytevar is one byte long, the next available memory location is going to be DS:1.
MASM, therefore, allocates storage for wordvar at location DS:1. Since words require two
bytes, the next available memory location after wordvar is DS:3 which is where MASM
allocates storage for dwordvar. Dwordvar is four bytes long, so MASM allocates storage for
byte2 starting at location DS:7. Likewise, MASM allocates storage for word2 at location
DS:8. Were you to stick another variable after word2, MASM would allocate storage for it
at location DS:0A.</font></p>

<p><font face="Arial" size="2">Whenever you refer to one of the names above, MASM
automatically substitutes the appropriate offset. For example, MASM would translate the <code>mov
ax,wordvar</code> instruction into<code> mov ax,ds:[1].</code> So now you can use symbolic
names for your variables and completely ignore the fact that these variables are really
memory locations with corresponding offsets into the data segment.</font></p>

<p><font face="Arial" size="3"><strong><a NAME="HEADING1-79"></a>5.3.1 Declaring and using
BYTE Variables</strong></font></p>

<p><font face="Arial" size="2">So what are byte variables good for, anyway? Well you can
certainly represent any data type that has less than 256 different values with a single
byte. This includes some very important and often-used data types including the character
data type, boolean data type, most enumerated data types, and small integer data types
(signed and unsigned), just to name a few.</font></p>

<p><font face="Arial" size="2">Characters on a typical IBM compatible system use the eight
bit ASCII/IBM character set. The 80x86 provides a rich set of instructions for
manipulating character data. It's not surprising to find that most byte variables in a
typical program hold character data.</font></p>

<p><font face="Arial" size="2">The boolean data type represents only two values: true or
false. Therefore, it only takes a single bit to represent a boolean value. However, the
80x86 really wants to work with data at least eight bits wide. It actually takes extra
code to manipulate a single bit rather than a whole byte. Therefore, you should use a
whole byte to represent a boolean value. Most programmers use the value zero to represent
false and anything else (typically one) to represent true. The 80x86's zero flag makes
testing for zero/not zero very easy. Note that this choice of zero or non-zero is mainly
for convenience. You could use any two different values (or two different sets of values)
to represent true and false. </font></p>

<p><font face="Arial" size="2">Most high level languages that support enumerated data
types convert them (internally) to unsigned integers. The first item in the list is
generally item zero, the second item in the list is item one, the third is item two, etc.
For example, consider the following Pascal enumerated data type: </font></p>

<pre><font face="Courier New" size="2">colors = (red, blue, green, purple, orange, yellow, white, black);</font></pre>

<p><font face="Arial" size="2">Most Pascal compilers will assign the value zero to red,
one to blue, two to green, etc.</font></p>

<p><font face="Arial" size="2">Later, you will see how to actually create your own
enumerated data types in assembly language. All you need to learn now is how to allocate
storage for a variable that holds an enumerated value. Since it's unlikely there will be
more than 256 items enumerated by the data type, you can use a simple byte variable to
hold the value. If you have a variable, say color of type colors, using the instruction<code>
mov color,2 </code>is the same thing as saying <code>color:=green </code>in Pascal.
(Later, you'll even learn how to use more meaningful statements like<code> mov color,green
</code>to assign the color green to the color variable).</font></p>

<p><font face="Arial" size="2">Of course, if you have a small unsigned integer value
(0...255) or small signed integer (-128...127) a single byte variable is the best way to
go in most cases. Note that most programmers treat all data types except small signed
integers as unsigned values. That is, characters, booleans, enumerated types, and unsigned
integers are all usually unsigned values. In some very special cases you might want to
treat a character as a signed value, but most of the time even characters are unsigned
values.</font></p>

<p><font face="Arial" size="2">There are three main statements for declaring byte
variables in a program. They are </font></p>

<pre><font face="Courier New" size="2">identifier		db	?
identifier		byte	?
and
identifier		sbyte	?</font></pre>

<p><font face="Arial" size="2">identifier represents the name of your byte variable.
&quot;<code>db</code>&quot; is an older term that predates MASM 6.x. You will see this
directive used quite a bit by other programmers (especially those who are not using MASM
6.x or later) but Microsoft considers it to be an obsolete term; you should always use the<code>
byte </code>and<code> sbyte </code>declarations instead. </font></p>

<p><font face="Arial" size="2">The<code> byte</code> declaration declares unsigned byte
variables. You should use this declaration for all byte variables except small signed
integers. For signed integer values, use the <code>sbyte</code> (signed byte) directive. </font></p>

<p><font face="Arial" size="2">Once you declare some byte variables with these statements,
you may reference those variables within your program by their names: </font></p>

<pre><font face="Courier New" size="2">i               db      ?
j               byte    ?
k               sbyte   ?
                  .
                  .
                  .
                mov     i, 0
                mov     j, 245
                mov     k, -5
                mov     al, i
                mov     j, al
                etc.</font></pre>

<p><font face="Arial" size="2">Although MASM 6.x performs a small amount of type checking,
you should not get the idea that assembly language is a strongly typed language. In fact,
MASM 6.x will only check the values you're moving around to verify that they will fit in
the target location. All of the following are legal in MASM 6.x: </font></p>

<pre><font face="Courier New" size="2">                mov     k, 255
                mov     j, -5
                mov     i, -127</font></pre>

<p><font face="Arial" size="2">Since all of these variables are byte-sized variables, and
all the associated constants will fit into eight bits, MASM happily allows each of these
statements. Yet if you look at them, they are logically incorrect. What does it mean to
move -5 into an unsigned byte variable? Since signed byte values must be in the range
-128...127, what happens when you store the value 255 into a signed byte variable? Well,
MASM simply converts these values to their eight bit equivalents (-5 becomes 0FBh, 255
becomes 0FFh [-1], etc.).</font></p>

<p><font face="Arial" size="2">Perhaps a later version of MASM will perform stronger type
checking on the values you shove into these variables, perhaps not. However, you should
always keep in mind that it will always be possible to circumvent this checking. It's up
to you to write your programs correctly. The assembler won't help you as much as Pascal or
Ada will. Of course, even if the assembler disallowed these statements, it would still be
easy to get around the type checking. Consider the following sequence: </font></p>

<pre><font face="Courier New" size="2">                mov     al, -5
                 .
        ; Any number of statements which do not affect AL
                 .
                mov     j, al</font></pre>

<p><font face="Arial" size="2">There is, unfortunately, no way the assembler is going to
be able to tell you that you're storing an illegal value into<code> j</code>. The
registers, by their very nature, are neither signed nor unsigned. Therefore the assembler
will let you store a register into a variable regardless of the value that may be in that
register.</font></p>

<p><font face="Arial" size="2">Although the assembler does not check to see if both
operands to an instruction are signed or unsigned, it most certainly checks their size. If
the sizes do not agree the assembler will complain with an appropriate error message. The
following examples are all illegal: </font></p>

<pre><font face="Courier New" size="2">                mov     i, ax           ;Cannot move 16 bits into eight
                mov     i, 300          ;300 won't fit in eight bits.
                mov     k, -130         ;-130 won't fit into eight bits.</font></pre>

<p><font face="Arial" size="2">You might ask &quot;if the assembler doesn't really
differentiate signed and unsigned values, why bother with them? Why not simply use<code>
db </code>all the time?&quot; Well, there are two reasons. First, it makes your programs
easier to read and understand if you explicitly state (by using byte and sbyte) which
variables are signed and which are unsigned. Second, who said anything about the assembler
ignoring whether the variables are signed or unsigned? The <code>mov</code> instruction
ignores the difference, but there are other instructions that do not.</font></p>

<p><font face="Arial" size="2">One final point is worth mentioning concerning the
declaration of byte variables. In all of the declarations you've seen thus far the operand
field of the instruction has always contained a question mark. This question mark tells
the assembler that the variable should be left uninitialized when DOS loads the program
into memory. You may specify an initial value for the variable, that will be loaded into
memory before the program starts executing, by replacing the question mark with your
initial value. Consider the following byte variable declarations: </font></p>

<pre><font face="Courier New" size="2">i               db      0
j               byte    255
k               sbyte   -1</font></pre>

<p><font face="Arial" size="2">In this example, the assembler will initialize<code> i, j,</code>
and<code> k </code>to zero, 255, and -1, respectively, when the program loads into memory.
This fact will prove quite useful later on, especially when discussing tables and arrays.
Once again, the assembler only checks the sizes of the operands. It does not check to make
sure that the operand for the<code> byte </code>directive is positive or that the value in
the operand field of <code>sbyte</code> is in the range -128...127. MASM will allow any
value in the range -128...255 in the operand field of any of these statements.</font></p>

<p><font face="Arial" size="2">In case you get the impression that there isn't a real
reason to use byte vs. sbyte in a program, you should note that while MASM sometimes
ignores the differences in these definitions, Microsoft's CodeView debugger does not. If
you've declared a variable as a signed value, CodeView will display it as such (including
a minus sign, if necessary). On the other hand, CodeView will always display<code> db </code>and
<code>byte</code> variables as positive values.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING1-138"></a>5.3.2 Declaring and
using WORD Variables</font></strong></p>

<p><font face="Arial" size="2">Most 80x86 programs use word values for three things: 16
bit signed integers, 16 bit unsigned integers, and offsets (pointers). Oh sure, you can
use word values for lots of other things as well, but these three represent most
applications of the word data type. Since the word is the largest data type the 8086,
8088, 80186, 80188, and 80286 can handle, you'll find that for most programs, the word is
the basis for most computations. Of course, the 80386 and later allow 32 bit computations,
but many programs do not use these 32 bit instructions since that would limit them to
running on 80386 or later CPUs.</font></p>

<p><font face="Arial" size="2">You use the<code> dw, word,</code> and <code>sword</code>
statements to declare word variables. The following examples demonstrate their use: </font></p>

<pre><font face="Courier New" size="2">NoSignedWord            dw      ?
UnsignedWord            word    ?
SignedWord              sword   ?
Initialized0            word    0
InitializedM1           sword   -1
InitializedBig          word    65535
InitializedOfs          dw      NoSignedWord</font></pre>

<p><font face="Arial" size="2">Most of these declarations are slight modifications of the
byte declarations you saw in the last section. Of course you may initialize any word
variable to a value in the range -32768...65535 (the union of the range for signed and
unsigned 16 bit constants). The last declaration above, however, is new. In this case a
label appears in the operand field (specifically, the name of the NoSignedWord variable).
When a label appears in the operand field the assembler will substitute the offset of that
label (within the variable's segment). If these were the only declarations in dseg and
they appeared in this order, the last declaration above would initialize InitializedOfs
with the value zero since NoSignedWord's offset is zero within the data segment. This form
of initialization is quite useful for initializing pointers. But more on that subject
later.</font></p>

<p><font face="Arial" size="2">The CodeView debugger differentiates <code>dw/word</code>
variables and <code>sword</code> variables. It always displays the unsigned values as
positive integers. On the other hand, it will display <code>sword</code> variables as
signed values (complete with minus sign, if the value is negative). Debugging support is
one of the main reasons you'll want to use <code>word</code> or <code>sword</code> as
appropriate.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING1-151"></a>5.3.3 Declaring and
using DWORD Variables </font></strong></p>

<p><font face="Arial" size="2">You may use the <code>dd, dword,</code> and <code>sdword</code>
instructions to declare four-byte integers, pointers, and other variables types. Such
variables will allow values in the range -2,147,483,648...4,294,967,295 (the union of the
range of signed and unsigned four-byte integers). You use these declarations like the <code>word</code>
declarations: </font></p>

<pre><font face="Courier New" size="2">NoSignedDWord   dd      ?
UnsignedDWord   dword   ?
SignedDWord     sdword  ?
InitBig         dword   4000000000
InitNegative    sdword  -1
InitPtr         dd      InitBig</font></pre>

<p><font face="Arial" size="2">The last example initializes a double word pointer with the
segment:offset address of the InitBig variable.</font></p>

<p><font face="Arial" size="2">Once again, it's worth pointing out that the assembler
doesn't check the types of these variables when looking at the initialization values. If
the value fits into 32 bits, the assembler will accept it. Size checking, however, is
strictly enforced. Since the only 32 bit <code>mov</code> instructions on processors
earlier than the 80386 are <code>les</code> and <code>lds</code>, you will get an error if
you attempt to access dword variables on these earlier processors using a <code>mov</code>
instruction. Of course, even on the 80386 you cannot move a 32 bit variable into a 16 bit
register, you must use the 32 bit registers. Later, you'll learn how to manipulate 32 bit
variables, even on a 16 bit processor. Until then, just pretend that you can't.</font></p>

<p><font face="Arial" size="2">Keep in mind, of course, that CodeView differentiates
between <code>dd/dword</code> and <code>sdword</code>. This will help you see the actual
values your variables have when you're debugging your programs. CodeView only does this,
though, if you use the proper declarations for your variables. Always use <code>sdword</code>
for signed values and <code>dd</code> or <code>dword</code> (<code>dword</code> is best)
for unsigned values.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING1-163"></a>5.3.4 Declaring and
using FWORD, QWORD, and TBYTE Variables</font></strong></p>

<p><font face="Arial" size="2">MASM 6.x also lets you declare six-byte, eight-byte, and
ten-byte variables using the <code>df/fword</code>, <code>dq/qword</code>, and <code>dt/tbyte</code>
statements. Declarations using these statements were originally intended for floating
point and BCD values. There are better directives for the floating point variables and you
don't need to concern yourself with the other data types you'd use these directives for.
The following discussion is for completeness' sake.</font></p>

<p><font face="Arial" size="2">The <code>df/fword</code> statement's main utility is
declaring 48 bit pointers for use in 32 bit protected mode on the 80386 and later.
Although you could use this directive to create an arbitrary six byte variable, there are
better directives for doing that. You should only use this directive for 48 bit far
pointers on the 80386.</font></p>

<p><font face="Arial" size="2"><code>dq/qword </code>lets you declare quadword (eight
byte) variables. The original purpose of this directive was to let you create 64 bit
double precision floating point variables and 64 bit integer variables. There are better
directives for creating floating point variables. As for 64 bit integers, you won't need
them very often on the 80x86 CPU (at least, not until Intel releases a member of the 80x86
family with 64 bit general purpose registers).</font></p>

<p><font face="Arial" size="2">The <code>dt/tbyte</code> directives allocate ten bytes of
storage. There are two data types indigenous to the 80x87 (math coprocessor) family that
use a ten byte data type: ten byte BCD values and extended precision (80 bit) floating
point values. This text will pretty much ignore the BCD data type. As for the floating
point type, once again there is a better way to do it.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING1-168"></a>5.3.5 Declaring Floating
Point Variables with REAL4, REAL8, and REAL10</font></strong></p>

<p><font face="Arial" size="2">These are the directives you should use when declaring
floating point variables. Like <code>dd, dq, </code>and <code>dt</code> these statements
reserve four, eight, and ten bytes. The operand fields for these statements may contain a
question mark (if you don't want to initialize the variable) or it may contain an initial
value in floating point form. The following examples demonstrate their use:</font> </p>

<pre><font face="Courier New" size="2">x       real4   1.5
y       real8   1.0e-25
z       real10  -1.2594e+10</font></pre>

<p><font face="Arial" size="2">Note that the operand field must contain a valid floating
point constant using either decimal or scientific notation. In particular, pure integer
constants are not allowed. The assembler will complain if you use an operand like the
following: </font></p>

<pre><font face="Courier New" size="2">x	real4	1</font></pre>

<p><font face="Arial" size="2">To correct this, change the operand field to
&quot;1.0&quot;.</font></p>

<p><font face="Arial" size="2">Please note that it takes special hardware to perform
floating point operations (e.g., an 80x87 chip or an 80x86 with built-in math
coprocessor). If such hardware is not available, you must write software to perform
operations like floating point addition, subtraction, multiplication, etc. In particular,
you cannot use the 80x86 <code>add</code> instruction to add two floating point values.
This text will cover floating point arithmetic in a later chapter. Nonetheless, it's
appropriate to discuss how to declare floating point variables in the chapter on data
structures.</font></p>

<p><font face="Arial" size="2">MASM also lets you use <code>dd, dq, </code>and <code>dt</code>
to declare floating point variables (since these directives reserve the necessary four,
eight, or ten bytes of space). You can even initialize such variables with floating point
constants in the operand field. But there are two major drawbacks to declaring variables
this way. First, as with bytes, words, and double words, the CodeView debugger will only
display your floating point variables properly if you use the<code> real4, real8, </code>or
<code>real10</code> directives. If you use <code>dd, dq, </code>or <code>dt,</code>
CodeView will display your values as four, eight, or ten byte unsigned integers. Another,
potentially bigger, problem with using <code>dd, dq,</code> and <code>dt</code> is that
they allow both integer and floating point constant initializers (remember, <code>real4,
real8, </code>and <code>real10</code> do not). Now this might seem like a good feature at
first glance. However, the integer representation for the value one is not the same as the
floating point representation for the value 1.0. So if you accidentally enter the value
&quot;1&quot; in the operand field when you really meant &quot;1.0&quot;, the assembler
would happily digest this and then give you incorrect results. Hence, you should always
use the <code>real4, real8, </code>and <code>real10</code> statements to declare floating
point variables.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING1-180"></a>5.4
    Creating Your Own Type Names with TYPEDEF</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">Let's say that you simply do not like the names that
Microsoft decided to use for declaring byte, word, dword, real, and other variables. Let's
say that you prefer Pascal's naming convention or, perhaps, C's naming convention. You
want to use terms like integer, float, double, char, boolean, or whatever. If this were
Pascal you could redefine the names in the type section of the program. With C you could
use a &quot;#define&quot; or a typedef statement to accomplish the task. Well, MASM 6.x
has it's own typedef statement that also lets you create aliases of these names. The
following example demonstrates how to set up some Pascal compatible names in your assembly
language programs: </font></p>

<pre><font face="Courier New" size="2">integer         typedef         sword
char            typedef         byte
boolean         typedef         byte
float           typedef         real4
colors          typedef         byte</font></pre>

<p><font face="Arial" size="2">Now you can declare your variables with more meaningful
statements like: </font></p>

<pre><font face="Courier New" size="2">i               integer         ?
ch              char            ?
FoundIt         boolean         ?
x               float           ?
HouseColor      colors          ?</font></pre>

<p><font face="Arial" size="2">If you are an Ada, C, or FORTRAN programmer (or any other
language, for that matter), you can pick type names you're more comfortable with. Of
course, this doesn't change how the 80x86 or MASM reacts to these variables one iota, but
it does let you create programs that are easier to read and understand since the type
names are more indicative of the actual underlying types.</font></p>

<p><font face="Arial" size="2">Note that CodeView still respects the underlying data type.
If you define integer to be an <code>sword</code> type, CodeView will display variables of
type integer as signed values. Likewise, if you define float to mean <code>real4</code>,
CodeView will still properly display float variables as four-byte floating point values.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING1-197"></a>5.5
    Pointer Data Types</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">Some people refer to pointers as scalar data types, others
refer to them as composite data types. This text will treat them as scalar data types even
though they exhibit some tendencies of both scalar and composite data types (for a
complete description of composite data types, see &quot;Composite Data Types&quot;).</font></p>

<p><font face="Arial" size="2">Of course, the place to start is with the question
&quot;What is a pointer?&quot; Now you've probably experienced pointers first hand in the
Pascal, C, or Ada programming languages and you're probably getting worried right now.
Almost everyone has a real bad experience when they first encounter pointers in a high
level language. Well, fear not! Pointers are actually easier to deal with in assembly
language. Besides, most of the problems you had with pointers probably had nothing to do
with pointers, but rather with the linked list and tree data structures you were trying to
implement with them. Pointers, on the other hand, have lots of uses in assembly language
that have nothing to do with linked lists, trees, and other scary data structures. Indeed,
simple data structures like arrays and records often involve the use of pointers. So if
you've got some deep-rooted fear about pointers, well forget everything you know about
them. You're going to learn how great pointers really are.</font></p>

<p><font face="Arial" size="2">Probably the best place to start is with the definition of
a pointer. Just exactly what is a pointer, anyway? Unfortunately, high level languages
like Pascal tend to hide the simplicity of pointers behind a wall of abstraction. This
added complexity (which exists for good reason, by the way) tends to frighten programmers
because they don't understand what's going on.</font></p>

<p><font face="Arial" size="2">Now if you're afraid of pointers, well, let's just ignore
them for the time being and work with an array. Consider the following array declaration
in Pascal: </font></p>

<pre><font face="Courier New" size="2">	M: array [0..1023] of integer;</font></pre>

<p><font face="Arial" size="2">Even if you don't know Pascal, the concept here is pretty
easy to understand. M is an array with 1024 integers in it, indexed from<code> M[0] </code>to<code>
M[1023].</code> Each one of these array elements can hold an integer value that is
independent of all the others. In other words, this array gives you 1024 different integer
variables each of which you refer to by number (the array index) rather than by name.</font></p>

<p><font face="Arial" size="2">If you encountered a program that had the statement<code>
M[0]:=100</code> you probably wouldn't have to think at all about what is happening with
this statement. It is storing the value 100 into the first element of the array M. Now
consider the following two statements: </font></p>

<pre><font face="Courier New" size="2">	i := 0; (* Assume &quot;i&quot; is an integer variable *)
	M [i] := 100;</font></pre>

<p><font face="Arial" size="2">You should agree, without too much hesitation, that these
two statements perform the same exact operation as<code> M[0]:=100;</code>. Indeed, you're
probably willing to agree that you can use any integer expression in the range 0...1023 as
an index into this array. The following statements still perform the same operation as our
single assignment to index zero: </font></p>

<pre><font face="Courier New" size="2">        i := 5;         (* assume all variables are integers*)
        j := 10;
        k := 50;
        m [i*j-k] := 100;</font></pre>

<p><font face="Arial" size="2">&quot;Okay, so what's the point?&quot; you're probably
thinking. &quot;Anything that produces an integer in the range 0...1023 is legal. So
what?&quot; Okay, how about the following: </font></p>

<pre><font face="Courier New" size="2">	M [1] := 0;
	M [ M [1] ] := 100;</font></pre>

<p><font face="Arial" size="2">Whoa! Now that takes a few moments to digest. However, if
you take it slowly, it makes sense and you'll discover that these two instructions perform
the exact same operation you've been doing all along. The first statement stores zero into
array element <code>M[1]</code>. The second statement fetches the value of <code>M[1]</code>,
which is an integer so you can use it as an array index into M, and uses that value (zero)
to control where it stores the value 100.</font></p>

<p><font face="Arial" size="2">If you're willing to accept the above as reasonable,
perhaps bizarre, but usable nonetheless, then you'll have no problems with pointers.
Because <code>m[1] </code>is a pointer! Well, not really, but if you were to change
&quot;M&quot; to &quot;memory&quot; and treat this array as all of memory, this is the
exact definition of a pointer.</font></p>

<p><font face="Arial" size="2">A pointer is simply a memory location whose value is the
address (or index, if you prefer) of some other memory location. Pointers are very easy to
declare and use in an assembly language program. You don't even have to worry about array
indices or anything like that. In fact, the only complication you're going to run into is
that the 80x86 supports two kinds of pointers: near pointers and far pointers.</font></p>

<p><font face="Arial" size="2">A near pointer is a 16 bit value that provides an offset
into a segment. It could be any segment but you will generally use the data segment (dseg
in SHELL.ASM). If you have a word variable <code>p</code> that contains 1000h, then <code>p
</code>&quot;points&quot; at memory location 1000h in dseg. To access the word that <code>p</code>
points at, you could use code like the following: </font></p>

<pre><font face="Courier New" size="2">                mov     bx, p           ;Load BX with pointer.
                mov     ax, [bx]        ;Fetch data that p points at.</font></pre>

<p><font face="Arial" size="2">By loading the value of <code>p</code> into <code>bx</code>
this code loads the value 1000h into <code>bx</code> (assuming <code>p</code> contains
1000h and, therefore, points at memory location 1000h in dseg). The second instruction
above loads the <code>ax</code> register with the word starting at the location whose
offset appears in <code>bx</code>. Since <code>bx</code> now contains 1000h, this will
load <code>ax</code> from locations DS:1000 and DS:1001.</font></p>

<p><font face="Arial" size="2">Why not just load <code>ax</code> directly from location
1000h using an instruction like <code>mov ax,ds:[1000h]</code>? Well, there are lots of
reasons. But the primary reason is that this single instruction always loads <code>ax</code>
from location 1000h. Unless you are willing to mess around with self-modifying code, you
cannot change the location from which it loads <code>ax</code>. The previous two
instructions, however, always load <code>ax</code> from the location that <code>p</code>
points at. This is very easy to change under program control, without using self-modifying
code. In fact, the simple instruction <code>mov p,2000h</code> will cause those two
instructions above to load <code>ax</code> from memory location DS:2000 the next time they
execute. Consider the following instructions: </font></p>

<pre><font face="Courier New" size="2">                lea     bx, i           ;This can actually be done with
                mov     p, bx           ; a single instruction as you'll
                 .                      ; see in Chapter Eight.
                 .
        &lt; Some code that skips over the next two instructions &gt;</font></pre>

<pre><font face="Courier New" size="2">                lea     bx, j           ;Assume the above code skips these
                mov     p, bx           ; two instructions, that you get
                 .                      ; here by jumping to this point from
                 .                      ; somewhere else.
                mov     bx, p           ;Assume both code paths above wind
                mov     ax, [bx]        ; up down here.</font></pre>

<p><font face="Arial" size="2">This short example demonstrates two execution paths through
the program. The first path loads the variable <code>p</code> with the address of the
variable <code>i</code> (remember, <code>lea</code> loads <code>bx</code> with the offset
of the second operand). The second path through the code loads <code>p</code> with the
address of the variable<code> j</code>. Both execution paths converge on the last two <code>mov</code>
instructions that load <code>ax</code> with <code>i</code> or <code>j</code> depending
upon which execution path was taken. In many respects, this is like a parameter to a
procedure in a high level language like Pascal. Executing the same instructions accesses
different variables depending on whose address (<code>i </code>or<code> j</code>) winds up
in <code>p</code>.</font></p>

<p><font face="Arial" size="2">Sixteen bit near pointers are small, fast, and the 80x86
provides efficient access using them. Unfortunately, they have one very serious drawback -
you can only access 64K of data (one segment) when using near pointers. Far pointers
overcome this limitation at the expense of being 32 bits long. However, far pointers let
you access any piece of data anywhere in the memory space. For this reason, and the fact
that the UCR Standard Library uses far pointers exclusively, this text will use far
pointers most of the time. But keep in mind that this is a decision based on trying to
keep things simple. Code that uses near pointers rather than far pointers will be shorter
and faster.</font></p>

<p><font face="Arial" size="2">To access data referenced by a 32 bit pointer, you will
need to load the offset portion (L.O. word) of the pointer into <code>bx, bp, si,</code>
or <code>di</code> and the segment portion into a segment register (typically <code>es</code>).
Then you could access the object using the register indirect addressing mode. Since the <code>les</code>
instruction is so convenient for this operation, it is the perfect choice for loading <code>es</code>
and one of the above four registers with a pointer value. The following sample code stores
the value in <code>al</code> into the byte pointed at by the far pointer<code> p</code>: </font></p>

<pre><font face="Courier New" size="2">                les     bx, p           ;Load p into ES:BX
                mov     es:[bx], al     ;Store away AL</font></pre>

<p><font face="Arial" size="2">Since near pointers are 16 bits long and far pointers are
32 bits long, you could simply use the <code>dw/word </code>and <code>dd/dword</code>
directives to allocate storage for your pointers (pointers are inherently unsigned, so you
wouldn't normally use <code>sword</code> or <code>sdword</code> to declare a pointer).
However, there is a much better way to do this by using the <code>typedef</code>
statement. Consider the following general forms: </font></p>

<pre><font face="Courier New" size="2">typename        typedef near ptr basetype
typename        typedef far ptr basetype</font></pre>

<p><font face="Arial" size="2">In these two examples typename represents the name of the
new type you're creating while basetype is the name of the type you want to create a
pointer for. Let's look at some specific examples: </font></p>

<pre><font face="Courier New" size="2">nbytptr         typedef near ptr byte
fbytptr         typedef far ptr byte
colorsptr       typedef far ptr colors
wptr            typedef near ptr word
intptr          typedef near ptr integer
intHandle       typedef near ptr intptr</font></pre>

<p><font face="Arial" size="2">(these declarations assume that you've previously defined
the types colors and integer with the <code>typedef</code> statement). The <code>typedef</code>
statements with the near ptr operands produce 16 bit near pointers. Those with the far ptr
operands produce 32 bit far pointers. MASM 6.x ignores the base type supplied after the
near ptr or far ptr. However, CodeView uses the base type to display the object a pointer
refers to in its correct format.</font></p>

<p><font face="Arial" size="2">Note that you can use any type as the base type for a
pointer. As the last example above demonstrates, you can even define a pointer to another
pointer (a handle). CodeView would properly display the object a variable of type
intHandle points at as an address.</font></p>

<p><font face="Arial" size="2">With the above types, you can now generate pointer
variables as follows:</font></p>

<pre><font face="Courier New" size="2">bytestr         nbytptr         ?
bytestr2        fbytptr         ?
CurrentColor    colorsptr       ?
CurrentItem     wptr            ?
LastInt         intptr          ?</font></pre>

<p><font face="Arial" size="2">Of course, you can initialize these pointers at assembly
time if you know where they are going to point when the program first starts running. For
example, you could initialize the bytestr variable above with the offset of MyString using
the following declaration: </font></p>

<pre><font face="Courier New" size="2">bytestr		nbytptr	MyString</font></pre>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="../Chapter_4/CH04-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="../Chapter_4/CH04-1.html">Chapter
    Four</a></strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH05-2.html">Chapter Five</a> (Part 2) </strong></font><a href="CH05-2.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Five: Variables and Data
Structures (Part 1)<br>
26 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_5/CH05-1.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:01 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
