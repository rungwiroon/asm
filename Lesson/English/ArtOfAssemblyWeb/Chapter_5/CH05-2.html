<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_5/CH05-2.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:02 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER FIVE: VARIABLES AND DATA STRUCTURES (Part 2)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING2"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH05-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH05-1.html">Chapter Five</a> (Part 1)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH05-3.html">Chapter Five</a> (Part 3) </strong></font><a href="CH05-3.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10" colspan="2"><a NAME="HEADING2-0"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0" colspan="2"><font face="Arial" size="4"><strong>CHAPTER
    FIVE:<br>
    VARIABLES AND DATA STRUCTURES (Part 2)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10" colspan="2"></td>
  </tr>
  <tr>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING2-1"><b>5.6 </b>-
    Composite Data Types</a> <br>
    <a HREF="#HEADING2-4"><b>5.6.1 </b>- Arrays</a> <br>
    <a HREF="#HEADING2-16"><b>5.6.1.1 </b>- Declaring Arrays in Your Data Segment</a> <br>
    <a HREF="#HEADING2-55"><b>5.6.1.2 </b>- Accessing Elements of a Single Dimension Array</a>
    <br>
    <a HREF="#HEADING2-97"><b>5.6.2 </b>- Multidimensional Arrays</a> </font></td>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING2-105"><b>5.6.2.1
    </b>- Row Major Ordering</a> <br>
    <a HREF="#HEADING2-200"><b>5.6.2.2 </b>- Column Major Ordering</a> <br>
    <a HREF="#HEADING2-224"><b>5.6.2.3 </b>- Allocating Storage for Multidimensional Arrays</a>
    <br>
    <a HREF="#HEADING2-250"><b>5.6.2.4 </b>- Accessing Multidimensional Array Elements in
    Assembly Language</a> </font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="20" colspan="2"></td>
  </tr>
  <tr>
    <td width="100%" colspan="2"><strong><font face="Arial" size="3"><a NAME="HEADING2-1"></a>5.6
    Composite Data Types</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="1" colspan="2" bgcolor="#000000"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">Composite data types are those that are built up from other
(generally scalar) data types. An array is a good example of a composite data type - it is
an aggregate of elements all the same type. Note that a composite data type need not be
composed of scalar data types, there are arrays of arrays for example, but ultimately you
can decompose a composite data type into some primitive, scalar, types.</font></p>

<p><font face="Arial" size="2">This section will cover two of the more common composite
data types: arrays and records. It's a little premature to discuss some of the more
advanced composite data types. </font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-4"></a>5.6.1 Arrays</font></strong></p>

<p><font face="Arial" size="2">Arrays are probably the most commonly used composite data
type. Yet most beginning programmers have a very weak understanding of how arrays operate
and their associated efficiency trade-offs. It's surprising how many novice (and even
advanced!) programmers view arrays from a completely different perspective once they learn
how to deal with arrays at the machine level.</font></p>

<p><font face="Arial" size="2">Abstractly, an array is an aggregate data type whose
members (elements) are all the same type. Selection of a member from the array is by an
integer index. Different indices select unique elements of the array. This text assumes
that the integer indices are contiguous (though it is by no means required). That is, if
the number x is a valid index into the array and <code>y</code> is also a valid index,
with x &lt; y, then all<code> i</code> such that x &lt; i &lt; y are valid indices into
the array.</font></p>

<p><font face="Arial" size="2">Whenever you apply the indexing operator to an array, the
result is the specific array element chosen by that index. For example, <code>A[i] </code>chooses
the <code>i<em>th</em></code> element from array <code>A</code>. Note that there is no
formal requirement that element <code>i </code>be anywhere near element <code>i+1</code>
in memory. As long as <code>A[i]</code> always refers to the same memory location and <code>A[i+1]</code>
always refers to its corresponding location (and the two are different), the definition of
an array is satisfied.</font></p>

<p><font face="Arial" size="2">In this text, arrays occupy contiguous locations in memory.
An array with five elements will appear in memory as shown below:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch05a.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH05/ch05a.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="332" HEIGHT="90"> </font></p>

<p><font face="Arial" size="2">The base address of an array is the address of the first
element on the array and always appears in the lowest memory location. The second array
element directly follows the first in memory, the third element follows the second, etc.
Note that there is no requirement that the indices start at zero. They may start with any
number as long as they are contiguous. However, for the purposes of discussion, it's
easier to discuss accessing array elements if the first index is zero. This text generally
begins most arrays at index zero unless there is a good reason to do otherwise. However,
this is for consistency only. There is no efficiency benefit one way or another to
starting the array index at some value other than zero.</font></p>

<p><font face="Arial" size="2">To access an element of an array, you need a function that
converts an array index into the address of the indexed element. For a single dimension
array, this function is very simple. It is </font></p>

<pre><font face="Courier New" size="2">Element_Address = Base_Address + ((Index - Initial_Index) * Element_Size)</font></pre>

<p><font face="Arial" size="2">where <code>Initial_Index</code> is the value of the first
index in the array (which you can ignore if zero) and the value<code> Element_Size</code>
is the size, in bytes, of an individual element of the array.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-16"></a>5.6.1.1 Declaring Arrays
in Your Data Segment</font></strong></p>

<p><font face="Arial" size="2">Before you access elements of an array, you need to set
aside storage for that array. Fortunately, array declarations build on the declarations
you've seen so far. To allocate n elements in an array, you would use a declaration like
the following:</font> </p>

<pre><font face="Courier New" size="2">arrayname		basetype		n dup (?)</font></pre>

<p><font face="Arial" size="2">Arrayname is the name of the array variable and basetype is
the type of an element of that array. This sets aside storage for the array. To obtain the
base address of the array, just use arrayname.</font></p>

<p><font face="Arial" size="2">The<code> n dup (?) </code>operand tells the assembler to
duplicate the object inside the parentheses n times. Since a question mark appears inside
the parentheses, the definition above would create n occurrences of an uninitialized
value. Now let's look at some specific examples: </font></p>

<pre><font face="Courier New" size="2">CharArray       char    128 dup (?)     ;array[0..127] of char
IntArray        integer 8 dup (?)       ;array[0..7] of integer
BytArray        byte    10 dup (?)      ;array[0..9] of byte
PtrArray        dword   4 dup (?)       ;array[0..3] of dword</font></pre>

<p><font face="Arial" size="2">The first two examples, of course, assume that you've used
the <code>typedef</code> statement to define the <code>char</code> and <code>integer</code>
data types.</font></p>

<p><font face="Arial" size="2">These examples all allocate storage for uninitialized
arrays. You may also specify that the elements of the arrays be initialized to a single
value using declarations like the following: </font></p>

<pre><font face="Courier New" size="2">RealArray       real4   8 dup (1.0)
IntegerAry      integer 8 dup (1)</font></pre>

<p><font face="Arial" size="2">These definitions both create arrays with eight elements.
The first definition initializes each four-byte real value to 1.0, the second declaration
initializes each integer element to one.</font></p>

<p><font face="Arial" size="2">This initialization mechanism is fine if you want each
element of the array to have the same value. What if you want to initialize each element
of the array with a (possibly) different value? Well, that is easily handled as well. The
variable declaration statements you've seen thus far offer yet another initialization
form: </font></p>

<pre><font face="Courier New" size="2">name            type    value1, value2, value3, ..., valuen</font></pre>

<p><font face="Arial" size="2">This form allocates n variables of type type. It
initializes the first item to value<em>1</em>, the second item to value<em>2</em>, etc. So
by simply enumerating each value in the operand field, you can create an array with the
desired initial values. In the following integer array, for example, each element contains
the square of its index: </font></p>

<pre><font face="Courier New" size="2">Squares         integer 0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100</font></pre>

<p><font face="Arial" size="2">If your array has more elements than will fit on one line,
there are several ways to continue the array onto the next line. The most straight-forward
method is to use another integer statement but without a label: </font></p>

<pre><font face="Courier New" size="2">Squares         integer 0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100
                integer 121, 144, 169, 196, 225, 256, 289, 324
                integer 361, 400</font></pre>

<p><font face="Arial" size="2">Another option, that is better in some circumstances, is to
use a backslash at the end of each line to tell MASM 6.x to continue reading data on the
next line: </font></p>

<pre><font face="Courier New" size="2">Squares         integer 0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, \
                        121, 144, 169, 196, 225, 256, 289, 324, \
                        361, 400</font></pre>

<p><font face="Arial" size="2">Of course, if your array has several thousand elements in
it, typing them all in will not be very much fun. Most arrays initialized this way have no
more than a couple hundred entries, and generally far less than 100.</font></p>

<p><font face="Arial" size="2">You need to learn about one final technique for
initializing single dimension arrays before moving on. Consider the following declaration:
</font></p>

<pre><font face="Courier New" size="2">BigArray		word	256 dup (0,1,2,3)</font></pre>

<p><font face="Arial" size="2">This array has 1024 elements, not 256. The <code>n dup
(xxxx) </code>operand tells MASM to duplicate <code>xxxx</code> n times, not create an
array with n elements. If <code>xxxx</code> consists of a single item, then the <code>dup</code>
operator will create an n element array. However, if <code>xxxx</code> contains two items
separated by a comma, the <code>dup</code> operator will create an array with 2*n
elements. If <code>xxxx</code> contains three items separated by commas, the <code>dup</code>
operator creates an array with 3*n items, and so on. Since there are four items in the
parentheses above, the <code>dup</code> operator creates 256*4 or 1024 items in the array.
The values in the array will initially be 0 1 2 3 0 1 2 3 0 1 2 3 0 1 2 3 ...</font></p>

<p><font face="Arial" size="2">You will see some more possibilities with the <code>dup</code>
operator when looking at multidimensional arrays a little later.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-55"></a>5.6.1.2 Accessing
Elements of a Single Dimension Array</font></strong></p>

<p><font face="Arial" size="2">To access an element of a zero-based array, you can use the
simplified formula:</font></p>

<p><font face="Arial" size="2">Element_Address = Base_Address + index * Element_Size</font></p>

<p><font face="Arial" size="2">For the <code>Base_Address</code> entry you can use the
name of the array (since MASM associates the address of the first operand with the label).
The <code>Element_Size </code>entry is the number of bytes for each array element. If the
object is an array of bytes, the <code>Element_Size</code> field is one (resulting in a
very simple computation). If each element of the array is a word (or integer, or other
two-byte type) then <code>Element_Size is</code> two. And so on. To access an element of
the <code>Squares</code> array in the previous section, you'd use the formula:</font></p>

<p><font face="Arial" size="2">Element_Address = Squares + index*2</font></p>

<p><font face="Arial" size="2">The 80x86 code equivalent to the statement <code>AX:=Squares[index]</code>
is </font></p>

<pre><font face="Courier New" size="2">                mov     bx, index
                add     bx, bx          ;Sneaky way to compute 2*bx
                mov     ax, Squares [bx]</font></pre>

<p><font face="Arial" size="2">There are two important things to notice here. First of
all, this code uses the <code>add</code> instruction rather than the <code>mul</code>
instruction to compute 2*index. The main reason for choosing <code>add</code> is that it
was more convenient (remember, <code>mul</code> doesn't work with constants and it only
operates on the <code>ax</code> register). It turns out that <code>add</code> is a lot
faster than <code>mul </code>on many processors, but since you probably didn't know that,
it wasn't an overriding consideration in the choice of this instruction.</font></p>

<p><font face="Arial" size="2">The second thing to note about this instruction sequence is
that it does not explicitly compute the sum of the base address plus the index times two.
Instead, it relies on the indexed addressing mode to implicitly compute this sum. The
instruction <code>mov ax, Squares[bx] </code>loads <code>ax</code> from location <code>Squares+bx
</code>which is the base address plus index*2 (since <code>bx</code> contains index*2).
Sure, you could have used </font></p>

<pre><font face="Courier New" size="2">                lea     ax, Squares
                add     bx, ax
                mov     ax, [bx]</font></pre>

<p><font face="Arial" size="2">in place of the last instruction, but why use three
instructions where one will do the same job? This is a good example of why you should know
your addressing modes inside and out. Choosing the proper addressing mode can reduce the
size of your program, thereby speeding it up.</font></p>

<p><font face="Arial" size="2">The indexed addressing mode on the 80x86 is a natural for
accessing elements of a single dimension array. Indeed, it's syntax even suggests an array
access. The only thing to keep in mind is that you must remember to multiply the index by
the size of an element. Failure to do so will produce incorrect results.</font></p>

<p><font face="Arial" size="2">If you are using an 80386 or later, you can take advantage
of the scaled indexed addressing mode to speed up accessing an array element even more.
Consider the following statements: </font></p>

<pre><font face="Courier New" size="2">                mov     ebx, index              ;Assume a 32 bit value.
                mov     ax, Squares [ebx*2]</font></pre>

<p><font face="Arial" size="2">This brings the instruction count down to two instructions.
You'll soon see that two instructions aren't necessarily faster than three instructions,
but hopefully you get the idea. Knowing your addressing modes can surely help.</font></p>

<p><font face="Arial" size="2">Before moving on to multidimensional arrays, a couple of
additional points about addressing modes and arrays are in order. The above sequences work
great if you only access a single element from the <code>Squares</code> array. However, if
you access several different elements from the array within a short section of code, and
you can afford to dedicate another register to the operation, you can certainly shorten
your code and, perhaps, speed it up as well. The <code>mov ax,Squares[BX] </code>instruction
is four bytes long (assuming you need a two-byte displacement to hold the offset to <code>Squares</code>
in the data segment). You can reduce this to a two byte instruction by using the
base/indexed addressing mode as follows: </font></p>

<pre><font face="Courier New" size="2">                lea     bx, Squares
                mov     si, index
                add     si, si
                mov     ax, [bx][si]</font></pre>

<p><font face="Arial" size="2">Now <code>bx</code> contains the base address and <code>si</code>
contains the index*2 value. Of course, this just replaced a single four-byte instruction
with a three-byte and a two-byte instruction, hardly a good trade-off. However, you do not
have to reload <code>bx</code> with the base address of <code>Squares</code> for the next
access. The following sequence is one byte shorter than the comparable sequence that
doesn't load the base address into <code>bx</code>: </font></p>

<pre><font face="Courier New" size="2">                lea     bx, Squares
                mov     si, index
                add     si, si
                mov     ax, [bx][si]
                 .
                 .                      ;Assumption: BX is left alone 
                 .                      ; through this code.
                mov     si, index2
                add     si, si
                mov     cx, [bx][si]</font></pre>

<p><font face="Arial" size="2">Of course the more accesses to <code>Squares</code> you
make without reloading <code>bx</code>, the greater your savings will be. Tricky little
code sequences such as this one sometimes pay off handsomely. However, the savings depend
entirely on which processor you're using. Code sequences that run faster on an 8086 might
actually run slower on an 80486 (and vice versa). Unfortunately, if speed is what you're
after there are no hard and fast rules. In fact, it is very difficult to predict the speed
of most instructions on the simple 8086, even more so on processors like the 80486 and
Pentium/80586 that offer pipelining, on-chip caches, and even superscalar operation. </font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-97"></a>5.6.2 Multidimensional
Arrays</font></strong></p>

<p><font face="Arial" size="2">The 80x86 hardware can easily handle single dimension
arrays. Unfortunately, there is no magic addressing mode that lets you easily access
elements of multidimensional arrays. That's going to take some work and lots of
instructions.</font></p>

<p><font face="Arial" size="2">Before discussing how to declare or access multidimensional
arrays, it would be a good idea to figure out how to implement them in memory. The first
problem is to figure out how to store a multi-dimensional object into a one-dimensional
memory space.</font></p>

<p><font face="Arial" size="2">Consider for a moment a Pascal array of the form <code>A:array[0..3,0..3]
of char</code>. This array contains 16 bytes organized as four rows of four characters.
Somehow you've got to draw a correspondence with each of the 16 bytes in this array and 16
contiguous bytes in main memory. The figure below shows one way to do this.</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch05a1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH05/ch05a1.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="224" HEIGHT="199"> </font></p>

<p><font face="Arial" size="2">The actual mapping is not important as long as two things
occur: (1) each element maps to a unique memory location (that is, no two entries in the
array occupy the same memory locations) and (2) the mapping is consistent. That is, a
given element in the array always maps to the same memory location. So what you really
need is a function with two input parameters (row and column) that produces an offset into
a linear array of sixteen bytes.</font></p>

<p><font face="Arial" size="2">Now any function that satisfies the above constraints will
work fine. Indeed, you could randomly choose a mapping as long as it was unique. However,
what you really want is a mapping that is efficient to compute at run time and works for
any size array (not just 4x4 or even limited to two dimensions). While there are a large
number of possible functions that fit this bill, there are two functions in particular
that most programmers and most high level languages use: row major ordering and column
major ordering.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-105"></a>5.6.2.1 Row Major
Ordering</font></strong></p>

<p><font face="Arial" size="2">Row major ordering assigns successive elements, moving
across the rows and then down the columns, to successive memory locations. The mapping is
best describedby the diagram:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch05a2.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH05/ch05a2.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="271" HEIGHT="213"> </font></p>

<p><font face="Arial" size="2">Row major ordering is the method employed by most high
level programming languages including Pascal, C, Ada, Modula-2, etc. It is very easy to
implement and easy to use in machine language (especially within a debugger such as
CodeView). The conversion from a two-dimensional structure to a linear array is very
intuitive. You start with the first row (row number zero) and then concatenate the second
row to its end. You then concatenate the third row to the end of the list, then the fourth
row, etc:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch05a3.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH05/ch05a3.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="362" HEIGHT="156"> </font></p>

<p><font face="Arial" size="2">For those who like to think in terms of program code, the
following nested Pascal loop also demonstrates how row major ordering works: </font></p>

<pre><font face="Courier New" size="2">index := 0;
for colindex := 0 to 3 do
        for rowindex := 0 to 3 do 
        begin

                memory [index] := rowmajor [colindex][rowindex];
                index := index + 1;
        end;</font></pre>

<p><font face="Arial" size="2">The important thing to note from this code, that applies
across the board to row major order no matter how many dimensions it has, is that the
rightmost index increases the fastest. That is, as you allocate successive memory
locations you increment the rightmost index until you reach the end of the current row.
Upon reaching the end, you reset the index back to the beginning of the row and increment
the next successive index by one (that is, move down to the next row.). This works equally
well for any number of dimensions. The following Pascal segment demonstrates row major
organization for a 4x4x4 array: </font></p>

<pre><font face="Courier New" size="2">index := 0;
for depthindex := 0 to 3 do
        for colindex := 0 to 3 do
           for rowindex := 0 to 3 do begin

                memory [index] := rowmajor [depthindex][colindex][rowindex];
                index := index + 1;

           end;</font></pre>

<p><font face="Arial" size="2">The actual function that converts a list of index values
into an offset doesn't involve loops or much in the way of fancy computations. Indeed,
it's a slight modification of the formula for computing the address of an element of a
single dimension array. The formula to compute the offset for a two-dimension row major
ordered array declared as <code>A:array [0..3,0..3] of integer </code>is </font></p>

<pre><font face="Courier New" size="2">Element_Address = Base_Address + (colindex * row_size + rowindex) * Element_Size</font></pre>

<p><font face="Arial" size="2">As usual, <code>Base_Address</code> is the address of the
first element of the array (<code>A[0][0]</code> in this case) and <code>Element_Size</code>
is the size of an individual element of the array, in bytes. <code>Colindex</code> is the
leftmost index, <code>rowindex </code>is the rightmost index into the array. <code>Row_size</code>
is the number of elements in one row of the array (four, in this case, since each row has
four elements). Assuming <code>Element_Size</code> is one, This formula computes the
following offsets from the base address: </font></p>

<pre><font face="Courier New" size="2">Column Index         Row Index  Offset into Array
        0               0               0
        0               1               1
        0               2               2
        0               3               3
        1               0               4
        1               1               5
        1               2               6
        1               3               7
        2               0               8
        2               1               9
        2               2               10
        2               3               11
        3               0               12
        3               1               13
        3               2               14
        3               3               15</font></pre>

<p><font face="Arial" size="2">For a three-dimensional array, the formula to compute the
offset into memory is the following: </font></p>

<pre><font face="Courier New" size="2">Address = Base + ((depthindex*col_size+colindex) * row_size + rowindex) * Element_Size</font></pre>
<code>

<p><font face="Arial" size="2">Col_size </code>is the number of items in a column,<code>
row_size</code> is the number of items in a row. In Pascal, if you've declared the array
as &quot;<code>A:array [i..j] [k..l] [m..n] of type;</code>&quot; then <code>row_size</code>
is equal to<code> n-m+1 </code>and <code>col_size</code> is equal to <code>l-k+1</code>.</font></p>

<p><font face="Arial" size="2">For a four dimensional array, declared as &quot;<code>A:array
[g..h] [i..j] [k..l] [m..n] of type;</code>&quot; the formula for computing the address of
an array element is </font></p>

<p><font face="Courier New" size="2">Address = Base + (((LeftIndex * depth_size +
depthindex)*col_size+colindex) * row_size + rowindex) * Element_Size</font></p>

<p><font face="Arial" size="2"><code>Depth_size </code>is equal to<code> i-j+1</code>, <code>col_size
</code>and <code>row_size </code>are the same as before. <code>LeftIndex</code> represents
the value of the leftmost index.</font></p>

<p><font face="Arial" size="2">By now you're probably beginning to see a pattern. There is
a generic formula that will compute the offset into memory for an array with any number of
dimensions, however, you'll rarely use more than four.</font></p>

<p><font face="Arial" size="2">Another convenient way to think of row major arrays is as
arrays of arrays. Consider the following single dimension array definition: </font></p>

<pre><font face="Courier New" size="2">A: array [0..3] of sometype;</font></pre>

<p><font face="Arial" size="2">Assume that sometype is the type &quot;<code>sometype =
array [0..3] of char;</code>&quot;.</font></p>

<p><font face="Arial" size="2"><code>A</code> is a single dimension array. Its individual
elements happen to be arrays, but you can safely ignore that for the time being. The
formula to compute the address of an element of a single dimension array is </font></p>

<pre><font face="Courier New" size="2">Element_Address = Base + Index * Element_Size</font></pre>

<p><font face="Arial" size="2">In this case <code>Element_Size</code> happens to be four
since each element of <code>A</code> is an array of four characters. So what does this
formula compute? It computes the base address of each row in this 4x4 array of characters:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch05a4.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH05/ch05a4.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="197" HEIGHT="171"> </font></p>

<p><font face="Arial" size="2">Of course, once you compute the base address of a row, you
can reapply the single dimension formula to get the address of a particular element. While
this doesn't affect the computation at all, conceptually it's probably a little easier to
deal with several single dimension computations rather than a complex multidimensional
array element address computation.</font></p>

<p><font face="Arial" size="2">Consider a Pascal array defined as &quot;<code>A:array
[0..3] [0..3] [0..3] [0..3] [0..3] of char;</code>&quot; You can view this five-dimension
array as a single dimension array of arrays: </font></p>

<pre><font face="Courier New" size="2">type
        OneD = array [0..3] of char;
        TwoD = array [0..3] of OneD;
        ThreeD = array [0..3] of TwoD;
        FourD = array [0..3] of ThreeD;
var
        A : array [0..3] of FourD;</font></pre>

<p><font face="Arial" size="2">The size of <code>OneD</code> is four bytes. Since <code>TwoD</code>
contains four <code>OneD</code> arrays, its size is 16 bytes. Likewise, <code>ThreeD</code>
is four <code>TwoDs</code>, so it is 64 bytes long. Finally, <code>FourD</code> is four <code>ThreeDs</code>,
so it is 256 bytes long. To compute the address of &quot;<code>A [b] [c] [d] [e] [f]</code>&quot;
you could use the following steps: </font>

<ul>
  <li><font face="Arial" size="2">Compute the address of A [b] as &quot;Base + b * size&quot;.
    Here size is 256 bytes. Use this result as the new base address in the next computation.</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Compute the address of A [b] [c] by the formula &quot;Base +
    c*size&quot;, where Base is the value obtained immediately above and size is 64. Use the
    result as the new base in the next computation.</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Compute the address of A [b] [c] [d] by &quot;Base +
    d*size&quot; with Base coming from the above computation and size being 16.</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Compute the address of A [b] [c] [d] [e] with the formula
    &quot;Base + e*size&quot; with Base from above and size being four. Use this value as the
    base for the next computation.</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Finally, compute the address of A [b] [c] [d] [e] [f] using
    the formula &quot;Base + f*size&quot; where base comes from the above computation and size
    is one (obviously you can simply ignore this final multiplication). The result you obtain
    at this point is the address of the desired element. </font></li>
</ul>

<p><font face="Arial" size="2">Not only is this scheme easier to deal with than the fancy
formulae from above, but it is easier to compute (using a single loop) as well. Suppose
you have two arrays initialized as follows</font></p>

<p><font face="Arial" size="2">A1 = {256, 64, 16, 4, 1} and A2 = {b, c, d, e, f}</font></p>

<p><font face="Arial" size="2">then the Pascal code to perform the element address
computation becomes: </font></p>

<pre><font face="Courier New" size="2">	for i := 0 to 4 do
		base := base + A1[i] * A2[i];</font></pre>

<p><font face="Arial" size="2">Presumably <code>base</code> contains the base address of
the array before executing this loop. Note that you can easily extend this code to any
number of dimensions by simply initializing <code>A1</code> and <code>A2</code>
appropriately and changing the ending value of the for loop.</font></p>

<p><font face="Arial" size="2">As it turns out, the computational overhead for a loop like
this is too great to consider in practice. You would only use an algorithm like this if
you needed to be able to specify the number of dimensions at run time. Indeed, one of the
main reasons you won't find higher dimension arrays in assembly language is that assembly
language displays the inefficiencies associated with such access. It's easy to enter
something like &quot;<code>A [b,c,d,e,f]</code>&quot; into a Pascal program, not realizing
what the compiler is doing with the code. Assembly language programmers are not so
cavalier - they see the mess you wind up with when you use higher dimension arrays.
Indeed, good assembly language programmers try to avoid two dimension arrays and often
resort to tricks in order to access data in such an array when its use becomes absolutely
mandatory. But more on that a little later.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-200"></a>5.6.2.2 Column Major
Ordering</font></strong></p>

<p><font face="Arial" size="2">Column major ordering is the other function frequently used
to compute the address of an array element. FORTRAN and various dialects of BASIC (e.g.,
Microsoft) use this method to index arrays.</font></p>

<p><font face="Arial" size="2">In row major ordering the rightmost index increased the
fastest as you moved through consecutive memory locations. In column major ordering the
leftmost index increases the fastest. Pictorially, a column major ordered array is
organized as shown below:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch05a5.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH05/ch05a5.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="271" HEIGHT="213"> </font></p>

<p><font face="Arial" size="2">The formulae for computing the address of an array element
when using column major ordering is very similar to that for row major ordering. You
simply reverse the indexes and sizes in the computation:</font></p>

<p><font face="Arial" size="2">For a two-dimension column major array: </font></p>
<font face="Courier New" size="2">

<p>Element_Address = Base_Address + (rowindex * col_size + colindex) * Element_Size</font>
</p>

<p>For a three-dimension column major array: </p>

<pre><font face="Courier New" size="2">Address = Base + ((rowindex*col_size+colindex) * depth_size + depthindex) * Element_Size</font></pre>

<p>For a four-dimension column major array: </p>

<p><font face="Courier New" size="2">Address = Base + (((rowindex * col_size +
colindex)*depth_size+depthindex) * Left_size + Leftindex) * Element_Size</font></p>

<p><font face="Arial" size="2">The single Pascal loop provided for row major access
remains unchanged (to access <code>A [b] [c] [d] [e] [f]</code>): </font></p>

<pre><font face="Courier New" size="2">	for i := 0 to 4 do
		base := base + A1[i] * A2[i];</font></pre>

<p><font face="Arial" size="2">Likewise, the initial values of the A1 array remain
unchanged: </font></p>

<pre><font face="Courier New" size="2">	A1 = {256, 64, 16, 4, 1}</font></pre>

<p><font face="Arial" size="2">The only thing that needs to change is the initial values
for the A2 array, and all you have to do here is reverse the order of the indices: </font></p>

<pre><font face="Courier New" size="2">	A2 = {f, e, d, c, b}</font></pre>

<h3><strong><font face="Arial" size="3"><a name="HEADING2-224"></a>5.6.2.3 Allocating
Storage for Multidimensional Arrays</font></strong></h3>

<p><font face="Arial" size="2">If you have an m x n array, it will have m * n elements and
require m*n*Element_Size bytes of storage. To allocate storage for an array you must
reserve this amount of memory. As usual, there are several different ways of accomplishing
this task. This text will try to take the approach that is easiest to read and understand
in your programs.</font></p>

<p><font face="Arial" size="2">Reconsider the <code>dup</code> operator for reserving
storage. <code>n dup (xxxx) </code>replicates <code>xxxx</code> n times. As you saw
earlier, this <code>dup</code> operator allows not just one, but several items within the
parentheses and it duplicates everything inside the specified number of times. In fact,
the <code>dup</code> operator allows anything that you might normally expect to find in
the operand field of a <code>byte</code> statement including additional occurrences of the
<code>DUP</code> operator. Consider the following statement: </font></p>

<pre><font face="Courier New" size="2">A       byte    4 dup (4 dup (?))</font></pre>

<p><font face="Arial" size="2">The first <code>dup</code> operator repeats everything
inside the parentheses four times. Inside the parentheses the<code> 4 DUP (?) </code>operation
tells MASM to set aside storage for four bytes. Four copies of four bytes yields 16 bytes,
the number necessary for a 4 x 4 array. Of course, to reserve storage for this array you
could have just as easily used the statement:</font> </p>

<pre><font face="Courier New" size="2">A	byte	16 dup (?)</font></pre>

<p><font face="Arial" size="2">Either way the assembler is going to set aside 16
contiguous bytes in memory. As far as the 80x86 is concerned, there is no difference
between these two forms. On the other hand, the former version provides a better
indication that <code>A</code> is a 4 x 4 array than the latter version. The latter
version looks like a single dimension array with 16 elements.</font></p>

<p><font face="Arial" size="2">You can very easily extend this concept to arrays of higher
arity as well. The declaration for a three dimension array, <code>A:array [0..2, 0..3,
0..4] of integer </code>might be </font></p>

<pre><font face="Courier New" size="2">A	integer	3 dup (4 dup (5 dup (?)))</font></pre>

<p><font face="Arial" size="2">(of course, you will need the<code> integer typedef word </code>statement
in your program for this to work.)</font></p>

<p><font face="Arial" size="2">As was the case with single dimension arrays, you may
initialize every element of the array to a specific value by replacing the question mark
(?) with some particular value. For example, to initialize the above array so that each
element contains one you'd use the code: </font></p>

<pre><font face="Courier New" size="2">A	integer	3 dup (4 dup (5 dup (1)))</font></pre>

<p><font face="Arial" size="2">If you want to initialize each element of the array to a
different value, you'll have to enter each value individually. If the size of a row is
small enough, the best way to approach this task is to place the data for each row of an
array on its own line. Consider the following 4x4 array declaration: </font></p>

<pre><font face="Courier New" size="2">A       integer 0,1,2,3
        integer 1,0,1,1
        integer 5,7,2,2
        integer 0,0,7,6</font></pre>

<p><font face="Arial" size="2">Once again, the assembler doesn't care where you split the
lines, but the above is much easier to identify as a 4x4 array than the following that
emits the exact same data:</font> </p>

<pre><font face="Courier New" size="2">A	integer	0,1,2,3,1,0,1,1,5,7,2,2,0,0,7,6</font></pre>

<p><font face="Arial" size="2">Of course, if you have a large array, an array with really
large rows, or an array with many dimensions, there is little hope for winding up with
something reasonable. That's when comments that carefully explain everything come in
handy.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-250"></a>5.6.2.4 Accessing
Multidimensional Array Elements in Assembly Language</font></strong></p>

<p><font face="Arial" size="2">Well, you've seen the formulae for computing the address of
an array element. You've even looked at some Pascal code you could use to access elements
of a multidimensional array. Now it's time to see how to access elements of those arrays
using assembly language.</font></p>

<p><font face="Arial" size="2">The<code> mov, add,</code> and <code>mul</code>
instructions make short work of the various equations that compute offsets into
multidimensional arrays. Let's consider a two dimension array first: </font></p>

<pre><font face="Courier New" size="2">; Note: TwoD's row size is 16 bytes.

TwoD            integer 4 dup (8 dup (?))
i               integer ?
j               integer ?

                 .      .
                 .      .
                 .      .

; To peform the operation TwoD[i,j] := 5; you'd use the code:

                mov     ax, 8           ;8 elements per row
                mul     i
                add     ax, j
                add     ax, ax          ;Multiply by element size (2)
                mov     bx, ax          ;Put in a register we can use
                mov     TwoD [bx], 5</font></pre>

<p><font face="Arial" size="2">Of course, if you have an 80386 chip (or better), you could
use the following code: </font></p>

<pre><font face="Courier New" size="2">                mov     eax, 8          ;Zeros H.O. 16 bits of EAX.
                mul     i
                add     ax, j
                mov     TwoD[eax*2], 5</font></pre>

<p><font face="Arial" size="2">Note that this code does not require the use of a two
register addressing mode on the 80x86. Although an addressing mode like <code>TwoD
[bx][si] </code>looks like it should be a natural for accessing two dimensional arrays,
that isn't the purpose of this addressing mode.</font></p>

<p><font face="Arial" size="2">Now consider a second example that uses a three dimension
array: </font></p>

<pre><font face="Courier New" size="2">ThreeD          integer 4 dup (4 dup (4 dup (?)))
i               integer ?
j               integer ?
k               integer ?

                 .      .
                 .      .
                 .      .

; To peform the operation ThreeD[i,j,k] := 1; you'd use the code:

                mov     bx, 4           ;4 elements per column
                mov     ax, i
                mul     bx
                add     ax, j
                mul     bx              ;4 elements per row
                add     ax, k
                add     ax, ax          ;Multiply by element size (2)
                mov     bx, ax          ;Put in a register we can use
                mov     ThreeD [bx], 1</font></pre>

<p><font face="Arial" size="2">Of course, if you have an 80386 or better processor, this
can be improved somewhat by using the following code: </font></p>

<pre><font face="Courier New" size="2">                mov     ebx, 4
                mov     eax, ebx
                mul     i
                add     ax, j
                mul     bx
                add     k
                mov     ThreeD[eax*2], 1</font></pre>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH05-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH05-1.html">Chapter Five</a> (Part 1)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH05-3.html">Chapter Five</a> (Part 3) </strong></font><a href="CH05-3.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Five: Variables and Data
Structures (Part 2)<br>
26 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_5/CH05-2.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:11 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
