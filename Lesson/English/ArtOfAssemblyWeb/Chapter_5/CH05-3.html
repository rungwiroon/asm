<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_5/CH05-3.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:12 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER FIVE: VARIABLES AND DATA STRUCTURES (Part 3)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING3"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH05-2.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH05-2.html">Chapter Five</a> (Part 2)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH05-4.html">Chapter Five</a> (Part 4) </strong></font><a href="CH05-4.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10"><a NAME="HEADING3-0"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0"><font face="Arial" size="4"><strong>CHAPTER FIVE:<br>
    VARIABLES AND DATA STRUCTURES (Part 3)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10"></td>
  </tr>
  <tr>
    <td width="100%"><font face="Arial" size="2"><a HREF="#HEADING3-1"><b>5.6.3 </b>-
    Structures</a><br>
    <a HREF="#HEADING3-59"><b>5.6.4 </b>- Arrays of Structures and Arrays/Structures as
    Structure Fields</a> <br>
    <a HREF="#HEADING3-109"><b>5.6.5 </b>- Pointers to Structures</a> </font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="20"><font face="Arial" size="2"></font></td>
  </tr>
</table>
</center></div>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-1"></a>5.6.3 Structures</font></strong></p>

<p><font face="Arial" size="2">The second major composite data structure is the Pascal
record or C structure. The Pascal terminology is probably better, since it tends to avoid
confusion with the more general term data structure. However, MASM uses
&quot;structure&quot; so it doesn't make sense to deviate from this. Furthermore, MASM
uses the term record to denote something slightly different, furthering the reason to
stick with the term structure.</font></p>

<p><font face="Arial" size="2">Whereas an array is homogeneous, whose elements are all the
same, the elements in a structure can be of any type. Arrays let you select a particular
element via an integer index. With structures, you must select an element (known as a
field) by name.</font></p>

<p><font face="Arial" size="2">The whole purpose of a structure is to let you encapsulate
different, but logically related, data into a single package. The Pascal record
declaration for a student is probably the most typical example: </font></p>

<p><font face="Courier New" size="2">student = record<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Name:
string [64];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Major:
integer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SSN:
&nbsp;&nbsp; string[11];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Midterm1:
integer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Midterm2:
integer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Final:
integer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Homework:
integer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Projects:
integer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end;</font></p>

<p><font face="Arial" size="2">Most Pascal compilers allocate each field in a record to
contiguous memory locations. This means that Pascal will reserve the first 65 bytes for
the name, the next two bytes hold the major code, the next 12 the Social Security Number,
etc.</font></p>

<p><font face="Arial" size="2">In assembly language, you can also create structure types
using the MASM <code>struct</code> statement. You would encode the above record in
assembly language as follows: </font></p>

<pre><font face="Courier New" size="2">student         struct
Name            char    65 dup (?)
Major           integer ?
SSN             char    12 dup (?)
Midterm1        integer ?
Midterm2        integer ?
Final           integer ?
Homework        integer ?
Projects        integer ?
student         ends</font></pre>

<p><font face="Arial" size="2">Note that the structure ends with the <code>ends</code>
(for end structure) statement. The label on the <code>ends</code> statement must be the
same as on the <code>struct</code> statement.</font></p>

<p><font face="Arial" size="2">The field names within the structure must be unique. That
is, the same name may not appear two or more times in the same structure. However, all
field names are local to that structure. Therefore, you may reuse those field names
elsewhere in the program.</font></p>

<p><font face="Arial" size="2">The <code>struct</code> directive only defines a structure
type. It does not reserve storage for a structure variable. To actually reserve storage
you need to declare a variable using the structure name as a MASM statement, e.g., </font></p>

<pre><font face="Courier New" size="2">John	student		{}</font></pre>

<p><font face="Arial" size="2">The braces must appear in the operand field. Any initial
values must appear between the braces. The above declaration allocates memory as shown in
below:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch05a6.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH05/ch05a6.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="305" HEIGHT="73"> </font></p>

<p><font face="Arial" size="2">If the label <code>John</code> corresponds to the base
address of this structure, then the <code>Name</code> field is at offset<code> John+0</code>,
the <code>Major</code> field is at offset<code> John+65</code>, the <code>SSN</code> field
is at offset<code> John+67</code>, etc.</font></p>

<p><font face="Arial" size="2">To access an element of a structure you need to know the
offset from the beginning of the structure to the desired field. For example, the <code>Major</code>
field in the variable <code>John</code> is at offset 65 from the base address of <code>John</code>.
Therefore, you could store the value in <code>ax</code> into this field using the
instruction<code> mov John[65], ax</code>. Unfortunately, memorizing all the offsets to
fields in a structure defeats the whole purpose of using them in the first place. After
all, if you've got to deal with these numeric offsets why not just use an array of bytes
instead of a structure?</font></p>

<p><font face="Arial" size="2">Well, as it turns out, MASM lets you refer to field names
in a structure using the same mechanism C and Pascal use: the dot operator. To store <code>ax</code>
into the <code>Major</code> field, you could use <code>mov John.Major,ax</code> instead of
the previous instruction. This is much more readable and certainly easier to use.</font></p>

<p><font face="Arial" size="2">Note that the use of the dot operator does not introduce a
new addressing mode. The instruction <code>mov John.Major,ax</code> still uses the
displacement only addressing mode. MASM simply adds the base address of <code>John</code>
with the offset to the <code>Major</code> field (65) to get the actual displacement to
encode into the instruction.</font></p>

<p><font face="Arial" size="2">You may also specify default initial values when creating a
structure. In the previous example, the fields of the student structure were given
indeterminate values by specifying &quot;?&quot; in the operand field of each field's
declaration. As it turns out, there are two different ways to specify an initial value for
structure fields. Consider the following definition of a &quot;point&quot; data structure:
</font></p>

<pre><font face="Courier New" size="2">Point           struct
x               word    0
y               word    0
z               word    0
Point           ends</font></pre>

<p><font face="Arial" size="2">Whenever you declare a variable of type point using a
statement similar to </font></p>

<pre><font face="Courier New" size="2">CurPoint        Point   {}</font></pre>

<p><font face="Arial" size="2">MASM automatically initializes the <code>CurPoint.x</code>,
<code>CurPoint.y</code>, and <code>CurPoint.z</code> variables to zero. This works out
great in those cases where your objects usually start off with the same initial values. Of
course, it might turn out that you would like to initialize the <code>X, Y,</code> and <code>Z</code>
fields of the points you declare, but you want to give each point a different value. That
is easily accomplished by specifying initial values inside the braces: </font></p>

<pre><font face="Courier New" size="2">Point1          point   {0,1,2}
Point2          point   {1,1,1}
Point3          point   {0,1,1}</font></pre>

<p><font face="Arial" size="2">MASM fills in the values for the fields in the order that
they appear in the operand field. For <code>Point1</code> above, MASM initializes the <code>X</code>
field with zero, the <code>Y</code> field with one, and the <code>Z</code> field with two.</font></p>

<p><font face="Arial" size="2">The type of the initial value in the operand field must
match the type of the corresponding field in the structure definition. You cannot, for
example, specify an integer constant for a <code>real4 </code>field, nor could you specify
a value greater than 255 for a <code>byte </code>field. </font></p>

<p><font face="Arial" size="2">MASM does not require that you initialize all fields in a
structure. If you leave a field blank, MASM will use the specified default value
(undefined if you specify &quot;?&quot; rather than a default value). </font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-59"></a>5.6.4 Arrays of
Structures and Arrays/Structures as Structure Fields</font></strong></p>

<p><font face="Arial" size="2">Structs may contain other structures or arrays as fields.
Consider the following definition: </font></p>

<pre><font face="Courier New" size="2">Pixel           struct
Pt              point   {}
Color           dword   ?
Pixel           ends</font></pre>

<p><font face="Arial" size="2">The definition above defines a single point with a 32 bit
color component. When initializing an object of type Pixel, the first initializer
corresponds to the <code>Pt</code> field, not the x-coordinate field. The following
definition is incorrect: </font></p>

<pre><font face="Courier New" size="2">ThisPt          Pixel   {5,10}</font></pre>

<p><font face="Arial" size="2">The value of the first field (&quot;5&quot;) is not an
object of type <code>point</code>. Therefore, the assembler generates an error when
encountering this statement. MASM will allow you to initialize the fields of <code>ThisPt</code>
using declarations like the following: </font></p>

<pre><font face="Courier New" size="2">ThisPt          Pixel   {,10}</font></pre>

<pre><font face="Courier New" size="2">ThisPt          Pixel   {{},10}</font></pre>

<pre><font face="Courier New" size="2">ThisPt          Pixel   {{1,2,3}, 10}</font></pre>

<pre><font face="Courier New" size="2">ThisPt          Pixel   {{1,,1}, 12}</font></pre>

<p><font face="Arial" size="2">The first and second examples above use the default values
for the <code>Pt</code> field (<code>x</code>=0, <code>y</code>=0, <code>z</code>=0) and
set the <code>Color</code> field to 10. Note the use of braces to surround the initial
values for the point type in the second, third, and fourth examples. The third example
above initializes the <code>x</code>, <code>y</code>, and <code>z</code> fields of the <code>Pt</code>
field to one, two, and three, respectively. The last example initializes the <code>x</code>
and <code>z</code> fields to one and lets the <code>y</code> field take on the initial
value specified by the <code>Point</code> structure (zero).</font></p>

<p><font face="Arial" size="2">Accessing Pixel fields is very easy. Like a high level
language you use a single period to reference the <code>Pt</code> field and a second
period to access the <code>x</code>, <code>y</code>, and <code>z</code> fields of point: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, ThisPt.Pt.X
                 .
                 .
                 .
                mov     ThisPt.Pt.Y, 0
                 .
                 .
                 .
                mov     ThisPt.Pt.Z, di
                 .
                 .
                 .
                mov     ThisPt.Color, EAX</font></pre>

<p><font face="Arial" size="2">You can also declare arrays as structure fields. The
following structure creates a data type capable of representing an object with eight
points (e.g., a cube): </font></p>

<pre><font face="Courier New" size="2">Object8         struct
Pts             point   8 dup (?)
Color           dword   0
Object8         ends</font></pre>

<p><font face="Arial" size="2">This structure allocates storage for eight different
points. Accessing an element of the <code>Pts</code> array requires that you know the size
of an object of type point (remember, you must multiply the index into the array by the
size of one element, six in this particular case). Suppose, for example, that you have a
variable <code>CUBE</code> of type <code>Object8</code>. You could access elements of the <code>Pts</code>
array as follows: </font></p>

<pre><font face="Courier New" size="2">; CUBE.Pts[i].X := 0;
                mov     ax, 6
                mul     i               ;6 bytes per element.
                mov     si, ax
                mov     CUBE.Pts[si].X, 0</font></pre>

<p><font face="Arial" size="2">The one unfortunate aspect of all this is that you must
know the size of each element of the <code>Pts</code> array. Fortunately, MASM provides an
operator that will compute the size of an array element (in bytes) for you, more on that
later.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-109"></a>5.6.5 Pointers to
Structures</font></strong></p>

<p><font face="Arial" size="2">During execution, your program may refer to structure
objects directly or indirectly using a pointer. When you use a pointer to access fields of
a structure, you must load one of the 80x86's pointer registers (<code>si, di, bx,</code>
or <code>bp</code> on processors less than the 80386) with the offset and <code>es, ds,
ss,</code> or <code>cs (fs/gs on the 386 and later) </code>with the segment of the desired
structure. Suppose you have the following variable declarations (assuming the <code>Object8</code>
structure from the previous section):</font> </p>

<pre><font face="Courier New" size="2">Cube            Object8 {}
CubePtr         dword   Cube</font></pre>
<code>

<p><font face="Arial" size="2">CubePtr</code> contains the address of (i.e., it is a
pointer to) the <code>Cube</code> object. To access the <code>Color</code> field of the <code>Cube</code>
object, you could use an instruction like <code>mov eax,Cube.Color</code>. When accessing
a field via a pointer you need to load the address of the object into a segment:pointer
register pair, such as <code>es:bx</code>. The instruction <code>les bx,CubePtr</code>
will do the trick. After doing so, you can access fields of the <code>Cube</code> object
using the<code> disp+bx</code> addressing mode. The only problem is &quot;How do you
specify which field to access?&quot; Consider briefly, the following incorrect code: </font></p>

<pre><font face="Courier New" size="2">                les     bx, CubePtr
                mov     eax, es:[bx].Color</font></pre>

<p><font face="Arial" size="2">There is one major problem with the code above. Since field
names are local to a structure and it's possible to reuse a field name in two or more
structures, how does MASM determine which offset <code>Color</code> represents? When
accessing structure members directly (.e.g., <code>mov eax,Cube.Color</code>) there is no
ambiguity since <code>Cube</code> has a specific type that the assembler can check. <code>es:bx</code>,
on the other hand, can point at anything. In particular, it can point at any structure
that contains a <code>Color</code> field. So the assembler cannot, on its own, decide
which offset to use for the <code>Color</code> symbol.</font></p>

<p><font face="Arial" size="2">MASM resolves this ambiguity by requiring that you
explicitly supply a type in this case. Probably the easiest way to do this is to specify
the structure name as a pseudo-field: </font></p>

<pre><font face="Courier New" size="2">                les     bx, CubePtr
                mov     eax, es:[bx].Object8.Color</font></pre>

<p><font face="Arial" size="2">By specifying the structure name, MASM knows which offset
value to use for the <code>Color</code> symbol.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH05-2.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH05-2.html">Chapter Five</a> (Part 2)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH05-4.html">Chapter Five</a> (Part 4) </strong></font><a href="CH05-4.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Five: Variables and Data
Structures (Part 3)<br>
26 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_5/CH05-3.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:13 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
