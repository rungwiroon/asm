<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_7/CH07-1.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:28 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER SEVEN: THE UCR STANDARD LIBRARY (Part 1)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING1"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="../Chapter_6/CH06-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="../Chapter_6/CH06-1.html">Chapter
    Six</a></strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH07-2.html">Chapter Seven</a> (Part 2) </strong></font><a href="CH07-2.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3" bgcolor="#FFFFFF" nowrap height="10"><a NAME="HEADING1-0"></a></td>
  </tr>
  <tr>
    <td width="100%" colspan="3" bgcolor="#F0F0F0"><font face="Arial" size="4"><strong>CHAPTER
    SEVEN:<br>
    THE UCR STANDARD LIBRARY (Part 1)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" colspan="3" nowrap height="10"></td>
  </tr>
  <tr>
    <td width="40%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING1-2"><b>7.0 </b>-
    Chapter Overview</a> <br>
    <a HREF="#HEADING1-10"><b>7.1 </b>- An Introduction to the UCR Standard Library</a> <br>
    <a HREF="#HEADING1-17"><b>7.1.1 </b>- Memory Management Routines: MEMINIT, MALLOC, and
    FREE</a> <br>
    <a HREF="#HEADING1-33"><b>7.1.2 </b>- The Standard Input Routines: GETC, GETS, GETSM</a> <br>
    <a HREF="#HEADING1-91"><b>7.1.3 </b>- The Standard Output Routines: PUTC, PUTCR, PUTS,
    PUTH, PUTI, PRINT, and PRINTF</a> <br>
    <a HREF="#HEADING1-221"><b>7.1.4 </b>- Formatted Output Routines: Putisize, Putusize,
    Putlsize, and Putulsize</a> <br>
    <a HREF="#HEADING1-224"><b>7.1.5 </b>- Output Field Size Routines: Isize, Usize, and Lsize</a>
    <br>
    <a HREF="#HEADING1-227"><b>7.1.6 </b>- Conversion Routines: ATOx, and xTOA</a> <br>
    <a HREF="#HEADING1-287"><b>7.1.7 </b>- Routines that Test Characters for Set Membership</a>
    <br>
    <a HREF="#HEADING1-295"><b>7.1.8 </b>- Character Conversion Routines: ToUpper, ToLower</a>
    <br>
    <a HREF="#HEADING1-299"><b>7.1.9 </b>- Random Number Generation: Random, Randomize</a> <br>
    <a HREF="#HEADING1-312"><b>7.1.10 </b>- Constants, Macros, and other Miscellany</a> <br>
    <a HREF="#HEADING1-347"><b>7.1.11 </b>- Plus more!</a> <br>
    <a HREF="CH07-2.html#HEADING2-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH07/CH07-2.html#HEADING2-1"><b>7.2 </b>-
    Sample Programs</a> <br>
    <a HREF="CH07-2.html#HEADING2-3" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH07/CH07-2.html#HEADING2-3"><b>7.2.1 </b>-
    Stripped SHELL.ASM File</a> <br>
    <a HREF="CH07-2.html#HEADING2-54" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH07/CH07-2.html#HEADING2-54"><b>7.2.2
    </b>- Numeric I/O</a> </font></td>
    <td width="20" nowrap valign="top"></td>
    <td width="60%" valign="top"><font size="1" face="Arial">Copyright 1996 by Randall Hyde
    All rights reserved. <br>
    <br>
    Duplication other than for immediate display through a browser is prohibited by U.S.
    Copyright Law. <br>
    This material is provided on-line as a beta-test of this text. It is for the personal use
    of the reader only. If you are interested in using this material as part of a course,
    please contact rhyde@cs.ucr.edu <br>
    <br>
    Supporting software and other materials are available via anonymous ftp from
    ftp.cs.ucr.edu. See the &quot;/pub/pc/ibmpcdir&quot; directory for details. You may also
    download the material from &quot;Randall Hyde's Assembly Language Page&quot; at URL:
    http://webster.ucr.edu<br>
    <br>
    Notes: <br>
    This document does not contain the laboratory exercises, programming assignments,
    exercises, or chapter summary. These portions were omitted for several reasons: either
    they wouldn't format properly, they contained hyperlinks that were too much work to
    resolve, they were under constant revision, or they were not included for security
    reasons. Such omission should have very little impact on the reader interested in learning
    this material or evaluating this document. <br>
    <br>
    This document was prepared using Harlequin's Web Maker 2.2 and Quadralay's Webworks
    Publisher. Since HTML does not support the rich formatting options available in
    Framemaker, this document is only an approximation of the actual chapter from the
    textbook. <br>
    <br>
    If you are absolutely dying to get your hands on a version other than HTML, you might
    consider having the UCR Printing a Reprographics Department run you off a copy on their
    Xerox machines. For details, please read the following EMAIL message I received from the
    Printing and Reprographics Department: </font><blockquote>
      <p><font size="1" face="Arial">Hello Again Professor Hyde,<br>
      <br>
      Dallas gave me permission to take orders for the Computer Science 13 Manuals. We would
      need to take charge card orders. The only cards we take are: Master Card, Visa, and
      Discover. They would need to send the name, numbers, expiration date, type of card, and
      authorization to charge $95.00 for the manual and shipping, also we should have their
      phone number in case the company has any trouble delivery. They can use my e-mail address
      for the orders and I will process them as soon as possible. I would assume that two weeks
      would be sufficient for printing, packages and delivery time.<br>
      <br>
      I am open to suggestions if you can think of any to make this as easy as possible.<br>
      <br>
      Thank You for your business,<br>
      Kathy Chapman, Assistant<br>
      Printing and Reprographics University of California Riverside (909) 787-4443/4444 </font></p>
    </blockquote>
    <p><font size="1" face="Arial">We are currently working on ways to publish this text in a
    form other than HTML (e.g., Postscript, PDF, Frameviewer, hard copy, etc.). This, however,
    is a low-priority project. Please do not contact Randall Hyde concerning this effort. When
    something happens, an announcement will appear on &quot;Randall Hyde's Assembly Language
    Page.&quot; Please visit this WEB site at http://webster.ucr.edu for the latest scoop.</font></p>
    <p><font size="1" face="Arial">Redesigned 10/2000 with &quot;MS FrontPage 98&quot; using
    17&quot; monitor 1024x768<br>
    (c)&nbsp; 2000 <a href="mail%20to_%20bircom_yanoo.html">BIRCOM Entertainment'95</a></font></td>
  </tr>
</table>
</center></div>

<hr noshade size="1" color="#000000">

<p><font face="Arial" size="2">Most programming languages provide several
&quot;built-in&quot; functions to reduce the effort needed to write a program.
Traditionally, assembly language programmers have not had access to a standard set of
commonly used subroutines for their programs; hence, assembly language programmers'
productivity has been quite low because they are constantly &quot;reinventing the
wheel&quot; in every program they write. The UCR Standard Library for 80x86 programmers
provides such a set of routines. This chapter discusses a small subset of the routines
available in the library. After reading this chapter, you should peruse the documentation
accompanying the standard library routines.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING1-2"></a>7.0 Chapter
    Overview</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">This chapter provides a basic introduction to the functions
available in the UCR Standard Librfary for 80x86 assembly language programmers. This brief
introduction covers the following subjects: </font>

<ul>
  <li><font face="Arial" size="2">The UCR Standard Library for 80x86 Assembly Language
    Programmers. </font></li>
  <li><font face="Arial" size="2">Memory management routines. </font></li>
  <li><font face="Arial" size="2">Input routines. </font></li>
  <li><font face="Arial" size="2">Output routines. </font></li>
  <li><font face="Arial" size="2">Conversions. </font></li>
  <li><font face="Arial" size="2">Predefined constants and macros. </font></li>
</ul>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING1-10"></a>7.1 An
    Introduction to the UCR Standard Library</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">The &quot;UCR Standard Library for 80x86 Assembly Language
Programmers&quot; is a set of assembly language subroutines patterned after the
&quot;C&quot; standard library. Among other things, the standard library includes
procedures to handle input, output, conversions, various comparisons and checks, string
handling, memory management, character set operators, floating point operations, list
handling, serial port I/O, concurrency and coroutines, and pattern matching. </font></p>

<p><font face="Arial" size="2">This chapter will not attempt to describe every routine in
the library. First of all, the Library is constantly changing so such a description would
quickly become outdated. Second, some of the library routines are for advanced programmers
only and are beyond the scope of this text. Finally, there are hundreds of routines in the
library. Attempting to describe them all here would be a major distraction from the real
job at hand- learning assembly language.</font></p>

<p><font face="Arial" size="2">Therefore, this chapter will cover the few necessary
routines that will get you up and running with the least amount of effort. Note that the
full documentation for the library, as well as the source code and several example files
are on the companion diskette for this text. A reference guide appears in the appendices
of this text. You can also find the latest version of the UCR Standard Library on many
on-line services, BBSes, and from many shareware software houses. It is also available via
anonymous FTP on the internet.</font></p>

<p><font face="Arial" size="2">When using the UCR Standard Library you should always use
the SHELL.ASM file provided as the &quot;skeleton&quot; of a new program. This file sets
up the necessary segments, provides the proper <code>include </code>directives, and
initializes necessary Library routines for you. You should not attempt to create a new
program from scratch unless you are very familiar with the internal operation of the
Standard Library. </font></p>

<p><font face="Arial" size="2">Note that most of the Standard Library routines use macros
rather than the <code>call </code>instruction for invocation. You cannot, for example,
directly <code>call </code>the <code>putc </code>routine. Instead, you invoke the <code>putc
</code>macro that includes a call to the <code>sl_putc </code>procedure (&quot;SL&quot;
stands for &quot;Standard Library&quot;).</font></p>

<p><font face="Arial" size="2">If you choose not to use the SHELL.ASM file, your program
must include several statements to activate the standard library and satisfy certain
requirements for the standard library. Please see the documentation accompanying the
standard library if you choose to go this route. Until you gain some more experience with
assembly language programming, you should always use the SHELL.ASM file as the starting
point for your programs.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING1-17"></a>7.1.1 Memory Management
Routines: MEMINIT, MALLOC, and FREE</font></strong></p>

<p><font face="Arial" size="2">The Standard Library provides several routines that manage
free memory in the heap. They give assembly language programmers the ability to
dynamically allocate memory during program execution and return this memory to the system
when the program no longer needs it. By dynamically allocating and freeing blocks of
memory, you can make efficient use of memory on a PC.</font></p>

<p><font face="Arial" size="2">The <code>meminit </code>routine initializes the memory
manager and you must call it before any routine that uses the memory manager. Since many
Standard Library routines use the memory manager, you should call this procedure early in
the program. The &quot;SHELL.ASM&quot; file makes this call for you.</font></p>

<p><font face="Arial" size="2">The <code>malloc </code>routine allocates storage on the
heap and returns a pointer to the block it allocates in the <code>es:di </code>registers.
Before calling <code>malloc </code>you need to load the size of the block (in bytes) into
the <code>cx </code>register. On return, <code>malloc </code>sets the carry flag if an
error occurs (insufficient memory). If the carry is clear, <code>es:di </code>points at a
block of bytes the size you've specified: </font></p>

<pre><font face="Courier New" size="2">        mov     cx, 1024                ;Grab 1024 bytes on the heap
        malloc                          ;Call MALLOC
        jc      MallocError             ;If memory error.
        mov     word ptr PNTR, DI       ;Save away pointer to block.
        mov     word ptr PNTR+2, ES</font></pre>

<p><font face="Arial" size="2">When you call <code>malloc</code>, the memory manager
promises that the block it gives you is free and clear and it will not reallocate that
block until you explicitly free it. To return a block of memory back to the memory manager
so you can (possibly) re-use that block of memory in the future, use the <code>free </code>Library
routine. <code>free </code>expects you to pass the pointer returned by <code>malloc</code>:
</font></p>

<pre><font face="Courier New" size="2">        les     di, PNTR        ;Get pointer to free
        free                    ;Free that block
        jc      BadFree</font></pre>

<p><font face="Arial" size="2">As usual for most Standard Library routines, if the <code>free
</code>routine has some sort of difficulty it will return the carry flag set to denote an
error.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING1-33"></a>7.1.2 The Standard Input
Routines: GETC, GETS, GETSM</font></strong></p>

<p><font face="Arial" size="2">While the Standard Library provides several input routines,
there are three in particular you will use all the time: <code>getc </code>(get a
character), <code>gets </code>(get a string), and <code>getsm </code>(get a malloc'd
string).</font></p>

<p><font face="Arial" size="2"><code>Getc </code>reads a single character from the
keyboard and returns that character in the <code>al </code>register. It returns end of
file (EOF ) status in the <code>ah </code>register (zero means EOF did not occur, one
means EOF did occur). It does not modify any other registers. As usual, the carry flag
returns the error status. You do not need to pass <code>getc </code>any values in the
registers. <code>Getc </code>does not echo the input character to the display screen. You
must explicitly print the character if you want it to appear on the output monitor.</font></p>

<p><font face="Arial" size="2">The following example program continually loops until the
user presses the Enter key: </font></p>

<pre><font face="Courier New" size="2">; Note: &quot;CR&quot; is a symbol that appears in the &quot;consts.a&quot;
; header file. It is the value 13 which is the ASCII code
; for the carriage return character

Wait4Enter:     getc
                cmp     al, cr
                jne     Wait4Enter</font></pre>

<p><font face="Arial" size="2">The <code>gets </code>routine reads an entire line of text
from the keyboard. It stores each successive character of the input line into a byte array
whose base address you pass in the <code>es:di </code>register pair. This array must have
room for at least 128 bytes. The <code>gets </code>routine will read each character and
place it in the array except for the carriage return character. <code>Gets </code>terminates
the input line with a zero byte (which is compatible with the Standard Library string
handling routines). <code>Gets </code>echoes each character you type to the display
device, it also handles simple line editing functions such as backspace. As usual, <code>gets
</code>returns the carry set if an error occurs. The following example reads a line of
text from the standard input device and then counts the number of characters typed. This
code is tricky, note that it initializes the count and pointer to -1 prior to entering the
loop and then immediately increments them by one. This sets the count to zero and adjusts
the pointer so that it points at the first character in the string. This simplification
produces slightly more efficient code than the straightforward solution would produce: </font></p>

<pre><font face="Courier New" size="2">DSEG            segment

MyArray         byte    128 dup (?)

DSEG            ends

CSEG            segment

                 .
                 .
                 .

; Note: LESI is a macro (found in consts.a) that loads
; ES:DI with the address of its operand. It expands to the
; code:
;
;               mov di, seg operand
;               mov es, di
;               mov di, offset operand
;
; You will use the macro quite a bit before many Standard
; Library calls.

                lesi    MyArray                 ;Get address of inp buf.
                gets                            ;Read a line of text.
                mov     ah, -1                  ;Save count here.
                lea     bx, -1[di]              ;Point just before string.
CountLoop:      inc     ah                      ;Bump count by one.
                inc     bx                      ;Point at next char in str.
                cmp     byte ptr es:[bx], 0
                jne     CoutLoop

; Now AH contains the number of chars in the string.

                 .
                 .
                 .</font></pre>

<p><font face="Arial" size="2">The <code>getsm </code>routine also reads a string from the
keyboard and returns a pointer to that string in <code>es:di. </code>The difference
between <code>gets </code>and <code>getsm </code>is that you do not have to pass the
address of an input buffer in <code>es:di</code>. <code>Getsm </code>automatically
allocates storage on the heap with a call to <code>malloc </code>and returns a pointer to
the buffer in <code>es:di</code>. Don't forget that you must call <code>meminit </code>at
the beginning of your program if you use this routine. The SHELL.ASM skeleton file calls <code>meminit
</code>for you. Also, don't forget to call <code>free </code>to return the storage to the
heap when you're done with the input line. </font></p>

<pre><font face="Courier New" size="2">                getsm   ;Returns pointer in ES:DI
                 .
                 .
                 .
                free    ;Return storageto heap.</font></pre>

<pre><strong><font face="Arial" size="3">7.1.3 The Standard Output Routines: PUTC, PUTCR, PUTS, PUTH, PUTI, PRINT, and PRINTF</font></strong></pre>

<p><font face="Arial" size="2">The Standard Library provides a wide array of output
routines, far more than you will see here. The following routines are representative of
the routines you'll find in the Library. </font></p>

<p><font face="Arial" size="2"><code>Putc </code>outputs a single character to the display
device. It outputs the character appearing in the <code>al </code>register. It does not
affect any registers unless there is an error on output (the carry flag denotes error/no
error, as usual). See the Standard Library documentation for more details.</font></p>

<p><font face="Arial" size="2"><code>Putcr </code>outputs a &quot;newline&quot; (carriage
return/line feed combination) to the standard output. It is completely equivalent to the
code: </font></p>

<pre><font face="Courier New" size="2">                mov     al, cr          ;CR and LF are constants
                putc                    ; appearing in the consts.a
                mov     al, lf          ; header file.
                putc</font></pre>

<p><font face="Arial" size="2">The <code>puts </code>(put a string) routine prints the
zero terminated string at which <code>es:di </code>points. Note that <code>puts </code>does
not automatically output a newline after printing the string. You must either put the
carriage return/line feed characters at the end of the string or call <code>putcr </code>after
calling <code>puts </code>if you want to print a newline after the string. <code>Puts </code>does
not affect any registers (unless there is an error). In particular, it does not change the
value of the <code>es:di </code>registers. The following code sequence uses this fact: </font></p>

<pre><font face="Courier New" size="2">                getsm           ;Read a string
                puts            ;Print it
                putcr           ;Print a new line
                free            ;Free the memory for string.</font></pre>

<p><font face="Arial" size="2">Since the routines above preserve <code>es:di </code>(except,
of course, <code>getsm</code>), the call to <code>free </code>deallocates the memory
allocated by the call to <code>getsm</code>.</font></p>

<p><font face="Arial" size="2">The <code>puth </code>routine prints the value in the <code>al
</code>register as exactly two hexadecimal digits, including a leading zero byte if the
value is in the range 0..Fh. The following loop reads a sequence of keys from the keyboard
and prints their ASCII values until the user presses the Enter key: </font></p>

<pre><font face="Courier New" size="2">KeyLoop:        getc
                cmp     al, cr
                je      Done
                puth
                putcr
                jmp     KeyLoop
Done:</font></pre>

<p><font face="Arial" size="2">The <code>puti </code>routine prints the value in <code>ax </code>as
a signed 16 bit integer. The following code fragment prints the sum of<code> I</code> and<code>
J</code> to the display: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, I
                add     ax, J
                puti
                putcr</font></pre>

<p><font face="Arial" size="2"><code>Putu</code> is similar to <code>puti</code> except it
outputs unsigned integer values rather than signed integers.</font></p>

<p><font face="Arial" size="2">Routines like <code>puti</code> and <code>putu</code>
always output numbers using the minimum number of possible print positions. For example, <code>puti</code>
uses three print positions on the string to print the value 123. Sometimes, you may want
to force these output routines to print their values using a fixed number of print
positions, padding any extra positions with spaces. The <code>putisize</code> and <code>putusize</code>
routines provide this capability. These routines expect a numeric value in <code>ax</code>
and a field width specification in <code>cx</code>. They will print the number in a field
width of at least <code>cx</code> positions. If the value in <code>cx</code> is larger
than the number of print position the value requires, these routines will right justify
the number in a field of <code>cx</code> print positions. If the value in <code>cx</code>
is less than the number of print positions the value requires, these routines ignore the
value in <code>cx</code> and use however many print positions the number requires. </font></p>

<pre><font face="Courier New" size="2">; The following loop prints out the values of a 3x3 matrix in matrix form:
; On entry, bx points at element [0,0] of a row column matrix.

                mov     dx, 3           ;Repeat for each row.
PrtMatrix:      mov     ax, [bx]        ;Get first element in this row.
                mov     cx, 7           ;Use seven print positions.
                putisize                ;Print this value.
                mov     ax, 2[bx]       ;Get the second element.
                putisize                ;CX is still seven.
                mov     ax, 4[bx]       ;Get the third element.
                putisize
                putcr                   ;Output a new line.
                add     bx, 6           ;Move on to next row.
                dec     dx              ;Repeat for each row.
                jne     PrtMatrix</font></pre>

<p><font face="Arial" size="2">The <code>print </code>routine is one of the most-often
called procedures in the library. It prints the zero terminated string that immediately
follows the call to print: </font></p>

<pre><font face="Courier New" size="2">                print
                byte    &quot;Print this string to the display&quot;,cr,lf,0</font></pre>

<p><font face="Arial" size="2">The example above prints the string <code>&quot;Print this
string to the display&quot;</code> followed by a new line. Note that <code>print </code>will
print whatever characters immediately follow the call to <code>print</code>, up to the
first zero byte it encounters. In particular, you can print the newline sequence and any
other control characters as shown above. Also note that you are not limited to printing
one line of text with the <code>print </code>routine: </font></p>

<pre><font face="Courier New" size="2">                print
                byte    &quot;This example of the PRINT routine&quot;,cr,lf
                byte    &quot;prints several lines of text.&quot;,cr,lf
                byte    &quot;Also note,&quot;,cr,lf,&quot;that the source lines &quot;
                byte    &quot;do not have to correspond to the output.&quot;
                byte    cr,lf
                byte    0</font></pre>

<p><font face="Arial" size="2">The above displays: </font></p>

<pre><font face="Courier New" size="2">This example of the PRINT routine
prints several lines of text.
Also note,
that the source lines do not have to correspond to the output.</font></pre>

<p><font face="Arial" size="2">It is very important that you not forget about that zero
terminating byte. The <code>print </code>routine begins executing the first 80x86 machine
language instruction following that zero terminating byte. If you forget to put the zero
terminating byte after your string, the <code>print </code>routine will gladly eat up the
instruction bytes following your string (printing them) until it finds a zero byte (zero
bytes are common in assembly language programs). This will cause your program to misbehave
and is a big source of errors beginning programmers have when they use the <code>print </code>routine.
Always keep this in mind.</font></p>

<p><font face="Arial" size="2"><code>Printf</code>, like its &quot;C&quot; namesake,
provides formatted output capabilities for the Standard Library package. A typical call to
<code>printf </code>always takes the following form: </font></p>

<pre><font face="Courier New" size="2">                printf
                byte            &quot;format string&quot;,0
                dword           operand1, operand2, ..., operandn</font></pre>

<p><font face="Arial" size="2">The format string is comparable to the one provided in the
&quot;C&quot; programming language. For most characters, <code>printf</code> simply prints
the characters in the format string up to the terminating zero byte. The two exceptions
are characters prefixed by a backslash (&quot;\&quot;) and characters prefixed by a
percent sign (&quot;%&quot;). Like C's <code>printf</code>, the Standard Library's <code>printf</code>
uses the backslash as an escape character and the percent sign as a lead-in to a format
string.</font></p>

<p><font face="Arial" size="2"><code>Printf </code>uses the escape character
(&quot;\&quot;) to print special characters in a fashion similar to, but not identical to
C's <code>printf</code>. The Standard Library's <code>printf</code> routine supports the
following special characters: </font>

<ul>
  <li><font face="Arial" size="2">\r Print a carriage return (but no line feed) </font></li>
  <li><font face="Arial" size="2">\n Print a new line character (carriage return/line feed). </font></li>
  <li><font face="Arial" size="2">\b Print a backspace character. </font></li>
  <li><font face="Arial" size="2">\t Print a tab character. </font></li>
  <li><font face="Arial" size="2">\l Print a line feed character (but no carriage return). </font></li>
  <li><font face="Arial" size="2">\f Print a form feed character. </font></li>
  <li><font face="Arial" size="2">\\ Print the backslash character. </font></li>
  <li><font face="Arial" size="2">\% Print the percent sign character. </font></li>
  <li><font face="Arial" size="2">\0xhh Print ASCII code hh, represented by two hex digits. </font></li>
</ul>

<p><font face="Arial" size="2">C users should note a couple of differences between
Standard Library's escape sequences and C's. First, use &quot;\%&quot; to print a percent
sign within a format string, not &quot;%%&quot;. C doesn't allow the use of &quot;\%&quot;
because the C compiler processes &quot;\%&quot; at compile time (leaving a single
&quot;%&quot; in the object code) whereas <code>printf</code> processes the format string
at run-time. It would see a single &quot;%&quot; and treat it as a format lead-in
character. The Standard Library's <code>printf</code>, on the other hand, processes both
the &quot;\&quot; and &quot;%&quot; at run-time, therefore it can distinguish
&quot;\%&quot;.</font></p>

<p><font face="Arial" size="2">Strings of the form &quot;\0xhh&quot; must contain exactly
two hex digits. The current <code>printf</code> routine isn't robust enough to handle
sequences of the form &quot;\0xh&quot; which contain only a single hex digit. Keep this in
mind if you find printf chopping off characters after you print a value.</font></p>

<p><font face="Arial" size="2">There is absolutely no reason to use any hexadecimal escape
character sequence except &quot;\0x00&quot;. <code>Printf</code> grabs all characters
following the call to <code>printf</code> up to the terminating zero byte (which is why
you'd need to use &quot;\0x00&quot; if you want to print the null character, printf will
not print such values). The Standard Library's <code>printf</code> routine doesn't care
how those characters got there. In particular, you are not limited to using a single
string after the <code>printf</code> call. The following is perfectly legal: </font></p>

<pre><font face="Courier New" size="2">                printf
                byte &quot;This is a string&quot;,13,10
                byte &quot;This is on a new line&quot;,13,10
                byte &quot;Print a backspace at the end of this line:&quot;
                byte 8,13,10,0</font></pre>

<p><font face="Arial" size="2">Your code will run a tiny amount faster if you avoid the
use of the escape character sequences. More importantly, the escape character sequences
take at least two bytes. You can encode most of them as a single byte by simply embedding
the ASCII code for that byte directly into the code stream. Don't forget, you cannot embed
a zero byte into the code stream. A zero byte terminates the format string. Instead, use
the &quot;\0x00&quot; escape sequence.</font></p>

<p><font face="Arial" size="2">Format sequences always begin with &quot;%&quot;. For each
format sequence, you must provide a far pointer to the associated data immediately
following the format string, e.g., </font></p>

<pre><font face="Courier New" size="2">                printf
                byte            &quot;%i %i&quot;,0
                dword           i,j</font></pre>

<p><font face="Arial" size="2">Format sequences take the general form &quot;%s\cn^f&quot;
where: </font>

<ul>
  <li><font face="Arial" size="2">&quot;%&quot; is always the &quot;%&quot; character. Use
    &quot;\%&quot; if you actually want to print a percent sign. </font></li>
  <li><font face="Arial" size="2">s is either nothing or a minus sign (&quot;-&quot;). </font></li>
  <li><font face="Arial" size="2">&quot;\c&quot; is also optional, it may or may not appear in
    the format item. &quot;c&quot; represents any printable character. </font></li>
  <li><font face="Arial" size="2">&quot;n&quot; represents a string of 1 or more decimal
    digits. </font></li>
  <li><font face="Arial" size="2">&quot;^&quot; is just the caret (up-arrow) character. </font></li>
  <li><font face="Arial" size="2">&quot;f&quot; represents one of the format characters: i, d,
    x, h, u, c, s, ld, li, lx, or lu. </font></li>
</ul>

<p><font face="Arial" size="2">The &quot;s&quot;, &quot;\c&quot;, &quot;n&quot;, and
&quot;^&quot; items are optional, the &quot;%&quot; and &quot;f&quot; items must be
present. Furthermore, the order of these items in the format item is very important. The
&quot;\c&quot; entry, for example, cannot precede the &quot;s&quot; entry. Likewise, the
&quot;^&quot; character, if present, must follow everything except the &quot;f&quot;
character(s).</font></p>

<p><font face="Arial" size="2">The format characters i, d, x, h, u, c, s, ld, li, lx, and
lu control the output format for the data. The i and d format characters perform identical
functions, they tell <code>printf</code> to print the following value as a 16 bit signed
decimal integer. The x and h format characters instruct <code>printf</code> to print the
specified value as a 16 bit or 8-bit hexadecimal value (respectively). If you specify u, <code>printf</code>
prints the value as a 16-bit unsigned decimal integer. Using c tells <code>printf</code>
to print the value as a single character. S tells <code>printf</code> that you're
supplying the address of a zero-terminated character string, <code>printf</code> prints
that string. The ld, li, lx, and lu entries are long (32-bit) versions of d/i, x, and u.
The corresponding address points at a 32-bit value that <code>printf</code> will format
and print to the standard output.</font></p>

<p><font face="Arial" size="2">The following example demonstrates these format items: </font></p>

<pre><font face="Courier New" size="2">                printf
                byte            &quot;I= %i, U= %u, HexC= %h, HexI= %x, C= %c, &quot;
                dbyte           &quot;S= %s&quot;,13,10
                byte            &quot;L= %ld&quot;,13,10,0
                dword           i,u,c,i,c,s,l</font></pre>

<p><font face="Arial" size="2">The number of far addresses (specified by operands to the
&quot;dd&quot; pseudo-opcode) must match the number of &quot;%&quot; format items in the
format string. <code>Printf</code> counts the number of &quot;%&quot; format items in the
format string and skips over this many far addresses following the format string. If the
number of items do not match, the return address for <code>printf</code> will be incorrect
and the program will probably hang or otherwise malfunction. Likewise (as for the <code>print</code>
routine), the format string must end with a zero byte. The addresses of the items
following the format string must point directly at the memory locations where the
specified data lies.</font></p>

<p><font face="Arial" size="2">When used in the format above, <code>printf</code> always
prints the values using the minimum number of print positions for each operand. If you
want to specify a minimum field width, you can do so using the &quot;n&quot; format
option. A format item of the format &quot;%10d&quot; prints a decimal integer using at
least ten print positions. Likewise, &quot;%16s&quot; prints a string using at least 16
print positions. If the value to print requires more than the specified number of print
positions, printf will use however many are necessary. If the value to print requires
fewer, printf will always print the specified number, padding the value with blanks. <code>Printf</code>
will print the value right justified in the print field (regardless of the data's type).
If you want to print the value left justified in the output file, use the &quot;-&quot;
format character as a prefix to the field width, e.g., </font></p>

<pre><font face="Courier New" size="2">                printf
                byte            &quot;%-17s&quot;,0
                dword           string</font></pre>

<p><font face="Arial" size="2">In this example, <code>printf</code> prints the string
using a 17 character long field with the string left justified in the output field.</font></p>

<p><font face="Arial" size="2">By default, <code>printf</code> blank fills the output
field if the value to print requires fewer print positions than specified by the format
item. The &quot;\c&quot; format item allows you to change the padding character. For
example, to print a value, right justified, using &quot;*&quot; as the padding character
you would use the format item &quot;%\*10d&quot;. To print it left justified you would use
the format item &quot;%-\*10d&quot;. Note that the &quot;-&quot; must precede the
&quot;\*&quot;. This is a limitation of the current version of the software. The operands
must appear in this order. Normally, the address(es) following the <code>printf</code>
format string must be far pointers to the actual data to print.</font></p>

<p><font face="Arial" size="2">On occasion, especially when allocating storage on the heap
(using <code>malloc</code>), you may not know (at assembly time) the address of the object
you want to print. You may have only a pointer to the data you want to print. The
&quot;^&quot; format option tells printf that the far pointer following the format string
is the address of a pointer to the data rather than the address of the data itself. This
option lets you access the data indirectly.</font></p>

<p><font face="Arial" size="2">Note: unlike C, Standard Library's <code>printf</code>
routine does not support floating point output. Putting floating point into <code>printf</code>
would increase the size of this routine a tremendous amount. Since most people don't need
the floating point output facilities, it doesn't appear here. There is a separate routine,
<code>printff</code>, that includes floating point output.</font></p>

<p><font face="Arial" size="2">The Standard Library <code>printf</code> routine is a
complex beast. However, it is very flexible and extremely useful. You should spend the
time to master its major functions. You will be using this routine quite a bit in your
assembly language programs.</font></p>

<p><font face="Arial" size="2">The standard output package provides many additional
routines besides those mentioned here. There simply isn't enough room to go into all of
them in this chapter. For more details, please consult the Standard Library documentation.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING1-221"></a>7.1.4 Formatted Output
Routines: Putisize, Putusize, Putlsize, and Putulsize</font></strong></p>

<p><font face="Arial" size="2">The <code>puti, putu, and putl </code>routines output the
numeric strings using the minimum number of print positions necessary. For example, <code>puti</code>
uses three character positions to print the value -12. On occasion, you may need to
specify a different field width so you can line up columns of numbers or achieve other
formatting tasks. Although you can use <code>printf</code> to accomplish this goal, <code>printf</code>
has two major drawbacks - it only prints values in memory (i.e., it cannot print values in
registers) and the field width you specify for <code>printf</code> must be a constant. The
<code>putisize</code>, <code>putusize</code>, and <code>putlsize</code> routines overcome
these limitations.</font></p>

<p><font face="Arial" size="2">Like their puti, putu, and putl counterparts, these
routines print signed integer, unsigned integer, and 32-bitsigned integer values. They
expect the value to print in the <code>ax</code> register (<code>putisize</code> and <code>putusize</code>)
or the <code>dx:ax</code> register pair (<code>putlsize</code>). They also expect a
minimum field width in the <code>cx</code> register. As with <code>printf</code>, if the
value in the <code>cx</code> register is smaller than the number of print positions that
the number actually needs to print, <code>putisize, putusize,</code> and <code>putlsize</code>
will ignore the value in <code>cx</code> and print the value using the minimum necessary
number of print positions.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING1-224"></a>7.1.5 Output Field Size
Routines: Isize, Usize, and Lsize</font></strong></p>

<p><font face="Arial" size="2">Once in a while you may want to know the number of print
positions a value will require before actually printing that value. For example, you might
want to compute the maximum print width of a set of numbers so you can print them in
columnar format automatically adjusting the field width for the largest number in the set.
The <code>isize, usize,</code> and <code>lsize</code> routines do this for you.</font></p>

<p><font face="Arial" size="2">The <code>isize</code> routine expects a signed integer in
the <code>ax</code> register. It returns the minimum field width of that value (including
a position for the minus sign, if necessary) in the <code>ax</code> register. <code>Usize</code>
computes the size of the unsigned integer in <code>ax</code> and returns the minimum field
width in the <code>ax</code> register. <code>Lsize</code> computes the minimum width of
the signed integer in <code>dx:ax</code> (including a position for the minus sign, if
necessary) and returns this width in the <code>ax</code> register.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING1-227"></a>7.1.6 Conversion
Routines: ATOx, and xTOA</font></strong></p>

<p><font face="Arial" size="2">The Standard Library provides several routines to convert
between string and numeric values. These include <code>atoi, atoh, atou, itoa, htoa, wtoa,
</code>and<code> utoa </code>(plus others). The <code>ATOx</code> routines convert an
ASCII string in the appropriate format to a numeric value and leave that value in <code>ax
</code>or <code>al</code>. The <code>ITOx</code> routines convert the value in <code>al/ax
</code>to a string of digits and store this string in the buffer whose address is in <code>es:di</code>.
There are several variations on each routine that handle different cases. The following
paragraphs describe each routine.</font></p>

<p><font face="Arial" size="2">The <code>atoi </code>routine assumes that <code>es:di </code>points
at a string containing integer digits (and, perhaps, a leading minus sign). They convert
this string to an integer value and return the integer in <code>ax</code>. On return, <code>es:di
</code>still points at the beginning of the string. If <code>es:di </code>does not point
at a string of digits upon entry or if an overflow occurs, <code>atoi </code>returns the
carry flag set. <code>Atoi</code> preserves the value of the <code>es:di </code>register
pair. A variant of <code>atoi</code>, <code>atoi2</code>, also converts an ASCII string to
an integer except it does not preserve the value in the <code>di</code> register. The <code>atoi2</code>
routine is particularly useful if you need to convert a sequence of numbers appearing in
the same string. Each call to <code>atoi2</code> leaves the <code>di</code> register
pointing at the first character beyond the string of digits. You can easily skip over any
spaces, commas, or other delimiter characters until you reach the next number in the
string; then you can call <code>atoi2</code> to convert that string to a number. You can
repeat this process for each number on the line.</font></p>

<p><font face="Arial" size="2"><code>Atoh </code>works like the <code>atoi </code>routine,
except it expects the string to contain hexadecimal digits (no leading minus sign). On
return, <code>ax </code>contains the converted 16 bit value and the carry flag denotes
error/no error. Like <code>atoi</code>, the <code>atoh</code> routine preserves the values
in the <code>es:di</code> register pair. You can call <code>atoh2</code> if you want the
routine to leave the <code>di</code> register pointing at the first character beyond the
end of the string of hexadecimal digits.</font></p>

<p><font face="Arial" size="2"><code>Atou </code>converts an ASCII string of decimal
digits in the range 0..65535 to an integer value and returns this value in <code>ax</code>.
Except that the minus sign is not allowed, this routine behaves just like <code>atoi</code>.
There is also an <code>atou2</code> routine that does not preserve the value of the <code>di</code>
register; it leaves <code>di</code> pointing at the first character beyond the string of
decimal digits.</font></p>

<p><font face="Arial" size="2">Since there is no <code>geti</code>, <code>geth</code>, or <code>getu
</code>routines available in the Standard Library, you will have to construct these
yourself. The following code demonstrates how to read an integer from the keyboard: </font></p>

<pre><font face="Courier New" size="2">                print
                byte            &quot;Enter an integer value:&quot;,0
                getsm
                atoi            ;Convert string to an integer in AX
                free            ;Return storage allocated by getsm
                print
                byte            &quot;You entered &quot;,0
                puti            ;Print value returned by ATOI.
                putcr</font></pre>

<p><font face="Arial" size="2">The <code>itoa</code>, <code>utoa</code>, <code>htoa</code>,
and <code>wtoa</code> routines are the logical inverse to the atox routines. They convert
numeric values to their integer, unsigned, and hexadecimal string representations. There
are several variations of these routines depending upon whether you want them to
automatically allocate storage for the string or if you want them to preserve the <code>di</code>
register.</font></p>

<p><font face="Arial" size="2"><code>Itoa</code> converts the 16 bit signed integer in <code>ax</code>
to a string and stores the characters of this string starting at location <code>es:di</code>.
When you call <code>itoa</code>, you must ensure that <code>es:di</code> points at a
character array large enough to hold the resulting string. <code>Itoa</code> requires a
maximum of seven bytes for the conversion: five numeric digits, a sign, and a zero
terminating byte. <code>Itoa</code> preserves the values in the <code>es:di</code>
register pair, so upon return <code>es:di</code> points at the beginning of the string
produced by <code>itoa</code>. </font></p>

<p><font face="Arial" size="2">Occasionally, you may not want to preserve the value in the
<code>di</code> register when calling the <code>itoa</code> routine. For example, if you
want to create a single string containing several converted values, it would be nice if <code>itoa</code>
would leave <code>di</code> pointing at the end of the string rather than at the beginning
of the string. The <code>itoa2</code> routine does this for you; it will leave the <code>di</code>
register pointing at the zero terminating byte at the end of the string. Consider the
following code segment that will produce a string containing the ASCII representations for
three integer variables, <code>Int1</code>, <code>Int2</code>, and <code>Int3</code>: </font></p>

<pre><font face="Courier New" size="2">; Assume es:di already points at the starting location to store the converted
; integer values

                mov     ax, Int1
                itoa2                   ;Convert Int1 to a string.

; Okay, output a space between the numbers and bump di so that it points
; at the next available position in the string.

                mov     byte ptr es:[di], ' '
                inc     di

; Convert the second value.

                mov     ax, Int2
                itoa2
                mov     byte ptr es:[di], ' '
                inc     di

; Convert the third value.

                mov     ax, Int3
                itoa2

; At this point, di points at the end of the string containing the
; converted values. Hopefully you still know where the start of the
; string is so you can manipulate it!</font></pre>

<p><font face="Arial" size="2">Another variant of the <code>itoa</code> routine, <code>itoam</code>,
does not require you to initialize the <code>es:di</code> register pair. This routine
calls <code>malloc</code> to automatically allocate the storage for you. It returns a
pointer to the converted string on the heap in the <code>es:di </code>register pair. When
you are done with the string, you should call <code>free</code> to return its storage to
the heap. </font></p>

<pre><font face="Courier New" size="2">; The following code fragment converts the integer in AX to a string and prints
; this string. Of course, you could do this same operation with PUTI, but this
; code does demonstrate how to call itoam.

                itoam           ;Convert integer to string.
                puts            ;Print the string.
                free            ;Return storage to the heap.</font></pre>

<p><font face="Arial" size="2">The <code>utoa</code>, <code>utoa2</code>, and <code>utoam</code>
routines work just like <code>itoa</code>, <code>itoa2</code>, and <code>itoam</code>,
except they convert the unsigned integer value in <code>ax</code> to a string. Note that <code>utoa</code>
and <code>utoa2</code> require, at most, six bytes since they never output a sign
character.</font></p>

<p><font face="Arial" size="2"><code>Wtoa</code>, <code>wtoa2</code>, and <code>wtoam</code>
convert the 16 bit value in <code>ax</code> to a string of exactly four hexadecimal
characters plus a zero terminating byte. Otherwise, they behave exactly like <code>itoa</code>,
<code>itoa2</code>, and <code>itoam</code>. Note that these routines output leading zeros
so the value is always four digits long.</font></p>

<p><font face="Arial" size="2">The <code>htoa</code>, <code>htoa2</code>, and <code>htoam</code>
routines are similar to the <code>wtoa</code>, <code>wtoa2</code>, and <code>wtoam</code>
routines. However, the <code>htox</code> routines convert the eight bit value in <code>al</code>
to a string of two hexadecimal characters plus a zero terminating byte. </font></p>

<p><font face="Arial" size="2">The Standard Library provides several other conversion
routines as well as the ones mentioned in this section. See the Standard Library
documentation in the appendices for more details.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING1-287"></a>7.1.7 Routines that Test
Characters for Set Membership</font></strong></p>

<p><font face="Arial" size="2">The UCR Standard Library provides many routines that test
the character in the <code>al</code> register to see if it falls within a certain set of
characters. These routines all return the status in the zero flag. If the condition is
true, they return the zero flag set (so you can test the condition with a <code>je</code>
instruction). If the condition is false, they clear the zero flag (test this condition
with <code>jne</code>). These routines are </font>

<ul>
  <li><font face="Arial" size="2">IsAlNum- Checks to see if <code>al</code> contains an
    alphanumeric character. </font></li>
  <li><font face="Arial" size="2">IsXDigit- Checks <code>al</code> to see if it contains a
    hexadecimal digit character. </font></li>
  <li><font face="Arial" size="2">IsDigit- Checks <code>al</code> to see if it contains a
    decimal digit character. </font></li>
  <li><font face="Arial" size="2">IsAlpha- Checks <code>al</code> to see if it contains an
    alphabetic character. </font></li>
  <li><font face="Arial" size="2">IsLower- Checks <code>al</code> to see if it contains a
    lower case alpha character. </font></li>
  <li><font face="Arial" size="2">IsUpper- Checks <code>al</code> to see if it contains an
    upper case alpha character. </font></li>
</ul>

<p><strong><font face="Arial" size="3"><a NAME="HEADING1-295"></a>7.1.8 Character
Conversion Routines: ToUpper, ToLower</font></strong></p>

<p><font face="Arial" size="2">The ToUpper and ToLower routines check the character in the
<code>al</code> register. They will convert the character in <code>al</code> to the
appropriate alphabetic case.</font></p>

<p><font face="Arial" size="2">If <code>al</code> contains a lower case alphabetic
character, <code>ToUpper</code> will convert it to the equivalent upper case character. If
<code>al</code> contains any other character, <code>ToUpper</code> will return it
unchanged.</font></p>

<p><font face="Arial" size="2">If <code>al</code> contains an upper case alphabetic
character, <code>ToLower</code> will convert it to the equivalent lower case character. If
the value is not an upper case alphabetic character <code>ToLower</code> will return it
unchanged.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING1-299"></a>7.1.9 Random Number
Generation: Random, Randomize</font></strong></p>

<p><font face="Arial" size="2">The Standard Library <code>Random</code> routine generates
a sequence of pseudo-random numbers. It returns a random value in the <code>ax</code>
register on each call. You can treat this value as a signed or unsigned value since <code>Random</code>
manipulates all 16 bits of the <code>ax</code> register.</font></p>

<p><font face="Arial" size="2">You can use the <code>div</code> and <code>idiv</code>
instructions to force the output of <code>random</code> to a specific range. Just divide
the value random returns by some number n and the remainder of this division will be a
value in the range 0..n-1. For example, to compute a random number in the range 1..10, you
could use code like the following: </font></p>

<pre><font face="Courier New" size="2">                random                  ;Get a random number in range 0..65535.
                sub     dx, dx          ;Zero extend to 16 bits.
                mov     bx, 10          ;Want value in the range 1..10.
                div     bx              ;Remainder goes to dx!
                inc     dx              ;Convert 0..9 to 1..10.

; At this point, a random number in the range 1..10 is in the dx register.</font></pre>

<p><font face="Arial" size="2">The <code>random</code> routine always returns the same
sequence of values when a program loads from disk and executes. <code>Random</code> uses
an internal table of seed values that it stores as part of its code. Since these values
are fixed, and always load into memory with the program, the algorithm that <code>random</code>
uses will always produce the same sequence of values when a program containing it loads
from the disk and begins running. This might not seem very &quot;random&quot; but, in
fact, this is a nice feature since it is very difficult to test a program that uses truly
random values. If a random number generator always produces the same sequence of numbers,
any tests you run on that program will be repeatable.</font></p>

<p><font face="Arial" size="2">Unfortunately, there are many examples of programs that you
may want to write (e.g., games) where having repeatable results is not acceptable. For
these applications you can call the <code>randomize</code> routine. <code>Randomize</code>
uses the current value of the time of day clock to generate a nearly random starting
sequence. So if you need a (nearly) unique sequence of random numbers each time your
program begins execution, call the <code>randomize</code> routine once before ever calling
the <code>random</code> routine. Note that there is little benefit to calling the <code>randomize</code>
routine more than once in your program. Once <code>random</code> establishes a random
starting point, further calls to <code>randomize</code> will not improve the quality
(randomness) of the numbers it generates.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING1-312"></a>7.1.10 Constants,
Macros, and other Miscellany</font></strong></p>

<p><font face="Arial" size="2">When you include the &quot;stdlib.a&quot; header file, you
are also defining certain macros (see Chapter Eight for a discussion of macros) and
commonly used constants. These include the following: </font></p>

<pre><font face="Courier New" size="2">NULL            =       0       ;Some common ASCII codes
BELL            =       07      ;Bell character
bs              =       08      ;Backspace character
tab             =       09      ;Tab character
lf              =       0ah     ;Line feed character
cr              =       0dh     ;Carriage return</font></pre>

<p><font face="Arial" size="2">In addition to the constants above, &quot;stdlib.a&quot;
also defines some useful macros including <code>ExitPgm, lesi, and ldxi</code>. These
macros contain the following instructions: </font></p>

<pre><font face="Courier New" size="2">; ExitPgm- Returns control to MS-DOS

ExitPgm         macro
                mov     ah, 4ch ;DOS terminate program opcode
                int     21h     ;DOS call.
                endm

; LESI ADRS-
;       Loads ES:DI with the address of the specified operand. 

lesi            macro   adrs
                mov     di, seg adrs
                mov     es, di
                mov     di, offset adrs
                endm

; LDXI ADRS-
;       Loads DX:SI with the address of the specified operand.

ldxi            macro   adrs
                mov     dx, seg adrs
                mov     si, offset adrs
                endm</font></pre>

<p><font face="Arial" size="2">The <code>lesi</code> and <code>ldxi</code> macros are
especially useful for load addresses into es:di or dx:si before calling various standard
library routines (see Chapter Eight for details about macros).</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING1-347"></a>7.1.11 Plus more!</font></strong></p>

<p><font face="Arial" size="2">The Standard Library contains many, many, routines that
this chapter doesn't even mention. As you get time, you should read through the
documentation for the Standard Library and find out what's available. The routines
mentioned in this chapter are the ones you will use right away. This text will introduce
new Standard Library routines as they are needed.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="../Chapter_6/CH06-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="../Chapter_6/CH06-1.html">Chapter
    Six</a></strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH07-2.html">Chapter Seven</a> (Part 2) </strong></font><a href="CH07-2.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Seven: The UCR Standard
Library (Part 1)<br>
26 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_7/CH07-1.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:26:29 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
