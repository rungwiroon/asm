<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_1/CH01-1.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:24:01 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER ONE: DATA REPRESENTATION (Part 1)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="2"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="2"><a NAME="HEADING1"></a></td>
  </tr>
  <tr>
    <td width="50%" valign="middle" align="center" bgcolor="#FFFFFF" height="25" nowrap><p align="left"><a href="../toc.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a> <a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="50%" valign="middle" align="center" bgcolor="#FFFFFF" height="25" nowrap><font face="Arial" size="2"><strong><p align="right"><a href="CH01-2.html">Chapter One</a> (Part
    2) <a href="CH01-2.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></strong></font></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3" bgcolor="#FFFFFF" nowrap height="10"></td>
  </tr>
  <tr>
    <td width="100%" colspan="3" bgcolor="#F0F0F0"><font face="Arial" size="4"><strong>CHAPTER
    ONE:<br>
    DATA REPRESENTATION (Part 1)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" colspan="3" nowrap height="10"></td>
  </tr>
  <tr>
    <td width="40%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING1-32"><b>1.0 </b>-
    Chapter Overview</a> <br>
    <a HREF="#HEADING1-34"><b>1.1 </b>- Numbering Systems</a> <br>
    <a HREF="#HEADING1-36"><b>1.1.1 </b>- A Review of the Decimal System</a> <br>
    <a HREF="#HEADING1-46"><b>1.1.2 </b>- The Binary Numbering System</a> <br>
    <a HREF="#HEADING1-69"><b>1.1.3 </b>- Binary Formats</a> <br>
    <a HREF="#HEADING1-86"><b>1.2 </b>- Data Organization</a> <br>
    <a HREF="#HEADING1-88"><b>1.2.1 </b>- Bits</a> <br>
    <a HREF="#HEADING1-93"><b>1.2.2 </b>- Nibbles</a> <br>
    <a HREF="#HEADING1-95"><b>1.2.3 </b>- Bytes</a> <br>
    <a HREF="#HEADING1-107"><b>1.2.4 </b>- Words</a> <br>
    <a HREF="#HEADING1-121"><b>1.2.5 </b>- Double Words</a> <br>
    <a HREF="CH01-2.html#HEADING2-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH01/CH01-2.html#HEADING2-1"><b>1.3 </b>-
    The Hexadecimal Numbering System</a> <br>
    <a HREF="CH01-2.html#HEADING2-26" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH01/CH01-2.html#HEADING2-26"><b>1.4 </b>-
    Arithmetic Operations on Binary and Hexadecimal Numbers</a> <br>
    <a HREF="CH01-2.html#HEADING2-49" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH01/CH01-2.html#HEADING2-49"><b>1.5 </b>-
    Logical Operations on Bits</a> <br>
    <a HREF="CH01-2.html#HEADING2-86" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH01/CH01-2.html#HEADING2-86"><b>1.6 </b>-
    Logical Operations on Binary Numbers and Bit Strings</a> <br>
    <a HREF="CH01-2.html#HEADING2-96" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH01/CH01-2.html#HEADING2-96"><b>1.7 </b>-
    Signed and Unsigned Numbers</a> <br>
    <a HREF="CH01-2.html#HEADING2-151" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH01/CH01-2.html#HEADING2-151"><b>1.8 </b>-
    Sign and Zero Extension</a> <br>
    <a HREF="CH01-3.html#HEADING3-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH01/CH01-3.html#HEADING3-1"><b>1.9 </b>-
    Shifts and Rotates</a> <br>
    <a HREF="CH01-3.html#HEADING3-24" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH01/CH01-3.html#HEADING3-24"><b>1.10 </b>-
    Bit Fields and Packed Data</a> <br>
    <a HREF="CH01-3.html#HEADING3-34" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH01/CH01-3.html#HEADING3-34"><b>1.11 </b>-
    The ASCII Character Set</a></font></td>
    <td width="20" nowrap valign="top"></td>
    <td width="60%" valign="top"><font size="1" face="Arial">Copyright 1996 by Randall Hyde
    All rights reserved. <br>
    <br>
    Duplication other than for immediate display through a browser is prohibited by U.S.
    Copyright Law. <br>
    This material is provided on-line as a beta-test of this text. It is for the personal use
    of the reader only. If you are interested in using this material as part of a course,
    please contact rhyde@cs.ucr.edu <br>
    <br>
    Supporting software and other materials are available via anonymous ftp from
    ftp.cs.ucr.edu. See the &quot;/pub/pc/ibmpcdir&quot; directory for details. You may also
    download the material from &quot;Randall Hyde's Assembly Language Page&quot; at URL:
    http://webster.ucr.edu<br>
    <br>
    Notes: <br>
    This document does not contain the laboratory exercises, programming assignments,
    exercises, or chapter summary. These portions were omitted for several reasons: either
    they wouldn't format properly, they contained hyperlinks that were too much work to
    resolve, they were under constant revision, or they were not included for security
    reasons. Such omission should have very little impact on the reader interested in learning
    this material or evaluating this document. <br>
    <br>
    This document was prepared using Harlequin's Web Maker 2.2 and Quadralay's Webworks
    Publisher. Since HTML does not support the rich formatting options available in
    Framemaker, this document is only an approximation of the actual chapter from the
    textbook. <br>
    <br>
    If you are absolutely dying to get your hands on a version other than HTML, you might
    consider having the UCR Printing a Reprographics Department run you off a copy on their
    Xerox machines. For details, please read the following EMAIL message I received from the
    Printing and Reprographics Department: </font><blockquote>
      <p><font size="1" face="Arial">Hello Again Professor Hyde,<br>
      <br>
      Dallas gave me permission to take orders for the Computer Science 13 Manuals. We would
      need to take charge card orders. The only cards we take are: Master Card, Visa, and
      Discover. They would need to send the name, numbers, expiration date, type of card, and
      authorization to charge $95.00 for the manual and shipping, also we should have their
      phone number in case the company has any trouble delivery. They can use my e-mail address
      for the orders and I will process them as soon as possible. I would assume that two weeks
      would be sufficient for printing, packages and delivery time.<br>
      <br>
      I am open to suggestions if you can think of any to make this as easy as possible.<br>
      <br>
      Thank You for your business,<br>
      Kathy Chapman, Assistant<br>
      Printing and Reprographics University of California Riverside (909) 787-4443/4444 </font></p>
    </blockquote>
    <p><font size="1" face="Arial">We are currently working on ways to publish this text in a
    form other than HTML (e.g., Postscript, PDF, Frameviewer, hard copy, etc.). This, however,
    is a low-priority project. Please do not contact Randall Hyde concerning this effort. When
    something happens, an announcement will appear on &quot;Randall Hyde's Assembly Language
    Page.&quot; Please visit this WEB site at http://webster.ucr.edu for the latest scoop.</font></p>
    <p><font size="1" face="Arial">Redesigned 10/2000 with &quot;MS FrontPage 98&quot; using
    17&quot; monitor 1024x768<br>
    (c) 2000 <a href="mail%20to_%20bircom_yanoo.html">BIRCOM Entertainment'95</a></font></td>
  </tr>
</table>
</center></div>

<hr noshade size="1" color="#000000">

<p><a NAME="HEADING1-30"></a><font face="Arial" size="2">Probably the biggest stumbling
block most beginners encounter when attempting to learn assembly language is the common
use of the binary and hexadecimal numbering systems. Many programmers think that
hexadecimal (or hex) numbers represent absolute proof that God never intended anyone to
work in assembly language. While it is true that hexadecimal numbers are a little
different from what you may be used to, their advantages outweigh their disadvantages by a
large margin. Nevertheless, understanding these numbering systems is important because
their use simplifies other complex topics including boolean algebra and logic design,
signed numeric representation, character codes, and packed data. </font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><a NAME="HEADING1-32"></a><font face="Arial" size="3"><strong>1.0 Chapter
    Overview</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">This chapter discusses several important concepts including
the binary and hexadecimal numbering systems, binary data organization (bits, nibbles,
bytes, words, and double words), signed and unsigned numbering systems, arithmetic,
logical, shift, and rotate operations on binary values, bit fields and packed data, and
the ASCII character set. This is basic material and the remainder of this text depends
upon your understanding of these concepts. If you are already familiar with these terms
from other courses or study, you should at least skim this material before proceeding to
the next chapter. If you are unfamiliar with this material, or only vaguely familiar with
it, you should study it carefully before proceeding. All of the material in this chapter
is important! Do not skip over any material.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING1-34"></a>1.1
    Numbering Systems</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">Most modern computer systems do not represent numeric
values using the decimal system. Instead, they typically use a binary or two's complement
numbering system. To understand the limitations of computer arithmetic, you must
understand how computers represent numbers.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING1-36"></a>1.1.1 A Review of the
Decimal System</font></strong></p>

<p><font face="Arial" size="2">You've been using the decimal (base 10) numbering system
for so long that you probably take it for granted. When you see a number like
&quot;123&quot;, you don't think about the value 123; rather, you generate a mental image
of how many items this value represents. In reality, however, the number 123 represents
(&quot;**&quot; represents exponentiation): </font></p>

<pre><font face="Courier New" size="2">1*10**2 + 2 * 10**1 + 3*10**0</font></pre>

<p><font face="Arial" size="2">or </font></p>

<pre><font face="Courier New" size="2">100+20+3</font></pre>

<p><font face="Arial" size="2">Each digit appearing to the left of the decimal point
represents a value between zero and nine times an increasing power of ten. Digits
appearing to the right of the decimal point represent a value between zero and nine times
an increasing negative power of ten. For example, the value 123.456 means: </font></p>

<pre><font face="Courier New" size="2">1*10**2 + 2*10**1 + 3*10**0 + 4*10**-1 + 5*10**-2 + 6*10**-3</font></pre>

<p><font face="Arial" size="2">or </font></p>

<pre><font face="Courier New" size="2">100 + 20 + 3 + 0.4 + 0.05 + 0.006</font></pre>

<pre><strong><font face="Arial" size="3">1.1.2 The Binary Numbering System</font></strong></pre>

<p><font face="Arial" size="2">Most modern computer systems (including the IBM PC) operate
using binary logic. The computer represents values using two voltage levels (usually 0v
and +5v). With two such levels we can represent exactly two different values. These could
be any two different values, but by convention we use the values zero and one. These two
values, coincidentally, correspond to the two digits used by the binary numbering system.
Since there is a correspondence between the logic levels used by the 80x86 and the two
digits used in the binary numbering system, it should come as no surprise that the IBM PC
employs the binary numbering system. </font></p>

<p><font face="Arial" size="2">The binary numbering system works just like the decimal
numbering system, with two exceptions: binary only allows the digits 0 and 1 (rather than
0-9), and binary uses powers of two rather than powers of ten. Therefore, it is very easy
to convert a binary number to decimal. For each &quot;1&quot; in the binary string, add in
2**n where &quot;n&quot; is the zero-based position of the binary digit. For example, the
binary value 11001010 represents: </font></p>

<pre><font face="Courier New" size="2">1*2**7 + 1*2**6 + 0*2**5 + 0*2**4 + 1*2**3 + 0*2**2 + 1*2**1 + 0*2**0
=
 128 + 64 + 8 + 2 
=
202 (base 10)</font></pre>

<p><font face="Arial" size="2">To convert decimal to binary is slightly more difficult.
You must find those powers of two which, when added together, produce the decimal result.
The easiest method is to work from the a large power of two down to 2**0. Consider the
decimal value 1359: </font>

<ul>
  <li><font face="Arial" size="2">2**10=1024, 2**11=2048. So 1024 is the largest power of two
    less than 1359. Subtract 1024 from 1359 and begin the binary value on the left with a
    &quot;1&quot; digit. Binary = &quot;1&quot;, Decimal result is 1359 - 1024 = 335.</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">The next lower power of two (2**9= 512) is greater than the
    result from above, so add a &quot;0&quot; to the end of the binary string. Binary =
    &quot;10&quot;, Decimal result is still 335.</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">The next lower power of two is 256 (2**8). Subtract this
    from 335 and add a &quot;1&quot; digit to the end of the binary number. Binary =
    &quot;101&quot;, Decimal result is 79.</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">128 (2**7) is greater than 79, so tack a &quot;0&quot; to
    the end of the binary string. Binary = &quot;1010&quot;, Decimal result remains 79.</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">The next lower power of two (2**6 = 64) is less than79, so
    subtract 64 and append a &quot;1&quot; to the end of the binary string. Binary =
    &quot;10101&quot;, Decimal result is 15.</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">15 is less than the next power of two (2**5 = 32) so simply
    add a &quot;0&quot; to the end of the binary string. Binary = &quot;101010&quot;, Decimal
    result is still 15.</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">16 (2**4) is greater than the remainder so far, so append a
    &quot;0&quot; to the end of the binary string. Binary = &quot;1010100&quot;, Decimal
    result is 15.</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">2**3(eight) is less than 15, so stick another &quot;1&quot;
    digit on the end of the binary string. Binary = &quot;10101001&quot;, Decimal result is 7.</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">2**2 is less than seven, so subtract four from seven and
    append another one to the binary string. Binary = &quot;101010011&quot;, decimal result is
    3.</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">2**1 is less than three, so append a one to the end of the
    binary string and subtract two from the decimal value. Binary = &quot;1010100111&quot;,
    Decimal result is now 1.</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Finally, the decimal result is one, which is2**0, so add a
    final &quot;1&quot; to the end of the binary string. The final binary result is
    &quot;10101001111&quot; </font></li>
</ul>

<p><font face="Arial" size="2">Binary numbers, although they have little importance in
high level languages, appear everywhere in assembly language programs. </font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING1-69"></a>1.1.3 Binary Formats</font></strong></p>

<p><font face="Arial" size="2">In the purest sense, every binary number contains an
infinite number of digits (or bits which is short for binary digits). For example, we can
represent the number five by: </font></p>

<p><font face="Courier New" size="2">101 00000101 0000000000101 ... 000000000000101</font></p>

<p><font face="Arial" size="2">Any number of leading zero bits may precede the binary
number without changing its value. </font></p>

<p><font face="Arial" size="2">We will adopt the convention ignoring any leading zeros.
For example, 101 (binary) represents the number five. Since the 80x86 works with groups of
eight bits, we'll find it much easier to zero extend all binary numbers to some multiple
of four or eight bits. Therefore, following this convention, we'd represent the number
five as 0101 (binary) or 00000101 (binary).</font></p>

<p><font face="Arial" size="2">In the United States, most people separate every three
digits with a comma to make larger numbers easier to read. For example, 1,023,435,208 is
much easier to read and comprehend than 1023435208. We'll adopt a similar convention in
this text for binary numbers. We will separate each group of four binary bits with a
space. For example, the binary value 1010111110110010 will be written 1010 1111 1011 0010.</font></p>

<p><font face="Arial" size="2">We often pack several values together into the same binary
number. One form of the 80x86 MOV instruction (see appendix D) uses the binary encoding
1011 0rrr dddd dddd to pack three items into 16 bits: a five-bit operation code (10110), a
three-bit register field (rrr), and an eight-bit immediate value (dddd dddd). For
convenience, we'll assign a numeric value to each bit position. We'll number each bit as
follows:</font></p>

<p><font face="Arial" size="2">1) The rightmost bit in a binary number is bit position
zero. </font></p>

<p><font face="Arial" size="2">2) Each bit to the left is given the next successive bit
number.</font></p>

<p><font face="Arial" size="2">An eight-bit binary value uses bits zero through seven: </font></p>

<pre><em><font face="Courier New" size="2">X7 X6 X5 X4 X3 X2 X1 X0</font></em></pre>

<p><font face="Arial" size="2">A 16-bit binary value uses bit positions zero through
fifteen: </font></p>

<pre><font face="Courier New" size="2">X<em>15</em> X<em>14</em> X<em>13</em> X<em>12</em> X<em>11</em> X<em>10</em> X<em>9</em> X<em>8</em> X<em>7</em> X<em>6</em> X<em>5</em> X<em>4</em> X<em>3</em> X<em>2</em> X<em>1</em> X<em>0</em></font></pre>

<p><font face="Arial" size="2">Bit zero is usually referred to as the low order ( L.O.)
bit. The left-most bit is typically called the high order ( H.O.) bit. We'll refer to the
intermediate bits by their respective bit numbers.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING1-86"></a>1.2 Data
    Organization</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">In pure mathematics a value may take an arbitrary number of
bits. Computers, on the other hand, generally work with some specific number of bits.
Common collections are single bits, groups of four bits (called <i>nibbles</i>), groups of
eight bits (called <i>bytes</i>), groups of 16 bits (called <i>words</i>), and more. The
sizes are not arbitrary. There is a good reason for these particular values. This section
will describe the bit groups commonly used on the Intel 80x86 chips.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING1-88"></a>1.2.1 Bits</font></strong></p>

<p><font face="Arial" size="2">The smallest &quot;unit&quot; of data on a binary computer
is a single <i>bit</i>. Since a single bit is capable of representing only two different
values (typically zero or one) you may get the impression that there are a very small
number of items you can represent with a single bit. Not true! There are an infinite
number of items you can represent with a single bit.</font></p>

<p><font face="Arial" size="2">With a single bit, you can represent any two distinct
items. Examples include zero or one, true or false, on or off, male or female, and right
or wrong. However, you are <i>not</i> limited to representing binary data types (that is,
those objects which have only two distinct values). You could use a single bit to
represent the numbers 723 and 1,245. Or perhaps 6,254 and 5. You could also use a single
bit to represent the colors red and blue. You could even represent two unrelated objects
with a single bit,. For example, you could represent the color red and the number 3,256
with a single bit. You can represent <i>any</i> two different values with a single bit.
However, you can represent <i>only two</i> different values with a single bit.</font></p>

<p><font face="Arial" size="2">To confuse things even more, different bits can represent
different things. For example, one bit might be used to represent the values zero and one,
while an adjacent bit might be used to represent the values true and false. How can you
tell by looking at the bits? The answer, of course, is that you can't. But this
illustrates the whole idea behind computer data structures: <i>data is what you define it
to be</i>. If you use a bit to represent a boolean (true/false) value then that bit (by
your definition) represents true or false. For the bit to have any true meaning, you must
be consistent. That is, if you're using a bit to represent true or false at one point in
your program, you shouldn't use the true/false value stored in that bit to represent red
or blue later. </font></p>

<p><font face="Arial" size="2">Since most items you'll be trying to model require more
than two different values, single bit values aren't the most popular data type you'll use.
However, since everything else consists of groups of bits, bits will play an important
role in your programs. Of course, there are several data types that require two distinct
values, so it would seem that bits are important by themselves. However, you will soon see
that individual bits are difficult to manipulate, so we'll often use other data types to
represent boolean values.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING1-93"></a>1.2.2 Nibbles</font></strong></p>

<p><font face="Arial" size="2">A <i>nibble</i> is a collection of four bits. It wouldn't
be a particularly interesting data structure except for two items: BCD (binary coded
decimal) numbers and hexadecimal numbers. It takes four bits to represent a single BCD or
hexadecimal digit. With a nibble, we can represent up to 16 distinct values. In the case
of hexadecimal numbers, the values 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, and F are
represented with four bits (see &quot;The Hexadecimal Numbering System&quot;). BCD uses
ten different digits (0, 1, 2, 3, 4, 5, 6, 7, 8, 9) and requires four bits. In fact, any
sixteen distinct values can be represented with a nibble, but hexadecimal and BCD digits
are the primary items we can represent with a single nibble.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING1-95"></a>1.2.3 Bytes</font></strong></p>

<p><font face="Arial" size="2">Without question, the most important data structure used by
the 80x86 microprocessor is the byte. A byte consists of eight bits and is the smallest
addressable datum (data item) on the 80x86 microprocessor. Main memory and I/O addresses
on the 80x86 are all byte addresses. This means that the smallest item that can be
individually accessed by an 80x86 program is an eight-bit value. To access anything
smaller requires that you read the byte containing the data and mask out the unwanted
bits. The bits in a byte are normally numbered from zero to seven using the convention
shown below:</font></p>

<p align="center"><img SRC="images/ch01a.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH01/ch01a.gif" ALIGN="bottom" NATURALSIZEFLAG="3" WIDTH="183" HEIGHT="42"> </p>

<p><font face="Arial" size="2">Bit 0 is the <i>low order bit</i> or <i>least significant
bit</i>, bit 7 is the <i>high order bit</i> or <i>most significant bit</i> of the byte.
We'll refer to all other bits by their number.</font></p>

<p><font face="Arial" size="2">Note that a byte also contains exactly two nibbles: </font></p>

<p align="center"><img SRC="images/ch01a1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH01/ch01a1.gif" ALIGN="bottom" NATURALSIZEFLAG="3" WIDTH="183" HEIGHT="56"> </p>

<p><font face="Arial" size="2">Bits 0..3 comprise the <i>low order nibble</i>, bits 4..7
form the <i>high order nibble</i>. Since a byte contains exactly two nibbles, byte values
require two hexadecimal digits. </font></p>

<p><font face="Arial" size="2">Since a byte contains eight bits, it can represent 2**8, or
256, different values. Generally, we'll use a byte to represent numeric values in the
range 0..255, signed numbers in the range -128..+127 (see &quot;Signed and Unsigned
Numbers&quot;), ASCII/IBM character codes, and other special data types requiring no more
than 256 different values. Many data types have fewer than 256 items so eight bits is
usually sufficient. </font></p>

<p><font face="Arial" size="2">Since the 80x86 is a byte addressable machine, it turns out
to be more efficient to manipulate a whole byte than an individual bit or nibble. For this
reason, most programmers use a whole byte to represent data types that require no more
than 256 items, even if fewer than eight bits would suffice. For example, we'll often
represent the boolean values true and false by 00000001 and 00000000 (respectively). </font></p>

<p><font face="Arial" size="2">Probably the most important use for a byte is holding a
character code. Characters typed at the keyboard, displayed on the screen, and printed on
the printer all have numeric values. To allow it to communicate with the rest of the
world, the IBM PC uses a variant of the ASCII character set (see &quot;The ASCII Character
Set&quot;). There are 128 defined codes in the ASCII character set. IBM uses the remaining
128 possible values for extended character codes including European characters, graphic
symbols, Greek letters, and math symbols. See Appendix A for the character/code
assignments. </font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING1-107"></a>1.2.4 Words</font></strong></p>

<p><font face="Arial" size="2">A word is a group of 16 bits. We'll number the bits in a
word starting from zero on up to fifteen. The bit numbering appears below:</font></p>

<p align="center"><img SRC="images/ch01a2.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH01/ch01a2.gif" ALIGN="bottom" NATURALSIZEFLAG="3" WIDTH="367" HEIGHT="45"> </p>

<p><font face="Arial" size="2">Like the byte, bit 0 is the low order bit and bit 15 is the
high order bit. When referencing the other bits in a word use their bit position number.</font></p>

<p><font face="Arial" size="2">Notice that a word contains exactly two bytes. Bits 0
through 7 form the low order byte, bits 8 through 15 form the high order byte:</font></p>

<p align="center"><img SRC="images/ch01a3.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH01/ch01a3.gif" ALIGN="bottom" NATURALSIZEFLAG="3" WIDTH="367" HEIGHT="60"> </p>

<p><font face="Arial" size="2">Naturally, a word may be further broken down into four
nibbles as shown below:</font></p>

<p align="center"><img SRC="images/ch01a4.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH01/ch01a4.gif" ALIGN="bottom" NATURALSIZEFLAG="3" WIDTH="367" HEIGHT="74"> </p>

<p><font face="Arial" size="2">Nibble zero is the low order nibble in the word and nibble
three is the high order nibble of the word. The other two nibbles are &quot;nibble
one&quot; or &quot;nibble two&quot;.</font></p>

<p><font face="Arial" size="2">With 16 bits, you can represent 2**16 (65,536) different
values. These could be the values in the range 0..65,535 (or, as is usually the case,
-32,768..+32,767) or any other data type with no more than 65,536 values. The three major
uses for words are integer values, offsets, and segment values. </font></p>

<p><font face="Arial" size="2">Words can represent integer values in the range 0..65,535
or -32,768..32,767. Unsigned numeric values are represented by the binary value
corresponding to the bits in the word. Signed numeric values use the two's complement form
for numeric values (see &quot;Signed and Unsigned Numbers&quot;). Segment values, which
are always 16 bits long, constitute the paragraph address of a code, data, extra, or stack
segment in memory. </font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING1-121"></a>1.2.5 Double Words</font></strong></p>

<p><font face="Arial" size="2">A double word is exactly what its name implies, a pair of
words. Therefore, a double word quantity is 32 bits long as shown below:</font></p>

<p align="center"><img SRC="images/ch01a5.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH01/ch01a5.gif" ALIGN="bottom" NATURALSIZEFLAG="3" WIDTH="368" HEIGHT="30"> </p>

<p><font face="Arial" size="2">Naturally, this double word can be divided into a high
order word and a low order word, or four different bytes, or eight different nibbles: </font></p>

<p align="center"><img SRC="images/ch01a6.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH01/ch01a6.gif" ALIGN="bottom" NATURALSIZEFLAG="3" WIDTH="369" HEIGHT="42"><br>
<br>
<img SRC="images/ch01a8.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH01/ch01a8.gif" ALIGN="bottom" NATURALSIZEFLAG="3" WIDTH="402" HEIGHT="58"> </p>

<p><font face="Arial" size="2">Double words can represent all kinds of different things.
First and foremost on the list is a segmented address. Another common item represented
with a double word is a 32-bit integer value (which allows unsigned numbers in the range
0..4,294,967,295 or signed numbers in the range -2,147,483,648..2,147,483,647). 32-bit
floating point values also fit into a double word. Most of the time, we'll use double
words to hold segmented addresses.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="2"></td>
  </tr>
  <tr>
    <td width="50%" valign="bottom" align="center" bgcolor="#FFFFFF" height="25" nowrap><p align="left"><a href="../toc.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="../toc.html">Table of Content</a></strong></font></td>
    <td width="50%" valign="bottom" align="center" bgcolor="#FFFFFF" height="25" nowrap><font face="Arial" size="2"><strong><p align="right"><a href="CH01-2.html">Chapter One</a> (Part
    2) <a href="CH01-2.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></strong></font></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter One: Data Representation
(Part 1)<br>
26 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_1/CH01-1.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:24:15 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
