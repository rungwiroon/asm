<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_2/CH02-3.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:24:42 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER TWO: BOOLEAN ALGEBRA (Part 3)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING3"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" height="25" nowrap><p align="left"><a href="CH02-2.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH02-2.html">Chapter Two</a>
    (Part 2)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" height="25" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" height="25" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="../Chapter_3/CH03-1.html">Chapter
    Three</a> </strong></font><a href="../Chapter_3/CH03-1.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10" colspan="2"><a NAME="HEADING3-0"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0" colspan="2"><font face="Arial" size="4"><strong>CHAPTER
    TWO:<br>
    BOOLEAN ALGEBRA (Part 3)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10" colspan="2"></td>
  </tr>
  <tr>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING3-1"><b>2.6 </b>-
    What Does This Have To Do With Computers, Anyway?</a> <br>
    <a HREF="#HEADING3-3"><b>2.6.1 </b>- Correspondence Between Electronic Circuits and
    Boolean Functions</a> <br>
    <a HREF="#HEADING3-27"><b>2.6.2 </b>- Combinatorial Circuits</a> </font></td>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING3-56"><b>2.6.3 </b>-
    Sequential and Clocked Logic</a> <br>
    <a HREF="#HEADING3-81"><b>2.7 </b>- Okay, What Does It Have To Do With Programming, Then?</a>
    <br>
    <a HREF="#HEADING3-98"><b>2.8 </b>- Generic Boolean Functions</a> </font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="20" colspan="2"></td>
  </tr>
  <tr>
    <td width="100%" colspan="2"><strong><font face="Arial" size="3"><a NAME="HEADING3-1"></a>2.6
    <a NAME="MARKER-9-69"></a>What Does This Have To Do With Computers, Anyway?</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1" colspan="2"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">Although there is a tenuous relationship between boolean
functions and boolean expressions in programming languages like C or Pascal, it is fair to
wonder why we're spending so much time on this material. However, the relationship between
boolean logic and computer systems is much stronger. There is a one-to-one relationship
between boolean functions and electronic circuits. Electrical engineers who design CPUs
and other computer related circuits need to be intimately familiar with this stuff. Even
if you never intend to design your own electronic circuits, understanding this
relationship is important if you want to make the most of any computer system.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-3"></a>2.6.1 <a NAME="MARKER-9-70"></a>Correspondence Between Electronic Circuits and Boolean Functions</font></strong></p>

<p><font face="Arial" size="2"><a NAME="MARKER-2-71"></a>There is a one-to-one
correspondence between an electrical circuits and boolean functions. For any boolean
function you can design an electronic circuit and vice versa. Since boolean functions only
require the AND, OR, and NOT boolean operators, we can construct any electronic circuit
using these operations exclusively. The boolean AND, OR, and NOT functions correspond to
the following electronic circuits, the AND, OR, and inverter (NOT) gates:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch02a17.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH02/CH02a17.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="327" HEIGHT="35"> </font></p>

<p><font face="Arial" size="2">One interesting fact is that you only need a single gate
type to implement any electronic circuit. This gate is the<a NAME="MARKER-2-73"></a><a NAME="MARKER-2-74"></a> NAND gate, shown below:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch02a18.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH02/CH02a18.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="131" HEIGHT="35"> </font></p>

<p><font face="Arial" size="2"><a NAME="MARKER-2-75"></a>To prove that we can construct
any boolean function using only NAND gates, we need only show how to build an inverter
(NOT), AND gate, and OR gate from a NAND (since we can create any boolean function using
only AND, NOT, and OR). Building an inverter is easy, just connect the two inputs
together:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch02a19.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH02/CH02a19.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="101" HEIGHT="35"> </font></p>

<p><font face="Arial" size="2">Once we can build an inverter, building an AND gate is easy
- just invert the output of a NAND gate. After all, <code>NOT (NOT (A AND B))</code> is
equivalent to <code>A AND B.</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch02a20.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH02/CH02a20.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="182" HEIGHT="35"></code> </font></p>

<p><font face="Arial" size="2">Of course, this takes two NAND gates to construct a single
AND gate, but no one said that circuits constructed only with NAND gates would be optimal,
only that it is possible to do.</font></p>

<p><font face="Arial" size="2">The remaining gate we need to synthesize is the logical-OR
gate. We can easily construct an OR gate from NAND gates by applying DeMorgan's theorems. </font></p>

<pre><font face="Courier New" size="2">(A or B)'       = A' and B'     DeMorgan's Theorem.
A or B          = (A' and B')'  Invert both sides of the equation.
A or B          = A' nand B'    Definition of NAND operation.</font></pre>

<p><font face="Arial" size="2">By applying these transformations, you get the circuit:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch02a21.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH02/CH02a21.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="183" HEIGHT="77"> </font></p>

<p><font face="Arial" size="2">Now you might be wondering why we would even bother with
this. After all, why not just use logical AND, OR, and inverter gates directly? There are
two reasons for this. First, NAND gates are generally less expensive to build than other
gates. Second, it is also much easier to build up complex integrated circuits from the
same basic building blocks than it is to construct an integrated circuit using different
basic gates.</font></p>

<p><font face="Arial" size="2"><a NAME="MARKER-2-76"></a>Note, by the way, that it is
possible to construct any logic circuit using only NOR gates. The correspondence between
NAND and NOR logic is orthogonal to the correspondence between the two canonical forms
appearing in this chapter (sum of minterms vs. product of maxterms). While NOR logic is
useful for many circuits, most electronic designs use NAND logic. See the exercises for
more examples.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-27"></a>2.6.2 <a NAME="MARKER-9-77"></a>Combinatorial Circuits<a NAME="MARKER-2-78"></a></font></strong></p>

<p><font face="Arial" size="2">A combinatorial circuit is a system containing basic
boolean operations (AND, OR, NOT), some inputs, and a set of outputs. Since each output
corresponds to an individual logic function, a combinatorial circuit often implements
several different boolean functions. It is very important that you remember this fact -
each output represents a different boolean function.</font></p>

<p><font face="Arial" size="2">A computer's CPU is built up from various combinatorial
circuits. For example, you can implement an addition circuit using boolean functions.
Suppose you have two one-bit numbers, A and B. You can produce the one-bit sum and the
one-bit carry of this addition using the two boolean functions: </font></p>

<pre><font face="Courier New" size="2">S =     AB' + A'B       Sum of A and B.
C =     AB              Carry from addition of A and B.</font></pre>

<p><font face="Arial" size="2">These two boolean functions implement a<a NAME="MARKER-2-79"></a> half-adder. Electrical engineers call it a half adder because it
adds two bits together but cannot add in a carry from a previous operation. A<a NAME="MARKER-2-80"></a><a NAME="MARKER-2-81"></a> full adder adds three one-bit inputs
(two bits plus a carry from a previous addition) and produces two outputs: the sum and the
carry. The two logic equations for a full adder are</font> </p>

<pre><font face="Courier New" size="2">S       = A'B'C + A'BC' + AB'C' + ABC
Cout    = AB + AC + BC</font></pre>

<p><font face="Arial" size="2">Although these logic equations only produce a single bit
result (ignoring the carry), it is easy to construct an n-bit sum by combining adder
circuits:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch02a22.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH02/CH02a22.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="138" HEIGHT="185"> </font></p>

<p><font face="Arial" size="2">So, as this example clearly illustrates, we can use logic
functions to implement arithmetic and boolean operations.</font></p>

<p><font face="Arial" size="2">Another common combinatorial circuit is the<a NAME="MARKER-2-82"></a> seven-segment decoder. This is a combinatorial circuit that
accepts four inputs and determines which of the seven segments on a seven-segment LED
display should be on (logic one) or off (logic zero). Since a seven segment display
contains seven output values (one for each segment), there will be seven logic functions
associated with the display (segment zero through segment six). See the figure below for
the segment assignments.</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch02a23.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH02/CH02a23.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="64" HEIGHT="82"> </font></p>

<p><font face="Arial" size="2">The figure below shows the segment assignments for each of
the ten decimal values.</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch02a24.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH02/CH02a24.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="144" HEIGHT="82"> </font></p>

<p><font face="Arial" size="2">The four inputs to each of these seven boolean functions
are the four bits from a binary number in the range 0..9. Let D be the H.O. bit of this
number and A be the L.O. bit of this number. Each logic function should produce a one
(segment on) for a given input if that particular segment should be illuminated. For
example S4 (segment four) should be on for binary values 0000, 0010, 0110, and 1000. For
each value that illuminates a segment, you will have one minterm in the logic equation: </font></p>

<pre><font face="Courier New" size="2">S4 = D'C'B'A' + D'C'BA' + D'CBA' + DC'B'A'. </font></pre>

<p><font face="Arial" size="2">So, as a second example, is on for values zero, two, three,
five, six, seven, eight, and nine. Therefore, the logic function for S0 is </font></p>

<pre><font face="Courier New" size="2">S0 = D'C'B'A' + D'C'BA' + D'C'BA + D'CB'A + D'CBA' + D'CBA + DC'B'A' + DC'B'A</font></pre>

<p><font face="Arial" size="2">You can generate the other five logic functions in a
similar fashion (see the exercises).</font></p>

<p><font face="Arial" size="2">Combinatorial circuits are the basis for many components of
a basic computer system. You can construct circuits for addition, subtraction, comparison,
multiplication, division, and many other operations using combinatorial logic.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-56"></a>2.6.3 <a NAME="MARKER-9-83"></a>Sequential and Clocked Logic<a NAME="MARKER-2-84"></a><a NAME="MARKER-2-85"></a></font></strong></p>

<p><font face="Arial" size="2">One major problem with combinatorial logic is that it is
memoryless. In theory, all logic function outputs depend only on the current inputs. Any
change in the input values is immediately reflected in the outputs. Unfortunately,
computers need the ability to remember the results of past computations. This is the
domain of sequential or clocked logic.</font></p>

<p><font face="Arial" size="2">A<a NAME="MARKER-2-86"></a><a NAME="MARKER-2-87"></a><a NAME="MARKER-2-88"></a> memory cell is an electronic circuit that remembers an input value
after the removal of that input value. The most basic memory unit is the set/reset
flip-flop. You can construct an SR flip-flop using two NAND gates, as shown below:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch02a25.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH02/CH02a25.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="160" HEIGHT="95"> </font></p>

<p><font face="Arial" size="2">The S and R inputs are normally high. If you temporarily
set the S input to zero and then bring it back to one (toggle the S input), this forces
the Q output to one. Likewise, if you toggle the R input from one to zero back to one,
this sets the Q output to zero. The Q' input is generally the inverse of the Q output. </font></p>

<p><font face="Arial" size="2">Note that if both S and R are one, then the Q output
depends upon Q. That is, whatever Q happens to be, the top NAND gate continues to output
that value. If Q was originally one, then there are two ones as inputs to the bottom
flip-flop (Q nand R). This produces an output of zero (Q'). Therefore, the two inputs to
the top NAND gate are zero and one. This produces the value one as an output (matching the
original value for Q). </font></p>

<p><font face="Arial" size="2">If the original value for Q was zero, then the inputs to
the bottom NAND gate are Q=0 and R=1. Therefore, the output of this NAND gate is one. The
inputs to the top NAND gate, therefore, are S=1 and Q'=1. This produces a zero output, the
original value of Q.</font></p>

<p><font face="Arial" size="2">Suppose Q is zero, S is zero and R is one. This sets the
two inputs to the top flip-flop to one and zero, forcing the output (Q) to one. Returning
S to the high state does not change the output at all. You can obtain this same result if
Q is one, S is zero, and R is one. Again, this produces an output value of one. This value
remains one even when S switches from zero to one. Therefore, toggling the S input from
one to zero and then back to one produces a one on the output (i.e., sets the flip-flop).
The same idea applies to the R input, except it forces the Q output to zero rather than to
one.</font></p>

<p><font face="Arial" size="2">There is one catch to this circuit. It does not operate
properly if you set both the S and R inputs to zero simultaneously. This forces both the Q
and Q' outputs to one (which is logically inconsistent). Whichever input remains zero the
longest determines the final state of the flip-flop. A flip-flop operating in this mode is
said to be unstable.</font></p>

<p><font face="Arial" size="2">The only problem with the S/R flip-flop is that you must
use separate inputs to remember a zero or a one value. A memory cell would be more
valuable to us if we could specify the data value to remember on one input and provide a
clock input to latch the input value. <a NAME="MARKER-2-89"></a>This type of flip-flop,
the D flip-flop (for data) uses the circuit;</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch02a26.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH02/CH02a26.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="296" HEIGHT="120"> </font></p>

<p><font face="Arial" size="2">Assuming you fix the Q and Q' outputs to either 0/1 or 1/0,
sending a clock pulse that goes from zero to one back to zero will copy the D input to the
Q output. It will also copy D' to Q'. The exercises at the end of this chapter will expect
you to describe this operation in detail, so study this diagram carefully.</font></p>

<p><font face="Arial" size="2">Although remembering a single bit is often important, in
most computer systems you will want to remember a group of bits. You can remember a
sequence of bits by combining several D flip-flops in parallel. Concatenating flip-flops
to store an n-bit value forms a<a NAME="MARKER-2-90"></a> register. The electronic
schematic in the figure below shows how to build an eight-bit register from a set of D
flip-flops.</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch02a27.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH02/CH02a27.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="421" HEIGHT="92"> </font></p>

<p><font face="Arial" size="2">Note that the eight D flip-flops use a common clock line.
This diagram does not show the Q' outputs on the flip-flops since they are rarely required
in a register.</font></p>

<p><font face="Arial" size="2">D flip-flops are useful for building many sequential
circuits above and beyond simple registers. For example, you can build a <a NAME="MARKER-2-91"></a>shift register that shifts the bits one position to the left on
each clock pulse. A four-bit shift register appears below: </font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch02a28.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH02/CH02a28.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="236" HEIGHT="92"> </font></p>

<p><font face="Arial" size="2">You can even build a <a NAME="MARKER-2-92"></a>counter,
that counts the number of times the clock toggles from one to zero and back to one using
flip-flops. The circuit in the figure below implements a four bit counter using D
flip-flops.</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch02a29.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH02/CH02a29.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="260" HEIGHT="99"> </font></p>

<p><font face="Arial" size="2">Surprisingly, you can build an entire CPU with
combinatorial circuits and only a few additional sequential circuits beyond these.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING3-81"></a>2.7 <a NAME="MARKER-9-93"></a>Okay, What Does It Have To Do With Programming, Then?</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">Once you have registers, counters, and shift registers, you
can build state machines. The implementation of an algorithm in hardware using state
machines is well beyond the scope of this text. However, one important point must be made
with respect to such circuitry - any algorithm you can implement in software you can also
implement directly in hardware. This suggests that boolean logic is the basis for
computation on all modern computer systems. Any program you can write, you can specify as
a sequence of boolean equations.</font></p>

<p><font face="Arial" size="2">Of course, it is much easier to specify a solution to a
programming problem using languages like Pascal, C, or even assembly language than it is
to specify the solution using boolean equations. Therefore, it is unlikely that you would
ever implement an entire program using a set of state machines and other logic circuitry.
Nevertheless, there are times when a hardware implementation is better. A hardware
solution can be one, two, three, or more orders of magnitude faster than an equivalent
software solution. Therefore, some time critical operations may require a hardware
solution.</font></p>

<p><font face="Arial" size="2">A more interesting fact is that the converse of the above
statement is also true. Not only can you implement all software functions in hardware, but
it is also possible to implement all hardware functions in software. This is an important
revelation because many operations you would normally implement in hardware are much
cheaper to implement using software on a microprocessor. Indeed, this is a primary use of
assembly language in modern systems - to inexpensively replace a complex electronic
circuit. It is often possible to replace many tens or hundreds of dollars of electronic
components with a single $25 microcomputer chip. The whole field of embedded systems deals
with this very problem. Embedded systems are computer systems embedded in other products.
For example, most microwave ovens, TV sets, video games, CD players, and other consumer
devices contain one or more complete computer systems whose sole purpose is to replace a
complex hardware design. Engineers use computers for this purpose because they are less
expensive and easier to design with than traditional electronic circuitry.</font></p>

<p><font face="Arial" size="2">You can easily design software that reads switches (input
variables) and turns on motors, LEDs or lights, locks or unlocks a door, etc. (output
functions). To write such software, you will need an understanding of boolean functions
and how to implement such functions in software.</font></p>

<p><font face="Arial" size="2">Of course, there is one other reason for studying boolean
functions, even if you never intend to write software intended for an embedded system or
write software that manipulates real-world devices. Many high level languages process
boolean expressions (e.g., those expressions that control an <code>if</code> statement or <code>while</code>
loop). By applying transformations like DeMorgan's theorems or a mapping optimization it
is often possible to improve the performance of high level language code. Therefore,
studying boolean functions is important even if you never intend to design an electronic
circuit. It can help you write better code in a traditional programming language.</font></p>

<p><font face="Arial" size="2">For example, suppose you have the following statement in
Pascal: </font></p>

<pre><font face="Courier New" size="2">if ((x=y) and (a &lt;&gt; b)) or ((x=y) and (c &lt;= d)) then SomeStmt;</font></pre>

<p><font face="Arial" size="2">You can use the distributive law to simplify this to: </font></p>

<pre><font face="Courier New" size="2">if ((x=y) and ((a &lt;&gt; b) or (c &lt;= d)) then SomeStmt;</font></pre>

<p><font face="Arial" size="2">Likewise, we can use DeMorgan's theorem to reduce </font></p>

<pre><font face="Courier New" size="2">while (not((a=b) and (c=d)) do Something;</font></pre>

<p><font face="Arial" size="2">to </font></p>

<pre><font face="Courier New" size="2">while (a &lt;&gt; b) or (c &lt;&gt; d) do Something;</font></pre>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING3-98"></a>2.8 Generic
    Boolean Functions</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">For a specific application, you can create a logic function
that achieves some specific result. Suppose, however, that you wanted to write a program
to simulate any possible boolean function? For example, on the companion diskette, there
is a program that lets you enter an arbitrary boolean function with one to four different
variables. This program will read the inputs and produce and necessary function results.
Since the number of unique four variable functions is large (65,536, to be exact), it is
not practical to include a specific solution for each one in a program. What is necessary
is a generic logic function, one that will compute the results for any arbitrary function.
This section describes how to write such a function.</font></p>

<p><font face="Arial" size="2">A generic boolean function of four variables requires five
parameters - the four input parameters and a fifth parameter that specifies the function
to compute. While there are lots of ways to specify the function to compute, we'll pass
the boolean function's number as this fifth parameter.</font></p>

<p><font face="Arial" size="2">At first glance you might wonder how we can compute a
function using the function's number. However, keep in mind that the bits that make up the
function's number come directly from the truth table for that function. Therefore, if we
extract the bits from the function's number, we can construct the truth table for that
function. Indeed, if we just select the ith bit of the function number, where i = D*8 +
C*4 + B*2 +A you will get the function result for that particular value of A, B, C, and D.
The following examples, in C and Pascal, show how to write such functions: </font></p>

<pre><font face="Courier New" size="2">/************************************************************************/
/*                                                                      */
/* This C program demonstrates how to write a generic logic function    */
/* that can compute any logic function of four variables.  Given C's    */
/* bit manipulation operators, along with hexadecimal I/O, this is an   */
/* easy task to accomplish in the C programming language.               */
/*                                                                      */
/************************************************************************/

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;


/* Generic logic function.  The &quot;Func&quot; parameter contains the 16-bit    */
/* logical function number.  This is actually an encoded truth table    */
/* for the function.  The a, b, c, and d parameters are the inputs to   */
/* the logic function.  If we treat &quot;func&quot; as a 2x2x2x2 array of bits,  */
/* this particular function selects bit &quot;func[d,c,b,a]&quot; from func.      */

int
generic(int func, int a, int b, int c, int d)
{
        /* Return the bit specified by a, b, c, and d */
        
        return (func &gt;&gt; (a + b*2 + c*4 + d*8)) &amp; 1;
}





/* Main program to drive the generic logic function written in C.       */

main()
{
        int func, a, b, c, d;

        /* Repeat the following until the user enters zero.             */
        
        do
        {
                /* Get the function's number (truth table)              */
                
                printf(&quot;Enter function value (hex): &quot;);
                scanf(&quot;%x&quot;, &amp;func);
                
                /* If the user specified zero as the function #, stop   */
                /* the program.                                         */
                
                if (func != 0)
                {
                        printf(&quot;Enter values for d, c, b, &amp; a: &quot;);
                        scanf(&quot;%d%d%d%d&quot;,
                                &amp;d, &amp;c, &amp;b, &amp;a);

                        printf(&quot;The result is %d\n&quot;, generic(func,a,b,c,d));
                        printf(&quot;Func = %x, A=%d, B=%d, C=%d, D=%d\n&quot;,
                                func, a, b, c, d);
                }
                
                
        } while (func !=0);

}</font></pre>

<p><font face="Arial" size="2">The following Pascal program is written for Standard
Pascal. Standard Pascal does not provide any bit manipulation operations, so this program
is lengthy since it has to simulate bits using an array of integers. Most modern Pascals
(especially Turbo Pascal) provide built-in bit operations or library routines that operate
on bits. This program would be much easier to write using such non-standard features. </font></p>

<pre><font face="Courier New" size="2">program GenericFunc(input,output);

(* Since standard Pascal does not provide an easy way to directly man-  *)
(* ipulate bits in an integer, we will simulate the function number     *)
(* using an array of 16 integers. &quot;GFTYPE&quot; is the type of that array.   *)

type
    gftype = array [0..15] of integer;

var
   a, b, c, d:integer;
   fresult:integer;
   func: gftype;


(* Standard Pascal does not provide the ability to shift integer data   *)
(* to the left or right.  Therefore, we will simulate a 16-bit value    *)
(* using an array of 16 integers.  We can simulate shifts by moving     *)
(* data around in the array.                                            *)
(*                                                                      *)
(* Note that Turbo Pascal *does* provide shl and shr operators.  How-   *)
(* ever, this code is written to work with standard Pascal, not just    *)
(* Turbo Pascal.                                                        *)
(*                                                                      *)
(* ShiftLeft shifts the values in func on position to the left and in-  *)
(* serts the shiftin value into &quot;bit position&quot; zero.                    *)

procedure ShiftLeft(shiftin:integer);
var i:integer;
begin

     for i := 15 downto 1 do func[i] := func[i-1];
     func[0] := shiftin;

end;


(* ShiftNibble shifts the data in func to the left four positions and   *)
(* inserts the four bits a (L.O.), b, c, and d (H.O.) into the vacated  *)
(* positions.                                                           *)

procedure ShiftNibble(d,c,b,a:integer);
begin

     ShiftLeft(d);
     ShiftLeft(c);
     ShiftLeft(b);
     ShiftLeft(a);
end;


(* ShiftRight shifts the data in func one position to the right.  It    *)
(* shifts a zero into the H.O. bit of the array.                        *)

procedure ShiftRight;
var i:integer;
begin

     for i := 0 to 14 do func[i] := func[i+1];
     func[15] := 0;

end;


(* ToUpper converts a lower case character to upper case.               *)

procedure toupper(var ch:char);
begin

     if (ch in ['a'..'z']) then ch := chr(ord(ch) - 32);

end;


(* ReadFunc reads a hexadecimal function number from the user and puts  *)
(* this value into the func array (bit by bit).                         *)

function ReadFunc:integer;
var ch:char;
    i, val:integer;
begin

     write('Enter function number (hexadecimal): ');
     for i := 0 to 15 do func[i] := 0;
     repeat

           read(ch);
           if not eoln then begin

                      toupper(ch);
                      case ch of
                           '0': ShiftNibble(0,0,0,0);
                           '1': ShiftNibble(0,0,0,1);
                           '2': ShiftNibble(0,0,1,0);
                           '3': ShiftNibble(0,0,1,1);
                           '4': ShiftNibble(0,1,0,0);
                           '5': ShiftNibble(0,1,0,1);
                           '6': ShiftNibble(0,1,1,0);
                           '7': ShiftNibble(0,1,1,1);
                           '8': ShiftNibble(1,0,0,0);
                           '9': ShiftNibble(1,0,0,1);
                           'A': ShiftNibble(1,0,1,0);
                           'B': ShiftNibble(1,0,1,1);
                           'C': ShiftNibble(1,1,0,0);
                           'D': ShiftNibble(1,1,0,1);
                           'E': ShiftNibble(1,1,1,0);
                           'F': ShiftNibble(1,1,1,1);
                           else write(chr(7),chr(8));
                      end;
           end;
     until eoln;
     val := 0;
     for i := 0 to 15 do val := val + func[i];
     ReadFunc := val;
end;


(* Generic - Computes the generic logical function specified by *)
(*           the function number &quot;func&quot; on the four input vars  *)
(*           a, b, c, and d.  It does this by returning bit     *)
(*           d*8 + c*4 + b*2 + a from func.                     *)

function Generic(var func:gftype; a,b,c,d:integer):integer;
begin
          Generic := func[a + b*2 + c*4 + d*8];
end;


begin (* main *)

      repeat

            fresult := ReadFunc;
            if (fresult &lt;&gt; 0) then begin

               write('Enter values for D, C, B, &amp; A (0/1):');
               readln(d, c, b, a);
               writeln('The result is ',Generic(func,a,b,c,d));

            end;
      until fresult = 0;

end.</font></pre>

<p><font face="Arial" size="2">The following code demonstrates the power of bit
manipulation operations. This version of the code above uses special features present in
the Turbo Pascal programming language that allows programmers to shift left or right and
do a bitwise logical AND on integer variables: </font></p>

<pre><font face="Courier New" size="2">program GenericFunc(input,output);
const
     hex = ['a'..'f', 'A'..'F'];
     decimal = ['0'..'9'];

var
   a, b, c, d:integer;
   fresult:integer;
   func: integer;


(* Here is a second version of the Pascal generic function that uses *)
(* the features of Turbo Pascal to simplify the program.             *)


function ReadFunc:integer;
var ch:char;
    i, val:integer;
begin

     write('Enter function number (hexadecimal): ');
     repeat

           read(ch);
           func := 0;
           if not eoln then begin

              if (ch in Hex) then 
                func := (func shl 4) + (ord(ch) and 15) + 9
              else if (ch in Decimal) then 
                func := (func shl 4) + (ord(ch) and 15)
              else write(chr(7));

           end;
     until eoln;
     ReadFunc := func;
end;


(* Generic - Computes the generic logical function specified by *)
(*           the function number &quot;func&quot; on the four input vars  *)
(*           a, b, c, and d.  It does this by returning bit     *)
(*           d*8 + c*4 + b*2 + a from func.  This version re-   *)
(*           lies on Turbo Pascal's shift right operator and    *)
(*           its ability to do bitwise operations on integers.  *)

function Generic(func,a,b,c,d:integer):integer;
begin
          Generic := (func shr (a + b*2 + c*4 + d*8)) and 1;
end;


begin (* main *)

      repeat

            fresult := ReadFunc;
            if (fresult &lt;&gt; 0) then begin

               write('Enter values for D, C, B, &amp; A (0/1):');
               readln(d, c, b, a);
               writeln('The result is ',Generic(func,a,b,c,d));

            end;
      until fresult = 0;

end.</font></pre>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH02-2.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH02-2.html">Chapter Two</a> (Part 2)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="../Chapter_3/CH03-1.html">Chapter Three</a> </strong></font><a href="../Chapter_3/CH03-1.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Two: Boolean Algebra (Part 3)<br>
26 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_2/CH02-3.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:24:54 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
