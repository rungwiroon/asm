<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_15/CH15-5.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:01 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER FIFTEEN: STRINGS AND CHARACTER SETS (Part 5)</title>
</head>

<body stylesrc="../toc.html" topmargin="10" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING5"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH15-4.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH15-4.html">Chapter
    Fifteen</a> (Part 4)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH15-6.html">Chapter Fifteen</a> (Part 6)&nbsp; </strong></font><a href="CH15-6.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10" colspan="2"><a NAME="HEADING5-0"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0" colspan="2"><font face="Arial" size="4"><strong>CHAPTER
    FIFTEEN:<br>
    STRINGS AND CHARACTER SETS (Part 5)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10" valign="top" colspan="2"></td>
  </tr>
  <tr>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING5-1"><b>15.4 </b>-
    String Functions in the UCR Standard Library</a> <br>
    <a HREF="#HEADING5-6"><b>15.4.1 </b>- StrBDel, StrBDelm</a> <br>
    <a HREF="#HEADING5-48"><b>15.4.2 </b>- Strcat, Strcatl, Strcatm, Strcatml</a> <br>
    <a HREF="#HEADING5-124"><b>15.4.3 </b>- Strchr</a> <br>
    <a HREF="#HEADING5-153"><b>15.4.4 </b>- Strcmp, Strcmpl, Stricmp, Stricmpl</a> <br>
    <a HREF="#HEADING5-213"><b>15.4.5 </b>- Strcpy, Strcpyl, Strdup, Strdupl</a> <br>
    <a HREF="#HEADING5-251"><b>15.4.6 </b>- Strdel, Strdelm</a> <br>
    <a HREF="#HEADING5-278"><b>15.4.7 </b>- Strins, Strinsl, Strinsm, Strinsml</a> </font></td>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING5-323"><b>15.4.8
    </b>- Strlen</a> <br>
    <a HREF="#HEADING5-337"><b>15.4.9 </b>- Strlwr, Strlwrm, Strupr, Struprm</a> <br>
    <a HREF="#HEADING5-376"><b>15.4.10 </b>- Strrev, Strrevm</a> <br>
    <a HREF="#HEADING5-402"><b>15.4.11 </b>- Strset, Strsetm</a> <br>
    <a HREF="#HEADING5-426"><b>15.4.12 </b>- Strspan, Strspanl, Strcspan, Strcspanl</a> <br>
    <a HREF="#HEADING5-476"><b>15.4.13 </b>- Strstr, Strstrl</a> <br>
    <a HREF="#HEADING5-508"><b>15.4.14 </b>- Strtrim, Strtrimm</a> <br>
    <a HREF="#HEADING5-555"><b>15.4.15 </b>- Other String Routines in the UCR Standard Library</a>
    </font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="20" colspan="2"></td>
  </tr>
  <tr>
    <td width="100%" colspan="2"><strong><font face="Arial" size="3"><a NAME="HEADING5-1"></a>15.4
    String Functions in the UCR Standard Library</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1" colspan="2"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">The UCR Standard Library for 80x86 Assembly Language
Programmers provides a very rich set of string functions you may use. These routines, for
the most part, are quite similar to the string functions provided in the C Standard
Library. As such, these functions support zero terminated strings rather than the length
prefixed strings supported by the functions in the previous sections.</font></p>

<p><font face="Arial" size="2">Because there are so many different UCR StdLib string
routines and the sources for all these routines are in the public domain (and are present
on the companion CD-ROM for this text), the following sections will not discuss the
implementation of each routine. Instead, the following sections will concentrate on how to
use these library routines.</font></p>

<p><font face="Arial" size="2">The UCR library often provides several variants of the same
routine. Generally a suffix of &quot;l&quot;, &quot;m&quot;, or &quot;ml&quot; appears at
the end of the name of these variant routines. The &quot;l&quot; suffix stands for
&quot;literal constant&quot;. Routines with the &quot;l&quot; (or &quot;ml&quot;) suffix
require two string operands. The first is generally pointed at by <code>es:di </code>and
the second immediate follows the <code>call</code> in the code stream. </font></p>

<p><font face="Arial" size="2">Most StdLib string routines operate on the specified string
(or one of the strings if the function has two operands). The &quot;m&quot; (or
&quot;ml&quot;) suffix instructs the string function to allocate storage on the heap
(using <code>malloc</code>, hence the &quot;m&quot; suffix) for the new string and store
the modified result there rather than changing the source string(s). These routines always
return a pointer to the newly created string in the <code>es:di </code>registers. In the
event of a memory allocation error (insufficient memory), these routines with the
&quot;m&quot; or &quot;ml&quot; suffix return the carry flag set. They return the carry
clear if the operation was successful.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-6"></a>15.4.1 StrBDel, StrBDelm</font></strong></p>

<p><font face="Arial" size="2">These two routines delete leading spaces from a string. <code>StrBDel</code>
removes any leading spaces from the string pointed at by <code>es:di</code>. It actually
modifies the source string. <code>StrBDelm</code> makes a copy of the string on the heap
with any leading spaces removed. If there are no leading spaces, then the <code>StrBDel</code>
routines return the original string without modification. Note that these routines only
affect leading spaces (those appearing at the beginning of the string). They do not remove
trailing spaces and spaces in the middle of the string. See <code>Strtrim </code>if you
want to remove trailing spaces. Examples:</font></p>

<pre><font face="Courier New" size="2">MyString        byte    &quot;    Hello there, this is my string&quot;,0
MyStrPtr        dword   MyString
                 .
                 .
                 .
                les     di, MyStrPtr
                strbdelm            ;Creates a new string w/o leading spaces,
                jc      error       ; pointer to string is in ES:DI on return.
                puts                ;Print the string pointed at by ES:DI.
                free                ;Deallocate storage allocated by strbdelm.
                 .
                 .
                 .
; Note that &quot;MyString&quot; still contains the leading spaces.
; The following printf call will print the string along with
; those leading spaces. &quot;strbdelm&quot; above did not change MyString.

                printf
                byte    &quot;MyString = '%s'\n&quot;,0
                dword   MyString
                 .
                 .
                 .
                les     di, MyStrPtr
                strbdel

; Now, we really have removed the leading spaces from &quot;MyString&quot;

                printf
                byte    &quot;MyString = '%s'\n&quot;,0
                dword   MyString
                 .
                 .
                 .</font></pre>

<p><font face="Arial" size="2">Output from this code fragment:</font></p>

<pre><font face="Courier New" size="2">Hello there, this is my string
MyString = '   Hello there, this is my string'
MyString = 'Hello there, this is my string'</font></pre>

<h3><strong><font face="Arial" size="3"><a name="HEADING5-48"></a>15.4.2 Strcat, Strcatl,
Strcatm, Strcatml</font></strong></h3>

<p><font face="Arial" size="2">The <code>strcat(xx)</code> routines perform string
concatenation. On entry, <code>es:di </code>points at the first string, and for <code>strcat/strcatm</code>
<code>dx:si </code>points at the second string. For <code>strcatl</code> and <code>strcatlm</code>
the second string follows the call in the code stream. These routines create a new string
by appending the second string to the end of the first. In the case of <code>strcat</code>
and <code>strcatl</code>, the second string is directly appended to the end of the first
string (<code>es:di</code>) in memory. You must make sure there is sufficient memory at
the end of the first string to hold the appended characters. <code>Strcatm</code> and <code>strcatml</code>
create a new string on the heap (using <code>malloc</code>) holding the concatenated
result. Examples:</font></p>

<pre><font face="Courier New" size="2">String1         byte    &quot;Hello &quot;,0
                byte    16 dup (0)              ;Room for concatenation.

String2         byte    &quot;world&quot;,0

; The following macro loads ES:DI with the address of the
; specified operand.

lesi            macro   operand
                mov     di, seg operand
                mov     es, di
                mov     di, offset operand
                endm

; The following macro loads DX:SI with the address of the
; specified operand.

ldxi            macro   operand
                mov     dx, seg operand
                mov     si, offset operand
                endm
                 .
                 .
                 .
                lesi    String1
                ldxi    String2
                strcatm                 ;Create &quot;Hello world&quot;
                jc      error           ;If insufficient memory.
                print
                byte    &quot;strcatm: &quot;,0
                puts                    ;Print &quot;Hello world&quot;
                putcr
                free                    ;Deallocate string storage.
                 .
                 .
                 .
                lesi    String1         ;Create the string
                strcatml                        ; &quot;Hello there&quot;
                jc      error           ;If insufficient memory.
                byte    &quot;there&quot;,0
                print
                byte    &quot;strcatml: &quot;,0
                puts                    ;Print &quot;Hello there&quot;
                putcr
                free
                 .
                 .
                 .
                lesi    String1
                ldxi    String2
                strcat                  ;Create &quot;Hello world&quot;
                printf
                byte    &quot;strcat: %s\n&quot;,0
                 .
                 .
                 .
; Note: since strcat above has actually modified String1,
; the following call to strcatl appends &quot;there&quot; to the end
; of the string &quot;Hello world&quot;.

                lesi    String1
                strcatl
                byte    &quot;there&quot;,0
                printf
                byte    &quot;strcatl: %s\n&quot;,0
                 .
                 .
                 .</font></pre>

<p><font face="Arial" size="2">The code above produces the following output:</font></p>

<pre><font face="Courier New" size="2">strcatm: Hello world
strcatml: Hello there
strcat: Hello world
strcatl: Hello world there</font></pre>

<h3><a name="HEADING5-124"></a>15.4.3 Strchr</h3>

<p><font face="Arial" size="2">Strchr searches for the first occurrence of a single
character within a string. In operation it is quite similar to the <code>scasb </code>instruction.
However, you do not have to specify an explicit length when using this function as you
would for <code>scasb</code>.</font></p>

<p><font face="Arial" size="2">On entry, <code>es:di </code>points at the string you want
to search through, <code>al </code>contains the value to search for. On return, the carry
flag denotes success (C=1 means the character was not present in the string, C=0 means the
character was present). If the character was found in the string, <code>cx </code>contains
the index into the string where strchr located the character. Note that the first
character of the string is at index zero. So <code>strchr</code> will return zero if al
matches the first character of the string. If the carry flag is set, then the value in <code>cx
</code>has no meaning. Example:</font></p>

<pre><font face="Courier New" size="2">; Note that the following string has a period at location
; &quot;HasPeriod+24&quot;. 

HasPeriod       byte    &quot;This string has a period.&quot;,0
                 .
                 .
                 .
                lesi    HasPeriod       ;See strcat for lesi definition.
                mov     al, &quot;.&quot;         ;Search for a period.
                strchr
                jnc     GotPeriod
                print
                byte    &quot;No period in string&quot;,cr,lf,0
                jmp     Done

; If we found the period, output the offset into the string:

GotPeriod:      print
                byte    &quot;Found period at offset &quot;,0
                mov     ax, cx
                puti
                putcr
Done:</font></pre>

<p><font face="Arial" size="2">This code fragment produces the output:</font></p>

<pre><font face="Courier New" size="2">Found period at offset 24</font></pre>

<h3><strong><font face="Arial" size="3"><a name="HEADING5-153"></a>15.4.4 Strcmp, Strcmpl,
Stricmp, Stricmpl</font></strong></h3>

<p><font face="Arial" size="2">These routines compare strings using a lexicographical
ordering. On entry to <code>strcmp or stricmp</code>, <code>es:di </code>points at the
first string and <code>dx:si </code>points at the second string. <code>Strcmp</code>
compares the first string to the second and returns the result of the comparison in the
flags register. <code>Strcmpl</code> operates in a similar fashion, except the second
string follows the call in the code stream. The <code>stricmp</code> and <code>stricmpl</code>
routines differ from their counterparts in that they ignore case during the comparison.
Whereas <code>strcmp</code> would return 'not equal' when comparing &quot;Strcmp&quot;
with &quot;strcmp&quot;, the <code>stricmp</code> (and <code>stricmpl</code>) routines
would return &quot;equal&quot; since the only differences are upper vs. lower case. The
&quot;i&quot; in <code>stricmp</code> and <code>stricmpl</code> stands for &quot;ignore
case.&quot; Examples:</font></p>

<pre><font face="Courier New" size="2">String1         byte    &quot;Hello world&quot;, 0
String2         byte    &quot;hello world&quot;, 0
String3         byte    &quot;Hello there&quot;, 0
                 .
                 .
                 .
                lesi    String1         ;See strcat for lesi definition.
                ldxi    String2         ;See strcat for ldxi definition.
                strcmp
                jae     IsGtrEql
                printf
                byte    &quot;%s is less than %s\n&quot;,0
                dword   String1, String2
                jmp     Tryl

IsGtrEql:               printf
                byte    &quot;%s is greater or equal to %s\n&quot;,0
                dword   String1, String2

Tryl:           lesi    String2
                strcmpl
                byte    &quot;hi world!&quot;,0
                jne     NotEql
                printf
                byte    &quot;Hmmm..., %s is equal to 'hi world!'\n&quot;,0
                dword   String2
                jmp     Tryi

NotEql:         printf
                byte    &quot;%s is not equal to 'hi world!'\n&quot;,0
                dword   String2

Tryi:           lesi    String1
                ldxi    String2
                stricmp
                jne     BadCmp
                printf
                byte    &quot;Ignoring case, %s equals %s\n&quot;,0
                dword   String1, String2
                jmp     Tryil

BadCmp:         printf
                byte    &quot;Wow, stricmp doesn't work! %s &lt;&gt; %s\n&quot;,0
                dword   String1, String2

Tryil:          lesi    String2
                stricmpl
                byte    &quot;hELLO THERE&quot;,0
                jne     BadCmp2
                print
                byte    &quot;Stricmpl worked&quot;,cr,lf,0
                jmp     Done

BadCmp2:        print
                byte    &quot;Stricmp did not work&quot;,cr,lf,0

Done:</font></pre>

<h3><strong><font face="Arial" size="3"><a name="HEADING5-213"></a>15.4.5 Strcpy, Strcpyl,
Strdup, Strdupl</font></strong></h3>

<p><font face="Arial" size="2">The <code>strcpy</code> and <code>strdup</code> routines
copy one string to another. There is no <code>strcpym</code> or <code>strcpyml</code>
routines. <code>Strdup</code> and <code>strdupl</code> correspond to those operations. The
UCR Standard Library uses the names <code>strdup</code> and <code>strdupl</code> rather
than <code>strcpym</code> and <code>strcpyml</code> so it will use the same names as the C
standard library.</font></p>

<p><font face="Arial" size="2"><code>Strcpy</code> copies the string pointed at by <code>es:di
</code>to the memory locations beginning at the address in <code>dx:si</code>. There is no
error checking; you must ensure that there is sufficient free space at location <code>dx:si
</code>before calling <code>strcpy</code>. <code>Strcpy</code> returns with <code>es:di </code>pointing
at the destination string (that is, the original <code>dx:si </code>value). <code>Strcpyl</code>
works in a similar fashion, except the source string follows the call. </font></p>

<p><font face="Arial" size="2"><code>Strdup</code> duplicates the string which <code>es:di
</code>points at and returns a pointer to the new string on the heap. <code>Strdupl</code>
works in a similar fashion, except the string follows the call. As usual, the carry flag
is set if there is a memory allocation error when using <code>strdup</code> or <code>strdupl</code>.
Examples:</font></p>

<pre><font face="Courier New" size="2">String1         byte            &quot;Copy this string&quot;,0
String2         byte            32 dup (0)
String3         byte            32 dup (0)
StrVar1         dword           0
StrVar2         dword           0
                 .
                 .
                 .
                lesi    String1         ;See strcat for lesi definition.
                ldxi    String2         ;See strcat for ldxi definition.
                strcpy

                ldxi    String3
                strcpyl
                byte    &quot;This string, too!&quot;,0

                lesi    String1
                strdup
                jc      error                   ;If insufficient mem.
                mov     word ptr StrVar1, di    ;Save away ptr to
                mov     word ptr StrVar1+2, es  ; string.

                strdupl
                jc      error
                byte    &quot;Also, this string&quot;,0
                mov     word ptr StrVar2, di
                mov     word ptr StrVar2+2, es

                printf
                byte    &quot;strcpy: %s\n&quot;
                byte    &quot;strcpyl: %s\n&quot;
                byte    &quot;strdup: %^s\n&quot;
                byte    &quot;strdupl: %^s\n&quot;,0
                dword   String2, String3, StrVar1, StrVar2</font></pre>

<h3><strong><font face="Arial" size="3"><a name="HEADING5-251"></a>15.4.6 Strdel, Strdelm</font></strong></h3>
<code>

<p><font face="Arial" size="2">Strdel</code> and <code>strdelm</code> delete characters
from a string. <code>Strdel</code> deletes the specified characters within the string, <code>strdelm</code>
creates a new copy of the source string without the specified characters. On entry, <code>es:di
</code>points at the string to manipulate, <code>cx </code>contains the index into the
string where the deletion is to start, and <code>ax </code>contains the number of
characters to delete from the string. On return, <code>es:di </code>points at the new
string (which is on the heap if you call strdelm). For <code>strdelm</code> only, if the
carry flag is set on return, there was a memory allocation error. As with all UCR StdLib
string routines, the index values for the string are zero-based. That is, zero is the
index of the first character in the source string. Example:</font></p>

<pre><font face="Courier New" size="2">String1         byte    &quot;Hello there, how are you?&quot;,0
                 .
                 .
                 .
                lesi    String1         ;See strcat for lesi definition.
                mov     cx, 5           ;Start at position five (&quot; there&quot;)
                mov     ax, 6           ;Delete six characters.
                strdelm                 ;Create a new string.
                jc      error           ;If insufficient memory.
                print
                byte    &quot;New string:&quot;,0
                puts
                putcr

                lesi    String1
                mov     ax, 11
                mov     cx, 13
                strdel
                printf
                byte    &quot;Modified string: %s\n&quot;,0
                dword   String1</font></pre>

<p><font face="Arial" size="2">This code prints the following:</font></p>

<p><font face="Courier New" size="2">New string: Hello, how are you?<br>
Modified string: Hello there</font></p>

<h3><strong><font face="Arial" size="3"><a name="HEADING5-278"></a>15.4.7 Strins, Strinsl,
Strinsm, Strinsml</font></strong></h3>

<p><font face="Arial" size="2">The <code>strins(xx) </code>functions insert one string
within another. For all four routines <code>es:di </code>points at the source string into
you want to insert another string. <code>Cx </code>contains the insertion point (0..length
of source string). For <code>strins</code> and <code>strinsm</code>, <code>dx:si </code>points
at the string you wish to insert. For <code>strinsl</code> and <code>strinsml</code>, the
string to insert appears as a literal constant in the code stream. <code>Strins</code> and
<code>strinsl</code> insert the second string directly into the string pointed at by <code>es:di</code>.
<code>Strinsm</code> and <code>strinsml</code> make a copy of the source string and insert
the second string into that copy. They return a pointer to the new string in <code>es:di</code>.
If there is a memory allocation error then <code>strinsm/strinsml</code> sets the carry
flag on return. For <code>strins</code> and <code>strinsl</code>, the first string must
have sufficient storage allocated to hold the new string. Examples:</font></p>

<pre><font face="Courier New" size="2">InsertInMe      byte    &quot;Insert &gt;&lt; Here&quot;,0
                byte    16 dup (0)
InsertStr       byte    &quot;insert this&quot;,0
StrPtr1         dword   0
StrPtr2         dword   0
                 .
                 .
                 .
                lesi    InsertInMe      ;See strcat for lesi definition.
                ldxi    InsertStr       ;See strcat for ldxi definition.
                mov     cx, 8           ;Însert before &quot;&lt;&quot;
                strinsm
                mov     word ptr StrPtr1, di
                mov     word ptr StrPtr1+2, es

                lesi    InsertInMe
                mov     cx, 8
                strinsml
                byte    &quot;insert that&quot;,0
                mov     word ptr StrPtr2, di
                mov     word ptr StrPtr2+2, es

                lesi    InsertInMe
                mov     cx, 8
                strinsl
                byte    &quot; &quot;,0           ;Two spaces

                lesi    InsertInMe
                ldxi    InsertStr
                mov     cx, 9           ;In front of first space from above.
                strins

                printf
                byte    &quot;First string: %^s\n&quot;
                byte    &quot;Second string: %^s\n&quot;
                byte    &quot;Third string: %s\n&quot;,0
                dword   StrPtr1, StrPtr2, InsertInMe</font></pre>

<p><font face="Arial" size="2">Note that the <code>strins</code> and <code>strinsl</code>
operations above both insert strings into the same destination string. The output from the
above code is</font></p>

<pre><font face="Courier New" size="2">First string: Insert &gt;insert this&lt; here
Second string: Insert &gt;insert that&lt; here
Third string: Insert &gt; insert this &lt; here</font></pre>

<h3><strong><font face="Arial" size="3"><a name="HEADING5-323"></a>15.4.8 Strlen</font></strong></h3>
<code>

<p><font face="Arial" size="2">Strlen</code> computes the length of the string pointed at
by <code>es:di</code>. It returns the number of characters up to, but not including, the
zero terminating byte. It returns this length in the <code>cx </code>register. Example:</font></p>

<pre><font face="Courier New" size="2">GetLen          byte    &quot;This string is 33 characters long&quot;,0
                 .
                 .
                 .
                lesi    GetLen          ;See strcat for lesi definition.
                strlen
                print
                byte    &quot;The string is &quot;,0
                mov     ax, cx          ;Puti needs the length in AX!
                puti
                print
                byte    &quot; characters long&quot;,cr,lf,0</font></pre>

<h3><strong><font face="Arial" size="3"><a name="HEADING5-337"></a>15.4.9 Strlwr, Strlwrm,
Strupr, Struprm</font></strong></h3>
<code>

<p><font face="Arial" size="2">Strlwr</code> and <code>Strlwrm</code> convert any upper
case characters in a string to lower case. <code>Strupr</code> and <code>Struprm</code>
convert any lower case characters in a string to upper case. These routines do not affect
any other characters present in the string. For all four routines, <code>es:di </code>points
at the source string to convert. <code>Strlwr</code> and <code>strupr</code> modify the
characters directly in that string. <code>Strlwrm</code> and <code>struprm</code> make a
copy of the string to the heap and then convert the characters in the new string. They
also return a pointer to this new string in <code>es:di</code>. As usual for UCR StdLib
routines, <code>strlwrm</code> and <code>struprm</code> return the carry flag set if there
is a memory allocation error. Examples:</font></p>

<pre><font face="Courier New" size="2">String1         byte    &quot;This string has lower case.&quot;,0
String2         byte    &quot;THIS STRING has Upper Case.&quot;,0
StrPtr1         dword   0
StrPtr2         dword   0
                 .
                 .
                 .
                lesi    String1         ;See strcat for lesi definition.
                struprm                 ;Convert lower case to upper case.
                jc      error
                mov     word ptr StrPtr1, di
                mov     word ptr StrPtr1+2, es

                lesi    String2
                strlwrm                 ;Convert upper case to lower case.
                jc      error
                mov     word ptr StrPtr2, di
                mov     word ptr StrPtr2+2, es

                lesi    String1
                strlwr                  ;Convert to lower case, in place.

                lesi    String2
                strupr                  ;Convert to upper case, in place.

                printf
                byte    &quot;struprm: %^s\n&quot;
                byte    &quot;strlwrm: %^s\n&quot;
                byte    &quot;strlwr: %s\n&quot;
                byte    &quot;strupr: %s\n&quot;,0
                dword   StrPtr1, StrPtr2, String1, String2</font></pre>

<p><font face="Arial" size="2">The above code fragment prints the following:</font></p>

<pre><font face="Courier New" size="2">struprm: THIS STRING HAS LOWER CASE
strlwrm: this string has upper case
strlwr: this string has lower case
strupr: THIS STRING HAS UPPER CASE</font></pre>

<h3><strong><font face="Arial" size="3"><a name="HEADING5-376"></a>15.4.10 Strrev, Strrevm</font></strong></h3>

<p><font face="Arial" size="2">These two routines reverse the characters in a string. For
example, if you pass <code>strrev</code> the string &quot;ABCDEF&quot; it will convert
that string to &quot;FEDCBA&quot;. As you'd expect by now, the <code>strrev</code> routine
reverse the string whose address you pass in <code>es:di</code>; <code>strrevm</code>
first makes a copy of the string on the heap and reverses those characters leaving the
original string unchanged. Of course <code>strrevm</code> will return the carry flag set
if there was a memory allocation error. Example:</font></p>

<pre><font face="Courier New" size="2">Palindrome      byte    &quot;radar&quot;,0
NotPaldrm       byte    &quot;x + y - z&quot;,0
StrPtr1         dword   0
                 .
                 .
                 .
                lesi    Palindrome      ;See strcat for lesi definition.
                strrevm
                jc      error
                mov     word ptr StrPtr1, di
                mov     word ptr StrPtr1+2, es

                lesi    NotPaldrm
                strrev

                printf
                byte    &quot;First string: %^s\n&quot;
                byte    &quot;Second string: %s\n&quot;,0
                dword   StrPtr1, NotPaldrm</font></pre>

<p><font face="Arial" size="2">The above code produces the following output:</font></p>

<pre><font face="Courier New" size="2">First string: radar
Second string: z - y + x</font></pre>

<h3><strong><font face="Arial" size="3"><a name="HEADING5-402"></a>15.4.11 Strset, Strsetm</font></strong></h3>
<code>

<p><font face="Arial" size="2">Strset</code> and <code>strsetm</code> replicate a single
character through a string. Their behavior, however, is not quite the same. In particular,
while <code>strsetm</code> is quite similar to the repeat function (see <a HREF="#nonexistent-marker">&quot;Repeat&quot; on page 840</a>), <code>strset</code> is
not. Both routines expect a single character value in the <code>al </code>register. They
will replicate this character throughout some string. <code>Strsetm</code> also requires a
count in the <code>cx </code>register. It creates a string on the heap consisting of <code>cx</code>
characters and returns a pointer to this string in <code>es:di </code>(assuming no memory
allocation error). <code>Strset</code>, on the other hand, expects you to pass it the
address of an existing string in <code>es:di</code>. It will replace each character in
that string with the character in <code>al</code>. Note that you do not specify a length
when using the <code>strset</code> function, strset uses the length of the existing
string. Example:</font></p>

<pre><font face="Courier New" size="2">String1         byte    &quot;Hello there&quot;,0
                 .
                 .
                 .
                lesi    String1         ;See strcat for lesi definition.
                mov     al, '*'
                strset

                mov     cx, 8
                mov     al, '#'
                strsetm

                print
                byte    &quot;String2: &quot;,0
                puts
                printf
                byte    &quot;\nString1: %s\n&quot;,0
                dword   String1</font></pre>

<p><font face="Arial" size="2">The above code produces the output:</font></p>

<pre><font face="Courier New" size="2">String2: ########
String1: ***********</font></pre>

<h3><strong><font face="Arial" size="3"><a name="HEADING5-426"></a>15.4.12 Strspan,
Strspanl, Strcspan, Strcspanl</font></strong></h3>

<p><font face="Arial" size="2">These four routines search through a string for a character
which is either in some specified character set (<code>strspan</code>, <code>strspanl</code>)
or not a member of some character set (<code>strcspan</code>, <code>strcspanl</code>).
These routines appear in the UCR Standard Library only because of their appearance in the
C standard library. You should rarely use these routines. The UCR Standard Library
includes some other routines for manipulating character sets and performing character
matching operations. Nonetheless, these routines are somewhat useful on occasion and are
worth a mention here.</font></p>

<p><font face="Arial" size="2">These routines expect you to pass them the addresses of two
strings: a source string and a character set string. They expect the address of the source
string in <code>es:di</code>. <code>Strspan</code> and <code>strcspan</code> want the
address of the character set string in <code>dx:si</code>; the character set string
follows the call with <code>strspanl</code> and <code>strcspanl</code>. On return, <code>cx
</code>contains an index into the string, defined as follows:</font></p>

<p><font face="Arial" size="2"><code>strspan, strspanl:</code> Index of first character in
source found in the character set.</font></p>

<p><font face="Arial" size="2"><code>strcspan, strcspanl: </code>Index of first character
in source not found in the character set.</font></p>

<p><font face="Arial" size="2">If all the characters are in the set (or are not in the
set) then <code>cx </code>contains the index into the string of the zero terminating byte.</font></p>

<p><font face="Arial" size="2">Example:</font></p>

<pre><font face="Courier New" size="2">Source          byte    &quot;ABCDEFG 0123456&quot;,0
Set1            byte    &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;,0
Set2            byte    &quot;0123456789&quot;,0
Index1          word    ?
Index2          word    ?
Index3          word    ?
Index4          word    ?
                 .
                 .
                 .
                lesi    Source          ;See strcat for lesi definition.
                ldxi    Set1            ;See strcat for ldxi definition.
                strspan                 ;Search for first ALPHA char.
                mov     Index1, cx      ;Index of first alphabetic char.

                lesi    Source
                lesi    Set2
                strspan                 ;Search for first numeric char.
                mov     Index2, cx

                lesi    Source
                strcspanl
                byte    &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;,0
                mov     Index3, cx

                lesi    Set2
                strcspnl
                byte    &quot;0123456789&quot;,0
                mov     Index4, cx

                printf
                byte    &quot;First alpha char in Source is at offset %d\n&quot;
                byte    &quot;First numeric char is at offset %d\n&quot;
                byte    &quot;First non-alpha in Source is at offset %d\n&quot;
                byte    &quot;First non-numeric in Set2 is at offset %d\n&quot;,0
                dword   Index1, Index2, Index3, Index4</font></pre>

<p><font face="Arial" size="2">This code outputs the following:</font></p>

<pre><font face="Courier New" size="2">First alpha char in Source is at offset 0
First numeric char is at offset 8
First non-alpha in Source is at offset 7
First non-numeric in Set2 is at offset 10</font></pre>

<h3><strong><font face="Arial" size="3"><a name="HEADING5-476"></a>15.4.13 Strstr, Strstrl</font></strong></h3>
<code>

<p><font face="Arial" size="2">Strstr</code> searches for the first occurrence of one
string within another. <code>es:di </code>contains the address of the string in which you
want to search for a second string. <code>dx:si </code>contains the address of the second
string for the <code>strstr</code> routine; for <code>strstrl</code> the search second
string immediately follows the call in the code stream.</font></p>

<p><font face="Arial" size="2">On return from <code>strstr</code> or <code>strstrl</code>,
the carry flag will be set if the second string is not present in the source string. If
the carry flag is clear, then the second string is present in the source string and <code>cx
</code>will contain the (zero-based) index where the second string was found. Example:</font></p>

<pre><font face="Courier New" size="2">SourceStr       byte    &quot;Search for 'this' in this string&quot;,0
SearchStr       byte    &quot;this&quot;,0
                 .
                 .
                 .
                lesi    SourceStr       ;See strcat for lesi definition.
                ldxi    SearchStr       ;See strcat for ldxi definition.
                strstr
                jc      NotPresent
                print
                byte    &quot;Found string at offset &quot;,0
                mov     ax, cx          ;Need offset in AX for puti
                puti
                putcr

                lesi    SourceStr
                strstrl
                byte    &quot;for&quot;,0
                jc      NotPresent
                print
                byte    &quot;Found 'for' at offset &quot;,0
                mov     ax, cx
                puti
                putcr
NotPresent:</font></pre>

<p><font face="Arial" size="2">The above code prints the following:</font></p>

<pre><font face="Courier New" size="2">Found string at offset 12
Found 'for' at offset 7</font></pre>

<h3><strong><font face="Arial" size="3"><a name="HEADING5-508"></a>15.4.14 Strtrim,
Strtrimm</font></strong></h3>

<p><font face="Arial" size="2">These two routines are quite similar to <code>strbdel</code>
and <code>strbdelm</code>. Rather than removing leading spaces, however, they trim off any
trailing spaces from a string. <code>Strtrim</code> trims off any trailing spaces directly
on the specified string in memory. <code>Strtrimm</code> first copies the source string
and then trims and space off the copy. Both routines expect you to pass the address of the
source string in <code>es:di</code>. <code>Strtrimm</code> returns a pointer to the new
string (if it could allocate it) in <code>es:di</code>. It also returns the carry set or
clear to denote error/no error. Example:</font></p>

<pre><font face="Courier New" size="2">String1         byte    &quot;Spaces at the end      &quot;,0
String2         byte    &quot;    Spaces on both sides     &quot;,0
StrPtr1         dword   0
StrPtr2         dword   0
                 .
                 .
                 .

; TrimSpcs trims the spaces off both ends of a string.
; Note that it is a little more efficient to perform the
; strbdel first, then the strtrim. This routine creates
; the new string on the heap and returns a pointer to this
; string in ES:DI.

TrimSpcs        proc
                strbdelm
                jc      BadAlloc        ;Just return if error.
                strtrim
                clc
BadAlloc:       ret
TrimSpcs        endp
                         .
                         .
                         .
                lesi    String1         ;See strcat for lesi definition.
                strtrimm
                jc      error
                mov     word ptr StrPtr1, di
                mov     word ptr StrPtr1+2, es

                lesi    String2
                call    TrimSpcs
                jc      error
                mov     word ptr StrPtr2, di
                mov     word ptr StrPtr2+2, es

                printf
                byte    &quot;First string: '%s'\n&quot;
                byte    &quot;Second string: '%s'\n&quot;,0
                dword   StrPtr1, StrPtr2</font></pre>

<p><font face="Arial" size="2">This code fragment outputs the following:</font></p>

<pre><font face="Courier New" size="2">First string: 'Spaces at the end'
Second string: 'Spaces on both sides'</font></pre>

<h3><strong><font face="Arial" size="3"><a name="HEADING5-555"></a>15.4.15 Other String
Routines in the UCR Standard Library</font></strong></h3>

<p><font face="Arial" size="2">In addition to the &quot;<code>strxxx</code>&quot; routines
listed in this section, there are many additional string routines available in the UCR
Standard Library. Routines to convert from numeric types (integer, hex, real, etc.) to a
string or vice versa, pattern matching and character set routines, and many other
conversion and string utilities. The routines described in this chapter are those whose
definitions appear in the &quot;strings.a&quot; header file and are specifically targeted
towards generic string manipulation. For more details on the other string routines,
consult the UCR Standard Library reference section in the appendices.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH15-4.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH15-4.html">Chapter
    Fifteen</a> (Part 4)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH15-6.html">Chapter Fifteen</a> (Part 6)&nbsp; </strong></font><a href="CH15-6.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Fifteen: Strings And
Character Sets (Part 5)<br>
28 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_15/CH15-5.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:01 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
