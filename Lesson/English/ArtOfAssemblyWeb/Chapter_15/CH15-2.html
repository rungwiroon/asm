<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_15/CH15-2.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:27:57 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER FIFTEEN: STRINGS AND CHARACTER SETS (Part 2)</title>
</head>

<body stylesrc="../toc.html" topmargin="10" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING2"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH15-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH15-1.html">Chapter
    Fifteen</a> (Part 1)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH15-3.html">Chapter Fifteen</a> (Part 3)&nbsp; </strong></font><a href="CH15-3.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10" colspan="2"><a NAME="HEADING2-1"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0" colspan="2"><font face="Arial" size="4"><strong>CHAPTER
    FIFTEEN:<br>
    STRINGS AND CHARACTER SETS (Part 2)</strong></font></td>
  </tr>
  <tr>
    <td width="50%" nowrap height="10" valign="top"><font face="Arial" size="2"><a HREF="#HEADING2-1"><b>15.1.4 </b>- The MOVS Instruction</a> <br>
    <a HREF="#HEADING2-72"><b>15.1.5 </b>- The CMPS Instruction</a> <br>
    <a HREF="#HEADING2-134"><b>15.1.6 </b>- The SCAS Instruction</a> <br>
    <a HREF="#HEADING2-150"><b>15.1.7 </b>- The STOS Instruction</a> </font></td>
    <td width="50%" nowrap height="10" valign="top"><font face="Arial" size="2"><a HREF="#HEADING2-170"><b>15.1.8 </b>- The LODS Instruction</a> <br>
    <a HREF="#HEADING2-180"><b>15.1.9 </b>- Building Complex String Functions from LODS and
    STOS</a> <br>
    <a HREF="#HEADING2-213"><b>15.1.10 </b>- Prefixes and the String Instructions</a> </font></td>
  </tr>
  <tr>
    <td width="100%" colspan="2"></td>
  </tr>
</table>
</center></div>

<h3><strong><font face="Arial" size="3">15.1.4 The MOVS Instruction</font></strong></h3>

<hr>

<p><font face="Arial" size="2">The <code>movs </code>instruction takes four basic forms. <code>Movs
</code>moves bytes, words, or double words, <code>movsb </code>moves byte strings, <code>movsw
</code>moves word strings, and <code>movsd </code>moves double word strings (on 80386 and
later processors). These four instructions use the following syntax:</font></p>

<pre><font face="Courier New" size="2">        {REP} MOVSB
        {REP} MOVSW
        {REP} MOVSD                     ;Available only on 80386+
        {REP} MOVS      Dest, Source</font></pre>

<p><font face="Arial" size="2">The <code>movsb </code>(move string, bytes) instruction
fetches the byte at address <code>ds:si</code>, stores it at address <code>es:di</code>,
and then increments or decrements the <code>si </code>and <code>di </code>registers by
one. If the <code>rep </code>prefix is present, the CPU checks <code>cx </code>to see if
it contains zero. If not, then it moves the byte from <code>ds:si </code>to <code>es:di </code>and
decrements the <code>cx </code>register. This process repeats until <code>cx </code>becomes
zero. </font></p>

<p><font face="Arial" size="2">The <code>movsw </code>(move string, words) instruction
fetches the word at address <code>ds:si</code>, stores it at address <code>es:di</code>,
and then increments or decrements <code>si </code>and <code>di </code>by two. If there is
a <code>rep </code>prefix, then the CPU repeats this procedure as many times as specified
in <code>cx</code>. </font></p>

<p><font face="Arial" size="2">The<code> movsd </code>instruction operates in a similar
fashion on double words. Incrementing or decrementing <code>si </code>and <code>di </code>by
four for each data movement.</font></p>

<p><font face="Arial" size="2">MASM automatically figures out the size of the <code>movs </code>instruction
by looking at the size of the operands specified. If you've defined the two operands with
the <code>byte </code>(or comparable) directive, then MASM will emit a <code>movsb </code>instruction.
If you've declared the two labels via <code>word </code>(or comparable), MASM will
generate a <code>movws </code>instruction. If you've declared the two labels with <code>dword</code>,
MASM emits a <code>movsd </code>instruction. The assembler will also check the segments of
the two operands to ensure they match the current assumptions (via the <code>assume </code>directive)
about the <code>es </code>and <code>ds </code>registers. You should always use the <code>movsb</code>,
<code>movsw</code>, and <code>movsd </code>forms and forget about the <code>movs </code>form.</font></p>

<p><font face="Arial" size="2">Although, in theory, the <code>movs </code>form appears to
be an elegant way to handle the move string instruction, in practice it creates more
trouble than it's worth. Furthermore, this form of the move string instruction implies
that <code>movs </code>has explicit operands, when, in fact, the <code>si </code>and <code>di
</code>registers implicitly specify the operands. For this reason, we'll always use the <code>movsb,
movsw, </code>or <code>movsd </code>instructions. When used with the <code>rep </code>prefix,
the <code>movsb </code>instruction will move the number of bytes specified in the <code>cx
</code>register. The following code segment copies 384 bytes from <code>String1</code> to <code>String2</code>:</font></p>

<pre><font face="Courier New" size="2">                cld
                lea     si, String1
                lea     di, String2
                mov     cx, 384
        rep     movsb
                 .
                 .
                 .
String1         byte    384 dup (?)
String2         byte    384 dup (?)</font></pre>

<p><font face="Arial" size="2">This code, of course, assumes that <code>String1</code> and
<code>String2</code> are in the same segment and both the <code>ds </code>and <code>es </code>registers
point at this segment. If you substitute <code>movws </code>for <code>movsb</code>, then
the code above will move 384 words (768 bytes) rather than 384 bytes:</font></p>

<pre><font face="Courier New" size="2">                cld
                lea     si, String1
                lea     di, String2
                mov     cx, 384
        rep     movsw
                 .
                 .
                 .
String1         word    384 dup (?)
String2         word    384 dup (?)</font></pre>

<p><font face="Arial" size="2">Remember, the <code>cx </code>register contains the element
count, not the byte count. When using the <code>movsw </code>instruction, the CPU moves
the number of words specified in the <code>cx </code>register.</font></p>

<p><font face="Arial" size="2">If you've set the direction flag before executing a <code>movsb/movsw/movsd
</code>instruction, the CPU decrements the <code>si </code>and <code>di </code>registers
after moving each string element. This means that the <code>si </code>and <code>di </code>registers
must point at the end of their respective strings before issuing a <code>movsb, movsw, or
movsd </code>instruction. For example,</font></p>

<pre><font face="Courier New" size="2">                std
                lea     si, String1+383
                lea     di, String2+383
                mov     cx, 384
        rep     movsb
                 .
                 .
                 .
String1         byte    384 dup (?)
String2         byte    384 dup (?)</font></pre>

<p><font face="Arial" size="2">Although there are times when processing a string from tail
to head is useful (see the <code>cmps </code>description in the next section), generally
you'll process strings in the forward direction since it's more straightforward to do so.
There is one class of string operations where being able to process strings in both
directions is absolutely mandatory: processing strings when the source and destination
blocks overlap. Consider what happens in the following code:</font></p>

<pre><font face="Courier New" size="2">                cld
                lea     si, String1
                lea     di, String2
                mov     cx, 384
        rep     movsb
                 .
                 .
                 .
String1         byte    ?
String2         byte    384 dup (?)</font></pre>

<p><font face="Arial" size="2">This sequence of instructions treats <code>String1</code>
and <code>String2</code> as a pair of 384 byte strings. However, the last 383 bytes in the
<code>String1</code> array overlap the first 383 bytes in the <code>String2</code> array.
Let's trace the operation of this code byte by byte. </font></p>

<p><font face="Arial" size="2">When the CPU executes the <code>movsb </code>instruction,
it copies the byte at <code>ds:si (String1)</code> to the byte pointed at by <code>es:di
(String2)</code>. Then it increments <code>si </code>and <code>di</code>, decrements <code>cx
</code>by one, and repeats this process. Now the <code>si </code>register points at <code>String1+1</code>
(which is the address of <code>String2</code>) and the <code>di </code>register points at<code>
String2+1</code>. The <code>movsb </code>instruction copies the byte pointed at by <code>si
</code>to the byte pointed at by <code>di</code>. However, this is the byte originally
copied from location <code>String1</code>. So the <code>movsb </code>instruction copies
the value originally in location <code>String1</code> to both locations <code>String2</code>
and <code>String2+1</code>. Again, the CPU increments <code>si </code>and <code>di</code>,
decrements <code>cx</code>, and repeats this operation. Now the <code>movsb </code>instruction
copies the byte from location <code>String1+2 </code>(<code>String2+1</code>) to location <code>String2+2</code>.
But once again, this is the value that originally appeared in location <code>String1</code>.
Each repetition of the loop copies the next element in <code>String1</code> to the next
available location in the <code>String2</code> array. Pictorially, it looks something
like:</font></p>

<p><font face="Arial" size="2"><img SRC="images/CH15-2-image-1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH15/CH15-2-image-1.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="306" HEIGHT="389"></font></p>

<p><font face="Arial" size="2">The end result is that <code>X</code> gets replicated
throughout the string. The move instruction copies the source operand into the memory
location which will become the source operand for the very next move operation, which
causes the replication. </font></p>

<p><font face="Arial" size="2">If you really want to move one array into another when they
overlap, you should move each element of the source string to the destination string
starting at the end of the two strings as shown below:</font></p>

<p><font face="Arial" size="2"><img SRC="images/CH15-2-image-2.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH15/CH15-2-image-2.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="335" HEIGHT="454"></font></p>

<p><font face="Arial" size="2">Setting the direction flag and pointing <code>si </code>and
<code>di </code>at the end of the strings will allow you to (correctly) move one string to
another when the two strings overlap and the source string begins at a lower address than
the destination string. If the two strings overlap and the source string begins at a
higher address than the destination string, then clear the direction flag and point <code>si
</code>and <code>di </code>at the beginning of the two strings. </font></p>

<p><font face="Arial" size="2">If the two strings do not overlap, then you can use either
technique to move the strings around in memory. Generally, operating with the direction
flag clear is the easiest, so that makes the most sense in this case.</font></p>

<p><font face="Arial" size="2">You shouldn't use the <code>movs </code>instruction to fill
an array with a single byte, word, or double word value. Another string instruction, <code>stos</code>,
is much better suited for this purpose. However, for arrays whose elements are larger than
four bytes, you can use the <code>movs </code>instruction to initialize the entire array
to the content of the first element. See the questions for additional information.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-72"></a>15.1.5 The CMPS
Instruction</font></strong></p>

<p><font face="Arial" size="2">The <code>cmps </code>instruction compares two strings. The
CPU compares the string referenced by <code>es:di </code>to the string pointed at by <code>ds:si</code>.
<code>Cx </code>contains the length of the two strings (when using the <code>rep </code>prefix).
Like the <code>movs </code>instruction, the MASM assembler allows several different forms
of this instruction:</font></p>

<pre><font face="Courier New" size="2">        {REPE}  CMPSB
        {REPE}  CMPSW
        {REPE}  CMPSD                   ;Available only on 80386+
        {REPE}  CMPS    dest, source
        {REPNE} CMPSB
        {REPNE} CMPSW 
        {REPNE} CMPSD                   ;Available only on 80386+
        {REPNE} CMPS    dest, source</font></pre>

<p><font face="Arial" size="2">Like the <code>movs </code>instruction, the operands
present in the operand field of the <code>cmps </code>instruction determine the size of
the operands. You specify the actual operand addresses in the <code>si </code>and <code>di
</code>registers. </font></p>

<p><font face="Arial" size="2">Without a repeat prefix, the <code>cmps </code>instruction
subtracts the value at location <code>es:di </code>from the value at <code>ds:si </code>and
updates the flags. Other than updating the flags, the CPU doesn't use the difference
produced by this subtraction. After comparing the two locations, <code>cmps </code>increments
or decrements the <code>si </code>and <code>di </code>registers by one, two, or four (for <code>cmpsb/cmpsw/cmpsd</code>,
respectively). <code>Cmps </code>increments the <code>si </code>and <code>di </code>registers
if the direction flag is clear and decrements them otherwise. </font></p>

<p><font face="Arial" size="2">Of course, you will not tap the real power of the <code>cmps
</code>instruction using it to compare single bytes or words in memory. This instruction
shines when you use it to compare whole strings. With <code>cmps</code>, you can compare
consecutive elements in a string until you find a match or until consecutive elements do
not match. </font></p>

<p><font face="Arial" size="2">To compare two strings to see if they are equal or not
equal, you must compare corresponding elements in a string until they don't match.
Consider the following strings:</font></p>

<p><font face="Arial" size="2">&quot;String1&quot; </font></p>

<p><font face="Arial" size="2">&quot;String1&quot;</font></p>

<p><font face="Arial" size="2">The only way to determine that these two strings are equal
is to compare each character in the first string to the corresponding character in the
second. After all, the second string could have been &quot;String2&quot; which definitely
is not equal to &quot;String1&quot;. Of course, once you encounter a character in the
destination string which doesn't equal the corresponding character in the source string,
the comparison can stop. You needn't compare any other characters in the two strings. </font></p>

<p><font face="Arial" size="2">The <code>repe </code>prefix accomplishes this operation.
It will compare successive elements in a string as long as they are equal and <code>cx </code>is
greater than zero. We could compare the two strings above using the following 80x86
assembly language code:</font></p>

<pre><font face="Courier New" size="2">; Assume both strings are in the same segment and ES and DS
; both point at this segment.

                cld
                lea     si, AdrsString1
                lea     di, AdrsString2
                mov     cx, 7
        repe    cmpsb</font></pre>

<p><font face="Arial" size="2">After the execution of the <code>cmpsb </code>instruction,
you can test the flags using the standard conditional jump instructions. This lets you
check for equality, inequality, less than, greater than, etc. </font></p>

<p><font face="Arial" size="2">Character strings are usually compared using
lexicographical ordering. In lexicographical ordering, the least significant element of a
string carries the most weight. This is in direct contrast to standard integer comparisons
where the most significant portion of the number carries the most weight. Furthermore, the
length of a string affects the comparison only if the two strings are identical up to the
length of the shorter string. For example, &quot;Zebra&quot; is less than
&quot;Zebras&quot;, because it is the shorter of the two strings, however,
&quot;Zebra&quot; is greater than &quot;AAAAAAAAAAH!&quot; even though it is shorter.
Lexicographical comparisons compare corresponding elements until encountering a character
which doesn't match, or until encountering the end of the shorter string. If a pair of
corresponding characters do not match, then this algorithm compares the two strings based
on that single character. If the two strings match up to the length of the shorter string,
we must compare their length. The two strings are equal if and only if their lengths are
equal and each corresponding pair of characters in the two strings is identical.
Lexicographical ordering is the standard alphabetical ordering you've grown up with. </font></p>

<p><font face="Arial" size="2">For character strings, use the <code>cmps </code>instruction
in the following manner: </font>

<ul>
  <li><font face="Arial" size="2">The direction flag must be cleared before comparing the
    strings. </font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Use the <code>cmpsb </code>instruction to compare the
    strings on a byte by byte basis. Even if the strings contain an even number of characters,
    you cannot use the <code>cmpsw </code>instruction. It does not compare strings in
    lexicographical order. </font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">The <code>cx </code>register must be loaded with the length
    of the smaller string. </font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Use the <code>repe </code>prefix. </font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">The <code>ds:si </code>and <code>es:di </code>registers must
    point at the very first character in the two strings you want to compare. </font></li>
</ul>

<p><font face="Arial" size="2">After the execution of the <code>cmps </code>instruction,
if the two strings were equal, their lengths must be compared in order to finish the
comparison. The following code compares a couple of character strings:</font></p>

<pre><font face="Courier New" size="2">                lea     si, source
                lea     di, dest
                mov     cx, lengthSource
                mov     ax, lengthDest
                cmp     cx, ax
                ja      NoSwap
                xchg    ax, cx
NoSwap:         repe    cmpsb
                jne     NotEqual
                mov     ax, lengthSource
                cmp     ax, lengthDest
NotEqual:</font></pre>

<p><font face="Arial" size="2">If you're using bytes to hold the string lengths, you
should adjust this code appropriately. </font></p>

<p><font face="Arial" size="2">You can also use the <code>cmps </code>instruction to
compare multi-word integer values (that is, extended precision integer values). Because of
the amount of setup required for a string comparison, this isn't practical for integer
values less than three or four words in length, but for large integer values, it's an
excellent way to compare such values. Unlike character strings, we cannot compare integer
strings using a lexicographical ordering. When comparing strings, we compare the
characters from the least significant byte to the most significant byte. When comparing
integers, we must compare the values from the most significant byte (or word/double word)
down to the least significant byte, word or double word. So, to compare two eight-word
(128-bit) integer values, use the following code on the 80286:</font></p>

<pre><font face="Courier New" size="2">                std
                lea     si, SourceInteger+14
                lea     di, DestInteger+14
                mov     cx, 8
        repe    cmpsw</font></pre>

<p><font face="Arial" size="2">This code compares the integers from their most significant
word down to the least significant word. The <code>cmpsw</code> instruction finishes when
the two values are unequal or upon decrementing <code>cx </code>to zero (implying that the
two values are equal). Once again, the flags provide the result of the comparison. </font></p>

<p><font face="Arial" size="2">The <code>repne </code>prefix will instruct the <code>cmps </code>instruction
to compare successive string elements as long as they do not match. The 80x86 flags are of
little use after the execution of this instruction. Either the <code>cx </code>register is
zero (in which case the two strings are totally different), or it contains the number of
elements compared in the two strings until a match. While this form of the <code>cmps </code>instruction
isn't particularly useful for comparing strings, it is useful for locating the first pair
of matching items in a couple of byte or word arrays. In general, though, you'll rarely
use the <code>repne </code>prefix with <code>cmps</code>. </font></p>

<p><font face="Arial" size="2">One last thing to keep in mind with using the <code>cmps </code>instruction
- the value in the <code>cx </code>register determines the number of elements to process,
not the number of bytes. Therefore, when using <code>cmpsw</code>, <code>cx </code>specifies
the number of words to compare. This, of course, is twice the number of bytes to compare.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-134"></a>15.1.6 The SCAS
Instruction</font></strong></p>

<p><font face="Arial" size="2">The <code>cmps </code>instruction compares two strings
against one another. You cannot use it to search for a particular element within a string.
For example, you could not use the <code>cmps </code>instruction to quickly scan for a
zero throughout some other string. You can use the <code>scas </code>(scan string)
instruction for this task. </font></p>

<p><font face="Arial" size="2">Unlike the <code>movs </code>and <code>cmps </code>instructions,
the <code>scas </code>instruction only requires a destination string (<code>es:di</code>)
rather than both a source and destination string. The source operand is the value in the <code>al
</code>(<code>scasb</code>), <code>ax </code>(<code>scasw</code>), or <code>eax </code>(<code>scasd)</code>
register. </font></p>

<p><font face="Arial" size="2">The <code>scas </code>instruction, by itself, compares the
value in the accumulator (<code>al, ax, </code>or <code>eax</code>) against the value
pointed at by <code>es:di </code>and then increments (or decrements) <code>di </code>by
one, two, or four. The CPU sets the flags according to the result of the comparison. While
this might be useful on occasion, <code>scas </code>is a lot more useful when using the <code>repe
</code>and <code>repne </code>prefixes. </font></p>

<p><font face="Arial" size="2">When the <code>repe </code>prefix (repeat while equal) is
present, <code>scas </code>scans the string searching for an element which does not match
the value in the accumulator. When using the <code>repne </code>prefix (repeat while not
equal), <code>scas </code>scans the string searching for the first string element which is
equal to the value in the accumulator. </font></p>

<p><font face="Arial" size="2">You're probably wondering &quot;why do these prefixes do
exactly the opposite of what they ought to do?&quot; The paragraphs above haven't quite
phrased the operation of the <code>scas </code>instruction properly. When using the <code>repe
</code>prefix with <code>scas</code>, the 80x86 scans through the string while the value
in the accumulator is equal to the string operand. This is equivalent to searching through
the string for the first element which does not match the value in the accumulator. The <code>scas
</code>instruction with <code>repne </code>scans through the string while the accumulator
is not equal to the string operand. Of course, this form searches for the first value in
the string which matches the value in the accumulator register. The <code>scas </code>instruction
takes the following forms:</font></p>

<pre><font face="Courier New" size="2">        {REPE}  SCASB
        {REPE}  SCASW
        {REPE}  SCASD           ;Available only on 80386+
        {REPE}  SCAS    dest
        {REPNE} SCASB
        {REPNE} SCASW
        {REPNE} SCASD           ;Available only on 80386+
        {REPNE} SCAS    dest</font></pre>

<p><font face="Arial" size="2">Like the <code>cmps </code>and <code>movs </code>instructions,
the value in the <code>cx </code>register specifies the number of elements to process, not
bytes, when using a repeat prefix.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-150"></a>15.1.7 The STOS
Instruction</font></strong></p>

<p><font face="Arial" size="2">The <code>stos </code>instruction stores the value in the
accumulator at the location specified by <code>es:di</code>. After storing the value, the
CPU increments or decrements <code>di </code>depending upon the state of the direction
flag. Although the <code>stos </code>instruction has many uses, its primary use is to
initialize arrays and strings to a constant value. For example, if you have a 256-byte
array you want to clear out with zeros, use the following code:</font></p>

<pre><font face="Courier New" size="2">; Presumably, the ES register already points at the segment
; containing DestString 

                cld
                lea     di, DestString
                mov     cx, 128         ;256 bytes is 128 words.
                xor     ax, ax          ;AX := 0
        rep     stosw</font></pre>

<p><font face="Arial" size="2">This code writes 128 words rather than 256 bytes because a
single <code>stosw </code>operation is faster than two <code>stosb </code>operations. On
an 80386 or later this code could have written 64 double words to accomplish the same
thing even faster. </font></p>

<p><font face="Arial" size="2">The <code>stos </code>instruction takes four forms. They
are</font></p>

<pre><font face="Courier New" size="2">        {REP}   STOSB
        {REP}   STOSW
        {REP}   STOSD
        {REP}   STOS    dest</font></pre>

<p><font face="Arial" size="2">The <code>stosb </code>instruction stores the value in the <code>al
</code>register into the specified memory location(s), the <code>stosw </code>instruction
stores the <code>ax </code>register into the specified memory location(s) and the <code>stosd
</code>instruction stores <code>eax </code>into the specified location(s). The <code>stos </code>instruction
is either an <code>stosb, stosw, </code>or <code>stosd </code>instruction depending upon
the size of the specified operand. </font></p>

<p><font face="Arial" size="2">Keep in mind that the <code>stos </code>instruction is
useful only for initializing a byte, word, or dword array to a constant value. If you need
to initialize an array to different values, you cannot use the <code>stos </code>instruction.
You can use <code>movs </code>in such a situation, see the exercises for additional
details.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-170"></a>15.1.8 The LODS
Instruction</font></strong></p>

<p><font face="Arial" size="2">The <code>lods </code>instruction is unique among the
string instructions. You will never use a repeat prefix with this instruction. The <code>lods
</code>instruction copies the byte or word pointed at by <code>ds:si </code>into the <code>al,
ax, </code>or <code>eax </code>register, after which it increments or decrements the <code>si
</code>register by one, two, or four. Repeating this instruction via the repeat prefix
would serve no purpose whatsoever since the accumulator register will be overwritten each
time the <code>lods </code>instruction repeats. At the end of the repeat operation, the
accumulator will contain the last value read from memory. </font></p>

<p><font face="Arial" size="2">Instead, use the <code>lods </code>instruction to fetch
bytes (<code>lodsb</code>), words (<code>lodsw</code>), or double words (<code>lodsd</code>)
from memory for further processing. By using the <code>stos </code>instruction, you can
synthesize powerful string operations. </font></p>

<p><font face="Arial" size="2">Like the <code>stos </code>instruction, the <code>lods </code>instruction
takes four forms:</font></p>

<pre><font face="Courier New" size="2">        {REP}   LODSB
        {REP}   LODSW
        {REP}   LODSD           ;Available only on 80386+
        {REP}   LODS    dest</font></pre>

<p><font face="Arial" size="2">As mentioned earlier, you'll rarely, if ever, use the <code>rep
</code>prefixes with these instructions<a HREF="#FOOTNOTE-3">[3]</a>. The 80x86 increments
or decrements <code>si </code>by one, two, or four depending on the direction flag and
whether you're using the <code>lodsb</code>, <code>lodsw</code>, or <code>lodsd </code>instruction.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-180"></a>15.1.9 Building Complex
String Functions from LODS and STOS</font></strong></p>

<p><font face="Arial" size="2">The 80x86 supports only five different string instructions:
<code>movs</code>, <code>cmps</code>, <code>scas</code>, <code>lods</code>, and <code>stos</code><a HREF="#FOOTNOTE-4">[4]</a>. These certainly aren't the only string operations you'll ever
want to use. However, you can use the <code>lods </code>and <code>stos </code>instructions
to easily generate any particular string operation you like. For example, suppose you
wanted a string operation that converts all the upper case characters in a string to lower
case. You could use the following code:</font></p>

<pre><font face="Courier New" size="2">; Presumably, ES and DS have been set up to point at the same
; segment, the one containing the string to convert.

                lea     si, String2Convert
                mov     di, si
                mov     cx, LengthOfString
Convert2Lower:  lodsb                           ;Get next char in str.
                cmp     al, 'A'                 ;Is it upper case?
                jb      NotUpper
                cmp     al, 'Z'
                ja      NotUpper
                or      al, 20h                 ;Convert to lower case. 
NotUpper:       stosb                           ;Store into destination.
                loop    Convert2Lower</font></pre>

<p><font face="Arial" size="2">Assuming you're willing to waste 256 bytes for a table,
this conversion operation can be sped up somewhat using the xlat instruction:</font></p>

<pre><font face="Courier New" size="2">; Presumably, ES and DS have been set up to point at the same
; segment, the one containing the string to be converted.

                cld
                lea     si, String2Convert
                mov     di, si
                mov     cx, LengthOfString
                lea     bx, ConversionTable
Convert2Lower:  lodsb                           ;Get next char in str.
                xlat                            ;Convert as appropriate.
                stosb                           ;Store into destination.
                loop    Convert2Lower</font></pre>

<p><font face="Arial" size="2">The conversion table, of course, would contain the index
into the table at each location except at offsets 41h..5Ah. At these locations the
conversion table would contain the values 61h..7Ah (i.e., at indexes 'A'..'Z' the table
would contain the codes for 'a'..'z'). </font></p>

<p><font face="Arial" size="2">Since the <code>lods </code>and <code>stos </code>instructions
use the accumulator as an intermediary, you can use any accumulator operation to quickly
manipulate string elements.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-213"></a>15.1.10 Prefixes and the
String Instructions</font></strong></p>

<p><font face="Arial" size="2">The string instructions will accept segment prefixes, lock<code>
</code>prefixes, and repeat prefixes. In fact, you can specify all three types of
instruction prefixes should you so desire. However, due to a bug in the earlier 80x86
chips (pre-80386), you should never use more than a single prefix (repeat, lock, or
segment override) on a string instruction unless your code will only run on later
processors; a likely event these days. If you absolutely must use two or more prefixes and
need to run on an earlier processor, make sure you turn off the interrupts while executing
the string instruction. </font></p>

<hr noshade size="1" color="#000000">

<p><font face="Arial" size="2"><strong><a NAME="FOOTNOTE-3"></a>[3]</strong> They appear
here simply because they are allowed. They're not useful, but they are allowed. </font></p>

<p><font face="Arial" size="2"><strong><a NAME="FOOTNOTE-4"></a>[4]</strong> Not counting
INS and OUTS which we're ignoring here.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH15-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH15-1.html">Chapter
    Fifteen</a> (Part 1)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH15-3.html">Chapter Fifteen</a> (Part 3)&nbsp; </strong></font><a href="CH15-3.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Fifteen: Strings And
Character Sets (Part 2)<br>
28 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_15/CH15-2.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:01 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
