<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_15/CH15-6.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:01 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER FIFTEEN: STRINGS AND CHARACTER SETS (Part 6)</title>
</head>

<body stylesrc="../toc.html" topmargin="10" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING6"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH15-5.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH15-5.html">Chapter Fifteen</a> (Part 5)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH15-7.html">Chapter Fifteen</a> (Part 7)&nbsp; </strong></font><a href="CH15-7.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10"><a NAME="HEADING6-1"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0"><font face="Arial" size="4"><strong>CHAPTER FIFTEEN:<br>
    STRINGS AND CHARACTER SETS (Part 6)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10" valign="top"></td>
  </tr>
  <tr>
    <td width="100%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING6-1"><b>15.5 </b>-
    The Character Set Routines in the UCR Standard Library</a> <br>
    <a HREF="#HEADING6-101"><b>15.6 </b>- Using the String Instructions on Other Data Types</a>
    <br>
    <a HREF="#HEADING6-103"><b>15.6.1 </b>- Multi-precision Integer Strings</a> <br>
    <a HREF="#HEADING6-113"><b>15.6.2 </b>- Dealing with Whole Arrays and Records</a></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="20"><font face="Arial" size="2"></font></td>
  </tr>
  <tr>
    <td width="100%"><font face="Arial" size="2"></font><strong><font face="Arial" size="3">15.5
    The Character Set Routines in the UCR Standard Library</font></strong><font face="Arial" size="2"></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"><font face="Arial" size="2"></font></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">The UCR Standard Library provides an extensive collection
of character set routines. These routines let you create sets, clear sets (set them to the
empty set), add and remove one or more items, test for set membership, copy sets, compute
the union, intersection, or difference, and extract items from a set. Although intended to
manipulate sets of characters, you can use the StdLib character set routines to manipulate
any set with 256 or fewer possible items.</font></p>

<p><font face="Arial" size="2">The first unusual thing to note about the StdLib's sets is
their storage format. A 256-bit array would normally consumes 32 consecutive bytes. For
performance reasons, the UCR Standard Library's set format packs eight separate sets into
272 bytes (256 bytes for the eight sets plus 16 bytes overhead). To declare set variables
in your data segment you should use the <code>set</code> macro. This macro takes the form:</font></p>

<pre><font face="Courier New" size="2">		set	SetName1, SetName2, ..., SetName8</font></pre>
<code>

<p><font face="Arial" size="2">SetName1..SetName8</code> represent the names of up to
eight set variables. You may have fewer than eight names in the operand field, but doing
so will waste some bits in the set array.</font></p>

<p><font face="Arial" size="2">The <code>CreateSets</code> routine provides another
mechanism for creating set variables. Unlike the set macro, which you would use to create
set variables in your data segment, the <code>CreateSets</code> routine allocates storage
for up to eight sets dynamically at run time. It returns a pointer to the first set
variable in <code>es:di</code>. The remaining seven sets follow at locations <code>es:di+1</code>,
<code>es:di+2</code>, ..., <code>es:di+7</code>. A typical program that allocates set
variables dynamically might use the following code:</font></p>

<pre><font face="Courier New" size="2">Set0            dword   ?
Set1            dword   ?
Set2            dword   ?
Set3            dword   ?
Set4            dword   ?
Set5            dword   ?
Set6            dword   ?
Set7            dword   ?
                 .
                 .
                 .
                CreateSets
                mov     word ptr Set0+2, es
                mov     word ptr Set1+2, es
                mov     word ptr Set2+2, es
                mov     word ptr Set3+2, es
                mov     word ptr Set4+2, es
                mov     word ptr Set5+2, es
                mov     word ptr Set6+2, es
                mov     word ptr Set7+2, es

                mov     word ptr Set0, di
                inc     di
                mov     word ptr Set1, di
                inc     di
                mov     word ptr Set2, di
                inc     di
                mov     word ptr Set3, di
                inc     di
                mov     word ptr Set4, di
                inc     di
                mov     word ptr Set5, di
                inc     di
                mov     word ptr Set6, di
                inc     di
                mov     word ptr Set7, di
                inc     di</font></pre>

<p><font face="Arial" size="2">This code segment creates eight different sets on the heap,
all empty, and stores pointers to them in the appropriate pointer variables.</font></p>

<p><font face="Arial" size="2">The SHELL.ASM file provides a commented-out line of code in
the data segment that includes the file STDSETS.A. This include file provides the bit
definitions for eight commonly used character sets. They are <code>alpha</code> (upper and
lower case alphabetics), <code>lower</code> (lower case alphabetics), <code>upper</code>
(upper case alphabetics), <code>digits</code> (&quot;0&quot;..&quot;9&quot;), <code>xdigits</code>
(&quot;0&quot;..&quot;9&quot;, &quot;A&quot;..&quot;F&quot;, and
&quot;a&quot;..&quot;f&quot;), <code>alphanum</code> (upper and lower case alphabetics
plus the digits), <code>whitespace</code> (space, tab, carriage return, and line feed),
and <code>delimiters</code> (whitespace plus commas, semicolons, less than, greater than,
and vertical bar). If you would like to use these standard character sets in your program,
you need to remove the semicolon from the beginning of the <code>include</code> statement
in the SHELL.ASM file.</font></p>

<p><font face="Arial" size="2">The UCR Standard Library provides 16 character set
routines: <code>CreateSets</code>, <code>EmptySet</code>, <code>RangeSet</code>, <code>AddStr</code>,
<code>AddStrl</code>, <code>RmvStr</code>, <code>RmvStrl</code>, <code>AddChar</code>, <code>RmvChar</code>,
<code>Member</code>, <code>CopySet</code>, <code>SetUnion</code>, <code>SetIntersect</code>,
<code>SetDifference</code>, <code>NextItem</code>, and <code>RmvItem</code>. All of these
routines except <code>CreateSets</code> require a pointer to a character set variable in
the <code>es:di</code> registers. Specific routines may require other parameters as well.</font></p>

<p><font face="Arial" size="2">The <code>EmptySet</code> routine clears all the bits in a
set producing the empty set. This routine requires the address of the set variable in the <code>es:di</code>.
The following example clears the set pointed at by <code>Set1</code>:</font></p>

<pre><font face="Courier New" size="2">                les     di, Set1
                EmptySet</font></pre>
<code>

<p><font face="Arial" size="2">RangeSet</code> unions in a range of values into the set
variable pointed at by <code>es:di</code>. The <code>al</code> register contains the lower
bound of the range of items, <code>ah</code> contains the upper bound. Note that <code>al</code>
must be less than or equal to <code>ah</code>. The following example constructs the set of
all control characters (ASCII codes one through 31, the null character [ASCII code zero]
is not allowed in sets):</font></p>

<pre><font face="Courier New" size="2">                les     di, CtrlCharSet         ;Ptr to ctrl char set.
                mov     al, 1
                mov     ah, 31
                RangeSet</font></pre>
<code>

<p><font face="Arial" size="2">AddStr</code> and <code>AddStrl</code> add all the
characters in a zero terminated string to a character set. For <code>AddStr</code>, the <code>dx:si</code>
register pair points at the zero terminated string. For <code>AddStrl</code>, the zero
terminated string follows the call to <code>AddStrl</code> in the code stream. These
routines union each character of the specified string into the set. The following examples
add the digits and some special characters into the <code>FPDigits</code> set:</font></p>

<pre><font face="Courier New" size="2">Digits          byte    &quot;0123456789&quot;,0
                set     FPDigitsSet
FPDigits        dword   FPDigitsSet
                 .
                 .
                 .
                ldxi    Digits          ;Loads DX:SI with adrs of Digits.
                les     di, FPDigits
                AddStr
                 .
                 .
                 .
                les     di, FPDigits
                AddStrL
                byte    &quot;Ee.+-&quot;,0</font></pre>
<code>

<p><font face="Arial" size="2">RmvStr</code> and <code>RmvStrl</code> remove characters
from a set. You supply the characters in a zero terminated string. For <code>RmvStr</code>,
<code>dx:si</code> points at the string of characters to remove from the string. For <code>RmvStrl</code>,
the zero terminated string follows the call. The following example uses RmvStrl to remove
the special symbols from FPDigits above:</font></p>

<pre><font face="Courier New" size="2">                les     di, FPDigits
                RmvStrl
                byte    &quot;Ee.+-&quot;,0</font></pre>

<p><font face="Arial" size="2">The <code>AddChar</code> and <code>RmvChar</code> routines
let you add or remove individual characters. As usual, <code>es:di</code> points at the
set; the <code>al</code> register contains the character you wish to add to the set or
remove from the set. The following example adds a space to the set FPDigits and removes
the &quot;,&quot; character (if present):</font></p>

<pre><font face="Courier New" size="2">                les     di, FPDigits
                mov     al, ' '
                AddChar
                 .
                 .
                 .
                les     di, FPDigits
                mov     al, ','
                RmvChar</font></pre>

<p><font face="Arial" size="2">The <code>Member</code> function checks to see if a
character is in a set. On entry, <code>es:di</code> must point at the set and <code>al</code>
must contain the character to check. On exit, the zero flag is set if the character is a
member of the set, the zero flag will be clear if the character is not in the set. The
following example reads characters from the keyboard until the user presses a key that is
not a whitespace character:</font></p>

<pre><font face="Courier New" size="2">SkipWS:         get                     ;Read char from user into AL.
                lesi    WhiteSpace      ;Address of WS set into es:di.
                member
                je      SkipWS</font></pre>

<p><font face="Arial" size="2">The <code>CopySet</code>, <code>SetUnion</code>, <code>SetIntersect</code>,
and <code>SetDifference</code> routines all operate on two sets of characters. The <code>es:di</code>
register points at the destination character set, the <code>dx:si</code> register pair
points at a source character set. <code>CopySet</code> copies the bits from the source set
to the destination set, replacing the original bits in the destination set. <code>SetUnion</code>
computes the union of the two sets and stores the result into the destination set. <code>SetIntersect</code>
computes the set intersection and stores the result into the destination set. Finally, the
<code>SetDifference</code> routine computes DestSet := DestSet - SrcSet.</font></p>

<p><font face="Arial" size="2">The <code>NextItem</code> and <code>RmvItem</code> routines
let you extract elements from a set. NextItem returns in <code>al</code> the ASCII code of
the first character it finds in a set. <code>RmvItem</code> does the same thing except it
also removes the character from the set. These routines return zero in <code>al</code> if
the set is empty (StdLib sets cannot contain the NULL character). You can use the <code>RmvItem</code>
routine to build a rudimentary iterator for a character set.</font></p>

<p><font face="Arial" size="2">The UCR Standard Library's character set routines are very
powerful. With them, you can easily manipulate character string data, especially when
searching for different patterns within a string. We will consider this routines again
when we study pattern matching later in this text.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING6-101"></a>15.6 Using
    the String Instructions on Other Data Types</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">The string instructions work with other data types besides
character strings. You can use the string instructions to copy whole arrays from one
variable to another, to initialize large data structures to a single value, or to compare
entire data structures for equality or inequality. Anytime you're dealing with data
structures containing several bytes, you may be able to use the string instructions.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING6-103"></a>15.6.1 Multi-precision
Integer Strings</font></strong></p>

<p><font face="Arial" size="2">The <code>cmps </code>instruction is useful for comparing
(very) large integer values. Unlike character strings, we cannot compare integers with <code>cmps
</code>from the L.O. byte through the H.O. byte. Instead, we must compare them from the
H.O. byte down to the L.O. byte. The following code compares two 12-byte integers:</font></p>

<pre><font face="Courier New" size="2">                lea     di, integer1+10
                lea     si, integer2+10
                mov     cx, 6
                std
        repe    cmpsw</font></pre>

<p>After the execution of the <code>cmpsw </code>instruction, the flags will contain the
result of the comparison. </p>

<p><font face="Arial" size="2">You can easily assign one long integer string to another
using the <code>movs </code>instruction. Nothing tricky here, just load up the <code>si,
di, </code>and <code>cx </code>registers and have at it. You must do other operations,
including arithmetic and logical operations, using the extended precision methods
described in the chapter on arithmetic operations.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING6-113"></a>15.6.2 Dealing with
Whole Arrays and Records</font></strong></p>

<p><font face="Arial" size="2">The only operations that apply, in general, to all array
and record structures are assignment and comparison (for equality/inequality only). You
can use the <code>movs </code>and <code>cmps </code>instructions for these operations. </font></p>

<p><font face="Arial" size="2">Operations such as scalar addition, transposition, etc.,
may be easily synthesized using the <code>lods </code>and <code>stos </code>instructions.
The following code shows how you can easily add the value 20 to each element of the
integer array A:</font></p>

<pre><font face="Courier New" size="2">                lea     si, A
                mov     di, si
                mov     cx, SizeOfA
                cld
AddLoop:        lodsw
                add     ax, 20
                stosw
                loop    AddLoop</font></pre>

<p><font face="Arial" size="2">You can implement other operations in a similar fashion.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH15-5.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH15-5.html">Chapter Fifteen</a> (Part 5)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH15-7.html">Chapter Fifteen</a> (Part 7)&nbsp; </strong></font><a href="CH15-7.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Fifteen: Strings And
Character Sets (Part 6)<br>
28 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_15/CH15-6.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:01 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
