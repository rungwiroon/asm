<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_20/CH20-2.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:48 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER TWENTY: THE PC KEYBOARD (Part 2)</title>
</head>

<body topmargin="10" stylesrc="http://Voodoo2/masm/toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING2"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH20-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH20-1.html">Chapter Twenty</a> (Part 1)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH20-3.html">Chapter Twenty</a> (Part 3)&nbsp; </strong></font><a href="CH20-3.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10"><a NAME="HEADING2-1"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0"><font face="Arial" size="4"><strong>CHAPTER TWENTY:<br>
    THE PC KEYBOARD (Part 2)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10"></td>
  </tr>
  <tr>
    <td width="100%"><font face="Arial" size="2"><a HREF="#HEADING2-1"><b>20.2 </b>- The
    Keyboard Hardware Interface</a> </font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="20"></td>
  </tr>
  <tr>
    <td width="100%"><strong><font face="Arial" size="3">20.2 <a NAME="MARKER-9-36"></a>The
    Keyboard Hardware Interface</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="1" bgcolor="#000000"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">IBM used a very simple hardware design for the keyboard
port on the original PC and PC/XT machines. When they introduced the PC/AT, IBM completely
resigned the interface between the PC and the keyboard. Since then, almost every PC model
and PC clone has followed this keyboard interface standard. Although IBM extended the
capabilities of the keyboard controller when they introduced their PS/2 systems, the PS/2
models are still upwards compatible from the PC/AT design. Since there are so few original
PCs in use today (and fewer people write original software for them), we will ignore the
original PC keyboard interface and concentrate on the AT and later designs.</font></p>

<p><font face="Arial" size="2">There are two keyboard microcontrollers that the system
communicates with - one on the PC's motherboard (the on-board microcontroller) and one
inside the keyboard case (the keyboard microcontroller). Communication with the on-board
microcontroller is through I/O port 64h. Reading this byte provides the status of the
keyboard controller<a NAME="MARKER-2-37"></a>. Writing to this byte sends the on-board
microcontroller a command. The organization of the status byte is</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch20a.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH20/ch20a.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="471" HEIGHT="196"> </font></p>

<p><font face="Arial" size="2">Communication to the microcontroller in the keyboard unit
is via the bytes at I/O addresses 60h and 64h. Bits zero and one in the status byte at
port 64h provide the necessary handshaking control for these ports. Before writing any
data to these ports, bit zero of port 64h must be zero; data is available for reading from
port 60h when bit one of port 64h contains a one. The keyboard enable and disable bits in
the command byte (port 64h) determine whether the keyboard is active and whether the
keyboard will interrupt the system when the user presses (or releases) a key, etc.</font></p>

<p><font face="Arial" size="2">Bytes written to port 60h are sent to the keyboard
microcontroller and bytes written to port 64h are sent to the on-board microcontroller.
Bytes read from port 60h generally come from the keyboard, although you can program the
on-board microcontroller to return certain values at this port, as well. The following
tables lists the commands sent to the keyboard microcontroller and the values you can
expect back. The following table lists the allowable commands you can write to port 64h:</font></p>
<div align="center"><center>

<table BORDER="1" bordercolor="#C0C0C0" width="100%" cellspacing="0" cellpadding="0">
  <caption><font face="Arial" size="2"><strong>On-Board Keyboard Controller Commands (Port
  64h)</strong></font></caption>
  <tr>
    <th align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">Value (hex)</font></strong></th>
    <th bgcolor="#F0F0F0"><p align="center"><font face="Arial" size="2">Description</font></th>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">20</font></strong></td>
    <td><font face="Arial" size="2">Transmit keyboard controller's command byte to system as a
    scan code at port 60h.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">60</font></strong></td>
    <td><font face="Arial" size="2">The next byte written to port 60h will be stored in the
    keyboard controller's command byte.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">A4</font></strong></td>
    <td><font face="Arial" size="2">Test if a password is installed (PS/2 only). Result comes
    back in port 60h. 0FAh means a password is installed, 0F1h means no password.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">A5</font></strong></td>
    <td><font face="Arial" size="2">Transmit password (PS/2 only). Starts receipt of password.
    The next sequence of scan codes written to port 60h, ending with a zero byte, are the new
    password.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">A6</font></strong></td>
    <td><font face="Arial" size="2">Password match. Characters from the keyboard are compared
    to password until a match occurs.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">A7</font></strong></td>
    <td><font face="Arial" size="2">Disable mouse device (PS/2 only). Identical to setting bit
    five of the command byte. </font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">A8</font></strong></td>
    <td><font face="Arial" size="2">Enable mouse device (PS/2 only). Identical to clearing bit
    five of the command byte.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">A9</font></strong></td>
    <td><font face="Arial" size="2">Test mouse device. Returns 0 if okay, 1 or 2 if there is a
    stuck clock, 3 or 4 if there is a stuck data line. Results come back in port 60h.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">AA</font></strong></td>
    <td><font face="Arial" size="2">Initiates self-test. Returns 55h in port 60h if
    successful.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">AB</font></strong></td>
    <td><font face="Arial" size="2">Keyboard interface test. Tests the keyboard interface.
    Returns 0 if okay, 1 or 2 if there is a stuck clock, 3 or 4 if there is a stuck data line.
    Results come back in port 60h.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">AC</font></strong></td>
    <td><font face="Arial" size="2">Diagnostic. Returns 16 bytes from the keyboard's
    microcontroller chip. Not available on PS/2 systems.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">AD</font></strong></td>
    <td><font face="Arial" size="2">Disable keyboard. Same operation as setting bit four of
    the command register.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">AE</font></strong></td>
    <td><font face="Arial" size="2">Enable keyboard. Same operation as clearing bit four of
    the command register.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">C0</font></strong></td>
    <td><font face="Arial" size="2">Read keyboard input port to port 60h. This input port
    contains the following values:<br>
    <br>
    bit 7: Keyboard inhibit keyswitch (0 = inhibit, 1 = enabled).<br>
    <br>
    bit 6: Display switch (0=color, 1=mono).<br>
    <br>
    bit 5: Manufacturing jumper.<br>
    <br>
    bit 4: System board RAM (always 1).<br>
    <br>
    bits 0-3: undefined.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">C1</font></strong></td>
    <td><font face="Arial" size="2">Copy input port (above) bits 0-3 to status bits 4-7. (PS/2
    only)</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">C2</font></strong></td>
    <td><font face="Arial" size="2">Copy input pot (above) bits 4-7 to status port bits 4-7.
    (PS/2 only).</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">D0</font></strong></td>
    <td><font face="Arial" size="2">Copy microcontroller output port value to port 60h (see
    definition below).</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">D1</font></strong></td>
    <td><font face="Arial" size="2">Write the next data byte written to port 60h to the
    microcontroller output port. This port has the following definition:<br>
    <br>
    bit 7: Keyboard data.<br>
    <br>
    bit 6: Keyboard clock.<br>
    <br>
    bit 5: Input buffer empty flag.<br>
    <br>
    bit 4: Output buffer full flag.<br>
    <br>
    bit 3: Undefined.<br>
    <br>
    bit 2: Undefined.<br>
    <br>
    bit 1: Gate A20 line.<br>
    <br>
    bit 0: System reset (if zero).<br>
    <br>
    &nbsp;<br>
    <br>
    Note: writing a zero to bit zero will reset the machine.<br>
    <br>
    Writing a one to bit one combines address lines 19 and 20 on the PC's address bus.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">D2</font></strong></td>
    <td><font face="Arial" size="2">Write keyboard buffer. The keyboard controller returns the
    next value sent to port 60h as though a keypress produced that value. (PS/2 only).</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">D3</font></strong></td>
    <td><font face="Arial" size="2">Write mouse buffer. The keyboard controller returns the
    next value sent to port 60h as though a mouse operation produced that value. (PS/2 only).</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">D4</font></strong></td>
    <td><font face="Arial" size="2">Writes the next data byte (60h) to the mouse (auxiliary)
    device. (PS/2 only).</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">E0</font></strong></td>
    <td><font face="Arial" size="2">Read test inputs. Returns in port 60h the status of the
    keyboard serial lines. Bit zero contains the keyboard clock input, bit one contains the
    keyboard data input.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">Fx</font></strong></td>
    <td><font face="Arial" size="2">Pulse output port (see definition for D1). Bits 0-3 of the
    keyboard controller command byte are pulsed onto the output port. Resets the system if bit
    zero is a zero.</font></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2"><a NAME="MARKER-2-38"></a>Commands 20h and 60h let you read
and write the <a NAME="MARKER-2-39"></a>keyboard controller command byte. This byte is
internal to the on-board microcontroller and has the following layout:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch20a1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH20/ch20a1.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="493" HEIGHT="229"> </font></p>

<p><font face="Arial" size="2">The system transmits bytes written to I/O port 60h directly
to the keyboard's microcontroller. Bit zero of the status register must contain a zero
before writing any data to this port. The commands the keyboard recognizes are</font></p>
<div align="center"><center>

<table BORDER="1" bordercolor="#C0C0C0" width="100%" cellspacing="0" cellpadding="0">
  <caption><font face="Arial" size="2"><strong>Keyboard Microcontroller Commands (Port 60h)</strong></font></caption>
  <tr>
    <th align="center" bgcolor="#F0F0F0"><p align="center"><strong><font face="Arial" size="2">Value
    (hex)</font></strong></th>
    <th bgcolor="#F0F0F0"><p align="center"><font face="Arial" size="2">Description</font></th>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">ED</font></strong></td>
    <td><font face="Arial" size="2">Send LED bits. The next byte written to port 60h updates
    the LEDs on the keyboard. The parameter (next) byte contains:<br>
    <br>
    bits 3-7: Must be zero.<br>
    <br>
    bit 2: Capslock LED (1 = on, 0 = off).<br>
    <br>
    bit 1: Numlock LED (1 = on, 0 = off).<br>
    <br>
    bit 0: Scroll lock LED (1 = on, 0 = off).</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">EE</font></strong></td>
    <td><font face="Arial" size="2">Echo commands. Returns 0EEh in port 60h as a diagnostic
    aid.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">F0</font></strong></td>
    <td><font face="Arial" size="2">Select alternate scan code set (PS/2 only). The next byte
    written to port 60h selects one of the following options:<br>
    <br>
    00: Report current scan code set in use (next value read from port 60h).<br>
    <br>
    01: Select scan code set #1 (standard PC/AT scan code set).<br>
    <br>
    02: Select scan code set #2.<br>
    <br>
    03: Select scan code set #3.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">F2</font></strong></td>
    <td><font face="Arial" size="2">Send two-byte keyboard ID code as the next two bytes read
    from port 60h (PS/2 only).</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">F3</font></strong></td>
    <td><font face="Arial" size="2">Set Autorepeat delay and repeat rate. Next byte written to
    port 60h determines rate:<br>
    <br>
    bit 7: must be zero<br>
    <br>
    bits 5,6: Delay. 00- 1/4 sec, 01- 1/2 sec, 10- 3/4 sec, 11- 1 sec.<br>
    <br>
    bits 0-4: Repeat rate. 0- approx 30 chars/sec to 1Fh- approx 2 chars/sec.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">F4</font></strong></td>
    <td><font face="Arial" size="2">Enable keyboard.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">F5</font></strong></td>
    <td><font face="Arial" size="2">Reset to power on condition and wait for enable command.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">F6</font></strong></td>
    <td><font face="Arial" size="2">Reset to power on condition and begin scanning keyboard.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">F7</font></strong></td>
    <td><font face="Arial" size="2">Make all keys autorepeat (PS/2 only).</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">F8</font></strong></td>
    <td><font face="Arial" size="2">Set all keys to generate an up code and a down code (PS/2
    only).</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">F9</font></strong></td>
    <td><font face="Arial" size="2">Set all keys to generate an up code only (PS/2 only).</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">FA</font></strong></td>
    <td><font face="Arial" size="2">Set all keys to autorepeat and generate up and down codes
    (PS/2 only).</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">FB</font></strong></td>
    <td><font face="Arial" size="2">Set an individual key to autorepeat. Next byte contains
    the scan code of the desired key. (PS/2 only).</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">FC</font></strong></td>
    <td><font face="Arial" size="2">Set an individual key to generate up and down codes. Next
    byte contains the scan code of the desired key. (PS/2 only).</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">FD</font></strong></td>
    <td><font face="Arial" size="2">Set an individual key to generate only down codes. Next
    byte contains the scan code of the desired key. (PS/2 only).</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">FE</font></strong></td>
    <td><font face="Arial" size="2">Resend last result. Use this command if there is an error
    receiving data.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">FF</font></strong></td>
    <td><font face="Arial" size="2">Reset keyboard to power on state and start the self-test.</font></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2"><a NAME="MARKER-2-40"></a>The following short program
demonstrates how to send commands to the keyboard's controller. This little TSR utility
programs a &quot;light show&quot; on the keyboard's LEDs.<a NAME="MARKER-2-41"></a></font></p>

<pre><font face="Courier New" size="2">; LEDSHOW.ASM
;
; This short TSR creates a light show on the keyboard's LEDs. For space
; reasons, this code does not implement a multiplex handler nor can you
; remove this TSR once installed. See the chapter on resident programs
; for details on how to do this.
;
; cseg and EndResident must occur before the standard library segments!

cseg            segment para public 'code'
cseg            ends

; Marker segment, to find the end of the resident section.

EndResident     segment para public 'Resident'
EndResident     ends

                .xlist
                include         stdlib.a
                includelib      stdlib.lib
                .list


byp             equ     &lt;byte ptr&gt;

cseg            segment para public 'code'
                assume  cs:cseg, ds:cseg



; SetCmd-       Sends the command byte in the AL register to the 8042
;               keyboard microcontroller chip (command register at
;               port 64h).

SetCmd          proc    near
                push    cx
                push    ax              ;Save command value.
                cli                     ;Critical region, no ints now.

; Wait until the 8042 is done processing the current command.

                xor     cx, cx          ;Allow 65,536 times thru loop.
Wait4Empty:     in      al, 64h         ;Read keyboard status register.
                test    al, 10b         ;Input buffer full?
                loopnz  Wait4Empty      ;If so, wait until empty.

; Okay, send the command to the 8042:

                pop     ax              ;Retrieve command.
                out     64h, al
                sti                     ;Okay, ints can happen again.
                pop     cx
                ret
SetCmd          endp




; SendCmd-      The following routine sends a command or data byte to the
;               keyboard data port (port 60h).

SendCmd         proc    near
                push    ds
                push    bx
                push    cx
                mov     cx, 40h
                mov     ds, cx
                mov     bx, ax          ;Save data byte

                mov     al, 0ADh        ;Disable kbd for now.
                call    SetCmd

                cli                     ;Disable ints while accessing HW.

; Wait until the 8042 is done processing the current command.

                xor     cx, cx          ;Allow 65,536 times thru loop.
Wait4Empty:     in      al, 64h         ;Read keyboard status register.
                test    al, 10b         ;Input buffer full?
                loopnz  Wait4Empty      ;If so, wait until empty.

; Okay, send the data to port 60h

                mov     al, bl
                out     60h, al

                mov     al, 0AEh        ;Reenable keyboard.
                call    SetCmd
                sti                     ;Allow interrupts now.

                pop     cx
                pop     bx
                pop     ds
                ret
SendCmd         endp


; SetLEDs-      Writes the value in AL to the LEDs on the keyboard.
;               Bits 0..2 correspond to scroll, num, and caps lock,
;               respectively.

SetLEDs         proc    near
                push    ax
                push    cx

                mov     ah, al          ;Save LED bits.

                mov     al, 0EDh        ;8042 set LEDs cmd.
                call    SendCmd         ;Send the command to 8042.
                mov     al, ah          ;Get parameter byte
                call    SendCmd         ;Send parameter to the 8042.

                pop     cx
                pop     ax
                ret
SetLEDs         endp



; MyInt1C-      Every 1/4 seconds (every 4th call) this routine
;               rotates the LEDs to produce an interesting light show.

CallsPerIter    equ     4
CallCnt         byte    CallsPerIter
LEDIndex        word    LEDTable
LEDTable        byte    111b, 110b, 101b, 011b,111b, 110b, 101b, 011b
                byte    111b, 110b, 101b, 011b,111b, 110b, 101b, 011b
                byte    111b, 110b, 101b, 011b,111b, 110b, 101b, 011b
                byte    111b, 110b, 101b, 011b,111b, 110b, 101b, 011b

                byte    000b, 100b, 010b, 001b, 000b, 100b, 010b, 001b
                byte    000b, 100b, 010b, 001b, 000b, 100b, 010b, 001b
                byte    000b, 100b, 010b, 001b, 000b, 100b, 010b, 001b
                byte    000b, 100b, 010b, 001b, 000b, 100b, 010b, 001b

                byte    000b, 001b, 010b, 100b, 000b, 001b, 010b, 100b
                byte    000b, 001b, 010b, 100b, 000b, 001b, 010b, 100b
                byte    000b, 001b, 010b, 100b, 000b, 001b, 010b, 100b
                byte    000b, 001b, 010b, 100b, 000b, 001b, 010b, 100b

                byte    010b, 001b, 010b, 100b, 010b, 001b, 010b, 100b
                byte    010b, 001b, 010b, 100b, 010b, 001b, 010b, 100b
                byte    010b, 001b, 010b, 100b, 010b, 001b, 010b, 100b
                byte    010b, 001b, 010b, 100b, 010b, 001b, 010b, 100b

                byte    000b, 111b, 000b, 111b, 000b, 111b, 000b, 111b
                byte    000b, 111b, 000b, 111b, 000b, 111b, 000b, 111b
                byte    000b, 111b, 000b, 111b, 000b, 111b, 000b, 111b
                byte    000b, 111b, 000b, 111b, 000b, 111b, 000b, 111b
TableEnd                equ     this byte

OldInt1C        dword   ?

MyInt1C         proc    far
                assume  ds:cseg

                push    ds
                push    ax
                push    bx

                mov     ax, cs
                mov     ds, ax

                dec     CallCnt
                jne     NotYet
                mov     CallCnt, CallsPerIter   ;Reset call count.
                mov     bx, LEDIndex
                mov     al, [bx]
                call    SetLEDs
                inc     bx
                cmp     bx, offset TableEnd
                jne     SetTbl
                lea     bx, LEDTable
SetTbl:         mov     LEDIndex, bx
NotYet:         pop     bx
                pop     ax
                pop     ds
                jmp     cs:OldInt1C
MyInt1C         endp


Main            proc

                mov     ax, cseg
                mov     ds, ax

                print
                byte    &quot;LED Light Show&quot;,cr,lf
                byte    &quot;Installing....&quot;,cr,lf,0

; Patch into the INT 1Ch interrupt vector. Note that the
; statements above have made cseg the current data segment,
; so we can store the old INT 1Ch values directly into
; the OldInt1C variable.

                cli                             ;Turn off interrupts!
                mov     ax, 0
                mov     es, ax
                mov     ax, es:[1Ch*4]
                mov     word ptr OldInt1C, ax
                mov     ax, es:[1Ch*4 + 2]
                mov     word ptr OldInt1C+2, ax
                mov     es:[1Ch*4], offset MyInt1C
                mov     es:[1Ch*4+2], cs
                sti                             ;Okay, ints back on.


; We're hooked up, the only thing that remains is to terminate and
; stay resident.

                print
                byte    &quot;Installed.&quot;,cr,lf,0

                mov     ah, 62h                 ;Get this program's PSP
                int     21h                     ; value.

                mov     dx, EndResident         ;Compute size of program.
                sub     dx, bx
                mov     ax, 3100h               ;DOS TSR command.
                int     21h
Main            endp
cseg            ends

sseg            segment para stack 'stack'
stk             db      1024 dup (&quot;stack &quot;)
sseg            ends

zzzzzzseg       segment para public 'zzzzzz'
LastBytes       db      16 dup (?)
zzzzzzseg       ends
                end     Main</font></pre>

<p><font face="Arial" size="2">The keyboard microcontroller also sends data to the
on-board microcontroller for processing and release to the system through port 60h. Most
of these values are key press scan codes (up or down codes), but the keyboard transmits
several other values as well. A well designed keyboard interrupt service routine should be
able to handle (or at least ignore) the non-scan code values. Any particular, any program
that sends commands to the keyboard needs to be able to handle the resend and acknowledge
commands that the keyboard microcontroller returns in port 60h. The keyboard
microcontroller sends the following values to the system:</font></p>
<div align="center"><center>

<table BORDER="1" bordercolor="#C0C0C0" width="100%" cellspacing="0" cellpadding="0">
  <caption><font face="Arial" size="2"><strong>Keyboard to System Transmissions</strong></font></caption>
  <tr>
    <th align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">Value (hex)</font></strong></th>
    <th bgcolor="#F0F0F0"><p align="center"><font face="Arial" size="2">Description</font></th>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">00</font></strong></td>
    <td><font face="Arial" size="2">Data overrun. System sends a zero byte as the last value
    when the keyboard controller's internal buffer overflows.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">1..58<br>
    <br>
    81..D8</font></strong></td>
    <td><font face="Arial" size="2">Scan codes for key presses. The positive values are down
    codes, the negative values (H.O. bit set) are up codes.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">83AB</font></strong></td>
    <td><font face="Arial" size="2">Keyboard ID code returned in response to the F2 command
    (PS/2 only).</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">AA</font></strong></td>
    <td><font face="Arial" size="2">Returned during basic assurance test after reset. Also the
    up code for the left shift key.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">EE</font></strong></td>
    <td><font face="Arial" size="2">Returned by the ECHO command.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">F0</font></strong></td>
    <td><font face="Arial" size="2">Prefix to certain up codes (N/A on PS/2).</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">FA</font></strong></td>
    <td><font face="Arial" size="2">Keyboard acknowledge to keyboard commands other than
    resend or ECHO.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">FC</font></strong></td>
    <td><font face="Arial" size="2">Basic assurance test failed (PS/2 only).</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">FD</font></strong></td>
    <td><font face="Arial" size="2">Diagnostic failure (not available on PS/2).</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">FE</font></strong></td>
    <td><font face="Arial" size="2">Resend. Keyboard requests the system to resend the last
    command.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">FF</font></strong></td>
    <td><font face="Arial" size="2">Key error (PS/2 only).</font></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2"><a NAME="MARKER-2-42"></a>Assuming you have not disabled
keyboard interrupts (see the keyboard controller command byte), any value the keyboard
microcontroller sends to the system through port 60h will generate an interrupt on IRQ
line one (int 9). Therefore, the keyboard interrupt service routine normally handles all
the above codes. If you are patching into int 9, don't forget to send and end of interrupt
(EOI) signal to the 8259A PIC at the end of your ISR code. Also, don't forget you can
enable or disable the keyboard interrupt at the 8259A.</font></p>

<p><font face="Arial" size="2">In general, your application software should not access the
keyboard hardware directly. Doing so will probably make your software incompatible with
utility software such as keyboard enhancers (keyboard macro programs), pop-up software,
and other resident programs that read the keyboard or insert data into the system's type
ahead buffer. Fortunately, DOS and BIOS provide an excellent set of functions to read and
write keyboard data. Your programs will be much more robust if you stick to using those
functions. Accessing the keyboard hardware directly should be left to keyboard ISRs and
those keyboard enhancers and pop-up programs that absolutely have to talk directly to the
hardware.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH20-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH20-1.html">Chapter Twenty</a> (Part 1)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH20-3.html">Chapter Twenty</a> (Part 3)&nbsp; </strong></font><a href="CH20-3.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Twenty: The PC Keyboard (Part
2)<br>
29 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_20/CH20-2.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:51 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
