<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-5.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:27:38 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER THIRTEEN: MS-DOS, PC-BIOS AND FILE I/O (Part 5)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING5"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH13-4.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH13-4.html">Chapter Thirteen</a> (Part 4)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH13-6.html">Chapter Thirteen</a> (Part 6)&nbsp; </strong></font><a href="CH13-6.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10" colspan="2"><a NAME="HEADING5-1"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0" colspan="2"><font face="Arial" size="4"><strong>CHAPTER
    THIRTEEN:<br>
    MS-DOS, PC-BIOS AND FILE I/O (Part 5)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10" colspan="2"></td>
  </tr>
  <tr>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING5-1"><b>13.3.6 </b>-
    MS-DOS Memory Management Functions</a> <br>
    <a HREF="#HEADING5-10"><b>13.3.6.1 </b>- Allocate Memory</a> <br>
    <a HREF="#HEADING5-21"><b>13.3.6.2 </b>- Deallocate Memory</a> <br>
    <a HREF="#HEADING5-27"><b>13.3.6.3 </b>- Modify Memory Allocation</a> <br>
    <a HREF="#HEADING5-36"><b>13.3.6.4 </b>- Advanced Memory Management Functions</a> </font></td>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING5-41"><b>13.3.7 </b>-
    MS-DOS Process Control Functions</a> <br>
    <a HREF="#HEADING5-43"><b>13.3.7.1 </b>- Terminate Program Execution</a> <br>
    <a HREF="#HEADING5-50"><b>13.3.7.2 </b>- Terminate, but Stay Resident</a> <br>
    <a HREF="#HEADING5-61"><b>13.3.7.3 </b>- Execute a Program</a> </font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="20" colspan="2"></td>
  </tr>
</table>
</center></div>

<h3><strong><font face="Arial" size="3">13.3.6 MS-DOS Memory Management Functions</font></strong></h3>

<p><font face="Arial" size="2">MS-DOS provides three memory management functions-
allocate, deallocate, and resize (modify). For most programs, these three memory
allocation calls are not used. When DOS executes a program, it gives all of the available
memory, from the start of that program to the end of RAM, to the executing process. Any
attempt to allocate memory without first giving unused memory back to the system will
produce an &quot;insufficient memory&quot; error. </font></p>

<p><font face="Arial" size="2">Sophisticated programs which terminate and remain resident,
run other programs, or perform complex memory management tasks, may require the use of
these memory management functions. Generally these types of programs immediately
deallocate all of the memory that they don't use and then begin allocating and
deallocating storage as they see fit. </font></p>

<p><font face="Arial" size="2">Since these are complex functions, they shouldn't be used
unless you have a very specific purpose for them. Misusing these commands may result in
loss of system memory that can be reclaimed only by rebooting the system. Each of the
following calls returns the error status in the carry flag. If the carry is clear on
return, then the operation was completed successfully. If the carry flag is set when DOS
returns, then the <code>ax </code>register contains one of the following error codes:</font></p>

<pre><font face="Courier New" size="2">7- Memory control blocks destroyed 
8- Insufficient memory
9- Invalid memory block address</font></pre>

<p><font face="Arial" size="2">Additional notes about these errors will be discussed as
appropriate.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-10"></a>13.3.6.1 Allocate Memory</font></strong></p>

<pre><font face="Courier New" size="2">Function (ah):  48h
Entry parameters:       bx- Requested block size (in paragraphs)
Exit parameters:        If no error (carry clear): 
                                ax:0 points at allocated memory block 

                        If an error (carry set):
                                bx- maximum possible allocation size
                                ax- error code (7 or 8)</font></pre>

<p><font face="Arial" size="2">This call is used to allocate a block of memory. On entry
into DOS, <code>bx </code>contains the size of the requested block in paragraphs (groups
of 16 bytes). On exit, assuming no error, the <code>ax </code>register contains the
segment address of the start of the allocated block. If an error occurs, the block is not
allocated and the <code>ax </code>register is returned containing the error code. If the
allocation request failed due to insufficient memory, the <code>bx </code>register is
returned containing the maximum number of paragraphs actually available.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-21"></a>13.3.6.2 Deallocate
Memory</font></strong></p>

<pre><font face="Courier New" size="2">Function (ah):          49h
Entry parameters:       es:0- Segment address of block to be deallocated
Exit parameters:        If the carry is set, ax contains the error code (7,9)</font></pre>

<p><font face="Arial" size="2">This call is used to deallocate memory allocated via
function 48h above. The <code>es </code>register cannot contain an arbitrary memory
address. It must contain a value returned by the allocate memory function. You cannot use
this call to deallocate a portion of an allocated block. The modify allocation function is
used for that operation.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-27"></a>13.3.6.3 Modify Memory
Allocation</font></strong></p>

<pre><font face="Courier New" size="2">Function (ah):          4Ah
Entry parameters:       es:0- address of block to modify allocation size
                        bx- size of new block
Exit parameters:        If the carry is set, then 
                        ax contains the error code 7, 8, or 9
                        bx contains the maximum size possible (if error 8)</font></pre>

<p><font face="Arial" size="2">This call is used to change the size of an allocated block.
On entry, <code>es </code>must contain the segment address of the allocated block returned
by the memory allocation function. <code>Bx </code>must contain the new size of this block
in paragraphs. While you can almost always reduce the size of a block, you cannot normally
increase the size of a block if other blocks have been allocated after the block being
modified. Keep this in mind when using this function.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-36"></a>13.3.6.4 Advanced Memory
Management Functions</font></strong></p>

<p><font face="Arial" size="2">The MS-DOS 58h opcode lets programmers adjust MS-DOS'
memory allocation strategy and control the use of upper memory blocks (UMBs). There are
four subfunctions to this call, with the subfunction value appearing in the al register.
The following table describes these calls:</font></p>
<div align="center"><center>

<table BORDER="1" bordercolor="#C0C0C0" width="100%" cellspacing="0" cellpadding="0">
  <caption><font face="Arial" size="2"><strong>Advanced Memory Management Functions</strong></font></caption>
  <tr>
    <th align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">Function # (AH)</font></strong></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">Input Parameters</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">Output Parameters</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">Description</font></th>
  </tr>
  <tr>
    <td bgcolor="#F0F0F0" align="center"><strong><font face="Arial" size="2">58h</font></strong></td>
    <td><font face="Arial" size="2"><code>al</code>-0</font></td>
    <td><font face="Arial" size="2"><code>ax</code>- strategy</font></td>
    <td><font face="Arial" size="2">Get Allocation Strategy: Returns the current allocation
    strategy in ax (see table below for details).</font></td>
  </tr>
  <tr>
    <td bgcolor="#F0F0F0" align="center"><strong><font face="Arial" size="2">58h</font></strong></td>
    <td><font face="Arial" size="2"><code>al-1 bx</code>- strategy</font></td>
    <td><p align="center"><font face="Arial" size="2">-</font></td>
    <td><font face="Arial" size="2">Set Allocation Strategy: Sets the MS-DOS allocation
    strategy to the value specified in bx (see the table below for details).</font></td>
  </tr>
  <tr>
    <td bgcolor="#F0F0F0" align="center"><strong><font face="Arial" size="2">58H</font></strong></td>
    <td><font face="Arial" size="2"><code>al</code>- 2</font></td>
    <td><font face="Arial" size="2"><code>al</code>- link flag</font></td>
    <td><font face="Arial" size="2">Get Upper Memory Link: Returns true/false (1/0) in al to
    determine whether a program can allocate memory in the upper memory blocks.</font></td>
  </tr>
  <tr>
    <td bgcolor="#F0F0F0" align="center"><strong><font face="Arial" size="2">58h</font></strong></td>
    <td><font face="Arial" size="2"><code>al- 3 bx</code>- link flag (0=no link, 1=link okay).</font></td>
    <td><p align="center"><font face="Arial" size="2">-</font></td>
    <td><font face="Arial" size="2">Set Upper Memory Link: Links or unlinks the upper memory
    area. When linked, an application can allocate memory from the UMB (using the normal DOS
    allocate call). </font></td>
  </tr>
</table>
</center></div>

<p>&nbsp;</p>
<div align="center"><center>

<table BORDER="1" bordercolor="#C0C0C0" width="100%" cellspacing="0" cellpadding="0">
  <caption><font face="Arial" size="2"><strong>Memory Allocation Strategies</strong></font></caption>
  <tr>
    <th bgcolor="#F0F0F0" align="center"><font face="Arial" size="2">Value</font></th>
    <th bgcolor="#F0F0F0" align="center"><font face="Arial" size="2">Name</font></th>
    <th bgcolor="#F0F0F0" align="center"><font face="Arial" size="2">Description</font></th>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">0</font></strong></td>
    <td><font face="Arial" size="2">First Fit Low</font></td>
    <td><font face="Arial" size="2">Search conventional memory for the first free block of
    memory large enough to satisfy the allocation request. This is the default case.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">1</font></strong></td>
    <td><font face="Arial" size="2">Best Fit Low</font></td>
    <td><font face="Arial" size="2">Search conventional memory for the smallest block large
    enough to satisfy the request.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">2</font></strong></td>
    <td><font face="Arial" size="2">Last Fit Low</font></td>
    <td><font face="Arial" size="2">Search conventional memory from the highest address
    downward for the first block large enough to satisfy the request.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">80h</font></strong></td>
    <td><font face="Arial" size="2">First Fit High</font></td>
    <td><font face="Arial" size="2">Search high memory, then conventional memory, for the
    first available block that can satisfy the allocation request.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">81h</font></strong></td>
    <td><font face="Arial" size="2">Best Fit High</font></td>
    <td><font face="Arial" size="2">Search high memory, then conventional memory for the
    smallest block large enough to satisfy the allocation request.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">82h</font></strong></td>
    <td><font face="Arial" size="2">Last Fit High</font></td>
    <td><font face="Arial" size="2">Search high memory from high addresses to low, then
    conventional memory from high addresses to low, for the first block large enough to
    satisfy the request.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">40h</font></strong></td>
    <td><font face="Arial" size="2">First Fit Highonly</font></td>
    <td><font face="Arial" size="2">Search high memory only for the first block large enough
    to satisfy the request.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">41h</font></strong></td>
    <td><font face="Arial" size="2">Best Fit Highonly</font></td>
    <td><font face="Arial" size="2">Search high memory only for the smallest block large
    enough to satisfy the request.</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">42h</font></strong></td>
    <td><font face="Arial" size="2">Last Fit Highonly</font></td>
    <td><font face="Arial" size="2">Search high memory only, from the end of memory downward,
    for the first block large enough to satisfy the request.</font></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">These different allocation strategies can have an impact on
system performance. For an analysis of different memory management strategies, please
consult a good operating systems theory text.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-41"></a>13.3.7 MS-DOS Process
Control Functions</font></strong></p>

<p><font face="Arial" size="2">DOS provides several services dealing with loading,
executing, and terminating programs. Many of these functions have been rendered obsolete
by later versions of DOS. There are three<a HREF="#FOOTNOTE-5">[5]</a> functions of
general interest- program termination, terminate and stay resident, and execute a program.
These three functions will be discussed in the following sections.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-43"></a>13.3.7.1 Terminate
Program Execution</font></strong></p>

<p><font face="Courier New" size="2">Function (ah):&nbsp;&nbsp;&nbsp;&nbsp; 4Ch<br>
Entry parameters:&nbsp; al- return code<br>
Exit parameters:&nbsp;&nbsp; Does not return to your program</font></p>

<p><font face="Arial" size="2">This is the function call normally used to terminate your
program. It returns control to the calling process (normally, but not necessarily, DOS). A
return code can be passed to the calling process in the <code>al </code>register. Exactly
what meaning this return code has is entirely up to you. This return code can be tested
with the DOS &quot;IF ERRORLEVEL return code&quot; command in a DOS batch file. All files
opened by the current process will be automatically closed upon program termination.</font></p>

<p><font face="Arial" size="2">Note that the UCR Standard Library function &quot;<code>ExitPgm</code>&quot;
is simply a macro which makes this particular DOS call. This is the normal way of
returning control back to MS-DOS or some other program which ran the currently active
application.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-50"></a>13.3.7.2 Terminate, but
Stay Resident</font></strong></p>

<pre><font face="Courier New" size="2">Function (ah):          31h
Entry parameters:       al- return code
                        dx- memory size, in paragraphs
Exit parameters:        does not return to your program</font></pre>

<p><font face="Arial" size="2">This function also terminates program execution, but upon
returning to DOS, the memory in use by the process is not returned to the DOS free memory
pool. Essentially, the program remains in memory. Programs which remain resident in memory
after returning to DOS are often called TSRs (terminate and stay resident programs). </font></p>

<p><font face="Arial" size="2">When this command is executed, the <code>dx </code>register
contains the number of memory paragraphs to leave around in memory. This value is measured
from the beginning of the &quot;program segment prefix&quot;, a segment marking the start
of your file in memory. The address of the PSP (program segment prefix) is passed to your
program in the <code>ds </code>register when your program is first executed. You'll have
to save this value if your program is a TSR<a HREF="#FOOTNOTE-6">[6]</a>. </font></p>

<p><font face="Arial" size="2">Programs that terminate and stay resident need to provide
some mechanism for restarting. Once they return to DOS they cannot normally be restarted.
Most TSRs patch into one of the interrupt vectors (such as a keyboard, printer, or serial
interrupt vector) in order to restart whenever some hardware related event occurs (such as
when a key is pressed). This is how &quot;pop-up&quot; programs like SmartKey work. </font></p>

<p><font face="Arial" size="2">Generally, TSR programs are pop-ups or special device
drivers. The TSR mechanism provides a convenient way for you to load your own routines to
replace or augment BIOS' routines. Your program loads into memory, patches the appropriate
interrupt vector so that it points at an interrupt handler internal to your code, and then
terminates and stays resident. Now, when the appropriate interrupt instruction is
executed, your code will be called rather than BIOS'. </font></p>

<p><font face="Arial" size="2">There are far too many details concerning TSRs including
compatibility issues, DOS re-entrancy issues, and how interrupts are processed, to be
considered here. Additional details will appear in a later chapter.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-61"></a>13.3.7.3 Execute a
Program</font></strong></p>

<p><font face="Courier New" size="2">Function (ah):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 40h<br>
Entry parameters:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ds:dx- pointer to pathname of
program to execute<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
es:bx- Pointer to parameter block<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
al- 0=load and execute, 1=load only, 3=load overlay.<br>
Exit parameters:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If carry is set, ax contains
one of the following error codes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1- invalid function <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
2- file not found<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
5- access denied <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
8- not enough memory<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
10- bad environment <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
11- bad format</font></p>

<p><font face="Arial" size="2">The execute (<code>exec</code>) function is an extremely
complex, but at the same time, very useful operation. This command allows you to load or
load and execute a program off of the disk drive. On entry into the <code>exec </code>function,
the <code>ds:dx </code>registers contain a pointer to a zero terminated string containing
the name of the file to be loaded or executed, <code>es:bx </code>points at a parameter
block, and <code>al </code>contains zero or one depending upon whether you want to load
and execute a program or simply load it into memory. On return, if the carry is clear,
then DOS properly executed the command. If the carry flag is set, then DOS encountered an
error while executing the command. </font></p>

<p><font face="Arial" size="2">The filename parameter can be a full pathname including
drive and subdirectory information. &quot;B:\DIR1\DIR2\MYPGM.EXE&quot; is a perfectly
valid filename (remember, however, it must be zero terminated). The segmented address of
this pathname is passed in the <code>ds:dx </code>registers. </font></p>

<p><font face="Arial" size="2">The <code>es:bx </code>registers point at a parameter block
for the <code>exec </code>call. This parameter block takes on three different forms
depending upon whether a program is being loaded and executed (<code>al</code>=0), just
loaded into memory (<code>al</code>=1), or loaded as an overlay (<code>al</code>=3). </font></p>

<p><font face="Arial" size="2">If <code>al</code>=0, the <code>exec </code>call loads and
executes a program. In this case the <code>es:bx </code>registers point at a parameter
block containing the following values:</font></p>

<pre><font face="Courier New" size="2">Offset  Description 
0       A word value containing the segment address of the default environment 
	  (usually this is set to zero which implies the use of the standard DOS
	  environment).
2       Double word pointer containing the segment address of a command line string.
6       Double word pointer to default FCB at address 5Ch
0Ah     Double word pointer to default FCB at address 6Ch</font></pre>

<p><font face="Arial" size="2">The environment area is a set of strings containing default
pathnames and other information (this information is provided by DOS using the PATH, SET,
and other DOS commands). If this parameter entry contains zero, then <code>exec </code>will
pass the standard DOS environment on to the new procedure. If non-zero, then this
parameter contains the segment address of the environment block that your process is
passing on to the program about to be executed. Generally, you should store a zero at this
address.</font></p>

<p><font face="Arial" size="2">The pointer to the command string should contain the
segmented address of a length prefixed string which is also terminated by a carriage
return character (the carriage return character is not figured into the length of the
string). This string corresponds to the data that is normally typed after the program name
on the DOS command line. For example, if you're executing the linker automatically, you
might pass a command string of the following form:</font></p>

<pre><font face="Courier New" size="2">CmdStr          byte    16,&quot;MyPgm+Routines /m&quot;,0dh</font></pre>

<p><font face="Arial" size="2">The second item in the parameter block must contain the
segmented address of this string.</font></p>

<p><font face="Arial" size="2">The third and fourth items in the parameter block point at
the default FCBs. FCBs are used by the obsolete DOS filing commands, so they are rarely
used in modern application programs. Since the data structures these two pointers point at
are rarely used, you can point them at a group of 20 zeros.</font></p>

<p><font face="Arial" size="2">Example: Format a floppy disk in drive A: using the
FORMAT.EXE command</font></p>

<pre><font face="Courier New" size="2">                mov     ah, 4Bh
                mov     al, 0
                mov     dx, seg PathName
                mov     ds, dx
                lea     dx, PathName
                mov     bx, seg ParmBlock
                mov     es, bx
                lea     bx, ParmBlock
                int     21h
                 .
                 .
                 .
PathName        byte    'C:\DOS\FORMAT.EXE',0
ParmBlock       word    0                       ;Default environment
                dword   CmdLine                 ;Command line string
                dword   Dummy,Dummy             ;Dummy FCBs

CmdLine         byte    3,' A:',0dh
Dummy           byte    20 dup (?)</font></pre>

<p><font face="Arial" size="2">MS-DOS versions earlier than 3.0 do not preserve any
registers except cs:ip when you execute the exec call. In particular, ss:sp is not
preserved. If you're using DOS v2.x or earlier, you'll need to use the following code: </font></p>

<pre><font face="Courier New" size="2">;Example: Format a floppy disk in drive A: using the FORMAT.EXE command

                &lt;push any registers you need preserved&gt;

                mov     cs:SS_Save, ss          ;Save SS:SP to a location
                mov     cs:SP_Save, sp          ; we have access to later.
                mov     ah, 4Bh                 ;EXEC DOS opcode.
                mov     al, 0                   ;Load and execute.
                mov     dx, seg PathName        ;Get filename into DS:DX.
                mov     ds, dx
                lea     dx, PathName
                mov     bx, seg ParmBlock       ;Point ES:BX at parameter
                mov     es, bx                  ; block.
                lea     bx, ParmBlock
                int     21h
                mov     ss, cs:SS_Save          ;Restore SS:SP from saved
                mov     sp, cs:SP_Save          ; locations.

        &lt;Restore registers pushed onto the stack&gt;
                 .
                 .
                 .
SS_Save         word    ?
SP_Save         word    ?
                 .
                 .
                 .
PathName        byte    'C:\DOS\FORMAT.EXE',0
ParmBlock       word    0                       ;Default environment
                dword   CmdLine                 ;Command line string
                dword   Dummy,Dummy ;Dummy      ;FCBs
CmdLine         byte    3,' A:',0dh
Dummy           byte    20 dup (?)</font></pre>

<p><font face="Arial" size="2"><code>SS_Save</code> and <code>SP_Save</code> must be
declared inside your code segment. The other variables can be declared anywhere. </font></p>

<p><font face="Arial" size="2">The <code>exec </code>command automatically allocates
memory for the program being executed. If you haven't freed up unused memory before
executing this command, you may get an insufficient memory error. Therefore, you should
use the DOS deallocate memory command to free up unused memory before attempting to use
the <code>exec </code>command. </font></p>

<p><font face="Arial" size="2">If <code>al</code>=1 when the <code>exec </code>function
executes, DOS will load the specified file but will not execute it. This function is
generally used to load a program to execute into memory but give the caller control and
let the caller start that code. When this function call is made, <code>es:bx </code>points
at the following parameter block: </font></p>

<pre><font face="Courier New" size="2">Offset  Description 
0       Word value containing the segment address of the environment block for the 
        new process. If you want to use the parent process' environment block set 
        this word to zero.

2       Dword pointer to the command tail for this operation. The command tail is the 
        command line string which will appear at location PSP:80.

6       Address of default FCB #1. For most programs, this should point at a block of 
        20 zeros (unless, of course, you're running a program which uses FCBs.).

0Ah     Address of default FCB #2. Should also point at a block of 20 zeros.

0Eh     SS:SP value. You must load these four bytes into SS and SP before starting 
        the application.

12h     CS:IP value. These four bytes contain the starting address of the program.</font></pre>

<p><font face="Arial" size="2">The <code>SSSP</code> and <code>CSIP</code> fields are
output values. DOS fills in the fields and returns them in the load structure. The other
fields are all inputs which you must fill in before calling the <code>exec </code>function
with <code>al</code>=1.</font></p>

<p><font face="Arial" size="2">When you execute the <code>exec </code>command with <code>al</code>=-3,
DOS simply loads an overlay into memory. Overlays generally consist of a single code
segment which contains some functions you want to execute. Since you are not creating a
new process, the parameter block for this type of load is much simpler than for the other
two types of load operations. On entry, <code>es:bx </code>must point at the following
parameter block in memory:</font></p>

<pre><font face="Courier New" size="2">Offset  Description 
0       Word value containing the segment address of where this file is going 
        to be loaded into memory.  The file will be loaded at offset zero within 
        this segment.

2       Word value containing a relocation factor for this file.</font></pre>

<p><font face="Arial" size="2">Unlike the load and execute functions, the overlay function
does not automatically allocate storage for the file being loaded. Your program has to
allocate sufficient storage and then pass the address of this storage block to the <code>exec
</code>command (though the parameter block above). Only the segment address of this block
is passed to the <code>exec </code>command, the offset is always assumed to be zero. The
relocation factor should also contain the segment address for &quot;.EXE&quot; files. For
&quot;.COM&quot; files, the relocation factor parameter should be zero.</font></p>

<p><font face="Arial" size="2">The overlay command is quite useful for loading overlays
from disk into memory. An overlay is a segment of code which resides on the disk drive
until the program actually needs to execute its code. Then the code is loaded into memory
and executed. Overlays can reduce the amount of memory your program takes up by allowing
you to reuse the same portion of memory for different overlay procedures (clearly, only
one such procedure can be active at any one time). By placing seldom-used code and
initialization code into overlay files, you can help reduce the amount of memory used by
your program file. One word of caution, however, managing overlays is a very complex task.
This is not something a beginning assembly language programmer would want to tackle right
away. When loading a file into memory (as opposed to loading and executing a file), DOS
does not scramble all of the registers, so you needn't take the extra care necessary to
preserve the <code>ss:sp </code>and other registers. </font></p>

<p><font face="Arial" size="2">The MS-DOS Encyclopedia contains an excellent description
of the use of the <code>exec </code>function.</font></p>

<hr noshade size="1" color="#000000">

<p><font face="Arial" size="2"><strong><a NAME="FOOTNOTE-5"></a>[5] </strong>Actually,
there are others. See the DOS technical reference manual for more details. We will only
consider these three here. </font></p>

<p><font face="Arial" size="2"><strong><a NAME="FOOTNOTE-6"></a>[6]</strong> DOS also
provides a call which will return the PSP for your program. </font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH13-4.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH13-4.html">Chapter Thirteen</a> (Part 4)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH13-6.html">Chapter Thirteen</a> (Part 6)&nbsp; </strong></font><a href="CH13-6.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Thirteen: MS-DOS, PC-BIOS and
File I/O (Part 5)<br>
28 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-5.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:27:38 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
