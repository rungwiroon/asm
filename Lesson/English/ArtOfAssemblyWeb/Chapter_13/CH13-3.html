<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-3.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:27:38 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER THIRTEEN: MS-DOS, PC-BIOS AND FILE I/O (Part 3)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING3"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH13-2.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH13-2.html">Chapter Thirteen</a> (Part 2)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH13-4.html">Chapter Thirteen</a> (Part 4)&nbsp; </strong></font><a href="CH13-4.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10" colspan="2"><a NAME="HEADING3-0"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0" colspan="2"><font face="Arial" size="4"><strong>CHAPTER
    THIRTEEN:<br>
    MS-DOS, PC-BIOS AND FILE I/O (Part 3)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10" colspan="2"></td>
  </tr>
  <tr>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING3-1"><b>13.2.6 </b>-
    INT 14h - Serial I/O</a> <br>
    <a HREF="#HEADING3-7"><b>13.2.6.1 </b>- AH=0: Serial Port Initialization</a> <br>
    <a HREF="#HEADING3-41"><b>13.2.6.2 </b>- AH=1: Transmit a Character to the Serial Port</a>
    <br>
    <a HREF="#HEADING3-52"><b>13.2.6.3 </b>- AH=2: Receive a Character from the Serial Port</a>
    <br>
    <a HREF="#HEADING3-63"><b>13.2.6.4 </b>- AH=3: Serial Port Status</a> <br>
    <a HREF="#HEADING3-85"><b>13.2.7 </b>- INT 15h - Miscellaneous Services</a> <br>
    <a HREF="#HEADING3-87"><b>13.2.8 </b>- INT 16h - Keyboard Services</a> <br>
    <a HREF="#HEADING3-93"><b>13.2.8.1 </b>- AH=0: Read a Key From the Keyboard</a> <br>
    <a HREF="#HEADING3-106"><b>13.2.8.2 </b>- AH=1: See if a Key is Available at the Keyboard</a>
    <br>
    <a HREF="#HEADING3-131"><b>13.2.8.3 </b>- AH=2: Return Keyboard Shift Key Status</a> </font></td>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING3-144"><b>13.2.9
    </b>- INT 17h - Printer Services</a> <br>
    <a HREF="#HEADING3-158"><b>13.2.9.1 </b>- AH=0: Print a Character</a> <br>
    <a HREF="#HEADING3-161"><b>13.2.9.2 </b>- AH=1: Initialize Printer</a> <br>
    <a HREF="#HEADING3-163"><b>13.2.9.3 </b>- AH=2: Return Printer Status</a> <br>
    <a HREF="#HEADING3-181"><b>13.2.10 </b>- INT 18h - Run BASIC</a> <br>
    <a HREF="#HEADING3-187"><b>13.2.11 </b>- INT 19h - Reboot Computer</a> <br>
    <a HREF="#HEADING3-193"><b>13.2.12 </b>- INT 1Ah - Real Time Clock</a> <br>
    <a HREF="#HEADING3-199"><b>13.2.12.1 </b>- AH=0: Read the Real Time Clock</a> <br>
    <a HREF="#HEADING3-208"><b>13.2.12.2 </b>- AH=1: Setting the Real Time Clock</a> </font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="20" colspan="2"></td>
  </tr>
</table>
</center></div>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-1"></a>13.2.6 INT 14h - Serial
I/O</font></strong></p>

<pre><font face="Courier New" size="2">Instruction:    int 14h
BIOS Operation: Access the serial communications port
Parameters:     ax, dx</font></pre>

<p><font face="Arial" size="2">The IBM BIOS supports up to four different serial
communications ports (the hardware supports up to eight). In general, most PCs have one or
two serial ports (COM1: and COM2:) installed. <code>Int 14h </code>supports four
subfunctions- initialize, transmit a character, receive a character, and status. For all
four services, the serial port number (a value in the range 0..3) is in the <code>dx </code>register
(0=COM1:, 1=COM2:, etc.). <code>Int 14h </code>expects and returns other data in the <code>al
</code>or <code>ax </code>register.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-7"></a>13.2.6.1 AH=0: Serial Port
Initialization</font></strong></p>

<p><font face="Arial" size="2">Subfunction zero initializes a serial port. This call lets
you set the baud rate, select parity modes, select the number of stop bits, and the number
of bits transmitted over the serial line. These parameters are all specified by the value
in the <code>al </code>register using the following bit encodings: </font></p>

<pre><font face="Courier New" size="2">Bits    Function 
5..7    Select baud rate
                000- 110 baud
                001- 150
                010- 300
                011- 600
                100- 1200
                101- 2400
                110- 4800
                111- 9600

3..4    Select parity
                00- No parity
                01- Odd parity
                10- No parity
                11- Even parity

2       Stop bits
                 0-One stop bit
                 1-Two stop bits
0..1    Character Size
                 10- 7 bits
                 11- 8 bits</font></pre>

<p><font face="Arial" size="2">Although the standard PC serial port hardware supports
19,200 baud, some BIOSes may not support this speed. </font></p>

<p><font face="Arial" size="2">Example: Initialize COM1: to 2400 baud, no parity, eight
bit data, and two stop bits-</font></p>

<pre><font face="Courier New" size="2">                mov     ah, 0           ;Initialize opcode
                mov     al, 10100111b   ;Parameter data.
                mov     dx, 0           ;COM1: port.
                int     14h</font></pre>

<p><font face="Arial" size="2">After the call to the initialization code, the serial port
status is returned in <code>ax </code>(see Serial Port Status, <code>ah</code>=3, below).</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-41"></a>13.2.6.2 AH=1: Transmit a
Character to the Serial Port</font></strong></p>

<p><font face="Arial" size="2">This function transmits the character in the <code>al </code>register
through the serial port specified in the <code>dx </code>register. On return, if <code>ah </code>contains
zero, then the character was transmitted properly. If bit 7 of <code>ah </code>contains
one, upon return, then some sort of error occurred. The remaining seven bits contain all
the error statuses returned by the <code>GetStatus</code> call except time out error
(which is returned in bit seven). If an error is reported, you should use subfunction
three to get the actual error values from the serial port hardware. </font></p>

<p><font face="Arial" size="2">Example: Transmit a character through the COM1: port</font></p>

<pre><font face="Courier New" size="2">                mov     dx, 0           ;Select COM1:
                mov     al, 'a'         ;Character to transmit
                mov     ah, 1           ;Transmit opcode
                int     14h
                test    ah, 80h         ;Check for error
                jnz     SerialError</font></pre>

<p><font face="Arial" size="2">This function will wait until the serial port finishes
transmitting the last character (if any) and then it will store the character into the
transmit register. </font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-52"></a>13.2.6.3 AH=2: Receive a
Character from the Serial Port</font></strong></p>

<p><font face="Arial" size="2">Subfunction two is used to read a character from the serial
port. On entry, <code>dx </code>contains the serial port number. On exit, <code>al </code>contains
the character read from the serial port and bit seven of <code>ah </code>contains the
error status. When this routine is called, it does not return to the caller until a
character is received at the serial port. </font></p>

<p><font face="Arial" size="2">Example: Reading a character from the COM1: port</font></p>

<pre><font face="Courier New" size="2">                mov     dx, 0           ;Select COM1:
                mov     ah, 2           ;Receive opcode
                int     14h
                test    ah, 80h         ;Check for error
                jnz     SerialError 

        &lt;Received character is now in AL&gt;</font></pre>

<pre><strong><font face="Arial" size="3">13.2.6.4 AH=3: Serial Port Status</font></strong></pre>

<p><font face="Arial" size="2">This call returns status information about the serial port
including whether or not an error has occurred, if a character has been received in the
receive buffer, if the transmit buffer is empty, and other pieces of useful information.
On entry into this routine, the <code>dx </code>register contains the serial port number.
On exit, the <code>ax </code>register contains the following values: </font></p>

<pre><font face="Courier New" size="2">AX:     Bit Meaning 
15      Time out error
14      Transmitter shift register empty
13      Transmitter holding register empty
12      Break detection error
11      Framing error
10      Parity error
9       Overrun error
8       Data available
7       Receive line signal detect 
6       Ring indicator
5       Data set ready (DSR)
4       Clear to send (CTS)
3       Delta receive line signal detect
2       Trailing edge ring detector
1       Delta data set ready
0       Delta clear to send</font></pre>

<p><font face="Arial" size="2">There are a couple of useful bits, not pertaining to
errors, returned in this status information. If the data available bit is set (bit #8),
then the serial port has received data and you should read it from the serial port. The
Transmitter holding register empty bit (bit #13) tells you if the transmit operation will
be delayed while waiting for the current character to be transmitted or if the next
character will be immediately transmitted. By testing these two bits, you can perform
other operations while waiting for the transmit register to become available or for the
receive register to contain a character.</font></p>

<p><font face="Arial" size="2">If you're interested in serial communications, you should
obtain a copy of Joe Campbell's C Programmer's Guide to Serial Communications. Although
written specifically for C programmers, this book contains a lot of information useful to
programmers working in any programming language. See the bibliography for more details.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-85"></a>13.2.7 INT 15h -
Miscellaneous Services</font></strong></p>

<p><font face="Arial" size="2">Originally, <code>int 15h </code>provided cassette tape
read and write services<a HREF="#FOOTNOTE-1">[1]</a>. Almost immediately, everyone
realized that cassettes were history, so IBM began using <code>int 15h </code>for many
other services. Today, <code>int 15h </code>is used for a wide variety of function
including accessing expanded memory, reading the joystick/game adapter card, and many,
many other operations. Except for the joystick calls, most of these services are beyond
the scope of this text. Check on the bibliography if you interested in obtaining
information on this BIOS call. </font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-87"></a>13.2.8 INT 16h - Keyboard
Services</font></strong></p>

<pre><font face="Courier New" size="2">Instruction:    int 16h
BIOS Operation: Read a key, test for a key, or get keyboard status
Parameters:     al</font></pre>

<p><font face="Arial" size="2">The IBM PC BIOS provides several function calls dealing
with the keyboard. As with many of the PC BIOS routines, the number of functions has
increased over the years. This section describes the three calls that were available on
the original IBM PC. </font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-93"></a>13.2.8.1 AH=0: Read a Key
From the Keyboard</font></strong></p>

<p><font face="Arial" size="2">If<code> int 16h</code> is called with <code>ah </code>equal
to zero, the BIOS will not return control to the caller until a key is available in the
system type ahead buffer. On return, <code>al </code>contains the ASCII code for the key
read from the buffer and <code>ah </code>contains the keyboard scan code. Keyboard scan
codes are described in the appendices. </font></p>

<p><font face="Arial" size="2">Certain keys on the PC's keyboard do not have any
corresponding ASCII codes. The function keys, Home, PgUp, End, PgDn, the arrow keys, and
the Alt keys are all good examples. When such a key is pressed, <code>int 16h </code>returns
a zero in <code>al </code>and the keyboard scan code in <code>ah</code>. Therefore,
whenever an ASCII code of zero is returned, you must check the <code>ah </code>register to
determine which key was pressed. </font></p>

<p><font face="Arial" size="2">Note that reading a key from the keyboard using the BIOS <code>int
16h </code>call does not echo the key pressed to the display. You have to call <code>putc</code>
or use <code>int 10h </code>to print the character once you've read it if you want it
echoed to the screen. </font></p>

<p><font face="Arial" size="2">Example: Read a sequence of keystrokes from the keyboard
until Enter is pressed.</font></p>

<pre><font face="Courier New" size="2">ReadLoop:       mov     ah, 0           ;Read Key opcode
                int     16h
                cmp     al, 0           ;Special function?
                jz      ReadLoop        ;If so, don't echo this keystroke
                putc
                cmp     al, 0dh         ;Carriage return (ENTER)?
                jne     ReadLoop</font></pre>

<pre><strong><font face="Arial" size="3">13.2.8.2 AH=1: See if a Key is Available at the Keyboard</font></strong></pre>

<p><font face="Arial" size="2">This particular <code>int 16h </code>subfunction allows you
to check to see if a key is available in the system type ahead buffer. Even if a key is
not available, control is returned (right away!) to the caller. With this call you can
occasionally poll the keyboard to see if a key is available and continue processing if a
key hasn't been pressed (as opposed to freezing up the computer until a key is pressed).</font></p>

<p><font face="Arial" size="2">There are no input parameters to this function. On return,
the zero flag will be clear if a key is available, set if there aren't any keys in the
type ahead buffer. If a key is available, then <code>ax </code>will contain the scan and
ASCII codes for that key. However, this function will not remove that keystroke from the
typeahead buffer. Subfunction #0 must be used to remove characters. The following example
demonstrates how to build a random number generator using the test keyboard function: </font></p>

<p><font face="Arial" size="2">Example: Generating a random number while waiting for a
keystroke</font></p>

<pre><font face="Courier New" size="2">; First, clear any characters out of the type ahead buffer

ClrBuffer:      mov     ah, 1           ;Is a key available?
                int     16h
                jz      BufferIsClr     ;If not, Discontinue flushing
                mov     ah, 0           ;Flush this character from the
                int     16h             ; buffer and try again.
                jmp     ClrBuffer

BufferIsClr:    mov     cx, 0           ;Initialize &quot;random&quot; number.
GenRandom:      inc     cx
                mov     ah, 1           ;See if a key is available yet.
                int     16h
                jz      GenRandom
                xor     cl, ch          ;Randomize even more.
                mov     ah, 0           ;Read character from buffer
                int     16h

; Random number is now in CL, key pressed by user is in AX</font></pre>

<p><font face="Arial" size="2">While waiting for a key, this routine is constantly
incrementing the <code>cx </code>register. Since human beings cannot respond rapidly (at
least in terms of microseconds) the <code>cl </code>register will overflow many times,
even for the fastest typist. As a result, <code>cl </code>will contain a random value
since the user will not be able to control (to better than about 2ms) when a key is
pressed.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-131"></a>13.2.8.3 AH=2: Return
Keyboard Shift Key Status</font></strong></p>

<p><font face="Arial" size="2">This function returns the state of various keys on the PC
keyboard in the <code>al </code>register. The values returned are as follows:</font></p>

<pre><font face="Courier New" size="2">Bit     Meaning 
7       Insert state (toggle by pressing INS key)
6       Caps lock (1=capslock on)
5       Num lock (1=numlock on)
4       Scroll lock (1=scroll lock on)
3       Alt (1=Alt key currently down)
2       Ctrl (1=Ctrl key currently down)
1       Left shift (1=left shift key down)
0       Right shift (1=right shift key down)</font></pre>

<p><font face="Arial" size="2">Due to a bug in the BIOS code, these bits only reflect the
current status of these keys, they do not necessarily reflect the status of these keys
when the next key to be read from the system type ahead buffer was depressed. In order to
ensure that these status bits correspond to the state of these keys when a scan code is
read from the type ahead buffer, you've got to flush the buffer, wait until a key is
pressed, and then immediately check the keyboard status.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-144"></a>13.2.9 INT 17h - Printer
Services</font></strong></p>

<pre><font face="Courier New" size="2">Instruction:    int 17h
BIOS Operation: Print data and test the printer status
Parameters:     ax, dx</font></pre>
<code>

<p><font face="Arial" size="2">Int 17h </code>controls the parallel printer interfaces on
the IBM PC in much the same way the <code>int 14h </code>controls the serial ports. Since
programming a parallel port is considerably easier than controlling a serial port, using
the<code> int 17h </code>routine is somewhat easier than using the <code>int 14h </code>routines.
</font></p>

<p><font face="Arial" size="2"><code>Int 17h </code>provides three subfunctions, specified
by the value in the <code>ah </code>register. These subfunctions are: </font></p>

<p><font face="Arial" size="2">0-Print the character in the AL register. </font></p>

<p><font face="Arial" size="2">1-Initialize the printer. </font></p>

<p><font face="Arial" size="2">2-Return the printer status. </font></p>

<p><font face="Arial" size="2">Each of these functions is described in the following
sections. </font></p>

<p><font face="Arial" size="2">Like the serial port services, the printer port services
allow you to specify which of the three printers installed in the system you wish to use
(LPT1:, LPT2:, or LPT3:). The value in the <code>dx </code>register (0..2) specifies which
printer port is to be used. </font></p>

<p><font face="Arial" size="2">One final note- under DOS it's possible to redirect all
printer output to a serial port. This is quite useful if you're using a serial printer.
The BIOS printer services only talk to parallel printer adapters. If you need to send data
to a serial printer using BIOS, you'll have to use<code> int 14h</code> to transmit the
data through a serial port.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-158"></a>13.2.9.1 AH=0: Print a
Character</font></strong></p>

<p><font face="Arial" size="2">If <code>ah </code>is zero when you call <code>int 17h</code>,
then the BIOS will print the character in the <code>al </code>register. Exactly how the
character code in the <code>al </code>register is treated is entirely up to the printer
device you're using. Most printers, however, respect the printable ASCII character set and
a few control characters as well. Many printers will also print all the symbols in the
IBM/ASCII character set (including European, line drawing, and other special symbols).
Most printers treat control characters (especially ESC sequences) in completely different
manners. Therefore, if you intend to print something other than standard ASCII characters,
be forewarned that your software may not work on printers other than the brand you're
developing your software on. </font></p>

<p><font face="Arial" size="2">Upon return from the <code>int 17h </code>subfunction zero
routine, the <code>ah </code>register contains the current status. The values actually
returned are described in the section on subfunction number two.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-161"></a>13.2.9.2 AH=1:
Initialize Printer</font></strong></p>

<p><font face="Arial" size="2">Executing this call sends an electrical impulse to the
printer telling it to initialize itself. On return, the <code>ah </code>register contains
the printer status as per function number two.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-163"></a>13.2.9.3 AH=2: Return
Printer Status</font></strong></p>

<p><font face="Arial" size="2">This function call checks the printer status and returns it
in the <code>ah </code>register. The values returned are:</font></p>

<pre><font face="Courier New" size="2">AH:     Bit Meaning 
7       1=Printer busy, 0=printer not busy
6       1=Acknowledge from printer
5       1=Out of paper signal
4       1=Printer selected
3       1=I/O error
2       Not used
1       Not used
0       Time out error</font></pre>

<p><font face="Arial" size="2">Acknowledge from printer is, essentially, a redundant
signal (since printer busy/not busy gives you the same information). As long as the
printer is busy, it will not accept additional data. Therefore, calling the print
character function (<code>ah</code>=0) will result in a delay. </font></p>

<p><font face="Arial" size="2">The out of paper signal is asserted whenever the printer
detects that it is out of paper. This signal is not implemented on many printer adapters.
On such adapters it is always programmed to a logic zero (even if the printer is out of
paper). Therefore, seeing a zero in this bit position doesn't always guarantee that there
is paper in the machine. Seeing a one here, however, definitely means that your printer is
out of paper. </font></p>

<p><font face="Arial" size="2">The printer selected bit contains a one as long as the
printer is on-line. If the user takes the printer off-line, then this bit will be cleared.
</font></p>

<p><font face="Arial" size="2">The I/O error bit contains a one if some general I/O error
has occurred. </font></p>

<p><font face="Arial" size="2">The time out error bit contains a one if the BIOS routine
waited for an extended period of time for the printer to become &quot;not busy&quot; yet
the printer remained busy. </font></p>

<p><font face="Arial" size="2">Note that certain peripheral devices (other than printers)
also interface to the parallel port, often in addition to a parallel printer. Some of
these devices use the error/status signal lines to return data to the PC. The software
controlling such devices often takes over the <code>int 17h </code>routine (via a
technique we'll talk about later on) and always returns a &quot;no error&quot; status or
&quot;time out error&quot; status if an error occurs on the printing device. Therefore,
you should take care not to depend too heavily on these signals changing when you make the
<code>int 17h </code>BIOS calls.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-181"></a>13.2.10 INT 18h - Run
BASIC</font></strong></p>

<pre><font face="Courier New" size="2">Instruction:    int 18h
BIOS Operation: Activate ROM BASIC
Parameters:     None </font></pre>

<p><font face="Arial" size="2">Executing <code>int 18h </code>activates the ROM BASIC
interpreter in an IBM PC. However, you shouldn't use this mechanism to run BASIC since
many PC compatibles do not have BASIC in ROM and the result of executing <code>int 18h </code>is
undefined.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-187"></a>13.2.11 INT 19h - Reboot
Computer</font></strong></p>

<pre><font face="Courier New" size="2">Instruction:    int 19h 
BIOS Operation: Restart the system
Parameters:     None </font></pre>

<p><font face="Arial" size="2">Executing this interrupt has the same effect as pressing
control-alt-del on the keyboard. For obvious reasons, this interrupt service should be
handled carefully!</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-193"></a>13.2.12 INT 1Ah - Real
Time Clock</font></strong></p>

<pre><font face="Courier New" size="2">Instruction:    int 1ah
BIOS Operation: Real time clock services
Parameters:     ax, cx, dx</font></pre>

<p><font face="Arial" size="2">There are two services provided by this BIOS routine- read
the clock and set the clock. The PC's real time clock maintains a counter that counts the
number of 1/18ths of a second that have transpired since midnight. When you read the
clock, you get the number of &quot;ticks&quot; which have occurred since then. When you
set the clock, you specify the number of &quot;ticks&quot; which have occurred since
midnight. As usual, the particular service is selected via the value in the <code>ah </code>register.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-199"></a>13.2.12.1 AH=0: Read the
Real Time Clock</font></strong></p>

<p><font face="Arial" size="2">If <code>ah </code>= 0, then <code>int 1ah </code>returns a
33-bit value in <code>al:cx:dx </code>as follows: </font></p>

<pre><font face="Courier New" size="2">Reg     Value Returned 
dx      L.O. word of clock count
cx      H.O. word of clock count
al      Zero if timer has not run for more than 24 hours
        Non-zero otherwise.</font></pre>

<p><font face="Arial" size="2">The 32-bit value in <code>cx:dx </code>represents the
number of 55 millisecond periods which have elapsed since midnight.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-208"></a>13.2.12.2 AH=1: Setting
the Real Time Clock</font></strong></p>

<p><font face="Arial" size="2">This call allows you to set the current system time value. <code>cx:dx
</code>contains the current count (in 55ms increments) since last midnight. <code>Cx </code>contains
the H.O. word, <code>dx </code>contains the L.O. word.</font></p>

<hr noshade size="1" color="#000000">

<p><font face="Arial" size="2"><strong><a NAME="FOOTNOTE-1"></a>[1]</strong> For those who
do not remember that far back, before there were hard disks people used to use only floppy
disks. And before there were floppy disks, people used to use cassette tapes to store
programs and data. The original IBM PC was introduced in late 1981 with a cassette port.
By early 1982, no one was using cassette tape for data storage.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH13-2.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH13-2.html">Chapter Thirteen</a> (Part 2)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH13-4.html">Chapter Thirteen</a> (Part 4)&nbsp; </strong></font><a href="CH13-4.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Thirteen: MS-DOS, PC-BIOS and
File I/O (Part 3)<br>
28 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-3.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:27:38 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
