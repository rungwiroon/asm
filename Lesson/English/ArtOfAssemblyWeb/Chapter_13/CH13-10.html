<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-10.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:27:38 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER THIRTEEN: MS-DOS, PC-BIOS AND FILE I/O (Part 10)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING10"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH13-9.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH13-9.html">Chapter Thirteen</a> (Part 9)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH13-11.html">Chapter Thirteen</a> (Part 11)&nbsp; </strong></font><a href="CH13-11.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10" colspan="2"><a NAME="HEADING10-1"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0" colspan="2"><font face="Arial" size="4"><strong>CHAPTER
    THIRTEEN:<br>
    MS-DOS, PC-BIOS AND FILE I/O (Part 10)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10" colspan="2"></td>
  </tr>
  <tr>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING10-1"><b>13.4 </b>-
    UCR Standard Library File I/O Routines</a> <br>
    <a HREF="#HEADING10-9"><b>13.4.1 </b>- Fopen</a> <br>
    <a HREF="#HEADING10-25"><b>13.4.2 </b>- Fcreate</a> <br>
    <a HREF="#HEADING10-37"><b>13.4.3 </b>- Fclose</a> <br>
    <a HREF="#HEADING10-47"><b>13.4.4 </b>- Fflush</a> </font></td>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING10-56"><b>13.4.5
    </b>- Fgetc</a> <br>
    <a HREF="#HEADING10-68"><b>13.4.6 </b>- Fread</a> <br>
    <a HREF="#HEADING10-83"><b>13.4.7 </b>- Fputc</a> <br>
    <a HREF="#HEADING10-94"><b>13.4.8 </b>- Fwrite</a> <br>
    <a HREF="#HEADING10-108"><b>13.4.9 </b>- Redirecting I/O Through the StdLib File I/O
    Routines</a> </font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="20" colspan="2"><font face="Arial" size="2"></font></td>
  </tr>
  <tr>
    <td width="100%" colspan="2"><font face="Arial" size="2"></font><strong><font face="Arial" size="3">13.4 UCR Standard Library File I/O Routines</font></strong><font face="Arial" size="2"></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="1" colspan="2" bgcolor="#000000"><font face="Arial" size="2"></font></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">Although MS-DOS' file I/O facilities are not too bad, the
UCR Standard Library provides a file I/O package which makes blocked sequential I/O as
easy as character at a time file I/O. Furthermore, with a tiny amount of effort, you can
use all the StdLib routines like <code>printf, print, puti, puth, putc, getc, gets,</code>
etc., when performing file I/O. This greatly simplifies text file operations in assembly
language.</font></p>

<p><font face="Arial" size="2">Note that record oriented, or binary I/O, is probably best
left to pure DOS. any time you want to do random access within a file. The Standard
Library routines really only support sequential text I/O. Nevertheless, this is the most
common form of file I/O around, so the Standard Library routines are quite useful indeed.</font></p>

<p><font face="Arial" size="2">The UCR Standard Library provides eight file I/O routines: <code>fopen</code>,
<code>fcreate</code>, <code>fclose</code>, <code>fgetc</code>, <code>fread</code>, <code>fputc</code>,
and <code>fwrite</code>. <code>Fgetc </code>and <code>fputc </code>perform character at a
time I/O, <code>fread </code>and <code>fwrite </code>let you read and write blocks of
data, the other four functions perform the obvious DOS operations.</font></p>

<p><font face="Arial" size="2">The UCR Standard Library uses a special file variable to
keep track of file operations. There is a special record type, FileVar, declared in
stdlib.a<a HREF="#FOOTNOTE-8">[8]</a>. When using the StdLib file I/O routines you must
create a variable of type <code>FileVar</code> for every file you need open at the same
time. This is very easy, just use a definition of the form:</font></p>

<pre><font face="Courier New" size="2">	MyFileVar       FileVar {}</font></pre>

<p><font face="Arial" size="2">Please note that a Standard Library file variable is not
the same thing as a DOS file handle. It is a structure which contains the DOS file handle,
a buffer (for blocked I/O), and various index and status variables. The internal structure
of this type is of no interest (remember data encapsulation!) except to the implementor of
the file routines. You will pass the address of this file variable to the various Standard
Library file I/O routines.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING10-9"></a>13.4.1 Fopen</font></strong></p>

<pre><font face="Courier New" size="2">Entry parameters:       
                ax-     File open mode
                 0- File opened for reading 
                 1- File opened for writing
                dx:si-  Points at a zero terminated string containing 
                        the filename.
                es:di-  Points at a StdLib file variable.

Exit parameters:        
                If the carry is set, 
                 ax contains the returned DOS error code 
                 (see DOS open function).</font></pre>
<code>

<p><font face="Arial" size="2">Fopen </code>opens a sequential text file for reading or
writing. Unlike DOS, you cannot open a file for reading and writing. Furthermore, this is
a sequential text file which does not support random access. Note that the file must exist
or <code>fopen </code>will return an error. This is even true when you open the file for
writing. </font></p>

<p><font face="Arial" size="2">Note that if you open a file for writing and that file
already exists, any data written to the file will overwrite the existing data. When you
close the file, any data appearing in the file after the data you wrote will still be
there. If you want to erase the existing file before writing data to it, use the <code>fcreate
</code>function.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING10-25"></a>13.4.2 Fcreate</font></strong></p>

<pre><font face="Courier New" size="2">Entry parameters:       
                dx:si-  Points at a zero terminated string containing 
                        the filename.
                es:di-  Points at a StdLib file variable.

Exit parameters:        
                If the carry is set, 
                 ax contains the returned DOS error code 
                 (see DOS open function).</font></pre>
<code>

<p><font face="Arial" size="2">Fcreate</code> creates a new file and opens it for writing.
If the file already exists, <code>fcreate</code> deletes the existing file and creates a
new one. It initializes the file variable for output but is otherwise identical to the <code>fopen
</code>call.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING10-37"></a>13.4.3 Fclose</font></strong></p>

<pre><font face="Courier New" size="2">Entry parameters:       
                es:di-  Points at a StdLib file variable.
Exit parameters:        
                If the carry is set, 
                 ax contains the returned DOS error code 
                 (see DOS open function).</font></pre>
<code>

<p><font face="Arial" size="2">Fclose </code>closes a file and updates any internal
housekeeping information. It is very important that you close all files opened with <code>fopen
</code>or <code>fcreate </code>using this call. When making DOS file calls, if you forget
to close a file DOS will automatically do that for you when your program terminates.
However, the StdLib routines cache up data in internal buffers. the fclose call
automatically flushes these buffers to disk. If you exit your program without calling <code>fclose</code>,
you may lose some data written to the file but not yet transferred from the internal
buffer to the disk.</font></p>

<p><font face="Arial" size="2">If you are in an environment where it is possible for
someone to abort the program without giving you a chance to close the file, you should
call the fflush routines (see the next section) on a regular basis to avoid losing too
much data.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING10-47"></a>13.4.4 Fflush</font></strong></p>

<pre><font face="Courier New" size="2">Entry parameters:       
                es:di-  Points at a StdLib file variable.
Exit parameters:        
                If the carry is set, 
                 ax contains the returned DOS error code 
                 (see DOS open function).</font></pre>

<p><font face="Arial" size="2">This routine immediately writes any data in the internal
file buffer to disk. Note that you should only use this routine in conjunction with files
opened for writing (or opened by <code>fcreate</code>). If you write data to a file and
then need to leave the file open, but inactive, for some time period, you should perform a
flush operation in case the program terminates abnormally.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING10-56"></a>13.4.5 Fgetc</font></strong></p>

<pre><font face="Courier New" size="2">Entry parameters:       
                es:di-  Points at a StdLib file variable.
Exit parameters:        
                If the carry flag is clear, 
                 al contains the character read from the file.
                If the carry is set, 
                 ax contains the returned DOS error code 
                 (see DOS open function). ax will contain zero if you attempt to read beyond the end of file.</font></pre>
<code>

<p><font face="Arial" size="2">Fgetc</code> reads a single character from the file and
returns this character in the <code>al </code>register. Unlike calls to DOS, single
character I/O using <code>fgetc </code>is relatively fast since the StdLib routines use
blocked I/O. Of course, multiple calls to <code>fgetc</code> will never be faster than a
call to <code>fread</code> (see the next section), but the performance is not too bad.</font></p>

<p><font face="Arial" size="2"><code>Fgetc</code> is very flexible. As you will see in a
little bit, you may redirect the StdLib input routines to read their data from a file
using <code>fgetc</code>. This lets you use the higher level routines like <code>gets</code>
and <code>getsm</code> when reading data from a file.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING10-68"></a>13.4.6 Fread</font></strong></p>

<pre><font face="Courier New" size="2">Entry parameters:       
                es:di-  Points at a StdLib file variable.
                dx:si-  Points at an input data buffer.
                cx-     Contains a byte count.
Exit parameters:        
                If the carry flag is clear, 
                 ax contains the actual number of bytes 
                 read from the file.
                If the carry is set, 
                 ax contains the returned DOS error code 
                 (see DOS open function).</font></pre>

<p><font face="Arial" size="2"><code>Fread</code> is very similar to the DOS <code>read</code>
command. It lets you read a block of bytes, rather than just one byte, from a file. Note
that if all you are doing is reading a block of bytes from a file, the DOS call is
slightly more efficient than <code>fread</code>. However, if you have a mixture of single
byte reads and multi-byte reads, the combination of <code>fread</code> and <code>fgetc</code>
work very well.</font></p>

<p><font face="Arial" size="2">As with the DOS read operation, if the byte count returned
in <code>ax </code>does not match the value passed in the <code>cx </code>register, then
you've read the remaining bytes in the file. When this occurs, the next call to <code>fread</code>
or <code>fgetc</code> will return an EOF error (carry will be set and <code>ax </code>will
contain zero). Note that <code>fread</code> does not return EOF unless there were zero
bytes read from the file.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING10-83"></a>13.4.7 Fputc</font></strong></p>

<pre><font face="Courier New" size="2">Entry parameters:       
                es:di-  Points at a StdLib file variable.
                al-     Contains the character to write to the file.

Exit parameters:        
                If the carry is set, 
                 ax contains the returned DOS error code 
                 (see DOS open function).</font></pre>

<p><font face="Arial" size="2"><code>Fputc</code> writes a single character (in <code>al</code>)
to the file specified by the file variable whose address is in <code>es:di</code>. This
call simply adds the character in <code>al </code>to an internal buffer (part of the file
variable) until the buffer is full. Whenever the buffer is filled or you call <code>fflush</code>
(or close the file with <code>fclose</code>), the file I/O routines write the data to
disk.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING10-94"></a>13.4.8 Fwrite</font></strong></p>

<pre><font face="Courier New" size="2">Entry parameters:       
                es:di-  Points at a StdLib file variable.
                dx:si-  Points at an output data buffer.
                cx-     Contains a byte count.
Exit parameters:        
                If the carry flag is clear, 
                 ax contains the actual number of bytes 
                 written to the file.
                If the carry is set, 
                 ax contains the returned DOS error code 
                 (see DOS open function).</font></pre>

<p><font face="Arial" size="2">Like <code>fread</code>, <code>fwrite</code> works on
blocks of bytes. It lets you write a block of bytes to a file opened for writing with
fopen or fcreate.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING10-108"></a>13.4.9 Redirecting I/O
Through the StdLib File I/O Routines</font></strong></p>

<p><font face="Arial" size="2">The Standard Library provides very few file I/O routines. <code>Fputc</code>
and <code>fwrite</code> are the only two output routines, for example. The &quot;C&quot;
programming language standard library (on which the UCR Standard Library is based)
provides many routines like <code>fprintf, fputs, fscanf, </code>etc. None of these are
necessary in the UCR Standard Library because the UCR library provides an I/O redirection
mechanism that lets you reuse all existing I/O routines to perform file I/O.</font></p>

<p><font face="Arial" size="2">The UCR Standard Library <code>putc</code> routine consists
of a single <code>jmp </code>instruction. This instruction transfers control to some
actual output routine via an indirect address internal to the putc code. Normally, this
pointer variable points at a piece of code which writes the character in the <code>al </code>register
to the DOS standard output device. However, the Standard Library also provides four
routines which let you manipulate this indirect pointer. By changing this pointer you can
redirect the output from its current routine to a routine of your choosing. All Standard
Library output routines (e.g., <code>printf, puti, puth, puts</code>) call <code>putc</code>
to output individual characters. Therefore, redirecting the <code>putc</code> routine
affects all the output routines. </font></p>

<p><font face="Arial" size="2">Likewise, the <code>getc</code> routine is nothing more
than an indirect <code>jmp </code>whose pointer variable normally points at a piece of
code which reads data from the DOS standard input. Since all Standard Library input
routines call the <code>getc</code> function to read each character you can redirect file
input in a manner identical to file output.</font></p>

<p><font face="Arial" size="2">The Standard Library <code>GetOutAdrs, SetOutAdrs,
PushOutAdrs,</code> and <code>PopOutAdrs</code> are the four main routines which
manipulate the output redirection pointer. <code>GetOutAdrs</code> returns the address of
the current output routine in the <code>es:di </code>registers. Conversely, <code>SetOutAdrs
</code>expects you to pass the address of a new output routine in the <code>es:di </code>registers
and it stores this address into the output pointer. <code>PushOutAdrs</code> and <code>PopOutAdrs</code>
push and pop the pointer on an internal stack. These do not use the 80x86's hardware
stack. You are limited to a small number of pushes and pops. Generally, you shouldn't
count on being able to push more than four of these addresses onto the internal stack
without overflowing it.</font></p>

<p><font face="Arial" size="2"><code>GetInAdrs, SetInAdrs, PushInAdrs, </code>and <code>PopInAdrs</code>
are the complementary routines for the input vector. They let you manipulate the input
routine pointer. Note that the stack for <code>PushInAdrs/PopInAdrs</code> is not the same
as the stack for <code>PushOutAdrs/PopOutAdrs</code>. Pushes and pops to these two stacks
are independent of one another. </font></p>

<p><font face="Arial" size="2">Normally, the output pointer (which we will henceforth
refer to as the output hook) points at the Standard Library routine <code>PutcStdOut<a HREF="#FOOTNOTE-9">[9]</a></code>. Therefore, you can return the output hook to its normal
initialization state at any time by executing the statements<a HREF="#FOOTNOTE-10">[10]</a>:</font></p>

<pre><font face="Courier New" size="2">                mov     di, seg SL_PutcStdOut
                mov     es, di
                mov     di, offset SL_PutcStdOut
                SetOutAdrs</font></pre>

<p><font face="Arial" size="2">The <code>PutcStdOut</code> routine writes the character in
the <code>al </code>register to the DOS standard output, which itself might be redirected
to some file or device (using the &quot;&gt;&quot; DOS redirection operator). If you want
to make sure your output is going to the video display, you can always call the <code>PutcBIOS</code>
routine which calls the BIOS directly to output a character<a HREF="#FOOTNOTE-11">[11]</a>.
You can force all Standard Library output to the standard error device using a code
sequence like:</font></p>

<pre><font face="Courier New" size="2">                mov     di, seg SL_PutcBIOS
                mov     es, di
                mov     di, offset SL_PutcBIOS
                SetOutAdrs</font></pre>

<p><font face="Arial" size="2">Generally, you would not simply blast the output hook by
storing a pointer to your routine over the top of whatever pointer was there and then
restoring the hook to <code>PutcStdOut</code> upon completion. Who knows if the hook was
pointing at <code>PutcStdOut</code> in the first place? The best solution is to use the
Standard Library <code>PushOutAdrs</code> and <code>PopOutAdrs</code> routines to preserve
and restore the previous hook. The following code demonstrates a gentler way of modifying
the output hook:</font></p>

<pre><font face="Courier New" size="2">                PushOutAdrs             ;Save current output routine.
                mov     di, seg Output_Routine
                mov     es, di
                mov     di, offset Output_Routine
                SetOutAdrs

        &lt;Do all output to Output_Routine here&gt;

                PopOutAdrs              ;Restore previous output routine.</font></pre>

<p><font face="Arial" size="2">Handle input in a similar fashion using the corresponding
input hook access routines and the <code>SL_GetcStdOut</code> and SL_<code>GetcBIOS</code>
routines. Always keep in mind that there are a limited number of entries on the input and
output hook stacks so what how many items you push onto these stacks without popping
anything off.</font></p>

<p><font face="Arial" size="2">To redirect output to a file (or redirect input from a
file) you must first write a short routine which writes (reads) a single character from
(to) a file. This is very easy. The code for a subroutine to output data to a file
described by file variable <code>OutputFile</code> is</font></p>

<pre><font face="Courier New" size="2">ToOutput        proc    far
                push    es
                push    di

; Load ES:DI with the address of the OutputFile variable. This
; code assumes OutputFile is of type FileVar, not a pointer to
; a variable of type FileVar.

                mov     di, seg OutputFile
                mov     es, di
                mov     di, offset OutputFile

; Output the character in AL to the file described by &quot;OutputFile&quot;

                fputc

                pop     di
                pop     es
                ret
ToOutput        endp</font></pre>

<p><font face="Arial" size="2">Now with only one additional piece of code, you can begin
writing data to an output file using all the Standard Library output routines. That is a
short piece of code which redirects the output hook to the &quot;<code>ToOutput</code>&quot;
routine above:</font></p>

<pre><font face="Courier New" size="2">SetOutFile      proc
                push    es
                push    di

                PushOutAdrs             ;Save current output hook.
                mov     di, seg ToOutput
                mov     es, di
                mov     di, offset ToOutput
                SetOutAdrs

                pop     di
                pop     es
                ret
SetOutFile      endp</font></pre>

<p><font face="Arial" size="2">There is no need for a separate routine to restore the
output hook to its previous value; <code>PopOutAdrs</code> will handle that task by
itself.</font></p>

<hr noshade size="1" color="#000000">

<p><font face="Arial" size="2"><strong><a NAME="FOOTNOTE-8"></a>[8]</strong> Actually,
it's declared in file.a. Stdlib.a includes file.a so this definition appears inside
stdlib.a as well. </font></p>

<p><font face="Arial" size="2"><strong><a NAME="FOOTNOTE-9"></a>[9]</strong> Actually, the
routine is SL_PutcStdOut. The Standard Library macro by which you would normally call this
routine is PutcStdOut. </font></p>

<p><font face="Arial" size="2"><strong><a NAME="FOOTNOTE-10"></a>[10]</strong> If you do
not have any calls to PutcStdOut in your program, you will also need to add the statement
&quot;externdef SL_PutcStdOut:far&quot; to your program. </font></p>

<p><font face="Arial" size="2"><strong><a NAME="FOOTNOTE-11"></a>[11]</strong> It is
possible to redirect even the BIOS output, but this is rarely done and not easy to do from
DOS. </font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH13-9.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH13-9.html">Chapter Thirteen</a> (Part 9)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH13-11.html">Chapter Thirteen</a> (Part 11)&nbsp; </strong></font><a href="CH13-11.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Thirteen: MS-DOS, PC-BIOS and
File I/O (Part 10)<br>
28 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-10.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:27:38 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
