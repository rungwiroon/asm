<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-8.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:27:38 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER THIRTEEN: MS-DOS, PC-BIOS AND FILE I/O (Part 8)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING8"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH13-7.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH13-7.html">Chapter Thirteen</a> (Part 7)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH13-9.html">Chapter Thirteen</a> (Part 9)&nbsp; </strong></font><a href="CH13-9.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10"><a NAME="HEADING8-1"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0"><font face="Arial" size="4"><strong>CHAPTER THIRTEEN:<br>
    MS-DOS, PC-BIOS AND FILE I/O (Part 8)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10"></td>
  </tr>
  <tr>
    <td width="100%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING8-1"><b>13.3.10
    </b>- Blocked File I/O</a> <br>
    <a HREF="#HEADING8-103"><b>13.3.11 </b>- The Program Segment Prefix (PSP)</a> </font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="20"><font face="Arial" size="2"></font></td>
  </tr>
</table>
</center></div>

<h3><strong><font face="Arial" size="3">13.3.10 Blocked File I/O</font></strong></h3>

<p><font face="Arial" size="2">The examples in the previous section suffer from a major
drawback, they are extremely slow. The performance problems with the code above are
entirely due to DOS. Making a DOS call is not, shall we say, the fastest operation in the
world. Calling DOS every time we want to read or write a single character from/to a file
will bring the system to its knees. As it turns out, it doesn't take (practically) any
more time to have DOS read or write two characters than it does to read or write one
character. Since the amount of time we (usually) spend processing the data is negligible
compared to the amount of time DOS takes to return or write the data, reading two
characters at a time will essentially double the speed of the program. If reading two
characters doubles the processing speed, how about reading four characters? Sure enough,
it almost quadruples the processing speed. Likewise processing ten characters at a time
almost increases the processing speed by an order of magnitude. Alas, this progression
doesn't continue forever. There comes a point of diminishing returns- when it takes far
too much memory to justify a (very) small improvement in performance (keeping in mind that
reading 64K in a single operation requires a 64K memory buffer to hold the data). A good
compromise is 256 or 512 bytes. Reading more data doesn't really improve the performance
much, yet a 256 or 512 byte buffer is easier to deal with than larger buffers. </font></p>

<p><font face="Arial" size="2">Reading data in groups or blocks is called blocked I/O.
Blocked I/O is often one to two orders of magnitude faster than single character I/O, so
obviously you should use blocked I/O whenever possible. </font></p>

<p><font face="Arial" size="2">There is one minor drawback to blocked I/O-- it's a little
more complex to program than single character I/O. Consider the example presented in the
section on the DOS read command: </font></p>

<p><font face="Arial" size="2">Example: This example opens a file and reads it to the EOF</font></p>

<pre><font face="Courier New" size="2">                mov     ah, 3dh         ;Open the file
                mov     al, 0           ;Open for reading
                lea     dx, Filename    ;Presume DS points at filename
                int     21h             ; segment
                jc      BadOpen
                mov     FHndl, ax       ;Save file handle

LP:             mov     ah,3fh          ;Read data from the file
                lea     dx, Buffer      ;Address of data buffer
                mov     cx, 1           ;Read one byte
                mov     bx, FHndl       ;Get file handle value
                int     21h
                jc      ReadError
                cmp     ax, cx          ;EOF reached?
                jne     EOF
                mov     al, Buffer      ;Get character read
                putc                    ;Print it (IOSHELL call)
                jmp     LP              ;Read next byte

EOF:            mov     bx, FHndl
                mov     ah, 3eh         ;Close file
                int     21h
                jc      CloseError</font></pre>

<p><font face="Arial" size="2">There isn't much to this program at all. Now consider the
same example rewritten to use blocked I/O: </font></p>

<p><font face="Arial" size="2">Example: This example opens a file and reads it to the EOF
using blocked I/O</font></p>

<pre><font face="Courier New" size="2">                mov     ah, 3dh         ;Open the file
                mov     al, 0           ;Open for reading
                lea     dx, Filename    ;Presume DS points at filename 
                int     21h             ; segment
                jc      BadOpen
                mov     FHndl, ax       ;Save file handle

LP:             mov     ah,3fh          ;Read data from the file
                lea     dx, Buffer      ;Address of data buffer
                mov     cx, 256         ;Read 256 bytes
                mov     bx, FHndl       ;Get file handle value
                int     21h
                jc      ReadError
                cmp     ax, cx          ;EOF reached?
                jne     EOF
                mov     si, 0           ;Note: CX=256 at this point.
PrtLp:          mov     al, Buffer[si]  ;Get character read
                putc                    ;Print it
                inc     si
                loop    PrtLp
                jmp     LP              ;Read next block

; Note, just because the number of bytes read doesn't equal 256, 
; don't get the idea we're through, there could be up to 255 bytes 
; in the buffer still waiting to be processed.

EOF:            mov     cx, ax
                jcxz    EOF2            ;If CX is zero, we're really done.
                mov     si, 0           ;Process the last block of data read 
Finis:          mov     al, Buffer[si]  ; from the file which contains 
                putc                    ; 1..255 bytes of valid data.
                inc     si
                loop    Finis

EOF2:           mov     bx, FHndl
                mov     ah, 3eh         ;Close file
                int     21h
                jc      CloseError</font></pre>

<p><font face="Arial" size="2">This example demonstrates one major hassle with blocked I/O
- when you reach the end of file, you haven't necessarily processed all of the data in the
file. If the block size is 256 and there are 255 bytes left in the file, DOS will return
an EOF condition (the number of bytes read don't match the request). In this case, we've
still got to process the characters that were read. The code above does this in a rather
straight-forward manner, using a second loop to finish up when the EOF is reached. You've
probably noticed that the two print loops are virtually identical. This program can be
reduced in size somewhat using the following code which is only a little more complex: </font></p>

<p><font face="Arial" size="2">Example: This example opens a file and reads it to the EOF
using blocked I/O</font></p>

<pre><font face="Courier New" size="2">                mov     ah, 3dh         ;Open the file
                mov     al, 0           ;Open for reading
                lea     dx, Filename    ;Presume DS points at filename
                int     21h             ; segment.
                jc      BadOpen
                mov     FHndl, ax       ;Save file handle

LP:             mov     ah,3fh          ;Read data from the file
                lea     dx, Buffer      ;Address of data buffer
                mov     cx, 256          ;Read 256 bytes
                mov     bx, FHndl       ;Get file handle value
                int     21h
                jc      ReadError
                mov     bx, ax          ;Save for later
                mov     cx, ax
                jcxz    EOF
                mov     si, 0           ;Note: CX=256 at this point.
PrtLp:          mov     al, Buffer[si]  ;Get character read
                putc                    ;Print it
                inc     si
                loop    PrtLp
                cmp     bx, 256         ;Reach EOF yet?
                je      LP

EOF:            mov     bx, FHndl
                mov     ah, 3eh         ;Close file
                int     21h
                jc      CloseError</font></pre>

<p><font face="Arial" size="2">Blocked I/O works best on sequential files. That is, those
files opened only for reading or writing (no seeking). When dealing with random access
files, you should read or write whole records at one time using the DOS read/write
commands to process the whole record. This is still considerably faster than manipulating
the data one byte at a time.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING8-103"></a>13.3.11 The Program
Segment Prefix (PSP)</font></strong></p>

<p><font face="Arial" size="2">When a program is loaded into memory for execution, DOS
first builds up a program segment prefix immediately before the program is loaded into
memory. This PSP contains lots of information, some of it useful, some of it obsolete.
Understanding the layout of the PSP is essential for programmers designing assembly
language programs. </font></p>

<p><font face="Arial" size="2">The PSP is 256 bytes long and contains the following
information: </font></p>

<pre><font face="Courier New" size="2">Offset  Length  Description 
0       2       An INT 20h instruction is stored here
2       2       Program ending address
4       1       Unused, reserved by DOS
5       5       Call to DOS function dispatcher
0Ah     4       Address of program termination code
0Eh     4       Address of break handler routine
12h     4       Address of critical error handler routine
16h     22      Reserved for use by DOS
2Ch     2       Segment address of environment area
2Eh     34      Reserved by DOS
50h     3       INT 21h, RETF instructions
53h     9       Reserved by DOS
5Ch     16      Default FCB #1
6Ch     20      Default FCB #2
80h     1       Length of command line string
81h     127     Command line string</font></pre>

<p><font face="Arial" size="2">Note: locations 80h..FFh are used for the default DTA. </font></p>

<p><font face="Arial" size="2">Most of the information in the PSP is of little use to a
modern MS-DOS assembly language program. Buried in the PSP, however, are a couple of gems
that are worth knowing about. Just for completeness, however, we'll take a look at all of
the fields in the PSP. </font></p>

<p><font face="Arial" size="2">The first field in the PSP contains an<code> int 20h </code>instruction.
<code>Int 20h </code>is an obsolete mechanism used to terminate program execution. Back in
the early days of DOS v1.0, your program would execute a <code>jmp </code>to this location
in order to terminate. Nowadays, of course, we have DOS function 4Ch which is much easier
(and safer) than jumping to location zero in the PSP. Therefore, this field is obsolete. </font></p>

<p><font face="Arial" size="2">Field number two contains a value which points at the last
paragraph allocated to your program By subtracting the address of the PSP from this value,
you can determine the amount of memory allocated to your program (and quit if there is
insufficient memory available).</font></p>

<p><font face="Arial" size="2">The third field is the first of many &quot;holes&quot; left
in the PSP by Microsoft. Why they're here is anyone's guess. </font></p>

<p><font face="Arial" size="2">The fourth field is a call to the DOS function dispatcher.
The purpose of this (now obsolete) DOS calling mechanism was to allow some additional
compatibility with CP/M-80 programs. For modern DOS programs, there is absolutely no need
to worry about this field. </font></p>

<p><font face="Arial" size="2">The next three fields are used to store special addresses
during the execution of a program. These fields contain the default terminate vector,
break vector, and critical error handler vectors. These are the values normally stored in
the interrupt vectors for <code>int 22h</code>, <code>int 23h</code>, and <code>int 24h</code>.
By storing a copy of the values in the vectors for these interrupts, you can change these
vectors so that they point into your own code. When your program terminates, DOS restores
those three vectors from these three fields in the PSP. For more details on these
interrupt vectors, please consult the DOS technical reference manual. </font></p>

<p><font face="Arial" size="2">The eighth field in the PSP record is another reserved
field, currently unavailable for use by your programs. </font></p>

<p><font face="Arial" size="2">The ninth field is another real gem. It's the address of
the environment strings area. This is a two-byte pointer which contains the segment
address of the environment storage area. The environment strings always begin with an
offset zero within this segment. The environment string area consists of a sequence of
zero-terminated strings. It uses the following format:</font></p>

<p><font face="Arial" size="2">string1 0 string2 0 string3 0 ... 0 stringn 0 0</font></p>

<p><font face="Arial" size="2">That is, the environment area consists of a list of zero
terminated strings, the list itself being terminated by a string of length zero (i.e., a
zero all by itself, or two zeros in a row, however you want to look at it). Strings are
(usually) placed in the environment area via DOS commands like PATH, SET, etc. Generally,
a string in the environment area takes the form</font></p>

<pre><font face="Courier New" size="2">&nbsp;		name = parameters</font></pre>

<p><font face="Arial" size="2">For example, the &quot;SET IPATH=C:\ASSEMBLY\INCLUDE&quot;
command copies the string &quot;IPATH=C:\ASSEMBLY\INCLUDE&quot; into the environment
string storage area. </font></p>

<p><font face="Arial" size="2">Many languages scan the environment storage area to find
default filename paths and other pieces of default information set up by DOS. Your
programs can take advantage of this as well. </font></p>

<p><font face="Arial" size="2">The next field in the PSP is another block of reserved
storage, currently undefined by DOS. </font></p>

<p><font face="Arial" size="2">The 11th field in the PSP is another call to the DOS
function dispatcher. Why this call exists (when the one at location 5 in the PSP already
exists and nobody really uses either mechanism to call DOS) is an interesting question. In
general, this field should be ignored by your programs. </font></p>

<p><font face="Arial" size="2">The 12th field is another block of unused bytes in the PSP
which should be ignored. </font></p>

<p><font face="Arial" size="2">The 13th and 14th fields in the PSP are the default FCBs
(File Control Blocks). File control blocks are another archaic data structure carried over
from CP/M-80. FCBs are used only with the obsolete DOS v1.0 file handling routines, so
they are of little interest to us. We'll ignore these FCBs in the PSP. </font></p>

<p><font face="Arial" size="2">Locations 80h through the end of the PSP contain a very
important piece of information- the command line parameters typed on the DOS command line
along with your program's name. If the following is typed on the DOS command line:</font></p>

<pre><font face="Courier New" size="2">		MYPGM parameter1, parameter2</font></pre>

<p><font face="Arial" size="2">the following is stored into the command line parameter
field:</font></p>

<pre><font face="Courier New" size="2">		23, &quot; parameter1, parameter2&quot;, 0Dh</font></pre>

<p><font face="Arial" size="2">Location 80h contains 2310, the length of the parameters
following the program name. Locations 81h through 97h contain the characters making up the
parameter string. Location 98h contains a carriage return. Notice that the carriage return
character is not figured into the length of the command line string. </font></p>

<p><font face="Arial" size="2">Processing the command line string is such an important
facet of assembly language programming that this process will be discussed in detail in
the next section. </font></p>

<p><font face="Arial" size="2">Locations 80h..FFh in the PSP also comprise the default
DTA. Therefore, if you don't use DOS function 1Ah to change the DTA and you execute a FIND
FIRST FILE, the filename information will be stored starting at location 80h in the PSP. </font></p>

<p><font face="Arial" size="2">One important detail we've omitted until now is exactly how
you access data in the PSP. Although the PSP is loaded into memory immediately before your
program, that doesn't necessarily mean that it appears 100h bytes before your code. Your
data segments may have been loaded into memory before your code segments, thereby
invalidating this method of locating the PSP. The segment address of the PSP is passed to
your program in the <code>ds </code>register. To store the PSP address away in your data
segment, your programs should begin with the following code:</font></p>

<pre><font face="Courier New" size="2">                push    ds              ;Save PSP value
                mov     ax, seg DSEG    ;Point DS and ES at our data
                mov     ds, ax                  ; segment.
                mov     es, ax
                pop     PSP             ;Store PSP value into &quot;PSP&quot;
                                        ; variable.
                 .
                 .
                 .</font></pre>

<p><font face="Arial" size="2">Another way to obtain the PSP address, in DOS 5.0 and
later, is to make a DOS call. If you load <code>ah </code>with 51h and execute an <code>int
21h </code>instruction, MS-DOS will return the segment address of the current PSP in the <code>bx
</code>register.</font></p>

<p><font face="Arial" size="2">There are lots of tricky things you can do with the data in
the PSP. Peter Norton's Programmer's Guide to the IBM PC lists all kinds of tricks. Such
operations won't be discussed here because they're a little beyond the scope of this
manual.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH13-7.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH13-7.html">Chapter Thirteen</a> (Part 7)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH13-9.html">Chapter Thirteen</a> (Part 9)&nbsp; </strong></font><a href="CH13-9.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Thirteen: MS-DOS, PC-BIOS and
File I/O (Part 8)<br>
28 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-8.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:27:38 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
