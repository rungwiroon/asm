<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_14/CH14-5.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:27:53 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER FOURTEEN: FLOATING POINT ARITHMETIC (Part 5)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING5"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH14-4.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH14-4.html">Chapter Fourteen</a> (Part 4)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH14-6.html">Chapter Fourteen</a> (Part 6)&nbsp; </strong></font><a href="CH14-6.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10" colspan="2"><a NAME="HEADING5-1"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0" colspan="2"><font face="Arial" size="4"><strong>CHAPTER
    FOURTEEN:<br>
    FLOATING POINT ARITHMETIC (Part 5)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10" colspan="2"></td>
  </tr>
  <tr>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING5-1"><b>14.4.7 </b>-
    Comparison Instructions</a> <br>
    <a HREF="#HEADING5-5"><b>14.4.7.1 </b>- The FCOM, FCOMP, and FCOMPP Instructions</a> <br>
    <a HREF="#HEADING5-22"><b>14.4.7.2 </b>- The FUCOM, FUCOMP, and FUCOMPP Instructions</a> <br>
    <a HREF="#HEADING5-31"><b>14.4.7.3 </b>- The FTST Instruction</a> <br>
    <a HREF="#HEADING5-33"><b>14.4.7.4 </b>- The FXAM Instruction</a> <br>
    <a HREF="#HEADING5-35"><b>14.4.8 </b>- Constant Instructions</a> <br>
    <a HREF="#HEADING5-44"><b>14.4.9 </b>- Transcendental Instructions</a> <br>
    <a HREF="#HEADING5-46"><b>14.4.9.1 </b>- The F2XM1 Instruction</a> <br>
    <a HREF="#HEADING5-58"><b>14.4.9.2 </b>- The FSIN, FCOS, and FSINCOS Instructions</a> <br>
    <a HREF="#HEADING5-62"><b>14.4.9.3 </b>- The FPTAN Instruction</a> <br>
    <a HREF="#HEADING5-65"><b>14.4.9.4 </b>- The FPATAN Instruction</a> <br>
    <a HREF="#HEADING5-70"><b>14.4.9.5 </b>- The FYL2X and FYL2XP1 Instructions</a> </font></td>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING5-79"><b>14.4.10
    </b>- Miscellaneous instructions</a> <br>
    <a HREF="#HEADING5-82"><b>14.4.10.1 </b>- The FINIT and FNINIT Instructions</a> <br>
    <a HREF="#HEADING5-84"><b>14.4.10.2 </b>- The FWAIT Instruction</a> <br>
    <a HREF="#HEADING5-86"><b>14.4.10.3 </b>- The FLDCW and FSTCW Instructions</a> <br>
    <a HREF="#HEADING5-93"><b>14.4.10.4 </b>- The FCLEX and FNCLEX Instructions</a> <br>
    <a HREF="#HEADING5-95"><b>14.4.10.5 </b>- The FLDENV, FSTENV, and FNSTENV Instructions</a>
    <br>
    <a HREF="#HEADING5-111"><b>14.4.10.6 </b>- The FSAVE, FNSAVE, and FRSTOR Instructions</a> <br>
    <a HREF="#HEADING5-135"><b>14.4.10.7 </b>- The FSTSW and FNSTSW Instructions</a> <br>
    <a HREF="#HEADING5-142"><b>14.4.10.8 </b>- The FINCSTP and FDECSTP Instructions</a> <br>
    <a HREF="#HEADING5-144"><b>14.4.10.9 </b>- The FNOP Instruction</a> <br>
    <a HREF="#HEADING5-146"><b>14.4.10.10 </b>- The FFREE Instruction</a> <br>
    <a HREF="#HEADING5-150"><b>14.4.11 </b>- Integer Operations</a> </font></td>
  </tr>
</table>
</center></div>

<h3><strong><font face="Arial" size="3">14.4.7 Comparison Instructions</font></strong></h3>

<p><font face="Arial" size="2">The 80x87 provides several instructions for comparing real
values. The <code>fcom</code>, <code>fcomp</code>, <code>fcompp</code>, <code>fucom</code>,
<code>fucomp</code>, and <code>fucompp</code> instructions compare the two values on the
top of stack and set the condition codes appropriately. The <code>ftst</code> instruction
compares the value on the top of stack with zero. The <code>fxam</code> instrution checks
the value on tos and reports sign, normalization, and tag information.</font></p>

<p><font face="Arial" size="2">Generally, most programs test the condition code bits
immediately after a comparison. Unfortunately, there are no conditional jump instructions
that branch based on the FPU condition codes. Instead, you can use the <code>fstsw</code>
instruction to copy the floating point status register (see &quot;The FPU Status
Register&quot;) into the <code>ax</code> register; then you can use the <code>sahf</code>
instruction to copy the <code>ah</code> register into the 80x86's condition code bits.
After doing this, you can can use the conditional jump instructions to test some
condition. This technique copies <code>C0</code> into the carry flag, <code>C2</code> into
the parity flag, and <code>C3</code> into the zero flag. The <code>sahf</code> instruction
does not copy <code>C1</code> into any of the 80x86's flag bits.</font></p>

<p><font face="Arial" size="2">Since the <code>sahf</code> instruction does not copy any
80x87 processor status bits into the sign or overflow flags, you cannot use the <code>jg</code>,
<code>jl</code>, <code>jge</code>, or <code>jle</code> instructions. Instead, use the <code>ja</code>,
<code>jae</code>, <code>jb</code>, <code>jbe</code>, <code>je</code>, and <code>jz</code>
instructions when testing the results of a floating point comparison. Yes, these
conditional jumps normally test unsigned values and floating point numbers are signed
values. However, use the unsigned conditional branches anyway; the <code>fstsw</code> and <code>sahf</code>
instructions set the 80x86 flags register to use the unsigned jumps.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-5"></a>14.4.7.1 The FCOM, FCOMP,
and FCOMPP Instructions</font></strong></p>

<p><font face="Arial" size="2">The <code>fcom</code>, <code>fcomp</code>, and <code>fcompp</code>
instructions compare <code>st(0)</code> to the specified operand and set the corresponding
80x87 condition code bits based on the result of the comparison. The legal forms for these
instructions are</font></p>

<pre><font face="Courier New" size="2">                fcom
                fcomp
                fcompp

                fcom    st(i)
                fcomp   st(i)

                fcom    mem
                fcomp   mem</font></pre>

<p><font face="Arial" size="2">With no operands, <code>fcom</code>, <code>fcomp</code>,
and <code>fcompp</code> compare <code>st(0)</code> against <code>st(1)</code> and set the
processor flags accordingly. In addition, <code>fcomp</code> pops <code>st(0)</code> off
the stack and <code>fcompp</code> pops both <code>st(0)</code> and <code>st(1)</code> off
the stack.</font></p>

<p><font face="Arial" size="2">With a single register operand, <code>fcom</code> and <code>fcomp</code>
compare <code>st(0)</code> against the specified register. <code>Fcomp</code> also pops <code>st(0)</code>
after the comparison.</font></p>

<p><font face="Arial" size="2">With a 32 or 64 bit memory operand, the <code>fcom</code>
and <code>fcomp</code> instructions convert the memory variable to an 80 bit extended
precision value and then compare <code>st(0)</code> against this value, setting the
condition code bits accordingly. <code>Fcomp</code> also pops <code>st(0)</code> after the
comparison.</font></p>

<p><font face="Arial" size="2">These instructions set <code>C2</code> (which winds up in
the parity flag) if the two operands are not comparable (e.g., NaN). If it is possible for
an illegal floating point value to wind up in a comparison, you should check the parity
flag for an error before checking the desired condition.</font></p>

<p><font face="Arial" size="2">These instructions set the stack fault bit if there aren't
two items on the top of the register stack. They set the denormalized exception bit if
either or both operands are denormalized. They set the invalid operation flag if either or
both operands are quite NaNs. These instructions always clear the <code>C1</code>
condition code.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-22"></a>14.4.7.2 The FUCOM,
FUCOMP, and FUCOMPP Instructions</font></strong></p>

<p><font face="Arial" size="2">These instructions are similar to the fcom, fcomp, and
fcompp instructions, although they only allow the following forms:</font></p>

<pre><font face="Courier New" size="2">                fucom
                fucomp
                fucompp
                fucom   st(i)
                fucomp  st(i)</font></pre>

<p><font face="Arial" size="2">The difference between fcom/fcomp/fcompp and
fucom/fucomp/fucompp is relatively minor. The fcom/fcomp/fcompp instructions set the
invalid operation exception bit if you compare two NaNs. The fucom/fucomp/fucompp
instructions do not. In all other cases, these two sets of instructions behave
identically.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-31"></a>14.4.7.3 The FTST
Instruction</font></strong></p>

<p><font face="Arial" size="2">The <code>ftst</code> instruction compares the value in <code>st(0)</code>
against 0.0. It behaves just like the <code>fcom</code> instruction would if <code>st(1</code>)
contained 0.0. Note that this instruction does not differentiate -0.0 from +0.0. If the
value in <code>st(0)</code> is either of these values, ftst will set <code>C3</code> to
denote equality. If you need to differentiate -0.0 from +0.0, use the <code>fxam</code>
instruction. Note that this instruction does not pop<code> st(0) </code>off the stack.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-33"></a>14.4.7.4 The FXAM
Instruction</font></strong></p>

<p><font face="Arial" size="2">The <code>fxam</code> instruction examines the value in <code>st(0)</code>
and reports the results in the condition code bits (see &quot;The FPU Status
Register&quot; for details on how fxam sets these bits). This instruction does not pop <code>st(0)</code>
off the stack.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-35"></a>14.4.8 Constant
Instructions</font></strong></p>

<p><font face="Arial" size="2">The 80x87 FPU provides several instructions that let you
load commonly used constants onto the FPU's register stack. These instructions set the
stack fault, invalid operation, and C1 flags if a stack overflow occurs; they do not
otherwise affect the FPU flags. The specific instructions in this category include:</font></p>

<pre><font face="Courier New" size="2">                fldz    ;Pushes +0.0.
                fld1    ;Pushes +1.0.
                fldp    ;Pushes p.
                fldl2t  ;Pushes log2(10).
                fldl2e  ;Pushes log2(e).
                fldlg2  ;Pushes log10(2).
                fldln2  ;Pushes ln(2).</font></pre>

<pre><font face="Arial" size="3"><strong>14.4.9 Transcendental Instructions</strong></font></pre>

<p><font face="Arial" size="2">The 80387 and later FPUs provide eight transcendental (log
and trigonometric) instructions to compute a partial tangent, partial arctangent, 2x-1, y
* log2(x), and y * log2(x+1). Using various algebraic identities, it is easy to compute
most of the other common transcendental functions using these instructions.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-46"></a>14.4.9.1 The F2XM1
Instruction</font></strong></p>
<code>

<p><font face="Arial" size="2">F2xm1</code> computes 2st(0)-1. The value in <code>st(0)</code>
must be in the range -1.0 <code>st(0)</code> +1.0. If <code>st(0)</code> is out of range <code>f2xm1</code>
generates an undefined result but raises no exceptions. The computed value replaces the
value in <code>st(0)</code>. Example:</font></p>

<pre><font face="Courier New" size="2">; Compute 10x using the identity: 10x = 2x*lg(10) (lg = log2).

                fld     x
                fldl2t
                fmul
                f2xm1
                fld1
                fadd</font></pre>

<p><font face="Arial" size="2">Note that <code>f2xm1</code> computes (2**x) - 1, which is
why the code above adds 1.0 to the result at the end of the computation.</font></p>

<p><strong><font face="Arial"><a NAME="HEADING5-58"></a>14.4.9.2 The FSIN, FCOS, and
FSINCOS Instructions</font></strong></p>

<p><font face="Arial" size="2">These instructions pop the value off the top of the
register stack and compute the sine, cosine, or both, and push the result(s) back onto the
stack. The <code>fsincos</code> pushes the sine followed by the cosine of the original
operand, hence it leaves cos(<code>st(0)</code>) in <code>st(0)</code> and sin(<code>st(0)</code>)
in <code>st(1)</code>.</font></p>

<p><font face="Arial" size="2">These instructions assume <code>st(0)</code> specifies an
angle in radians and this angle must be in the range -2**63 &lt; <code>st(0)</code> &lt;
+2**63. If the original operand is out of range, these instructions set the <code>C2</code>
flag and leave <code>st(0)</code> unchanged. You can use the fprem1 instruction, with a
divisor of 2<em>pi </em>to reduce the operand to a reasonable range.</font></p>

<p><font face="Arial" size="2">These instructions set the stack fault/<code>C1</code>,
precision, underflow, denormalized, and invalid operation flags according to the result of
the computation.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-62"></a>14.4.9.3 The FPTAN
Instruction</font></strong></p>
<code>

<p><font face="Arial" size="2">Fptan</code> computes the tangent of <code>st(0)</code> and
pushes this value and then it pushes 1.0 onto the stack. Like the <code>fsin</code> and <code>fcos</code>
instructions, the value of <code>st(0)</code> is assumed to be in radians and must be in
the range -2**63&lt;<code>st(0)</code>&lt;+2**63. If the value is outside this range,
fptan sets <code>C2 </code>to indicate that the conversion did not take place. As with the
<code>fsin</code>, <code>fcos</code>, and <code>fsincos</code> instructions, you can use
the <code>fprem1</code> instruction to reduce this operand to a reasonable range using a
divisor of 2<em>pi</em>.</font></p>

<p><font face="Arial" size="2">If the argument is invalid (i.e., zero or <em>pi </em>radians,
which causes a division by zero) the result is undefined and this instruction raises no
exceptions. <code>Fptan</code> will set the stack fault, precision, underflow, denormal,
invalid operation, <code>C2</code>, and <code>C1</code> bits as required by the operation.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-65"></a>14.4.9.4 The FPATAN
Instruction</font></strong></p>

<p><font face="Arial" size="2">This instruction expects two values on the top of stack. It
pops them and computes the following:</font></p>

<p><font face="Arial" size="2">st(0) = tan-1( st(1) / st(0) )</font></p>

<p><font face="Arial" size="2">The resulting value is the arctangent of the ratio on the
stack expressed in radians. If you have a value you wish to compute the tangent of, use <code>fld1</code>
to create the appropriate ratio and then execute the <code>fpatan</code> instruction.</font></p>

<p><font face="Arial" size="2">This instruction affects the stack fault/<code>C1</code>,
precision, underflow, denormal, and invalid operation bits if an problem occurs during the
computation. It sets the <code>C1 </code>condition code bit if it has to round the result.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-70"></a>14.4.9.5 The FYL2X and
FYL2XP1 Instructions</font></strong></p>

<p><font face="Arial" size="2">The <code>fyl2x</code> and <code>fyl2xp1</code>
instructions compute <code>st(1)</code> * log2(<code>st(0)</code>) and <code>st(1)</code>
* log2(<code>st(0)</code>+1), respectively. <code>Fyl2x</code> requires that <code>st(0)</code>
be greater than zero, <code>fyl2xp1</code> requires <code>st(0)</code> to be in the range:</font></p>
<div align="center"><center>

<pre><font face="Arial" size="2"><img SRC="images/ch14-11a.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH14/CH14-11a.gif" WIDTH="239" HEIGHT="34" ALIGN="bottom" NATURALSIZEFLAG="3"></font></pre>
</center></div><code>

<p><font face="Arial" size="2">Fyl2x</code> is useful for computing logs to bases other
than two; <code>fyl2xp1</code> is useful for computing compound interest, maintaining the
maximum precision during computation.</font></p>

<p><font face="Arial" size="2"><code>Fyl2x</code> can affect all the exception flags. <code>C1</code>
denotes rounding if there is not other error, stack overflow/underflow if the stack fault
bit is set.</font></p>

<p><font face="Arial" size="2">The <code>fyl2xp1</code> instruction does not affect the
overflow or zero divide exception flags. These exceptions occur when <code>st(0)</code> is
very small or zero. Since <code>fyl2xp1</code> adds one to <code>st(0)</code> before
computing the function, this condition never holds. <code>Fyl2xp1</code> affects the other
flags in a manner identical to <code>fyl2x</code>.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-79"></a>14.4.10 Miscellaneous
instructions</font></strong></p>

<p><font face="Arial" size="2">The 80x87 FPU includes several additional instructions
which control the FPU, synchronize operations, and let you test or set various status
bits. These instructions include <code>finit/fninit, fdisi/fndisi, feni/fneni, fldcw,
fstcw/fnstcw, fclex/fnclex, fsave/fnsave, frstor, frstpm, fstsw/fnstsw, fstenv/fnstenv,
fldenv, fincstp, fdecstp, fwait, fnop,</code> and <code>ffree</code>. The <code>fdisi/fndisi,
feni/fneni, </code>and <code>frstpm</code> are active only on FPUs earlier than the 80387,
so we will not consider them here.</font></p>

<p><font face="Arial" size="2">Many of these instructions have two forms. The first form
is Fxxxx and the second form is FNxxxx. The version without the &quot;N&quot; emits an <code>fwait</code>
instruction prior to opcode (which is standard for most coprocessor instructions). The
version with the &quot;N&quot; does not emit the <code>fwait</code> opcode (&quot;N&quot;
stands for no wait). </font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-82"></a>14.4.10.1 The FINIT and
FNINIT Instructions</font></strong></p>

<p><font face="Arial" size="2">The <code>finit</code> instruction intializes the FPU for
proper operation. Your applications should execute this instruction before executing any
other FPU instructions. This instruction initializes the control register to 37Fh (see
&quot;The FPU Control Register&quot;), the status register to zero (see &quot;The FPU
Status Register&quot;) and the tag word to 0FFFFh. The other registers are unaffected. </font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-84"></a>14.4.10.2 The FWAIT
Instruction</font></strong></p>

<p><font face="Arial" size="2">The <code>fwait</code> instruction pauses the system until
any currently executing FPU instruction completes. This is required because the FPU on the
80486sx and earlier CPU/FPU combinations can execute instructions in parallel with the
CPU. Therefore, any FPU instruction which reads or writes memory could suffer from a data
hazard if the main CPU accesses that same memory location before the FPU reads or writes
that location. The <code>fwait</code> instruction lets you synchronize the operation of
the FPU by waiting until the completion of the current FPU instruction. This resolves the
data hazard by, effectively, inserting an explict &quot;stall&quot; into the execution
stream.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-86"></a>14.4.10.3 The FLDCW and
FSTCW Instructions</font></strong></p>

<p><font face="Arial" size="2">The <code>fldcw</code> and <code>fstcw</code> instructions
require a single 16 bit memory operand:</font></p>

<pre><font face="Courier New" size="2">                fldcw   mem_16
                fstcw   mem_16</font></pre>

<p><font face="Arial" size="2">These two instructions load the control register (see
&quot;The FPU Control Register&quot;) from a memory location (<code>fldcw</code>) or store
the control word to a 16 bit memory location (<code>fstcw</code>). </font></p>

<p><font face="Arial" size="2">When using the <code>fldcw</code> instruction to turn on
one of the exceptions, if the corresponding exception flag is set when you enable that
exception, the FPU will generate an immediate interrupt before the CPU executes the next
instruction. Therefore, you should use the fclex instruction to clear any pending
interrupts before changing the FPU exception enable bits.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-93"></a>14.4.10.4 The FCLEX and
FNCLEX Instructions</font></strong></p>

<p><font face="Arial" size="2">The <code>fclex</code> and <code>fnclex</code> instructions
clear all exception bits the stack fault bit, and the busy flag in the FPU status register
(see &quot;The FPU Status Register&quot;).</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-95"></a>14.4.10.5 The FLDENV,
FSTENV, and FNSTENV Instructions</font></strong></p>

<pre><font face="Courier New" size="2">                fstenv  mem_14b
                fnstenv mem_14b
                fldenv  mem_14b</font></pre>

<p><font face="Arial" size="2">The <code>fstenv/fnstenv</code> instructions store a
14-byte FPU environment record to the memory operand specified. When operating in real
mode (the only mode this text considers), the environment record takes the form:</font></p>

<p align="center"><img SRC="images/ch14a11.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH14/ch14a11.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="304" HEIGHT="136"> </p>

<p><font face="Arial" size="2">You must execute the <code>fstenv</code> and <code>fnstenv</code>
instructions with the CPU interrupts disabled. Furthermore, you should always ensure that
the FPU is not busy before executing this instruction. This is easily accomplished by
using the following code:</font></p>

<pre><font face="Courier New" size="2">                pushf           ;Preserve I flag.
                cli             ;Disable interrupts.
                fstenv  mem_14b ;Implicit wait for not busy.
                fwait           ;Wait for operation to finish.
                popf            ;Restore I flag.</font></pre>

<p><font face="Arial" size="2">The <code>fldenv</code> instruction loads the FPU
environment from the specified memory operand. Note that this instruction lets you load
the the status word. There is no explicit instruction like <code>fldcw</code> to
accomplish this.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-111"></a>14.4.10.6 The FSAVE,
FNSAVE, and FRSTOR Instructions</font></strong></p>

<pre><font face="Courier New" size="2">                fsave   mem_94b
                fnsave  mem_94b
                frstor  mem_94b</font></pre>

<p><font face="Arial" size="2">These instructions save and restore the state of the FPU.
This includes saving all the internal control, status, and data registers. The destination
location for <code>fsave/fnsave</code> (source location for <code>frstor</code>) must be
94 bytes long. The first 14 bytes correspond to the environment record the <code>fldenv</code>
and <code>fstenv</code> instructions use; the remaining 80 bytes hold the data from the
FPU register stack written out as <code>st(0)</code> through <code>st(7)</code>. <code>Frstor</code>
reloads the environment record and floating point registers from the specified memory
operand.</font></p>

<p><font face="Arial" size="2">The <code>fsave/fnsave</code> and <code>frstor</code>
instructions are mainly intended for task switching. You can also use <code>fsave/fnsave</code>
and <code>frstor</code> as a &quot;push all&quot; and &quot;pop all&quot; sequence to
preserve the state of the FPU.</font></p>

<p><font face="Arial" size="2">Like the <code>fstenv</code> and <code>fldenv</code>
instructions, interrupts should be disabled while saving or restoring the FPU state.
Otherwise another interrupt service routine could manipulate the FPU registers and
invalidate the operation of the <code>fsave/fnsave</code> or <code>frestore</code>
operation. The following code properly protects the environment data while saving and
restore the FPU status:</font></p>

<pre><font face="Courier New" size="2">; Preserve the FPU state, assume di points at the environment
; record in memory.

                pushf
                cli
                fsave   [si]
                fwait
                popf
                 .
                 .
                 .
                pushf
                cli
                frstor  [si]
                fwait
                popf</font></pre>

<pre><strong><font face="Arial" size="3">14.4.10.7 The FSTSW and FNSTSW Instructions</font></strong></pre>

<pre><font face="Courier New" size="2">                fstsw   ax
                fnstsw  ax
                fstsw   mem_16
                fnstsw  mem_16</font></pre>

<p><font face="Arial" size="2">These instructions store the FPU status register (see
&quot;The FPU Status Register&quot;) into a 16 bit memory location or the <code>ax</code>
register. These instructions are unusual in the sense that they can copy an FPU value into
one of the 80x86 general purpose registers. Of course, the whole purpose behind allowing
the transfer of the status register into ax is to allow the CPU to easily test the
condition code register with the sahf instruction.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-142"></a>14.4.10.8 The FINCSTP
and FDECSTP Instructions</font></strong></p>

<p><font face="Arial" size="2">The <code>fincstp</code> and <code>fdecstp</code>
instructions do not take any operands. They simply increment and decrement the stack
pointer bits (mod 8) in the FPU status register. These two instructions clear the C1 flag,
but do not otherwise affect the condition code bits in the FPU status register.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-144"></a>14.4.10.9 The FNOP
Instruction</font></strong></p>

<p><font face="Arial" size="2">The <code>fnop </code>instruction is simply an alias for <code>fst
st, st(0)</code>. It performs no other operation on the FPU.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-146"></a>14.4.10.10 The FFREE
Instruction</font></strong></p>

<pre><font face="Courier New" size="2">                ffree   st(i)</font></pre>

<p><font face="Arial" size="2">This instruction modifies the tag bits for register i in
the tags register to mark the specified register as emtpy. The value is unaffected by this
instruction, but the FPU will no longer be able to access that data (without resetting the
appropriate tag bits).</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-150"></a>14.4.11 Integer
Operations</font></strong></p>

<p><font face="Arial" size="2">The 80x87 FPUs provide special instructions that combine
integer to extended precision conversion along with various arithmetic and comparison
operations. These instructions are the following:</font></p>

<pre><font face="Courier New" size="2">                fiadd   int
                fisub   int
                fisubr  int
                fimul   int
                fidiv   int
                fidivr  int

                ficom   int
                ficomp  int</font></pre>

<p><font face="Arial" size="2">These instructions convert their 16 or 32 bit integer
operands to an 80 bit extended precision floating point value and then use this value as
the source operand for the specified operation. These instructions use st(0) as the
destination operand.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH14-4.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH14-4.html">Chapter Fourteen</a> (Part 4)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH14-6.html">Chapter Fourteen</a> (Part 6)&nbsp; </strong></font><a href="CH14-6.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Fourteen: Floating Point
Arithmetics (Part 5)<br>
28 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_14/CH14-5.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:27:56 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
