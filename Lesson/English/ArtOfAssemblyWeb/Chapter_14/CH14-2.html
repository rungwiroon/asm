<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_14/CH14-2.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:27:44 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER FOURTEEN: FLOATING POINT ARITHMETIC (Part 2)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING2"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH14-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH14-1.html">Chapter Fourteen</a> (Part 1)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH14-3.html">Chapter Fourteen</a> (Part 3)&nbsp; </strong></font><a href="CH14-3.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10" colspan="2"><a NAME="HEADING2-1"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0" colspan="2"><font face="Arial" size="4"><strong>CHAPTER
    FOURTEEN:<br>
    FLOATING POINT ARITHMETIC (Part 2)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10" colspan="2"></td>
  </tr>
  <tr>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING2-1"><b>14.3 </b>-
    The UCR Standard Library Floating Point Routines</a> <br>
    <a HREF="#HEADING2-5"><b>14.3.1 </b>- Load and Store Routines</a> <br>
    <a HREF="#HEADING2-55"><b>14.3.2 </b>- Integer/Floating Point Conversion</a> </font></td>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING2-60"><b>14.3.3 </b>-
    Floating Point Arithmetic</a> <br>
    <a HREF="#HEADING2-64"><b>14.3.4 </b>- Float/Text Conversion and Printff</a> </font></td>
  </tr>
  <tr>
    <td width="100%" valign="top" colspan="2" nowrap height="20"><font face="Arial" size="2"></font></td>
  </tr>
  <tr>
    <td width="100%" valign="top" colspan="2"><h2><strong><font face="Arial" size="3">14.3 The
    UCR Standard Library Floating Point Routines</font></strong></h2>
    </td>
  </tr>
  <tr>
    <td width="100%" valign="top" colspan="2" nowrap bgcolor="#000000" height="1"><font face="Arial" size="2"></font></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">In most assembly language texts, which bother to cover
floating point arithmetic, this section would normally describe how to design your own
floating point routines for addition, subtraction, multiplication, and division. This text
will not do that for several reasons. First, to design a good floating point library
requires a solid background in numerical analysis; a prerequisite this text does not
assume of its readers. Second, the UCR Standard Library already provides a reasonable set
of floating point routines in source code form; why waste space in this text when the
sources are readily available elsewhere? Third, floating point units are quickly becoming
standard equipment on all modern CPUs or motherboards; it makes no more sense to describe
how to manually perform a floating point computation than it does to describe how to
manually perform an integer computation. Therefore, this section will describe how to use
the UCR Standard Library routines if you do not have an FPU available; a later section
will describe the use of the floating point unit.</font></p>

<p><font face="Arial" size="2">The UCR Standard Library provides a large number of
routines to support floating point computation and I/O. This library uses the same memory
format for 32, 64, and 80 bit floating point numbers as the 80x87 FPUs. The UCR Standard
Library's floating point routines do not exactly follow the IEEE requirements with respect
to error conditions and other degenerate cases, and it may produce slightly different
results than an 80x87 FPU, but the results will be very close<a HREF="#FOOTNOTE-5">[5]</a>.
Since the UCR Standard Library uses the same memory format for 32, 64, and 80 bit numbers
as the 80x87 FPUs, you can freely mix computations involving floating point between the
FPU and the Standard Library routines.</font></p>

<p><font face="Arial" size="2">The UCR Standard Library provides numerous routines to
manipulate floating point numbes. The following sections describe each of these routines,
by category.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-5"></a>14.3.1 Load and Store
Routines</font></strong></p>

<p><font face="Arial" size="2">Since 80x86 CPUs without an FPU do not provide any 80-bit
registers, the UCR Standard Library must use memory-based variables to hold floating point
values during computation. The UCR Standard Library routines use two pseudo registers, an
accumlator register and an operand register, when performing floating point operations.
For example, the floating point addition routine adds the value in the floating point
operand register to the floating point accumulator register, leaving the result in the
accumulator. The load and store routines allow you to load floating point values into the
floating point accumulator and operand registers as well as store the value of the
floating point accumulator back to memory. The routines in this category include <code>accop,
xaccop, lsfpa, ssfpa, ldfpa, sdfpa, lefpa, sefpa, lefpal, lsfpo, ldfpo, lefpo,</code> and
lefpol.</font></p>

<p><font face="Arial" size="2">The <code>accop</code> routine copies the value in the
floating point accumulator to the floating point operand register. This routine is useful
when you want to use the result of one computation as the second operand of a second
computation.</font></p>

<p><font face="Arial" size="2">The <code>xaccop </code>routine exchanges the values in the
floating point accumuator and operand registers. Note that many floating point
computations destory the value in the floating point operand register, so you cannot
blindly assume that the routines preserve the operand register. Therefore, calling this
routine only makes sense after performing some computation which you know does not affect
the floating point operand register.</font></p>

<p><font face="Arial" size="2"><code>Lsfpa, ldfpa, and lefpa</code> load the floating
point accumulator with a single, double, or extended precision floating point value,
respectively. The UCR Standard Library uses its own internal format for computations.
These routines convert the specified values to the internal format during the load. On
entry to each of these routines, <code>es:di</code> must contain the address of the
variable you want to load into the floating point accumulator. The following code
demonstrates how to call these routines:</font></p>

<pre><font face="Courier New" size="2">rVar            real4   1.0
drVar           real8   2.0
xrVar           real10  3.0
                 .
                 .
                 .
                lesi    rVar
                lsfpa
                 .
                 .
                 .
                lesi    drVar
                ldfpa
                 .
                 .
                 .
                lesi    xrVar
                lefpa</font></pre>

<p><font face="Arial" size="2">The <code>lsfpo, ldfpo,</code> and <code>lefpo</code>
routines are similar to the <code>lsfpa</code>, <code>ldfpa</code>, and <code>lefpa</code>
routines except, of course, they load the floating point operand register rather than the
floating point accumulator with the value at address <code>es:di</code>.</font></p>

<p><font face="Arial" size="2"><code>Lefpal</code> and <code>lefpol</code> load the
floating point accumulator or operand register with a literal 80 bit floating point
constant appearing in the code stream. To use these two routines, simply follow the call
with a <code>real10</code> directive and the appropriate constant, e.g., </font></p>

<pre><font face="Courier New" size="2">                lefpal
                real10  1.0
                lefpol
                real10  2.0e5</font></pre>

<p><font face="Arial" size="2">The <code>ssfpa</code>, <code>sdfpa</code>, and <code>sefpa</code>
routines store the value in the floating point accumulator into the memory based floating
point variable whose address appears in <code>es:di</code>. There are no corresponding
ssfpo, sdfpo, or sefpo routines because a result you would want to store should never
appear in the floating point operand register. If you happen to get a value in the
floating point operand that you want to store into memory, simply use the xaccop routine
to swap the accumulator and operand registers, then use the store accumulator routines to
save the result. The following code demonstrates the use of these routines:</font></p>

<pre><font face="Courier New" size="2">rVar            real4   1.0
drVar           real8   2.0
xrVar           real10  3.0
                 .
                 .
                 .
                lesi    rVar
                ssfpa
                 .
                 .
                 .
                lesi    drVar
                sdfpa
                 .
                 .
                 .
                lesi    xrVar
                sefpa</font></pre>

<pre><strong><font face="Arial" size="3">14.3.2 Integer/Floating Point Conversion</font></strong></pre>

<p><font face="Arial" size="2">The UCR Standard Library includes several routines to
convert between binary integers and floating point values. These routines are <code>itof,
utof, ltof, ultof, ftoi, ftou, ftol, </code>and <code>ftoul.</code> The first four
routines convert signed and unsigned integers to floating point format, the last four
routines truncate floating point values and convert them to an integer value.</font></p>

<p><font face="Arial" size="2"><code>Itof</code> converts the signed 16-bit value in <code>ax</code>
to a floating point value and leaves the result in the floating point accumulator. This
routine does not affect the floating point operand register. <code>Utof</code> converts
the unsigned integer in <code>ax</code> in a similar fashion. <code>Ltof</code> and <code>ultof</code>
convert the 32 bit signed (<code>ltof</code>) or unsigned (<code>ultof</code>) integer in <code>dx:ax</code>
to a floating point value, leaving the value in the floating point accumulator. These
routines always succeed.</font></p>

<p><font face="Arial" size="2"><code>Ftoi</code> converts the value in the floating point
accumulator to a signed integer value, leaving the result in <code>ax</code>. Conversion
is by truncation; this routine keeps the integer portion and throws away the fractional
part. If an overflow occurs because the resulting integer portion does not fit into 16
bits, <code>ftoi</code> returns the carry flag set. If the conversion occurs without
error, <code>ftoi</code> return the carry flag clear. <code>Ftou</code> works in a similar
fashion, except it converts the floating point value to an unsigned integer in <code>ax</code>;
it returns the carry set if the floating point value was negative.</font></p>

<p><font face="Arial" size="2"><code>Ftol</code> and <code>ftoul</code> converts the value
in the floating point accumulator to a 32 bit integer leaving the result in <code>dx:ax</code>.
<code>Ftol</code> works on signed values, <code>ftoul</code> works with unsigned values.
As with <code>ftoi</code> and <code>ftou</code>, these routines return the carry flag set
if a conversion error occurs.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-60"></a>14.3.3 Floating Point
Arithmetic</font></strong></p>

<p><font face="Arial" size="2">Floating point arithmetic is handled by the <code>fpadd</code>,
<code>fp sub</code>, <code>fpcmp</code>, <code>fpmul</code>, and <code>fpdiv</code>
routines. <code>Fpadd</code> adds the value in the floating point accumulator to the
floating point accumulator. <code>Fpsub</code> subtracts the value in the floating point
operand from the floating point accumulator. <code>Fpmul</code> multiplies the value in
the floating accumulator by the floating point operand. <code>Fpdiv</code> divides the
value in the floating point accumulator by the value in the floating point operand
register. <code>Fpcmp</code> compares the value in the floating point accumulator against
the floating point operand.</font></p>

<p><font face="Arial" size="2">The UCR Standard Library arithmetic routines do very little
error checking. For example, if arithmetic overflow occurs during addition, subtraction,
multiplication, or division, the Standard Library simply sets the result to the largest
legal value and returns. This is one of the major deviations from the IEEE floating point
standard. Likewise, when underflow occurs the routines simply set the result to zero and
return. If you divide any value by zero, the Standard Library routines simply set the
result to the largest possible value and return. You may need to modify the standard
library routines if you need to check for overflow, underflow, or division by zero in your
programs.</font></p>

<p><font face="Arial" size="2">The floating point comparison routine (<code>fpcmp</code>)
compares the floating point accumulator against the floating point operand and returns -1,
0, or 1 in the <code>ax</code> register if the accumulator is less than, equal, or greater
than the floating point operand. It also compares ax with zero immediately before
returning so it sets the flags so you can use the <code>jg, jge, jl, jle, je,</code> and <code>jne</code>
instructions immediately after calling <code>fpcmp</code>. Unlike <code>fpadd</code>, <code>fpsub</code>,
<code>fpmul</code>, and <code>fpdiv</code>, <code>fpcmp</code> does not destroy the value
in the floating point accumulator or the floating point operand register. Keep in mind the
problems associated with comparing floating point numbers!</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-64"></a>14.3.4 Float/Text
Conversion and Printff</font></strong></p>

<p><font face="Arial" size="2">The UCR Standard Library provides three routines, <code>ftoa</code>,
<code>etoa</code>, and <code>atof</code>, that let you convert floating point numbers to
ASCII strings and vice versa; it also provides a special version of <code>printf</code>, <code>printff</code>,
that includes the ability to print floating point values as well as other data types.</font></p>

<p><font face="Arial" size="2"><code>Ftoa</code> converts a floating point number to an
ASCII string which is a decimal representation of that floating point number. On entry,
the floating point accumulator contains the number you want to convert to a string. The <code>es:di</code>
register pair points at a buffer in memory where <code>ftoa</code> will store the string.
The <code>al</code> register contains the field width (number of print positions). The <code>ah</code>
register contains the number of positions to display to the right of the decimal point. If
<code>ftoa</code> cannot display the number using the print format specified by <code>al</code>
and <code>ah</code>, it will create a string of &quot;#&quot; characters, ah characters
long. <code>Es:di</code> must point at a byte array containing at least <code>al+1</code>
characters and al should contain at least five. The field width and decimal length values
in the al and ah registers are similar to the values appearing after floating point
numbers in the Pascal write statement, e.g.,</font></p>

<pre><font face="Courier New" size="2">		write(floatVal:al:ah);</font></pre>
<code>

<p><font face="Arial" size="2">Etoa</code> outputs the floating point number in
exponential form. As with <code>ftoa</code>, <code>es:di</code> points at the buffer where
<code>etoa</code> will store the result. The <code>al</code> register must contain at
least eight and is the field width for the number. If <code>al</code> contains less than
eight, <code>etoa</code> will output a string of &quot;#&quot; characters. The string that
<code>es:di </code>points at must contain at least <code>al+1</code> characters. This
conversion routine is similar to Pascal's write procedure when writing real values with a
single field width specification:</font></p>

<p><font face="Courier New" size="2"> write(realvar:al);</font></p>

<p><font face="Arial" size="2">The Standard Library <code>printff</code> routine provides
all the facilities of the standard printf routine plus the ability to handle floating
point output. The printff routine includes several new format specifications to print
floating point numbers in decimal form or using scientific notation. The specifications
are</font>

<ul>
  <li><font face="Arial" size="2">%x.yF Prints a 32 bit floating point number in decimal form.
    </font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">%x.yGF Prints a 64 bit floating point number in decimal
    form. </font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">%x.yLF Prints an 80 bit floating point number in decimal
    form. </font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">%zE Prints a 32 bit floating point number using scientific
    notation. </font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">%zGE Prints a 64 bit floating point number using scientific
    notation. </font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">%zLE Prints an 80 bit floating point value using scientific
    notation. </font></li>
</ul>

<p><font face="Arial" size="2">In the format strings above, x and z are integer constants
that denote the field width of the number to print. The y item is also an integer constant
that specifies the number of positions to print after the decimal point. The x.y values
are comparable to the values passed to <code>ftoa</code> in <code>al</code> and <code>ah</code>.
The z value is comparable to the value <code>etoa</code> expects in the <code>al</code>
register.</font></p>

<p><font face="Arial" size="2">Other than the addition of these six new formats, the <code>printff</code>
routine is identical to the <code>printf</code> routine. If you use the <code>printff</code>
routine in your assembly language programs, you should not use the <code>printf</code>
routine as well. <code>Printff</code> duplicates all the facilities of <code>printf</code>
and using both would only waste memory.</font></p>

<hr noshade size="1" color="#000000">

<p><font face="Arial" size="2"><strong><a NAME="FOOTNOTE-5"></a>[5]</strong> Note, by the
way, that different floating point chips, especially across different CPU lines, but even
within the Intel family, produce slightly different results. So the fact that the UCR
Standard Library does not produce the exact same results as a particular FPU is not that
important.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH14-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH14-1.html">Chapter Fourteen</a> (Part 1)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH14-3.html">Chapter Fourteen</a> (Part 3)&nbsp; </strong></font><a href="CH14-3.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Fourteen: Floating Point
Arithmetics (Part 2)<br>
28 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_14/CH14-2.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:27:44 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
