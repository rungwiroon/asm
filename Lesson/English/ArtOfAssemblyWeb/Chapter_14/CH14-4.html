<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_14/CH14-4.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:27:53 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER FOURTEEN: FLOATING POINT ARITHMETIC (Part 4)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING4"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH14-3.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH14-3.html">Chapter Fourteen</a> (Part 3)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH14-5.html">Chapter Fourteen</a> (Part 5)&nbsp; </strong></font><a href="CH14-5.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10" colspan="2"><a NAME="HEADING4-1"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0" colspan="2"><font face="Arial" size="4"><strong>CHAPTER
    FOURTEEN:<br>
    FLOATING POINT ARITHMETIC (Part 4)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10" colspan="2"></td>
  </tr>
  <tr>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING4-1"><b>14.4.3 </b>-
    The FPU Instruction Set</a> <br>
    <a HREF="#HEADING4-3"><b>14.4.4 </b>- FPU Data Movement Instructions</a> <br>
    <a HREF="#HEADING4-5"><b>14.4.4.1 </b>- The FLD Instruction</a> <br>
    <a HREF="#HEADING4-14"><b>14.4.4.2 </b>- The FST and FSTP Instructions</a> <br>
    <a HREF="#HEADING4-27"><b>14.4.4.3 </b>- The FXCH Instruction</a> <br>
    <a HREF="#HEADING4-35"><b>14.4.5 </b>- Conversions</a> <br>
    <a HREF="#HEADING4-37"><b>14.4.5.1 </b>- The FILD Instruction</a> <br>
    <a HREF="#HEADING4-43"><b>14.4.5.2 </b>- The FIST and FISTP Instructions</a> <br>
    <a HREF="#HEADING4-52"><b>14.4.5.3 </b>- The FBLD and FBSTP Instructions</a> <br>
    <a HREF="#HEADING4-66"><b>14.4.6 </b>- Arithmetic Instructions</a> <br>
    <a HREF="#HEADING4-68"><b>14.4.6.1 </b>- The FADD and FADDP Instructions</a> </font></td>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING4-82"><b>14.4.6.2
    </b>- The FSUB, FSUBP, FSUBR, and FSUBRP Instructions</a> <br>
    <a HREF="#HEADING4-104"><b>14.4.6.3 </b>- The FMUL and FMULP Instructions</a> <br>
    <a HREF="#HEADING4-118"><b>14.4.6.4 </b>- The FDIV, FDIVP, FDIVR, and FDIVRP Instructions</a>
    <br>
    <a HREF="#HEADING4-146"><b>14.4.6.5 </b>- The FSQRT Instruction</a> <br>
    <a HREF="#HEADING4-163"><b>14.4.6.6 </b>- The FSCALE Instruction</a> <br>
    <a HREF="#HEADING4-173"><b>14.4.6.7 </b>- The FPREM and FPREM1 Instructions</a> <br>
    <a HREF="#HEADING4-188"><b>14.4.6.8 </b>- The FRNDINT Instruction</a> <br>
    <a HREF="#HEADING4-191"><b>14.4.6.9 </b>- The FXTRACT Instruction</a> <br>
    <a HREF="#HEADING4-202"><b>14.4.6.10 </b>- The FABS Instruction</a> <br>
    <a HREF="#HEADING4-211"><b>14.4.6.11 </b>- The FCHS Instruction</a></font> </td>
  </tr>
</table>
</center></div>

<h3><strong><font face="Arial" size="3">14.4.3 The FPU Instruction Set</font></strong></h3>

<p><font face="Arial" size="2">The 80387 (and later) FPU adds over 80 new instructions to
the 80x86 instruction set. We can classify these instructions as data movement
instructions, conversions, arithmetic instructions, comparisons, constant instructions,
transcendental instructions, and miscellaneous instructions. The following sections
describe each of the instructions in these categories.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING4-3"></a>14.4.4 FPU Data Movement
Instructions</font></strong></p>

<p><font face="Arial" size="2">The data movement instructions transfer data between the
internal FPU registers and memory. The instructions in this category are <code>fld, fst,
fstp, and fxch</code>. The <code>fld</code> instructions always pushes its operand onto
the floating point stack. The <code>fstp</code> instruction always pops the top of stack
after storing the top of stack (tos) into its operation. The remaining instructions do not
affect the number of items on the stack.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING4-5"></a>14.4.4.1 The FLD
Instruction</font></strong></p>

<p><font face="Arial" size="2">The <code>fld</code> instruction loads a 32 bit, 64 bit, or
80 bit floating point value onto the stack. This instruction converts 32 and 64 bit
operand to an 80 bit extended precision value before pushing the value onto the floating
point stack.</font></p>

<p><font face="Arial" size="2">The <code>fld</code> instruction first decrements the tos
pointer (bits 11-13 of the status register) and then stores the 80 bit value in the
physical register specified by the new tos pointer. If the source operand of the <code>fld</code>
instruction is a floating point data register, <code>ST</code>(i), then the actual
register the 80x87 uses for the load operation is the register number before decrementing
the tos pointer. Therefore, <code>fld st</code> or <code>fld st(0)</code> duplicates the
value on the top of the stack.</font></p>

<p><font face="Arial" size="2">The <code>fld</code> instruction sets the stack fault bit
if stack overflow occurs. It sets the the denormalized exception bit if you load an 80 bit
denormalized value. It sets the invalid operation bit if you attempt to load an empty
floating point register onto the stop of stack (or perform some other invalid operation).</font></p>

<p><font face="Arial" size="2">Examples:</font></p>

<pre><font face="Courier New" size="2">                fld     st(1)
                fld     mem_32
                fld     MyRealVar
                fld     mem_64[bx]</font></pre>

<pre><strong><font face="Arial" size="3">14.4.4.2 The FST and FSTP Instructions</font></strong></pre>

<p><font face="Arial" size="2">The <code>fst</code> and <code>fstp</code> instructions
copy the value on the top of the floating point register stack to another floating point
register or to a 32, 64, or 80 bit memory variable. When copying data to a 32 or 64 bit
memory variable, the 80 bit extended precision value on the top of stack is rounded to the
smaller format as specified by the rounding control bits in the FPU control register.</font></p>

<p><font face="Arial" size="2">The <code>fstp</code> instruction pops the value off the
top of stack when moving it to the destination location. It does this by incrementing the
top of stack pointer in the status register after accessing the data in <code>st(0)</code>.
If the destination operand is a floating point register, the FPU stores the value at the
specified register number before popping the data off the top of the stack.</font></p>

<p><font face="Arial" size="2">Executing an <code>fstp st(0)</code> instruction
effectively pops the data off the top of stack with no data transfer. Examples:</font></p>

<pre><font face="Courier New" size="2">                fst     mem_32
                fstp    mem_64
                fstp    mem_64[ebx*8]
                fst     mem_80
                fst     st(2)
                fstp    st(1)</font></pre>

<p><font face="Arial" size="2">The last example above effectively pops <code>st(1)</code>
while leaving <code>st(0)</code> on the top of the stack.</font></p>

<p><font face="Arial" size="2">The <code>fst</code> and <code>fstp</code> instructions
will set the stack exception bit if a stack underflow occurs (attempting to store a value
from an empty register stack). They will set the precision bit if there is a loss of
precision during the store operation (this will occur, for example, when storing an 80 bit
extended precision value into a 32 or 64 bit memory variable and there are some bits lost
during conversion). They will set the underflow exception bit when storing an 80 bit value
value into a 32 or 64 bit memory variable, but the value is too small to fit into the
destination operand. Likewise, these instructions will set the overflow exception bit if
the value on the top of stack is too big to fit into a 32 or 64 bit memory variable. The <code>fst</code>
and <code>fstp</code> instructions set the denormalized flag when you try to store a
denormalized value into an 80 bit register or variable<a HREF="#FOOTNOTE-7">[7]</a>. They
set the invalid operation flag if an invalid operation (such as storing into an empty
register) occurs. Finally, these instructions set the <code>C1</code> condition bit if
rounding occurs during the store operation (this only occurs when storing into a 32 or 64
bit memory variable and you have to round the mantissa to fit into the destination).</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING4-27"></a>14.4.4.3 The FXCH
Instruction</font></strong></p>

<p><font face="Arial" size="2">The <code>fxch</code> instruction exchanges the value on
the top of stack with one of the other FPU registers. This instruction takes two forms:
one with a single FPU register as an operand, the second without any operands. The first
form exchanges the top of stack with the specified register. The second form of <code>fxch</code>
swaps the top of stack with <code>st(1)</code>.</font></p>

<p><font face="Arial" size="2">Many FPU instructions, e.g., <code>fsqrt</code>, operate
only on the top of the register stack. If you want to perform such an operation on a value
that is not on the top of stack, you can use the <code>fxch</code> instruction to swap
that register with tos, perform the desired operation, and then use the <code>fxch</code>
to swap the tos with the original register. The following example takes the square root of
<code>st(2)</code>:</font></p>

<pre><font face="Courier New" size="2">                fxch    st(2)
                fsqrt
                fxch    st(2)</font></pre>

<p><font face="Arial" size="2">The <code>fxch</code> instruction sets the stack exception
bit if the stack is empty. It sets the invalid operation bit if you specify an empty
register as the operand. This instruction always clears the <code>C1</code> condition code
bit.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING4-35"></a>14.4.5 Conversions</font></strong></p>

<p><font face="Arial" size="2">The 80x87 chip performs all arithmetic operations on 80 bit
real quantities. In a sense, the <code>fld</code> and <code>fst/fstp</code> instructions
are conversion instructions as well as data movement instructions because they
automatically convert between the internal 80 bit real format and the 32 and 64 bit memory
formats. Nonetheless, we'll simply classify them as data movement operations, rather than
conversions, because they are moving real values to and from memory. The 80x87 FPU
provides five routines which convert to or from integer or binary coded decimal (BCD)
format when moving data. These instructions are <code>fild</code>, <code>fist</code>, <code>fistp</code>,
<code>fbld</code>, and <code>fbstp</code>.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING4-37"></a>14.4.5.1 The FILD
Instruction</font></strong></p>

<p><font face="Arial" size="2">The <code>fild</code> (integer load) instruction converts a
16, 32, or 64 bit two's complement integer to the 80 bit extended precision format and
pushes the result onto the stack. This instruction always expects a single operand. This
operand must be the address of a word, double word, or quad word integer variable.
Although the instruction format for <code>fild</code> uses the familiar mod/rm fields, the
operand must be a memory variable, even for 16 and 32 bit integers. You cannot specify one
of the 80386's 16 or 32 bit general purpose registers. If you want to push an 80x86
general purpose register onto the FPU stack, you must first store it into a memory
variable and then use <code>fild</code> to push that value of that memory variable.</font></p>

<p><font face="Arial" size="2">The <code>fild</code> instruction sets the stack exception
bit and <code>C1</code> (accordingly) if stack overflow occurs while pushing the converted
value. Examples:</font></p>

<pre><font face="Courier New" size="2">                fild    mem_16
                fild    mem_32[ecx*4]
                fild    mem_64[ebx+ecx*8]</font></pre>

<pre><strong><font face="Arial" size="3">14.4.5.2 The FIST and FISTP Instructions</font></strong></pre>

<p><font face="Arial" size="2">The <code>fist</code> and <code>fistp</code> instructions
convert the 80 bit extended precision variable on the top of stack to a 16, 32, or 64 bit
integer and store the result away into the memory variable specified by the single
operand. These instructions convert the value on tos to an integer according to the
rounding setting in the FPU control register (bits 10 and 11). As for the <code>fild</code>
instruction, the <code>fist</code> and <code>fistp</code> instructions will not let you
specify one of the 80x86's general purpose 16 or 32 bit registers as the destination
operand.</font></p>

<p><font face="Arial" size="2">The <code>fist</code> instruction converts the value on the
top of stack to an integer and then stores the result; it does not otherwise affect the
floating point register stack. The <code>fistp</code> instruction pops the value off the
floating point register stack after storing the converted value.</font></p>

<p><font face="Arial" size="2">These instructions set the stack exception bit if the
floating point register stack is empty (this will also clear C1). They set the precision
(imprecise operation) and <code>C1</code> bits if rounding occurs (that is, if there is
any fractional component to the value in <code>st(0)</code>). These instructions set the
underflow exception bit if the result is too small (i.e., less than one but greater than
zero or less than zero but greater than -1). Examples:</font></p>

<pre><font face="Courier New" size="2">                fist    mem_16[bx]
                fist    mem_64
                fistp   mem_32</font></pre>

<p><font face="Arial" size="2">Don't forget that these instructions use the rounding
control settings to determine how they will convert the floating point data to an integer
during the store operation. Be default, the rouding control is usually set to
&quot;round&quot; mode; yet most programmers expect <code>fist/fistp</code> to truncate
the decimal portion during conversion. If you want<code> fist/fistp</code> to truncate
floating point values when converting them to an integer, you will need to set the
rounding control bits appropriately in the floating point control register.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING4-52"></a>14.4.5.3 The FBLD and
FBSTP Instructions</font></strong></p>

<p><font face="Arial" size="2">The <code>fbld</code> and <code>fbstp</code> instructions
load and store 80 bit BCD values. The <code>fbld</code> instruction converts a BCD value
to its 80 bit extended precision equivalent and pushes the result onto the stack. The <code>fbstp</code>
instruction pops the extended precision real value on tos, converts it to an 80 bit BCD
value (rounding according to the bits in the floating point control register), and stores
the converted result at the address specified by the destination memory operand. Note that
there is no <code>fbst</code> instruction which stores the value on tos without popping
it.</font></p>

<p><font face="Arial" size="2">The <code>fbld</code> instruction sets the stack exception
bit and <code>C1</code> if stack overflow occurs. It sets the invalid operation bit if you
attempt to load an invalid BCD value. The <code>fbstp</code> instruction sets the stack
exception bit and clears <code>C1</code> if stack underflow occurs (the stack is empty).
It sets the underflow flag under the same conditions as <code>fist</code> and <code>fistp</code>.
Examples:</font></p>

<pre><font face="Courier New" size="2">; Assuming fewer than eight items on the stack, the following
; code sequence is equivalent to an fbst instruction:

                fld     st(0)   ;Duplicate value on TOS.
                fbstp   mem_80

; The following example easily converts an 80 bit BCD value to
; a 64 bit integer:

                fbld    bcd_80  ;Get BCD value to convert.
                fist    mem_64  ;Store as an integer.</font></pre>

<pre><strong><font face="Arial" size="3">14.4.6 Arithmetic Instructions</font></strong></pre>

<p><font face="Arial" size="2">The arithmetic instructions make up a small, but important,
subset of the 80x87's instruction set. These instructions fall into two general categories
- those which operate on real values and those which operate on a real and an integer
value. </font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING4-68"></a>14.4.6.1 The FADD and
FADDP Instructions</font></strong></p>

<p><font face="Arial" size="2">These two instructions take the following forms:</font></p>

<pre><font face="Courier New" size="2">                fadd
                faddp
                fadd    st(i), st(0)
                fadd    st(0), st(i)
                faddp   st(i), st(0)
                fadd    mem</font></pre>

<p><font face="Arial" size="2">The first two forms are equivalent. They pop the two values
on the top of stack, add them, and push their sum back onto the stack. </font></p>

<p><font face="Arial" size="2">The next two forms of the <code>fadd</code> instruction,
those with two FPU register operands, behave like the 80x86's <code>add</code>
instruction. They add the value in the second register operand to the value in the first
register operand. Note that one of the register operands must be <code>st(0)</code><a HREF="#FOOTNOTE-8">[8]</a>.</font></p>

<p><font face="Arial" size="2">The <code>faddp</code> instruction with two operands adds <code>st(0)</code>
(which must always be the second operand) to the destination (first) operand and then pops
<code>st(0)</code>. The destination operand must be one of the other FPU registers.</font></p>

<p><font face="Arial" size="2">The last form above, <code>fadd</code> with a memory
operand, adds a 32 or 64 bit floating point variable to the value in <code>st(0)</code>.
This instruction will convert the 32 or 64 bit operands to an 80 bit extended precision
value before performing the addition. Note that this instruction does not allow an 80 bit
memory operand.</font></p>

<p><font face="Arial" size="2">These instructions can raise the stack, precision,
underflow, overflow, denormalized, and illegal operation exceptions, as appropriate. If a
stack fault exception occurs, <code>C1</code> denotes stack overflow or underflow.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING4-82"></a>14.4.6.2 The FSUB, FSUBP,
FSUBR, and FSUBRP Instructions</font></strong></p>

<p><font face="Arial" size="2">These four instructions take the following forms:</font></p>

<pre><font face="Courier New" size="2">                fsub
                fsubp
                fsubr
                fsubrp

                fsub    st(i). st(0)
                fsub    st(0), st(i)
                fsubp   st(i), st(0)
                fsub    mem

                fsubr   st(i). st(0)
                fsubr   st(0), st(i)
                fsubrp  st(i), st(0)
                fsubr   mem</font></pre>

<p><font face="Arial" size="2">With no operands, the <code>fsub</code> and <code>fsubp</code>
instructions operate identically. They pop <code>st(0)</code> and <code>st(1) </code>from
the register stack, compute <code>st(0)-st(1)</code>, and the push the difference back
onto the stack. The <code>fsubr</code> and <code>fsubrp</code> instructions (reverse
subtraction) operate in an almost identical fashion except they compute <code>st(1)-st(0)</code>
and push that difference.</font></p>

<p><font face="Arial" size="2">With two register operands (destination, source ) the <code>fsub</code>
instruction computes destination := destination - source. One of the two registers must be
<code>st(0)</code>. With two registers as operands, the <code>fsubp</code> also computes
destination := destination - source and then it pops <code>st(0)</code> off the stack
after computing the difference. For the <code>fsubp</code> instruction, the source operand
must be <code>st(0)</code>.</font></p>

<p><font face="Arial" size="2">With two register operands, the <code>fsubr</code> and <code>fsubrp</code>
instruction work in a similar fashion to <code>fsub</code> and <code>fsubp</code>, except
they compute destination := source - destination. </font></p>

<p><font face="Arial" size="2">The <code>fsub mem</code> and <code>fsubr mem</code>
instructions accept a 32 or 64 bit memory operand. They convert the memory operand to an
80 bit extended precision value and subtract this from <code>st(0)</code> (<code>fsub</code>)
or subtract <code>st(0)</code> from this value (<code>fsubr</code>) and store the result
back into <code>st(0)</code>.</font></p>

<p><font face="Arial" size="2">These instructions can raise the stack, precision,
underflow, overflow, denormalized, and illegal operation exceptions, as appropriate. If a
stack fault exception occurs, <code>C1</code> denotes stack overflow or underflow.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING4-104"></a>14.4.6.3 The FMUL and
FMULP Instructions</font></strong></p>

<p><font face="Arial" size="2">The <code>fmul</code> and <code>fmulp</code> instructions
multiply two floating point values. These instructions allow the following forms:</font></p>

<pre><font face="Courier New" size="2">                fmul
                fmulp

                fmul    st(0), st(i)
                fmul    st(i), st(0)
                fmul    mem

                fmulp   st(i), st(0)</font></pre>

<p><font face="Arial" size="2">With no operands, <code>fmul</code> and <code>fmulp</code>
both do the same thing - they pop <code>st(0)</code> and <code>st(1)</code>, multiply
these values, and push their product back onto the stack. The <code>fmul </code>instructions
with two register operands compute destination := destination * source. One of the
registers (source or destination) must be <code>st(0)</code>. </font></p>

<p><font face="Arial" size="2">The <code>fmulp st(i), st(0)</code> instruction computes <code>st(i)
:= st(i) * st(0)</code> and then pops <code>st(0)</code>. This instruction uses the value
for i before popping <code>st(0)</code>. The <code>fmul mem</code> instruction requires a
32 or 64 bit memory operand. It converts the specified memory variable to an 80 bit
extended precision value and the multiplies <code>st(0)</code> by this value.</font></p>

<p><font face="Arial" size="2">These instructions can raise the stack, precision,
underflow, overflow, denormalized, and illegal operation exceptions, as appropriate. If
rounding occurs during the computation, these instructions set the <code>C1</code>
condition code bit. If a stack fault exception occurs, <code>C1</code> denotes stack
overflow or underflow.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING4-118"></a>14.4.6.4 The FDIV,
FDIVP, FDIVR, and FDIVRP Instructions</font></strong></p>

<p><font face="Arial" size="2">These four instructions allow the following forms:</font></p>

<pre><font face="Courier New" size="2">                fdiv
                fdivp
                fdivr
                fdivrp

                fdiv    st(0), st(i)
                fdiv    st(i), st(0)
                fdivp   st(i), st(0)

                fdivr   st(0), st(i)
                fdivr   st(i), st(0)
                fdivrp  st(i), st(0)

                fdiv    mem
                fdivr   mem</font></pre>

<p><font face="Arial" size="2">With zero operands, the <code>fdiv</code> and <code>fdivp</code>
instructions pop <code>st(0)</code> and <code>st(1)</code>, compute <code>st(0)/st(1)</code>,
and push the result back onto the stack. The <code>fdivr</code> and <code>fdivrp</code>
instructions also pop <code>st(0)</code> and <code>st(1)</code> but compute <code>st(1)/st(0)</code>
before pushing the quotient onto the stack.</font></p>

<p><font face="Arial" size="2">With two register operands, these instructions compute the
following quotients:</font></p>

<pre><font face="Courier New" size="2">                fdiv    st(0), st(i)    ;st(0) := st(0)/st(i)
                fdiv    st(i), st(0)    ;st(i) := st(i)/st(0)
                fdivp   st(i), st(0)    ;st(i) := st(i)/st(0)
                fdivr   st(i), st(i)    ;st(0) := st(0)/st(i)
                fdivrp  st(i), st(0)    ;st(i) := st(0)/st(i)</font></pre>

<p><font face="Arial" size="2">The <code>fdivp</code> and <code>fdivrp</code> instructions
also pop <code>st(0)</code> after performing the division operation. The value for i in
this two instructions is computed before popping <code>st(0)</code>.</font></p>

<p><font face="Arial" size="2">These instructions can raise the stack, precision,
underflow, overflow, denormalized, zero divide, and illegal operation exceptions, as
appropriate. If rounding occurs during the computation, these instructions set the <code>C1</code>
condition code bit. If a stack fault exception occurs, <code>C1</code> denotes stack
overflow or underflow.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING4-146"></a>14.4.6.5 The FSQRT
Instruction</font></strong></p>

<p><font face="Arial" size="2">The <code>fsqrt</code> routine does not allow any operands.
It computes the square root of the value on tos and replaces <code>st(0)</code> with this
result. The value on tos must be zero or positive, otherwise <code>fsqrt</code> will
generate an invalid operation exception.</font></p>

<p><font face="Arial" size="2">This instruction can raise the stack, precision,
denormalized, and invalid operation exceptions, as appropriate. If rounding occurs during
the computation, <code>fsqrt</code> sets the <code>C1</code> condition code bit. If a
stack fault exception occurs, <code>C1</code> denotes stack overflow or underflow.</font></p>

<p><font face="Arial" size="2">Example:</font></p>

<pre><font face="Courier New" size="2">; Compute Z := sqrt(x**2 + y**2);

                fld     x       ;Load X.
                fld     st(0)   ;Duplicate X on TOS.
                fmul            ;Compute X**2.

                fld     y       ;Load Y.
                fld     st(0)   ;Duplicate Y on TOS.
                fmul            ;Compute Y**2.

                fadd            ;Compute X**2 + Y**2.
                fsqrt           ;Compute sqrt(x**2 + y**2).
                fst     Z       ;Store away result in Z.</font></pre>

<pre><strong><font face="Arial" size="3">14.4.6.6 The FSCALE Instruction</font></strong></pre>

<p><font face="Arial" size="2">The <code>fscale</code> instruction pops two values off the
stack. It multiplies <code>st(0)</code> by <code>2st(1)</code> and pushes the result back
onto the stack. If the value in <code>st(1)</code> is not an integer, <code>fscale</code>
truncates it towards zero before performing the operation.</font></p>

<p><font face="Arial" size="2">This instruction raises the stack exception if there are
not two items currently on the stack (this will also clear<code> C1</code> since stack
underflow occurs). It raises the precision exception if there is a loss of precision due
to this operation (this occurs when <code>st(1)</code> contains a large, negative, value).
Likewise, this instruction sets the underflow or overflow exception bits if you multiply <code>st(0)</code>
by a very large positive or negative power of two. If the result of the multiplication is
very small, <code>fscale</code> could set the denormalized bit. Also, this instruction
could set the invalid operation bit if you attempt to <code>fscale</code> illegal values. <code>Fscale</code>
sets <code>C1</code> if rounding occurs in an otherwise correct computation. Example:</font></p>

<pre><font face="Courier New" size="2">                fild    Sixteen ;Push sixteen onto the stack.
                fld     x       ;Compute x * (2**16).
                fscale
                 .
                 .
                 .
Sixteen         word    16</font></pre>

<pre><strong><font face="Arial" size="3">14.4.6.7 The FPREM and FPREM1 Instructions</font></strong></pre>

<p><font face="Arial" size="2">The <code>fprem</code> and <code>fprem1</code> instructions
compute a partial remainder. Intel designed the <code>fprem</code> instruction before the
IEEE finalized their floating point standard. In the final draft of the IEEE floating
point standard, the definition of <code>fprem</code> was a little different than Intel's
original design. Unfortunately, Intel needed to maintain compatibility with the existing
software that used the <code>fprem</code> instruction, so they designed a new version to
handle the IEEE partial remainder operation, <code>fprem1</code>. You should always use <code>fprem1</code>
in new software you write, therefore we will only discuss <code>fprem1</code> here,
although you use <code>fprem</code> in an identical fashion.</font></p>

<p><font face="Arial" size="2"><code>Fprem1</code> computes the partial remainder of <code>st(0)/st(1)</code>.
If the difference between the exponents of <code>st(0)</code> and <code>st(1)</code> is
less than 64, fprem1 can compute the exact remainder in one operation. Otherwise you will
have to execute the <code>fprem1</code> two or more times to get the correct remainder
value. The <code>C2</code> condition code bit determines when the computation is complete.
Note that <code>fprem1</code> does not pop the two operands off the stack; it leaves the
partial remainder in <code>st(0)</code> and the original divisor in s<code>t(1)</code> in
case you need to compute another partial product to complete the result.</font></p>

<p><font face="Arial" size="2">The <code>fprem1</code> instruction sets the stack
exception flag if there aren't two values on the top of stack. It sets the underflow and
denormal exception bits if the result is too small. It sets the invalid operation bit if
the values on tos are inappropriate for this operation. It sets the <code>C2</code>
condition code bit if the partial remainder operation is not complete. Finally, it loads <code>C3</code>,
<code>C1</code>, and <code>C0</code> with bits zero, one, and two of the quotient,
respectively.</font></p>

<p><font face="Arial" size="2">Example:</font></p>

<pre><font face="Courier New" size="2">; Compute Z := X mod Y

                fld     y
                fld     x
PartialLp:      fprem1
                fstsw   ax              ;Get condition bits in AX.
                test    ah, 100b        ;See if C2 is set.
                jnz     PartialLp       ;Repeat if not done yet.
                fstp    Z               ;Store remainder away.
                fstp    st(0)           ;Pop old y value.</font></pre>

<pre><strong><font face="Arial" size="3">14.4.6.8 The FRNDINT Instruction</font></strong></pre>

<p><font face="Arial" size="2">The frndint instruction rounds the value on tos to the
nearest integer using the rounding algorithm specified in the control register.</font></p>

<p><font face="Arial" size="2">This instruction sets the stack exception flag if there is
no value on the tos (it will also clear C1 in this case). It sets the precision and
denormal exception bits if there was a loss of precision. It sets the invalid operation
flag if the value on the tos is not a valid number.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING4-191"></a>14.4.6.9 The FXTRACT
Instruction</font></strong></p>

<p><font face="Arial" size="2">The <code>fxtract</code> instruction is the complement to
the <code>fscale</code> instruction. It pops the value off the top of the stack and pushes
a value which is the integer equivalent of the exponent (in 80 bit real form), and then
pushes the mantissa with an exponent of zero (3fffh in biased form).</font></p>

<p><font face="Arial" size="2">This instruction raises the stack exception if there is a
stack underflow when popping the original value or a stack overflow when pushing the two
results (<code>C1</code> determines whether stack overflow or underflow occurs). If the
original top of stack was zero, fxtract sets the zero division exception flag. The
denormalized flag is set if the result warrants it; and the invalid operation flag is set
if there are illegal input values when you execute <code>fxtract</code>.</font></p>

<p><font face="Arial" size="2">Example:</font></p>

<pre><font face="Courier New" size="2">; The following example extracts the binary exponent of X and
; stores this into the 16 bit integer variable Xponent.

                fld     x
                fxtract
                fstp    st(0)
                fistp   Xponent</font></pre>

<pre><strong><font face="Arial" size="3">14.4.6.10 The FABS Instruction</font></strong></pre>
<code>

<p><font face="Arial" size="2">Fabs</code> computes the absolute value of <code>st(0)</code>
by clearing the sign bit of <code>st(0)</code>. It sets the stack exception bit and
invalid operation bits if the stack is empty.</font></p>

<p><font face="Arial" size="2">Example:</font></p>

<pre><font face="Courier New" size="2">; Compute X := sqrt(abs(x));

                fld     x
                fabs
                fsqrt
                fstp    x</font></pre>

<pre><strong><font face="Arial" size="3">14.4.6.11 The FCHS Instruction</font></strong></pre>

<p><font face="Arial" size="2">Fchs changes the sign of st(0)'s value by inverting its
sign bit. It sets the stack exception bit and invalid operation bits if the stack is
empty. Example:</font></p>

<pre><font face="Courier New" size="2">; Compute X := -X if X is positive, X := X if X is negative.

                fld     x
                fabs
                fchs
                fstp    x</font></pre>

<hr noshade size="1" color="#000000">

<p><font face="Arial" size="2"><strong><a NAME="FOOTNOTE-7"></a>[7]</strong> Storing a
denormalized value into a 32 or 64 bit memory variable will always set the underflow
exception bit. </font></p>

<p><font face="Arial" size="2"><strong><a NAME="FOOTNOTE-8"></a>[8]</strong> Because you
will use <code>st(0)</code> quite a bit when programming the 80x87, MASM allows you to use
the abbreviation <code>st</code> for <code>st(0)</code>. However, this text will
explicitly state <code>st(0)</code> so there will be no confusion.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH14-3.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH14-3.html">Chapter Fourteen</a> (Part 3)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH14-5.html">Chapter Fourteen</a> (Part 5)&nbsp; </strong></font><a href="CH14-5.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Fourteen: Floating Point
Arithmetics (Part 4)<br>
28 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_14/CH14-4.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:27:53 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
