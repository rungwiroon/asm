<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_12/CH12-2.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:27:26 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER TWELVE: PROCEDURES: ADVANCED TOPICS (Part 2)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING2"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH12-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH12-1.html">Chapter Twelve</a> (Part 1)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH12-3.html">Chapter Twelve</a> (Part 3)&nbsp; </strong></font><a href="CH12-3.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10"><a NAME="HEADING2-1"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0"><font face="Arial" size="4"><strong>CHAPTER TWELVE:<br>
    PROCEDURES: ADVANCED TOPICS (Part 2)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10"></td>
  </tr>
  <tr>
    <td width="100%"><font face="Arial" size="2"><a HREF="#HEADING2-1"><b>12.1.3 </b>- Static
    Links</a> <br>
    <a HREF="#HEADING2-85"><b>12.1.4 </b>- Accessing Non-Local Variables Using Static Links</a>
    </font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="20"></td>
  </tr>
</table>
</center></div>

<h3><strong><font face="Arial" size="3">12.1.3 Static Links</font></strong></h3>

<p><font face="Arial" size="2">Pascal will allow procedure<code> Two</code> access to <code>I</code>
in procedure <code>One</code>. However, when there is the possibility of recursion there
may be several instances of <code>i </code>on the stack. Pascal, of course, will only let
procedure <code>Two</code> access the most recent instance of <code>i</code>. In the stack
diagram in the figure below, this corresponds to the value of <code>i </code>in the
activation record that begins with <code>&quot;One(9+1)</code> <code>parameter</code>.&quot;
The only problem is how do you know where to find the activation record containing <code>i</code>?</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch12a2.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH12/ch12a2.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="239" HEIGHT="362"> </font></p>

<p><font face="Arial" size="2">A quick, but poorly thought out answer, is to simply index
backwards into the stack. After all, you can easily see in the diagram above that <code>i </code>is
at offset eight from <code>Two</code>'s activation record. Unfortunately, this is not
always the case. Assume that procedure <code>Three</code> also calls procedure <code>Two</code>
and the following statement appears within procedure <code>One</code>:</font></p>

<pre><font face="Courier New" size="2">	If (Entry &lt;5) then Three(Entry*2) else Two(Entry);</font></pre>

<p><font face="Arial" size="2">With this statement in place, it's quite possible to have
two different stack frames upon entry into procedure <code>Two</code>: one with the
activation record for procedure <code>Three</code> sandwiched between <code>One</code> and
<code>Two</code>'s activation records and one with the activation records for procedures <code>One</code>
and <code>Two</code> adjacent to one another. Clearly a fixed offset from <code>Two</code>'s
activation record will not always point at the <code>i </code>variable on <code>One</code>'s
most recent activation record.</font></p>

<p><font face="Arial" size="2">The astute reader might notice that the saved <code>bp</code>
value in <code>Two</code>'s activation record points at the caller's activation record.
You might think you could use this as a pointer to <code>One</code>'s activation record.
But this scheme fails for the same reason the fixed offset technique fails. <code>Bp</code>'s
old value, the dynamic link, points at the caller's activation record. Since the caller
isn't necessarily the enclosing procedure the dynamic link might not point at the
enclosing procedure's activation record.</font></p>

<p><font face="Arial" size="2">What is really needed is a pointer to the enclosing
procedure's activation record. Many compilers for block structured languages create such a
pointer, the static link. Consider the following Pascal code:</font></p>

<pre><font face="Courier New" size="2">procedure Parent;
var i,j:integer;

        procedure Child1;
        var j:integer;
        begin

                for j := 0 to 2 do writeln(i);

        end {Child1};

        procedure Child2;
        var i:integer;
        begin

                for i := 0 to 1 do Child1;

        end {Child2};

begin {Parent}

        Child2;
        Child1;

end;</font></pre>

<p><font face="Arial" size="2">Just after entering <code>Child1</code> for the first time,
the stack would look like the following:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch12a3.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH12/ch12a3.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="197" HEIGHT="188"> </font></p>

<p><font face="Arial" size="2">When <code>Child1</code> attempts to access the variable <code>i</code>
from <code>Parent</code>, it will need a pointer, the static link, to <code>Parent</code>'s
activation record. Unfortunately, there is no way for <code>Child1</code>, upon entry, to
figure out on it's own where <code>Parent</code>'s activation record lies in memory. It
will be necessary for the caller (<code>Child2</code> in this example) to pass the static
link to <code>Child1</code>. In general, the callee can treat the static link as just
another parameter; usually pushed on the stack immediately before executing the <code>call</code>
instruction.</font></p>

<p><font face="Arial" size="2">To fully understand how to pass static links from call to
call, you must first understand the concept of a lexical level. Lexical levels in Pascal
correspond to the static nesting levels of procedures and functions. Most compiler writers
specify lex level zero as the main program. That is, all symbols you declare in your main
program exist at lex level zero. Procedure and function names appearing in your main
program define lex level one, no matter how many procedures or functions appear in the
main program. They all begin a new copy of lex level one. For each level of nesting,
Pascal introduces a new lex level. The figure below shows this:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch12a4.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH12/ch12a4.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="403" HEIGHT="173"> </font></p>

<p><font face="Arial" size="2">During execution, a program may only access variables at a
lex level less than or equal to the level of the current routine. Furthermore, only one
set of values at any given lex level are accessible at any one time<a HREF="#FOOTNOTE-4">[4]</a>
and those values are always in the most recent activation record at that lex level.</font></p>

<p><font face="Arial" size="2">Before worrying about how to access non-local variables
using a static link, you need to figure out how to pass the static link as a parameter.
When passing the static link as a parameter to a program unit (procedure or function),
there are three types of calling sequences to worry about:</font>

<ul>
  <li><font face="Arial" size="2">A program unit calls a child procedure or function. If the
    current lex level is n, then a child procedure or function is at lex level n+1 and is
    local to the current program unit. Note that most block structured languages do not allow
    calling procedures or functions at lex levels greater than n+1. </font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">A program unit calls a peer procedure or function. A peer
    procedure or function is one at the same lexical level as the current caller and a single
    program unit encloses both program units. </font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">A program unit calls an ancestor procedure or function. An
    ancestor unit is either the parent unit, a parent of an ancestor unit, or a peer of an
    ancestor unit. </font></li>
</ul>

<p><font face="Arial" size="2">Calling sequences for the first two types of calls above
are very simple. For the sake of this example, assume the activation record for these
procedures takes the generic form shown in:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch12a5.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH12/ch12a5.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="194" HEIGHT="192"> </font></p>

<p><font face="Arial" size="2">When a parent procedure or function calls a child program
unit, the static link is nothing more than the value in the <code>bp</code> register
immediately prior to the call. Therefore, to pass the static link to the child unit, just
push <code>bp</code> before executing the call instruction:</font></p>

<pre><font face="Courier New" size="2">        &lt;Push Other Parameters onto the stack&gt;
                push    bp
                call    ChildUnit</font></pre>

<p><font face="Arial" size="2">Of course the child unit can process the static link off
the stack just like any other parameter. In this case, that the static and dynamic links
are exactly the same. In general, however, this is not true.</font></p>

<p><font face="Arial" size="2">If a program unit calls a peer procedure or function, the
current value in <code>bp</code> is not the static link. It is a pointer to the caller's
local variables and the peer procedure cannot access those variables. However, as peers,
the caller and callee share the same parent program unit, so the caller can simply push a
copy of its static link onto the stack before calling the peer procedure or function. The
following code will do this, assuming all procedures and functions are near:</font></p>

<pre><font face="Courier New" size="2">        &lt;Push Other Parameters onto the Stack&gt;
                push    [bp+4]          ;Push static link onto stk.
                call    PeerUnit</font></pre>

<p><font face="Arial" size="2">If the procedure or function is far, the static link would
be two bytes farther up the stack, so you would need to use the following code:</font></p>

<pre><font face="Courier New" size="2">        &lt;Push Other Parameters onto the Stack&gt;
                push    [bp+6]          ;Push static link onto stk.
                call    PeerUnit</font></pre>

<p><font face="Arial" size="2">Calling an ancestor is a little more complex. If you are
currently at lex level n and you wish to call an ancestor at lex level m (m &lt; n), you
will need to traverse the list of static links to find the desired activation record. The
static links form a list of activation records. By following this chain of activation
records until it ends, you can step through the most recent activation records of all the
enclosing procedures and functions of a particular program unit. The stack diagram in The
figure below shows the static links for a sequence of procedure calls statically nested
five lex levels deep:</font></p>

<p align="center"><img SRC="images/ch12a6.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH12/ch12a6.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="210" HEIGHT="181"> </p>

<p><font face="Arial" size="2">If the program unit currently executing at lex level five
wishes to call a procedure at lex level three, it must push a static link to the most
recently activated program unit at lex level two. In order to find this static link you
will have to traverse the chain of static links. If you are at lex level n and you want to
call a procedure at lex level m you will have to traverse (n-m)+1 static links. The code
to accomplish this is</font></p>

<pre><font face="Courier New" size="2">; Current lex level is 5. This code locates the static link for,
; and then calls a procedure at lex level 2. Assume all calls are
; near:

        &lt;Push necessary parameters&gt;

                mov     bx, [bp+4]      ;Traverse static link to LL 4.
                mov     bx, ss:[bx+4]   ;To Lex Level 3.
                mov     bx, ss:[bx+4]   ;To Lex Level 2.
                push    ss:[bx+4]       ;Ptr to most recent LL1 A.R.
                call    ProcAtLL2</font></pre>

<p><font face="Arial" size="2">Note the <code>ss:</code> prefix in the instructions above.
Remember, the activation records are all in the stack segment and <code>bx</code> indexes
the data segment by default.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-85"></a>12.1.4 Accessing
Non-Local Variables Using Static Links</font></strong></p>

<p><font face="Arial" size="2">In order to access a non-local variable, you must traverse
the chain of static links until you get a pointer to the desired activation record. This
operation is similar to locating the static link for a procedure call outlined in the
previous section, except you traverse only n-m static links rather than (n-m)+1 links to
obtain a pointer to the appropriate activation record. Consider the following Pascal code:</font></p>

<pre><font face="Courier New" size="2">procedure Outer;
var i:integer;

        procedure Middle;
        var j:integer;

                procedure Inner;
                var k:integer;
                begin

                        k := 3;
                        writeln(i+j+k);

                end;

        begin {middle}

                j := 2;
                writeln(i+j);
                Inner;

        end; {middle}

begin {Outer}

        i := 1;
        Middle;

end; {Outer}</font></pre>

<p><font face="Arial" size="2">The Inner procedure accesses global variables at lex level
n-1 and n-2 (where n is the lex level of the Inner procedure). The Middle procedure
accesses a single global variable at lex level m-1 (where m is the lex level of procedure
Middle). The following assembly language code could implement these three procedures:</font></p>

<pre><font face="Courier New" size="2">Outer           proc    near
                push    bp
                mov     bp, sp
                sub     sp, 2                   ;Make room for I.

                mov     word ptr [bp-2],1       ;Set I to one.
                push    bp                      ;Static link for Middle.
                call    Middle

                mov     sp, bp                  ;Remove local variables.
                pop     bp
                ret     2                       ;Remove static link on ret.
Outer           endp

Middle          proc    near
                push    bp                      ;Save dynamic link
                mov     bp, sp                  ;Set up activation record.
                sub     sp, 2                   ;Make room for J.

                mov     word ptr [bp-2],2       ;J := 2;
                mov     bx, [bp+4]              ;Get static link to prev LL.
                mov     ax, ss:[bx-2]           ;Get I's value.
                add     ax, [bp-2]              ;Add to J and then
                puti                            ; print the sum.
                putcr
                push    bp                      ;Static link for Inner.
                call    Inner

                mov     sp, bp
                pop     bp
                ret     2                       ;Remove static link on RET.
Middle          endp

Inner           proc    near
                push    bp                      ;Save dynamic link
                mov     bp, sp                  ;Set up activation record.
                sub     sp, 2                   ;Make room for K.

                mov     word ptr [bp-2],2       ;K := 3;
                mov     bx, [bp+4]              ;Get static link to prev LL.
                mov     ax, ss:[bx-2]           ;Get J's value.
                add     ax, [bp-2]              ;Add to K
        
                mov     bx, ss:[bx+4]           ;Get ptr to Outer's Act Rec.
                add     ax, ss:[bx-2]           ;Add in I's value and then
                puti                            ; print the sum.
                putcr

                mov     sp, bp
                pop     bp
                ret     2                       ;Remove static link on RET.
Inner           endp</font></pre>

<p><font face="Arial" size="2">As you can see, accessing global variables can be very
inefficient<a HREF="#FOOTNOTE-5">[5]</a>. </font></p>

<p><font face="Arial" size="2">Note that as the difference between the activation records
increases, it becomes less and less efficient to access global variables. Accessing global
variables in the previous activation record requires only one additional instruction per
access, at two lex levels you need two additional instructions, etc. If you analyze a
large number of Pascal programs, you will find that most of them do not nest procedures
and functions and in the ones where there are nested program units, they rarely access
global variables. There is one major exception, however. Although Pascal procedures and
functions rarely access local variables inside other procedures and functions, they
frequently access global variables declared in the main program. Since such variables
appear at lex level zero, access to such variables would be as inefficient as possible
when using the static links. To solve this minor problem, most 80x86 based block
structured languages allocate variables at lex level zero directly in the data segment and
access them directly.</font></p>

<hr noshade size="1" color="#000000">

<p><font face="Arial" size="2"><a NAME="FOOTNOTE-4"></a><strong>[4]</strong> There is one
exception. If you have a pointer to a variable and the pointer remains accessible, you can
access the data it points at even if the variable actually holding that data is
inaccessible. Of course, in (standard) Pascal you cannot take the address of a local
variable and put it into a pointer. However, certain dialects of Pascal (e.g., Turbo) and
other block structured languages will allow this operation. </font></p>

<p><font face="Arial" size="2"><a NAME="FOOTNOTE-5"></a><strong>[5]</strong> Indeed,
perhaps one of the main reasons the C programming language is not block structured is
because the language designers wanted to avoid inefficient access to non-local variables.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH12-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH12-1.html">Chapter Twelve</a> (Part 1)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH12-3.html">Chapter Twelve</a> (Part 3)&nbsp; </strong></font><a href="CH12-3.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Twelve: Procedures: Advanced
Topics (Part 2)<br>
27 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_12/CH12-2.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:27:32 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
