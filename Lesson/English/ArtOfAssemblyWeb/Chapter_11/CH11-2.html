<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_11/CH11-2.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:27:10 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER ELEVEN: PROCEDURES AND FUNCTIONS (Part 2)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING2"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH11-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH11-1.html">Chapter Eleven</a> (Part 1)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH11-3.html">Chapter Eleven</a> (Part 3)&nbsp; </strong></font><a href="CH11-3.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10" colspan="2"><a NAME="HEADING2-1"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0" colspan="2"><font face="Arial" size="4"><strong>CHAPTER
    ELEVEN:<br>
    PROCEDURES AND FUNCTIONS (Part 2)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10" colspan="2"></td>
  </tr>
  <tr>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING2-1"><b>11.5 </b>-
    Parameters</a> <br>
    <a HREF="#HEADING2-23"><b>11.5.1 </b>- Pass by Value</a> <br>
    <a HREF="#HEADING2-29"><b>11.5.2 </b>- Pass by Reference</a> <br>
    <a HREF="#HEADING2-57"><b>11.5.3 </b>- Pass by Value-Returned</a> </font></td>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING2-61"><b>11.5.4 </b>-
    Pass by Result</a> <br>
    <a HREF="#HEADING2-63"><b>11.5.5 </b>- Pass by Name</a> <br>
    <a HREF="#HEADING2-117"><b>11.5.6 </b>- Pass by Lazy-Evaluation</a> </font></td>
  </tr>
  <tr>
    <td width="100%" valign="top" colspan="2" nowrap height="20"><font face="Arial" size="2"></font></td>
  </tr>
  <tr>
    <td width="100%" valign="top" colspan="2"><font face="Arial" size="2"></font><strong><font face="Arial" size="3">11.5 Parameters</font></strong><font face="Arial" size="2"></font></td>
  </tr>
  <tr>
    <td width="100%" valign="top" colspan="2" nowrap height="1" bgcolor="#000000"><font face="Arial" size="2"></font></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">Although there is a large class of procedures that are
totally self-contained, most procedures require some input data and return some data to
the caller. Parameters are values that you pass to and from a procedure. There are many
facets to parameters. Questions concerning parameters include:</font>

<ul>
  <li><font face="Arial" size="2">where is the data coming from? </font></li>
  <li><font face="Arial" size="2">how do you pass and return data? </font></li>
  <li><font face="Arial" size="2">what is the amount of data to pass? </font></li>
</ul>

<p><font face="Arial" size="2">There are six major mechanisms for passing data to and from
a procedure, they are </font>

<ul>
  <li><font face="Arial" size="2">pass by value, </font></li>
  <li><font face="Arial" size="2">pass by reference, </font></li>
  <li><font face="Arial" size="2">pass by value/returned, </font></li>
  <li><font face="Arial" size="2">pass by result, and </font></li>
  <li><font face="Arial" size="2">pass by name. </font></li>
  <li><font face="Arial" size="2">pass by lazy evaluation </font></li>
</ul>

<p><font face="Arial" size="2">You also have to worry about where you can pass parameters.
Common places are </font>

<ul>
  <li><font face="Arial" size="2">in registers, </font></li>
  <li><font face="Arial" size="2">in global memory locations, </font></li>
  <li><font face="Arial" size="2">on the stack, </font></li>
  <li><font face="Arial" size="2">in the code stream, or </font></li>
  <li><font face="Arial" size="2">in a parameter block referenced via a pointer. </font></li>
</ul>

<p><font face="Arial" size="2">Finally, the amount of data has a direct bearing on where
and how to pass it. The following sections take up these issues.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-23"></a>11.5.1 Pass by Value</font></strong></p>

<p><font face="Arial" size="2">A parameter passed by value is just that - the caller
passes a value to the procedure. Pass by value parameters are input only parameters. That
is, you can pass them to a procedure but the procedure cannot return them. In HLLs, like
Pascal, the idea of a pass by value parameter being an input only parameter makes a lot of
sense. Given the Pascal procedure call:</font></p>

<pre><font face="Courier New" size="2">		CallProc(I);</font></pre>

<p><font face="Arial" size="2">If you pass <code>I</code> by value, the <code>CallProc</code>
does not change the value of <code>I</code>, regardless of what happens to the parameter
inside <code>CallProc</code>. </font></p>

<p><font face="Arial" size="2">Since you must pass a copy of the data to the procedure,
you should only use this method for passing small objects like bytes, words, and double
words. Passing arrays and strings by value is very inefficient (since you must create and
pass a copy of the structure to the procedure).</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-29"></a>11.5.2 Pass by Reference</font></strong></p>

<p><font face="Arial" size="2">To pass a parameter by reference, you must pass the address
of a variable rather than its value. In other words, you must pass a pointer to the data.
The procedure must dereference this pointer to access the data. Passing parameters by
reference is useful when you must modify the actual parameter or when you pass large data
structures between procedures. </font></p>

<p><font face="Arial" size="2">Passing parameters by reference can produce some peculiar
results. The following Pascal procedure provides an example of one problem you might
encounter:</font></p>

<pre><font face="Courier New" size="2">program main(input,output);
var m:integer;

                procedure bletch(var i,j:integer);
                begin

                        i := i+2;
                        j := j-i;
                        writeln(i,' ',j);

                end;

                 .
                 .
                 .

        begin {main}

                m := 5;
                bletch(m,m);

        end.</font></pre>

<p><font face="Arial" size="2">This particular code sequence will print &quot;00&quot;
regardless of <code>m</code>'s value. This is because the parameters <code>i</code> and<code>
j</code> are pointers to the actual data and they both point at the same object.
Therefore, the statement <code>j:=j-i; </code>always produces zero since <code>i </code>and<code>
j </code>refer to the same variable. </font></p>

<p><font face="Arial" size="2">Pass by reference is usually less efficient than pass by
value. You must dereference all pass by reference parameters on each access; this is
slower than simply using a value. However, when passing a large data structure, pass by
reference is faster because you do not have to copy a large data structure before calling
the procedure.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-57"></a>11.5.3 Pass by
Value-Returned</font></strong></p>

<p><font face="Arial" size="2">Pass by value-returned (also known as value-result)
combines features from both the pass by value and pass by reference mechanisms. You pass a
value-returned parameter by address, just like pass by reference parameters. However, upon
entry, the procedure makes a temporary copy of this parameter and uses the copy while the
procedure is executing. When the procedure finishes, it copies the temporary copy back to
the original parameter. </font></p>

<p><font face="Arial" size="2">The Pascal code presented in the previous section would
operate properly with pass by value-returned parameters. Of course, when <code>Bletch</code>
returns to the calling code, <code>m</code> could only contain one of the two values, but
while <code>Bletch</code> is executing,<code> i</code> and<code> j </code>would contain
distinct values.</font></p>

<p><font face="Arial" size="2">In some instances, pass by value-returned is more efficient
than pass by reference, in others it is less efficient. If a procedure only references the
parameter a couple of times, copying the parameter's data is expensive. On the other hand,
if the procedure uses this parameter often, the procedure amortizes the fixed cost of
copying the data over many inexpensive accesses to the local copy. </font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-61"></a>11.5.4 Pass by Result</font></strong></p>

<p><font face="Arial" size="2">Pass by result is almost identical to pass by
value-returned. You pass in a pointer to the desired object and the procedure uses a local
copy of the variable and then stores the result through the pointer when returning. The
only difference between pass by value-returned and pass by result is that when passing
parameters by result you do not copy the data upon entering the procedure. Pass by result
parameters are for returning values, not passing data to the procedure. Therefore, pass by
result is slightly more efficient than pass by value-returned since you save the cost of
copying the data into the local variable.</font></p>

<p><font face="Arial" size="3"><strong><a NAME="HEADING2-63"></a>11.5.5 Pass by Name</strong></font></p>

<p><font face="Arial" size="2">Pass by name is the parameter passing mechanism used by
macros, text equates, and the <code>#define </code>macro facility in the C programming
language. This parameter passing mechanism uses textual substitution on the parameters.
Consider the following MASM macro:</font></p>

<pre><font face="Courier New" size="2">PassByName      macro   Parameter1, Parameter2
                mov     ax, Parameter1
                add     ax, Parameter2
                endm</font></pre>

<p><font face="Arial" size="2">If you have a macro invocation of the form:</font></p>

<pre><font face="Courier New" size="2">                PassByName bx, I</font></pre>

<p><font face="Arial" size="2">MASM emits the following code, substituting bx for
Parameter1 and I for Parameter2:</font></p>

<pre><font face="Courier New" size="2">                mov     ax, bx
                add     ax, I</font></pre>

<p><font face="Arial" size="2">Some high level languages, such as ALGOL-68 and Panacea,
support pass by name parameters. However, implementing pass by name using textual
substitution in a compiled language (like ALGOL-68) is very difficult and inefficient.
Basically, you would have to recompile a function everytime you call it. So compiled
languages that support pass by name parameters generally use a different technique to pass
those parameters. Consider the following Panacea procedure:</font></p>

<pre><font face="Courier New" size="2">PassByName: procedure(name item:integer; var index:integer);
begin PassByName;

        foreach index in 0..10 do

                item := 0;

        endfor;

end PassByName;</font></pre>

<p><font face="Arial" size="2">Assume you call this routine with the statement<code>
PassByName(A[i], i); </code>where <code>A</code> is an array of integers having (at least)
the elements A[0]..A[10]. Were you to substitute the pass by name parameter item you would
obtain the following code:</font></p>

<pre><font face="Courier New" size="2">begin PassByName;

        foreach index in 0..10 do

                A[I] := 0; (* Note that index and I are aliases *)

        endfor;

end PassByName;</font></pre>

<p><font face="Arial" size="2">This code zeros out elements 0..10 of array <code>A</code>.</font></p>

<p><font face="Arial" size="2">High level languages like ALGOL-68 and Panacea compile pass
by name parameters into functions that return the address of a given parameter. So in one
respect, pass by name parameters are similar to pass by reference parameters insofar as
you pass the address of an object. The major difference is that with pass by reference you
compute the address of an object before calling a subroutine; with pass by name the
subroutine itself calls some function to compute the address of the parameter.</font></p>

<p><font face="Arial" size="2">So what difference does this make? Well, reconsider the
code above. Had you passed<code> A[I] </code>by reference rather than by name, the calling
code would compute the address of <code>A[I] </code>just before the call and passed in
this address. Inside the <code>PassByName</code> procedure the variable <code>item</code>
would have always referred to a single address, not an address that changes along with<code>
I</code>. With pass by name parameters, <code>item</code> is really a function that
computes the address of the parameter into which the procedure stores the value zero. Such
a function might look like the following:</font></p>

<pre><font face="Courier New" size="2">ItemThunk       proc    near
                mov     bx, I
                shl     bx, 1
                lea     bx, A[bx]
                ret
ItemThunk       endp</font></pre>

<p><font face="Arial" size="2">The compiled code inside the PassByName procedure might
look something like the following:</font></p>

<pre><font face="Courier New" size="2">; item := 0;

                call    ItemThunk
                mov     word ptr [bx], 0</font></pre>

<p><font face="Arial" size="2">Thunk is the historical term for these functions that
compute the address of a pass by name parameter. It is worth noting that most HLLs
supporting pass by name parameters do not call thunks directly (like the <code>call</code>
above). Generally, the caller passes the address of a thunk and the subroutine calls the
thunk indirectly. This allows the same sequence of instructions to call several different
thunks (corresponding to different calls to the subroutine).</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING2-117"></a>11.5.6 Pass by
Lazy-Evaluation</font></strong></p>

<p><font face="Arial" size="2">Pass by name is similar to pass by reference insofar as the
procedure accesses the parameter using the address of the parameter. The primary
difference between the two is that a caller directly passes the address on the stack when
passing by reference, it passes the address of a function that computes the parameter's
address when passing a parameter by name. The pass by lazy evaluation mechanism shares
this same relationship with pass by value parameters - the caller passes the address of a
function that computes the parameter's value if the first access to that parameter is a
read operation.</font></p>

<p><font face="Arial" size="2">Pass by lazy evaluation is a useful parameter passing
technique if the cost of computing the parameter value is very high and the procedure may
not use the value. Consider the following Panacea procedure header:</font></p>

<pre><font face="Courier New" size="2">PassByEval: procedure(eval a:integer; eval b:integer; eval c:integer);</font></pre>

<p><font face="Arial" size="2">When you call the <code>PassByEval</code> function it does
not evaluate the actual parameters and pass their values to the procedure. Instead, the
compiler generates thunks that will compute the value of the parameter at most one time.
If the first access to an <code>eval</code> parameter is a read, the thunk will compute
the parameter's value and store that into a local variable. It will also set a flag so
that all future accesses will not call the thunk (since it has already computed the
parameter's value). If the first access to an <code>eval</code> parameter is a write, then
the code sets the flag and future accesses within the same procedure activation will use
the written value and ignore the thunk.</font></p>

<p><font face="Arial" size="2">Consider the <code>PassByEval</code> procedure above.
Suppose it takes several minutes to compute the values for the <code>a, b,</code> and <code>c</code>
parameters (these could be, for example, three different possible paths in a Chess game).
Perhaps the <code>PassByEval</code> procedure only uses the value of one of these
parameters. Without pass by lazy evaluation, the calling code would have to spend the time
to compute all three parameters even though the procedure will only use one of the values.
With pass by lazy evaluation, however, the procedure will only spend the time computing
the value of the one parameter it needs. Lazy evaluation is a common technique artificial
intelligence (AI) and operating systems use to improve performance.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH11-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH11-1.html">Chapter Eleven</a> (Part 1)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH11-3.html">Chapter Eleven</a> (Part 3)&nbsp; </strong></font><a href="CH11-3.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Eleven: Procedures and
Functions (Part 2)<br>
27 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_11/CH11-2.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:27:10 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
