<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_11/CH11-5.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:27:18 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER ELEVEN: PROCEDURES AND FUNCTIONS (Part 5)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING5"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH11-4.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH11-4.html">Chapter Eleven</a> (Part 4)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH11-6.html">Chapter Eleven</a> (Part 6)&nbsp; </strong></font><a href="CH11-6.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10"><a NAME="HEADING5-1"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0"><font face="Arial" size="4"><strong>CHAPTER ELEVEN:<br>
    PROCEDURES AND FUNCTIONS (Part 5)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10"></td>
  </tr>
  <tr>
    <td width="100%"><font face="Arial" size="2"><a HREF="#HEADING5-1"><b>11.5.10 </b>-
    Passing Parameters in the Code Stream</a> </font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="20"></td>
  </tr>
</table>
</center></div>

<h3><strong><font face="Arial" size="3">11.5.10 Passing Parameters in the Code Stream</font></strong></h3>

<p><font face="Arial" size="2">Another place where you can pass parameters is in the code
stream immediately after the <code>call</code> instruction. The <code>print</code> routine
in the UCR Standard Library package provides an excellent example:</font></p>

<pre><font face="Courier New" size="2">                print
                byte    &quot;This parameter is in the code stream.&quot;,0</font></pre>

<p><font face="Arial" size="2">Normally, a subroutine returns control to the first
instruction immediately following the <code>call</code> instruction. Were that to happen
here, the 80x86 would attempt to interpret the ASCII code for &quot;This...&quot; as an
instruction. This would produce undesirable results. Fortunately, you can skip over this
string when returning from the subroutine. </font></p>

<p><font face="Arial" size="2">So how do you gain access to these parameters? Easy. The
return address on the stack points at them. Consider the following implementation of <code>print</code>:</font></p>

<pre><font face="Courier New" size="2">MyPrint         proc    near
                push    bp
                mov     bp, sp
                push    bx
                push    ax
                mov     bx, 2[bp]       ;Load return address into BX
PrintLp:        mov     al, cs:[bx]     ;Get next character
                cmp     al, 0           ;Check for end of string
                jz      EndStr
                putc                    ;If not end, print this char
                inc     bx              ;Move on to the next character
                jmp     PrintLp

EndStr:         inc     bx              ;Point at first byte beyond zero
                mov     2[bp], bx       ;Save as new return address
                pop     ax
                pop     bx
                pop     bp
                ret
MyPrint         endp</font></pre>

<p><font face="Arial" size="2">This procedure begins by pushing all the affected registers
onto the stack. It then fetches the return address, at offset <code>2[BP]</code>, and
prints each successive character until encountering a zero byte. Note the presence of the <code>cs:
</code>segment override prefix in the <code>mov al, cs:[bx]</code> instruction. Since the
data is coming from the code segment, this prefix guarantees that <code>MyPrint</code>
fetches the character data from the proper segment. Upon encountering the zero byte, <code>MyPrint</code>
points <code>bx</code> at the first byte beyond the zero. This is the address of the first
instruction following the zero terminating byte. The CPU uses this value as the new return
address. Now the execution of the <code>ret</code> instruction returns control to the
instruction following the string. </font></p>

<p><font face="Arial" size="2">The above code works great if <code>MyPrint</code> is a
near procedure. If you need to call <code>MyPrint</code> from a different segment you will
need to create a far procedure. Of course, the major difference is that a far return
address will be on the stack at that point - you will need to use a far pointer rather
than a near pointer. The following implementation of <code>MyPrint</code> handles this
case.</font></p>

<pre><font face="Courier New" size="2">MyPrint         proc    far
                push    bp
                mov     bp, sp
                push    bx              ;Preserve ES, AX, and BX
                push    ax
                push    es

                les     bx, 2[bp]       ;Load return address into ES:BX
PrintLp:        mov     al, es:[bx]     ;Get next character
                cmp     al, 0           ;Check for end of string
                jz      EndStr
                putc                    ;If not end, print this char
                inc     bx              ;Move on to the next character
                jmp     PrintLp

EndStr:         inc     bx              ;Point at first byte beyond zero
                mov     2[bp], bx       ;Save as new return address
                pop     es
                pop     ax
                pop     bx
                pop     bp
                ret
MyPrint         endp</font></pre>

<p><font face="Arial" size="2">Note that this code does not store <code>es</code> back
into location<code> [bp+4]</code>. The reason is quite simple - <code>es</code> does not
change during the execution of this procedure; storing <code>es</code> into location <code>[bp+4]
</code>would not change the value at that location. You will notice that this version of <code>MyPrint</code>
fetches each character from location <code>es:[bx]</code> rather than <code>cs:[bx]</code>.
This is because the string you're printing is in the caller's segment, that might not be
the same segment containing <code>MyPrint</code>.</font></p>

<p><font face="Arial" size="2">Besides showing how to pass parameters in the code stream,
the <code>MyPrint</code> routine also exhibits another concept: variable length
parameters. The string following the <code>call</code> can be any practical length. The
zero terminating byte marks the end of the parameter list. There are two easy ways to
handle variable length parameters. Either use some special terminating value (like zero)
or you can pass a special length value that tells the subroutine how many parameters you
are passing. Both methods have their advantages and disadvantages. Using a special value
to terminate a parameter list requires that you choose a value that never appears in the
list. For example, <code>MyPrint</code> uses zero as the terminating value, so it cannot
print the NULL character (whose ASCII code is zero). Sometimes this isn't a limitation.
Specifying a special length parameter is another mechanism you can use to pass a variable
length parameter list. While this doesn't require any special codes or limit the range of
possible values that can be passed to a subroutine, setting up the length parameter and
maintaining the resulting code can be a real nightmare<a HREF="#FOOTNOTE-5">[5]</a>. </font></p>

<p><font face="Arial" size="2">Although passing parameters in the code stream is an ideal
way to pass variable length parameter lists, you can pass fixed length parameter lists as
well. The code stream is an excellent place to pass constants (like the string constants
passed to <code>MyPrint</code>) and reference parameters. Consider the following code that
expects three parameters by reference:</font></p>

<p><font face="Arial" size="2">Calling sequence:</font></p>

<pre><font face="Courier New" size="2">                call    AddEm
                word    I,J,K</font></pre>

<p><font face="Arial" size="2">Procedure:</font></p>

<pre><font face="Courier New" size="2">AddEm           proc    near
                push    bp
                mov     bp, sp
                push    si
                push    bx
                push    ax
                mov     si, [bp+2]      ;Get return address
                mov     bx, cs:[si+2]   ;Get address of J
                mov     ax, [bx]        ;Get J's value
                mov     bx, cs:[si+4]   ;Get address of K
                add     ax, [bx]        ;Add in K's value
                mov     bx, cs:[si]     ;Get address of I
                mov     [bx], ax        ;Store result
                add     si, 6           ;Skip past parms
                mov     [bp+2], si      ;Save return address
                pop     ax
                pop     bx
                pop     si
                pop     bp
                ret
AddEm           endp</font></pre>

<p><font face="Arial" size="2">This subroutine adds <code>J</code> and <code>K</code>
together and stores the result into <code>I</code>. Note that this code uses 16 bit near
pointers to pass the addresses of <code>I</code>,<code> J</code>, and <code>K</code> to <code>AddEm</code>.
Therefore, <code>I</code>, <code>J</code>, and <code>K</code> must be in the current data
segment. In the example above, <code>AddEm</code> is a near procedure. Had it been a far
procedure it would have needed to fetch a four byte pointer from the stack rather than a
two byte pointer. The following is a far version of <code>AddEm</code>:</font></p>

<pre><font face="Courier New" size="2">AddEm           proc    far
                push    bp
                mov     bp, sp
                push    si
                push    bx
                push    ax
                push    es
                les     si, [bp+2]      ;Get far ret adrs into es:si
                mov     bx, es:[si+2]   ;Get address of J
                mov     ax, [bx]        ;Get J's value
                mov     bx, es:[si+4]   ;Get address of K
                add     ax, [bx]        ;Add in K's value
                mov     bx, es:[si]     ;Get address of I
                mov     [bx], ax        ;Store result
                add     si, 6           ;Skip past parms
                mov     [bp+2], si      ;Save return address
                pop     es
                pop     ax
                pop     bx
                pop     si
                pop     bp
                ret
AddEm           endp</font></pre>

<p><font face="Arial" size="2">In both versions of <code>AddEm</code>, the pointers to<code>
I</code>, <code>J</code>, and <code>K</code> passed in the code stream are near pointers.
Both versions assume that <code>I</code>, <code>J</code>, and <code>K</code> are all in
the current data segment. It is possible to pass far pointers to these variables, or even
near pointers to some and far pointers to others, in the code stream. The following
example isn't quite so ambitious, it is a near procedure that expects far pointers, but it
does show some of the major differences. For additional examples, see the exercises.</font></p>

<p><font face="Arial" size="2">Calling sequence:</font></p>

<pre><font face="Courier New" size="2">                call    AddEm
                dword   I,J,K</font></pre>

<p><font face="Arial" size="2">Code:</font></p>

<pre><font face="Courier New" size="2">AddEm           proc    near
                push    bp
                mov     bp, sp
                push    si
                push    bx
                push    ax
                push    es
                mov     si, [bp+2]      ;Get near ret adrs into si
                les     bx, cs:[si+2]   ;Get address of J into es:bx
                mov     ax, es:[bx]     ;Get J's value
                les     bx, cs:[si+4]   ;Get address of K
                add     ax, es:[bx]     ;Add in K's value
                les     bx, cs:[si]     ;Get address of I
                mov     es:[bx], ax     ;Store result
                add     si, 12          ;Skip past parms
                mov     [bp+2], si      ;Save return address
                pop     es
                pop     ax
                pop     bx
                pop     si
                pop     bp
                ret
AddEm           endp</font></pre>

<p><font face="Arial" size="2">Note that there are 12 bytes of parameters in the code
stream this time around. This is why this code contains an <code>add si, 12</code>
instruction rather than the <code>add si, 6</code> appearing in the other versions.</font></p>

<p><font face="Arial" size="2">In the examples given to this point, <code>MyPrint</code>
expects a pass by value parameter, it prints the actual characters following the call, and
<code>AddEm</code> expects three pass by reference parameters - their addresses follow in
the code stream. Of course, you can also pass parameters by value-returned, by result, by
name, or by lazy evaluation in the code stream as well. The next example is a modification
of AddEm that uses pass by result for I, pass by value-returned for J, and pass by name
for K. This version is slightly differerent insofar as it modifies J as well as I, in
order to justify the use of the value-returned parameter.</font></p>

<pre><font face="Courier New" size="2">; AddEm(Result I:integer; ValueResult J:integer; Name K);
;
;       Computes        I:= J;
;                       J := J+K;
;
; Presumes all pointers in the code stream are near pointers.

AddEm           proc    near
                push    bp
                mov     bp, sp
                push    si                      ;Pointer to parameter block.
                push    bx                      ;General pointer.
                push    cx                      ;Temp value for I.
                push    ax                      ;Temp value for J.

                mov     si, [bp+2]              ;Get near ret adrs into si

                mov     bx, cs:[si+2]           ;Get address of J into bx
                mov     ax, es:[bx]             ;Create local copy of J.
                mov     cx, ax                  ;Do I:=J;

                call    word ptr cs:[si+4]      ;Call thunk to get K's adrs
                add     ax, [bx]                ;Compute J := J + K
                
                mov     bx, cs:[si]             ;Get address of I and store
                mov     [bx], cx                ; I away.

                mov     bx, cs:[si+2]           ;Get J's address and store
                mov     [bx], ax                ; J's value away.

                add     si, 6                   ;Skip past parms
                mov     [bp+2], si              ;Save return address
                pop     ax
                pop     cx
                pop     bx
                pop     si
                pop     bp
                ret
AddEm           endp</font></pre>

<p><font face="Arial" size="2">Example calling sequences:</font></p>

<pre><font face="Courier New" size="2">; AddEm(I,J,K)

                call    AddEm
                word    I,J,KThunk

; AddEm(I,J,A[I])

                call    AddEm
                word    I,J,AThunk
                 .
                 .
                 .
KThunk          proc    near
                lea     bx, K
                ret
KThunk          endp

AThunk          proc    near
                mov     bx, I
                shl     bx, 1
                lea     bx, A[bx]
                ret
AThunk          endp</font></pre>

<p><font face="Arial" size="2">Note: had you passed <code>I</code> by reference, rather
than by result, in this example, the call </font></p>

<pre><font face="Courier New" size="2"><code>		AddEm(I,J,A[i])</code></font></pre>

<p><font face="Arial" size="2">would have produced different results. Can you explain why?</font></p>

<p><font face="Arial" size="2">Passing parameters in the code stream lets you perform some
really clever tasks. The following example is considerably more complex than the others in
this section, but it demonstrates the power of passing parameters in the code stream and,
despite the complexity of this example, how they can simplify your programming tasks.</font></p>

<p><font face="Arial" size="2">The following two routines implement a <code>for/next</code>
statement, similar to that in BASIC, in assembly language. The calling sequence for these
routines is the following:</font></p>

<pre><font face="Courier New" size="2">                call    ForStmt
                word    &lt;&lt;LoopControlVar», &lt;&lt;StartValue», &lt;&lt;EndValue»
                 .
                 .
        &lt;&lt; loop body statements»
                 .
                 .
                call    Next</font></pre>

<p><font face="Arial" size="2">This code sets the loop control variable (whose near
address you pass as the first parameter, by reference) to the starting value (passed by
value as the second parameter). It then begins execution of the loop body. Upon executing
the call to <code>Next</code>, this program would increment the loop control variable and
then compare it to the ending value. If it is less than or equal to the ending value,
control would return to the beginning of the loop body (the first statement following the <code>word</code>
directive). Otherwise it would continue execution with the first statement past the call
to <code>Next</code>.</font></p>

<p><font face="Arial" size="2">Now you're probably wondering, &quot;How on earth does
control transfer to the beginning of the loop body?&quot; After all, there is no label at
that statement and there is no control transfer instruction instruction that jumps to the
first statement after the <code>word</code> directive. Well, it turns out you can do this
with a little tricky stack manipulation. Consider what the stack will look like upon entry
into the <code>ForStmt</code> routine, after pushing <code>bp</code> onto the stack: </font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch11a12.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH11/ch11a12.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="222" HEIGHT="77"> </font></p>

<p><font face="Arial" size="2">Normally, the <code>ForStmt</code> routine would pop <code>bp</code>
and return with a ret instruction, which removes <code>ForStmt</code>'s activation record
from the stack. Suppose, instead, <code>ForStmt</code> executes the following
instructions:</font></p>

<pre><font face="Courier New" size="2">                add     word ptr 2[b], 2        ;Skip the parameters.
                push    [bp+2]                  ;Make a copy of the rtn adrs.
                mov     bp, [bp]                ;Restore bp's value.
                ret                             ;Return to caller.</font></pre>

<p><font face="Arial" size="2">Just before the <code>ret</code> instruction above, the
stack has the entries shown below:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch11a13.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH11/ch11a13.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="207" HEIGHT="100"> </font></p>

<p><font face="Arial" size="2">Upon executing the <code>ret</code> instruction, <code>ForStmt</code>
will return to the proper return address but it will leave its activation record on the
stack!</font></p>

<p><font face="Arial" size="2">After executing the statements in the loop body, the
program calls the Next routine. Upon initial entry into Next (and setting up bp), the
stack contains the entries appearing below<a HREF="#FOOTNOTE-6">[6]</a>:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch11a14.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH11/ch11a14.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="221" HEIGHT="164"> </font></p>

<p><font face="Arial" size="2">The important thing to see here is that <code>ForStmt</code>'s
return address, that points at the first statement past the <code>word</code> directive,
is still on the stack and available to <code>Next</code> at offset <code>[bp+6]</code>. <code>Next</code>
can use this return address to gain access to the parameters and return to the appropriate
spot, if necessary. <code>Next</code> increments the loop control variable and compares it
to the ending value. If the loop control variable's value is less than the ending value, <code>Next</code>
pops its return address off the stack and returns through <code>ForStmt</code>'s return
address. If the loop control variable is greater than the ending value, <code>Next</code>
returns through its own return address and removes <code>ForStmt</code>'s activation
record from the stack. The following is the code for <code>Next</code> and <code>ForStmt</code>:</font></p>

<pre><font face="Courier New" size="2">                .xlist
                include         stdlib.a
                includelib      stdlib.lib
                .list

dseg            segment para public 'data'
I               word    ?
J               word    ?
dseg            ends

cseg            segment para public 'code'
                assume  cs:cseg, ds:dseg

wp              textequ &lt;word ptr&gt;

ForStmt         proc    near
                push    bp
                mov     bp, sp
                push    ax
                push    bx
                mov     bx, [bp+2]      ;Get return address
                mov     ax, cs:[bx+2]   ;Get starting value
                mov     bx, cs:[bx]     ;Get address of var
                mov     [bx], ax        ;var := starting value
                add     wp [bp+2], 6    ;Skip over parameters
                pop     bx
                pop     ax
                push    [bp+2]          ;Copy return address
                mov     bp, [bp]        ;Restore bp
                ret                     ;Leave Act Rec on stack
ForStmt         endp

Next            proc near
                push    bp
                mov     bp, sp
                push    ax
                push    bx
                mov     bx, [bp+6]      ;ForStmt's rtn adrs
                mov     ax, cs:[bx-2]   ;Ending value
                mov     bx, cs:[bx-6]   ;Ptr to loop ctrl var
                inc     wp [bx]         ;Bump up loop ctrl
                cmp     ax, [bx]        ;Is end val &lt; loop ctrl?
                jl      QuitLoop

; If we get here, the loop control variable is less than or equal 
; to the ending value. So we need to repeat the loop one more time.
; Copy ForStmt's return address over our own and then return, 
; leaving ForStmt's activation record intact.

                mov     ax, [bp+6]      ;ForStmt's return address
                mov     [bp+2], ax      ;Overwrite our return address
                pop     bx
                pop     ax
                pop     bp              ;Return to start of loop body
                ret

; If we get here, the loop control variable is greater than the 
; ending value, so we need to quit the loop (by returning to Next's 
; return address) and remove ForStmt's activation record.

QuitLoop:       pop     bx
                pop     ax
                pop     bp
                ret     4
Next            endp

Main            proc
                mov     ax, dseg
                mov     ds, ax
                mov     es, ax
                meminit

                call    ForStmt
                word    I,1,5
                call    ForStmt
                word    J,2,4
                printf
                byte    &quot;I=%d, J=%d\n&quot;,0
                dword   I,J

                call    Next            ;End of J loop
                call    Next            ;End of I loop
                print
                byte    &quot;All Done!&quot;,cr,lf,0

Quit:           ExitPgm
Main            endp
cseg            ends
sseg            segment para stack 'stack'
stk             byte    1024 dup (&quot;stack &quot;)
sseg            ends
zzzzzzseg       segment para public 'zzzzzz'
LastBytes       byte    16 dup (?)
zzzzzzseg       ends
                end     Main</font></pre>

<p><font face="Arial" size="2">The example code in the main program shows that these for
loops nest exactly as you would expect in a high level language like BASIC, Pascal, or C.
Of course, this is not a particularly good way to construct a for loop in assembly
language. It is many times slower than using the standard loop generation techniques (see
Chapter Ten for more details on that). Of course, if you don't care about speed, this is a
perfectly good way to implement a loop. It is certainly easier to read and understand than
the traditional methods for creating a <code>for</code> loop. For another (more efficient)
implementation of the <code>for</code> loop, check out the <code>ForLp</code> macros in
Chapter Eight.</font></p>

<p><font face="Arial" size="2">The code stream is a very convenient place to pass
parameters. The UCR Standard Library makes considerable use of this parameter passing
mechanism to make it easy to call certain routines. <code>Printf</code> is, perhaps, the
most complex example, but other examples (especially in the string library) abound. </font></p>

<p><font face="Arial" size="2">Despite the convenience, there are some disadvantages to
passing parameters in the code stream. First, if you fail to provide the exact number of
parameters the procedure requires, the subroutine will get very confused. Consider the UCR
Standard Library <code>print</code> routine. It prints a string of characters up to a zero
terminating byte and then returns control to the first instruction following the zero
terminating byte. If you leave off the zero terminating byte, the <code>print</code>
routine happily prints the following opcode bytes as ASCII characters until it finds a
zero byte. Since zero bytes often appear in the middle of an instruction, the <code>print</code>
routine might return control into the middle of some other instruction. This will probably
crash the machine. Inserting an extra zero, which occurs more often than you might think,
is another problem programmers have with the <code>print</code> routine. In such a case,
the <code>print</code> routine would return upon encountering the first zero byte and
attempt to execute the following ASCII characters as machine code. Once again, this
usually crashes the machine.</font></p>

<p><font face="Arial" size="2">Another problem with passing parameters in the code stream
is that it takes a little longer to access such parameters. Passing parameters in the
registers, in global variables, or on the stack is slightly more efficient, especially in
short routines. Nevertheless, accessing parameters in the code stream isn't extremely
slow, so the convenience of such parameters may outweigh the cost. Furthermore, many
routines (<code>print</code> is a good example) are so slow anyway that a few extra
microseconds won't make any difference.</font></p>

<hr noshade size="1" color="#000000">

<p><font face="Arial" size="2"><a NAME="FOOTNOTE-5"></a><strong>[5]</strong> Especially if
the parameter list changes frequently. </font></p>

<p><font face="Arial" size="2"><a NAME="FOOTNOTE-6"></a><strong>[6]</strong> Assuming the
loop does not push anything onto the stack, or pop anything off the stack. Should either
case occur, the ForStmt/Next loop would not work properly.</font> </p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH11-4.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH11-4.html">Chapter Eleven</a> (Part 4)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH11-6.html">Chapter Eleven</a> (Part 6)&nbsp; </strong></font><a href="CH11-6.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Eleven: Procedures and
Functions (Part 5)<br>
27 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_11/CH11-5.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:27:21 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
