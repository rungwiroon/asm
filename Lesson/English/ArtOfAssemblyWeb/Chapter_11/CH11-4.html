<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_11/CH11-4.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:27:10 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER ELEVEN: PROCEDURES AND FUNCTIONS (Part 4)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING4"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH11-3.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH11-3.html">Chapter Eleven</a> (Part 3)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH11-5.html">Chapter Eleven</a> (Part 5)&nbsp; </strong></font><a href="CH11-5.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10"><a NAME="HEADING4-1"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0"><font face="Arial" size="4"><strong>CHAPTER ELEVEN:<br>
    PROCEDURES AND FUNCTIONS (Part 4)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10"></td>
  </tr>
  <tr>
    <td width="100%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING4-1"><b>11.5.9 </b>-
    Passing Parameters on the Stack</a> </font></td>
  </tr>
  <tr>
    <td width="100%" valign="top" nowrap height="20"><font face="Arial" size="2"></font></td>
  </tr>
</table>
</center></div>

<h3><strong><font face="Arial" size="3">11.5.9 Passing Parameters on the Stack</font></strong></h3>

<p><font face="Arial" size="2">Most HLLs use the stack to pass parameters because this
method is fairly efficient. To pass parameters on the stack, push them immediately before
calling the subroutine. The subroutine then reads this data from the stack memory and
operates on it appropriately. Consider the following Pascal procedure call:</font></p>

<pre><font face="Courier New" size="2">		CallProc(i,j,k+4);</font></pre>

<p><font face="Arial" size="2">Most Pascal compilers push their parameters onto the stack
in the order that they appear in the parameter list. Therefore, the 80x86 code typically
emitted for this subroutine call (assuming you're passing the parameters by value) is</font></p>

<pre><font face="Courier New" size="2">                push    i
                push    j
                mov     ax, k
                add     ax, 4
                push    ax
                call    CallProc</font></pre>

<p><font face="Arial" size="2">Upon entry into <code>CallProc</code>, the 80x86's stack
looks like that shown below (for a near or a far procedure).</font></p>

<p align="center"><img SRC="images/ch11a4.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH11/ch11a4.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="232" HEIGHT="103"> </p>

<p align="center"><img SRC="images/ch11a5.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH11/ch11a5.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="232" HEIGHT="121"> </p>

<p><font face="Arial" size="2">You could gain access to the parameters passed on the stack
by removing the data from the stack (Assuming a near procedure call):</font></p>

<pre><font face="Courier New" size="2">CallProc        proc    near
                pop     RtnAdrs
                pop     kParm
                pop     jParm
                pop     iParm
                push    RtnAdrs
                 .
                 .
                 .
                ret
CallProc        endp</font></pre>

<p><font face="Arial" size="2">There is, however, a better way. The 80x86's architecture
allows you to use the <code>bp</code> (base pointer) register to access parameters passed
on the stack. This is one of the reasons the<code> disp[bp], [bp][di], [bp][si],
disp[bp][si],</code> and <code>disp[bp][di] </code>addressing modes use the stack segment
rather than the data segment. The following code segment gives the standard procedure
entry and exit code:</font></p>

<pre><font face="Courier New" size="2">StdProc         proc    near
                push    bp
                mov     bp, sp
                 .
                 .
                 .
                pop     bp
                ret     ParmSize
StdProc         endp</font></pre>
<code>

<p><font face="Arial" size="2">ParmSize</code> is the number of bytes of parameters pushed
onto the stack before calling the procedure. In the <code>CallProc</code> procedure there
were six bytes of parameters pushed onto the stack so <code>ParmSize</code> would be six. </font></p>

<p><font face="Arial" size="2">Take a look at the stack immediately after the execution of
<code>mov</code> <code>bp, sp </code>in <code>StdProc</code>. Assuming you've pushed three
parameter words onto the stack, it should look something like shown below:</font></p>

<p align="center"><img SRC="images/ch11a6.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH11/ch11a6.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="227" HEIGHT="121"> </p>

<p><font face="Arial" size="2">Now the parameters can be fetched by indexing off the <code>bp</code>
register:</font></p>

<pre><font face="Courier New" size="2">                mov     ax, 8[bp]        ;Accesses the first parameter
                mov     ax, 6[bp]        ;Accesses the second parameter
                mov     ax, 4[bp]        ;Accesses the third parameter</font></pre>

<p><font face="Arial" size="2">When returning to the calling code, the procedure must
remove these parameters from the stack. To accomplish this, pop the old <code>bp</code>
value off the stack and execute a <code>ret 6</code> instruction. This pops the return
address off the stack and adds six to the stack pointer, effectively removing the
parameters from the stack. </font></p>

<p><font face="Arial" size="2">The displacements given above are for near procedures only.
When calling a far procedure,</font>

<ul>
  <li><font face="Arial" size="2">0[BP] will point at the old BP value, </font></li>
  <li><font face="Arial" size="2">2[BP] will point at the offset portion of the return
    address, </font></li>
  <li><font face="Arial" size="2">4[BP] will point at the segment portion of the return
    address, and </font></li>
  <li><font face="Arial" size="2">6[BP] will point at the last parameter pushed onto the
    stack. </font></li>
</ul>

<p><font face="Arial" size="2">The stack contents when calling a far procedure are shown
below:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch11a7.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH11/ch11a7.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="232" HEIGHT="166"> </font></p>

<p><font face="Arial" size="2">This collection of parameters, return address, registers
saved on the stack, and other items, is a stack frame or activation record. </font></p>

<p><font face="Arial" size="2">When saving other registers onto the stack, always make
sure that you save and set up <code>bp</code> before pushing the other registers. If you
push the other registers before setting up <code>bp</code>, the offsets into the stack
frame will change. For example, the following code disturbs the ordering presented above:</font></p>

<pre><font face="Courier New" size="2">FunnyProc       proc    near
                push    ax
                push    bx
                push    bp
                mov     bp, sp
                 .
                 .
                 .
                pop     bp
                pop     bx
                pop     ax
                ret
FunnyProc       endp</font></pre>

<p><font face="Arial" size="2">Since this code pushes <code>ax</code> and <code>bx</code>
before pushing <code>bp</code> and copying <code>sp</code> to <code>bp</code>, <code>ax</code>
and <code>bx</code> appear in the activation record before the return address (that would
normally start at location <code>[bp+2]</code>). As a result, the value of <code>bx</code>
appears at location<code> [bp+2]</code> and the value of <code>ax</code> appears at
location <code>[bp+4]</code>. This pushes the return address and other parameters farther
up the stack as shown below:</font></p>

<p align="center"><img SRC="images/ch11a8.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH11/ch11a8.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="241" HEIGHT="187"> </p>

<p><font face="Arial" size="2">Although this is a near procedure, the parameters don't
begin until offset eight in the activation record. Had you pushed the <code>ax</code> and <code>bx</code>
registers after setting up <code>bp</code>, the offset to the parameters would have been
four:</font></p>

<p align="center"><img SRC="images/ch11a9.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH11/ch11a9.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="227" HEIGHT="114"> </p>

<pre><font face="Courier New" size="2">FunnyProc       proc    near
                push    bp
                mov     bp, sp
                push    ax
                push    bx
                 .
                 .
                 .
                pop     bx
                pop     ax
                pop     bp
                ret
FunnyProc       endp</font></pre>

<p><font face="Arial" size="2">Therefore, the <code>push bp</code> and <code>mov</code> <code>bp,
sp </code>instructions should be the first two instructions any subroutine executes when
it has parameters on the stack. </font></p>

<p><font face="Arial" size="2">Accessing the parameters using expressions like<code>
[bp+6]</code> can make your programs very hard to read and maintain. If you would like to
use meaningful names, there are several ways to do so. One way to reference parameters by
name is to use equates. Consider the following Pascal procedure and its equivalent 80x86
assembly language code:</font></p>

<pre><font face="Courier New" size="2">        procedure xyz(var i:integer; j,k:integer);
        begin
                i := j+k;
        end;</font></pre>

<p><font face="Arial" size="2">Calling sequence:</font></p>

<pre><font face="Courier New" size="2">                xyz(a,3,4);</font></pre>

<p><font face="Arial" size="2">Assembly language code:</font></p>

<pre><font face="Courier New" size="2">xyz_i           equ     8[bp]           ;Use equates so we can reference
xyz_j           equ     6[bp]           ; symbolic names in the body of
xyz_k           equ     4[bp]           ; the procedure.
xyz             proc    near
                push    bp
                mov     bp, sp
                push    es
                push    ax
                push    bx
                les     bx, xyz_i       ;Get address of I into ES:BX
                mov     ax, xyz_j       ;Get J parameter
                add     ax, xyz_k       ;Add to K parameter
                mov     es:[bx], ax     ;Store result into I parameter
                pop     bx
                pop     ax
                pop     es
                pop     bp
                ret     8
xyz             endp</font></pre>

<p><font face="Arial" size="2">Calling sequence:</font></p>

<pre><font face="Courier New" size="2">                mov     ax, seg a       ;This parameter is passed by
                push    ax              ; reference, so pass its
                mov     ax, offset a    ; address on the stack.
                push    ax
                mov     ax, 3           ;This is the second parameter
                push    ax
                mov     ax, 4           ;This is the third parameter.
                push    ax
                call    xyz</font></pre>

<p><font face="Arial" size="2">On an 80186 or later processor you could use the following
code in place of the above:</font></p>

<pre><font face="Courier New" size="2">                push    seg a           ;Pass address of &quot;a&quot; on the
                push    offset a        ; stack.
                push    3               ;Pass second parm by val.
                push    4               ;Pass third parm by val.
                call    xyz</font></pre>

<p><font face="Arial" size="2">Upon entry into the <code>xyz</code> procedure, before the
execution of the <code>les</code> instruction, the stack looks like shown below:</font></p>

<p align="center"><img SRC="images/ch11a10.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH11/ch11a10.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="225" HEIGHT="164"> </p>

<p><font face="Arial" size="2">Since you're passing I by reference, you must push its
address onto the stack. This code passes reference parameters using 32 bit segmented
addresses. Note that this code uses <code>ret 8</code>. Although there are three
parameters on the stack, the reference parameter<code> I </code>consumes four bytes since
it is a far address. Therefore there are eight bytes of parameters on the stack
necessitating the <code>ret 8</code> instruction.</font></p>

<p><font face="Arial" size="2">Were you to pass I by reference using a near pointer rather
than a far pointer, the code would look like the following:</font></p>

<pre><font face="Courier New" size="2">xyz_i           equ     8[bp]           ;Use equates so we can reference
xyz_j           equ     6[bp]           ; symbolic names in the body of
xyz_k           equ     4[bp]           ; the procedure.
xyz             proc    near
                push    bp
                mov     bp, sp
                push    ax
                push    bx
                mov     bx, xyz_i        ;Get address of I into BX
                mov     ax, xyz_j        ;Get J parameter
                add     ax, xyz_k        ;Add to K parameter
                mov     [bx], ax        ;Store result into I parameter
                pop     bx
                pop     ax
                pop     bp
                ret     6
xyz             endp</font></pre>

<p><font face="Arial" size="2">Note that since I's address on the stack is only two bytes
(rather than four), this routine only pops six bytes when it returns.</font></p>

<p><font face="Arial" size="2">Calling sequence:</font></p>

<pre><font face="Courier New" size="2">                mov     ax, offset a    ;Pass near address of a.
                push    ax
                mov     ax, 3           ;This is the second parameter
                push    ax
                mov     ax, 4           ;This is the third parameter.
                push    ax
                call    xyz</font></pre>

<p><font face="Arial" size="2">On an 80286 or later processor you could use the following
code in place of the above:</font></p>

<pre><font face="Courier New" size="2">                push    offset a        ;Pass near address of a.
                push    3               ;Pass second parm by val.
                push    4               ;Pass third parm by val.
                call    xyz</font></pre>

<p><font face="Arial" size="2">The stack frame for the above code appears below:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch11a11.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH11/ch11a11.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="225" HEIGHT="141"> </font></p>

<p><font face="Arial" size="2">When passing a parameter by value-returned or result, you
pass an address to the procedure, exactly like passing the parameter by reference. The
only difference is that you use a local copy of the variable within the procedure rather
than accessing the variable indirectly through the pointer. The following implementations
for <code>xyz</code> show how to pass<code> I </code>by value-returned and by result:</font></p>

<pre><font face="Courier New" size="2">; xyz version using Pass by Value-Returned for xyz_i

xyz_i           equ     8[bp]           ;Use equates so we can reference
xyz_j           equ     6[bp]           ; symbolic names in the body of
xyz_k           equ     4[bp]           ; the procedure.

xyz             proc    near
                push    bp
                mov     bp, sp
                push    ax
                push    bx
                push    cx              ;Keep local copy here.

                mov     bx, xyz_i        ;Get address of I into BX
                mov     cx, [bx]        ;Get local copy of I parameter.

                mov     ax, xyz_j        ;Get J parameter
                add     ax, xyz_k        ;Add to K parameter
                mov     cx, ax          ;Store result into local copy

                mov     bx, xyz_i       ;Get ptr to I, again
                mov     [bx], cx        ;Store result away.

                pop     cx
                pop     bx
                pop     ax
                pop     bp
                ret     6
xyz             endp</font></pre>

<p><font face="Arial" size="2">There are a couple of unnecessary mov instructions in this
code. They are present only to precisely implement pass by value-returned parameters. It
is easy to improve this code using pass by result parameters. The modified code is</font></p>

<pre><font face="Courier New" size="2">; xyz version using Pass by Result for xyz_i

xyz_i           equ     8[bp]           ;Use equates so we can reference
xyz_j           equ     6[bp]           ; symbolic names in the body of
xyz_k           equ     4[bp]           ; the procedure.

xyz             proc    near
                push    bp
                mov     bp, sp
                push    ax
                push    bx
                push    cx              ;Keep local copy here.

                mov     ax, xyz_j        ;Get J parameter
                add     ax, xyz_k        ;Add to K parameter
                mov     cx, ax          ;Store result into local copy

                mov     bx, xyz_i       ;Get ptr to I, again
                mov     [bx], cx        ;Store result away.

                pop     cx
                pop     bx
                pop     ax
                pop     bp
                ret     6
xyz             endp</font></pre>

<p><font face="Arial" size="2">As with passing value-returned and result parameters in
registers, you can improve the performance of this code using a modified form of pass by
value. Consider the following implementation of xyz:</font></p>

<pre><font face="Courier New" size="2">; xyz version using modified pass by value-result for xyz_i

xyz_i           equ     8[bp]           ;Use equates so we can reference
xyz_j           equ     6[bp]           ; symbolic names in the body of
xyz_k           equ     4[bp]           ; the procedure.

xyz             proc    near
                push    bp
                mov     bp, sp
                push    ax

                mov     ax, xyz_j       ;Get J parameter
                add     ax, xyz_k       ;Add to K parameter
                mov     xyz_i, ax       ;Store result into local copy

                pop     ax
                pop     bp
                ret     4               ;Note that we do not pop I parm.
xyz             endp

The calling sequence for this code is
                push    a               ;Pass a's value to xyz.
                push    3               ;Pass second parameter by val.
                push    4               ;Pass third parameter by val.
                call    xyz
                pop     a</font></pre>

<p><font face="Arial" size="2">Note that a pass by result version wouldn't be practical
since you have to push something on the stack to make room for the local copy of I inside
xyz. You may as well push the value of a on entry even though the xyz procedure ignores
it. This procedure pops only four bytes off the stack on exit. This leaves the value of
the I parameter on the stack so that the calling code can store it away to the proper
destination.</font></p>

<p><font face="Arial" size="2">To pass a parameter by name on the stack, you simply push
the address of the thunk. Consider the following pseudo-Pascal code:</font></p>

<pre><font face="Courier New" size="2">procedure swap(name Item1, Item2:integer);
var temp:integer;
begin

        temp := Item1;
        Item1 := Item2;
        Item2 := Temp;

end;</font></pre>

<p><font face="Arial" size="2">If swap is a near procedure, the 80x86 code for this
procedure could look like the following (note that this code has been slightly optimized
and does not following the exact sequence given above):</font></p>

<pre><font face="Courier New" size="2">; swap-         swaps two parameters passed by name on the stack.
;               Item1 is passed at address [bp+6], Item2 is passed
;               at address [bp+4]

wp              textequ &lt;word ptr&gt;
swap_Item1      equ     [bp+6]
swap_Item2      equ     [bp+4]

swap            proc    near
                push    bp
                mov     bp, sp
                push    ax                      ;Preserve temp value.
                push    bx                      ;Preserve bx.
                call    wp swap_Item1           ;Get adrs of Item1.
                mov     ax, [bx]                ;Save in temp (AX).
                call    wp swap_Item2           ;Get adrs of Item2.
                xchg    ax, [bx]                ;Swap temp &lt;-&gt; Item2.
                call    wp swap_Item1           ;Get adrs of Item1.
                mov     [bx], ax                ;Save temp in Item1.
                pop     bx                      ;Restore bx.
                pop     ax                      ;Restore ax.
                ret     4                       ;Return and pop Item1/2.
swap            endp</font></pre>

<p><font face="Arial" size="2">Some sample calls to swap follow:</font></p>

<pre><font face="Courier New" size="2">; swap(A[i], i) -- 8086 version.

                lea     ax, thunk1
                push    ax
                lea     ax, thunk2
                push    ax
                call    swap

; swap(A[i],i) -- 80186 &amp; later version.

                push    offset thunk1
                push    offset thunk2
                call    swap

                 .
                 .
                 .

; Note: this code assumes A is an array of two byte integers.

thunk1          proc    near
                mov     bx, i
                shl     bx, 1
                lea     bx, A[bx]
                ret
thunk1          endp

thunk2          proc    near
                lea     bx, i
                ret
thunk2          endp</font></pre>

<p><font face="Arial" size="2">The code above assumes that the thunks are near procs that
reside in the same segment as the swap routine. If the thunks are far procedures the
caller must pass far addresses on the stack and the swap routine must manipulate far
addresses. The following implementation of swap, thunk1, and thunk2 demonstrate this.</font></p>

<pre><font face="Courier New" size="2">; swap-         swaps two parameters passed by name on the stack.
;               Item1 is passed at address [bp+10], Item2 is passed
;               at address [bp+6]

swap_Item1      equ     [bp+10]
swap_Item2      equ     [bp+6]
dp              textequ &lt;dword ptr&gt;

swap            proc    far
                push    bp
                mov     bp, sp
                push    ax              ;Preserve temp value.
                push    bx              ;Preserve bx.
                push    es              ;Preserve es.
                call    dp swap_Item1   ;Get adrs of Item1.
                mov     ax, es:[bx]     ;Save in temp (AX).
                call    dp swap_Item2   ;Get adrs of Item2.
                xchg    ax, es:[bx]     ;Swap temp &lt;-&gt; Item2.
                call    dp swap_Item1   ;Get adrs of Item1.
                mov     es:[bx], ax     ;Save temp in Item1.
                pop     es              ;Restore es.
                pop     bx              ;Restore bx.
                pop     ax              ;Restore ax.
                ret     8               ;Return and pop Item1, Item2.
swap            endp</font></pre>

<p><font face="Arial" size="2">Some sample calls to swap follow:</font></p>

<pre><font face="Courier New" size="2">; swap(A[i], i) -- 8086 version.

                mov     ax, seg thunk1
                push    ax
                lea     ax, thunk1
                push    ax
                mov     ax, seg thunk2
                push    ax
                lea     ax, thunk2
                push    ax
                call    swap

; swap(A[i],i) -- 80186 &amp; later version.

                push    seg thunk1
                push    offset thunk1
                push    seg thunk2
                push    offset thunk2
                call    swap

                 .
                 .
                 .

; Note:         this code assumes A is an array of two byte integers.
;               Also note that we do not know which segment(s) contain
;               A and I.

thunk1          proc    far
                mov     bx, seg A       ;Need to return seg A in ES.
                push    bx              ;Save for later.
                mov     bx, seg i       ;Need segment of I in order
                mov     es, bx          ; to access it.
                mov     bx, es:i        ;Get I's value.
                shl     bx, 1
                lea     bx, A[bx]
                pop     es              ;Return segment of A[I] in es.
                ret
thunk1          endp

thunk2          proc    near
                mov     bx, seg i       ;Need to return I's seg in es.
                mov     es, bx
                lea     bx, i
                ret
thunk2          endp</font></pre>

<p><font face="Arial" size="2">Passing parameters by lazy evaluation is left for the
programming projects.</font></p>

<p><font face="Arial" size="2">Additional information on activation records and stack
frames appears later in this chapter in the section on local variables. </font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH11-3.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH11-3.html">Chapter Eleven</a> (Part 3)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH11-5.html">Chapter Eleven</a> (Part 5)&nbsp; </strong></font><a href="CH11-5.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Eleven: Procedures and
Functions (Part 4)<br>
27 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_11/CH11-4.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:27:18 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
