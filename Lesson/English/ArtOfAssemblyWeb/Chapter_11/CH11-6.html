<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_11/CH11-6.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:27:22 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER ELEVEN: PROCEDURES AND FUNCTIONS (Part 6)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING6"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH11-5.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH11-5.html">Chapter Eleven</a> (Part 5)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH11-7.html">Chapter Eleven</a> (Part 7)&nbsp; </strong></font><a href="CH11-7.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10" colspan="2"><a NAME="HEADING6-1"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0" colspan="2"><font face="Arial" size="4"><strong>CHAPTER
    ELEVEN:<br>
    PROCEDURES AND FUNCTIONS (Part 6)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10" colspan="2"></td>
  </tr>
  <tr>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING6-1"><b>11.5.11 </b>-
    Passing Parameters via a Parameter Block</a> <br>
    <a HREF="#HEADING6-120"><b>11.6 </b>- Function Results</a> <br>
    <a HREF="#HEADING6-123"><b>11.6.1 </b>- Returning Function Results in a Register</a> </font></td>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING6-135"><b>11.6.2
    </b>- Returning Function Results on the Stack</a> <br>
    <a HREF="#HEADING6-182"><b>11.6.3 </b>- Returning Function Results in Memory Locations</a>
    <br>
    <a HREF="#HEADING6-186"><b>11.7 </b>- Side Effects</a> </font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="20" colspan="2"></td>
  </tr>
</table>
</center></div>

<h3><strong><font face="Arial" size="3">11.5.11 Passing Parameters via a Parameter Block</font></strong></h3>

<p><font face="Arial" size="2">Another way to pass parameters in memory is through a
parameter block. A parameter block is a set of contiguous memory locations containing the
parameters. To access such parameters, you would pass the subroutine a pointer to the
parameter block. Consider the subroutine from the previous section that adds J and K
together, storing the result in I; the code that passes these parameters through a
parameter block might be.</font></p>

<p><font face="Arial" size="2">Calling sequence:</font></p>

<pre><font face="Courier New" size="2">ParmBlock       dword   I
I               word    ?               ;I, J, and K must appear in
J               word    ?               ; this order.
K               word    ?
                 .
                 .
                 .
                les     bx, ParmBlock
                call    AddEm
                 .
                 .
                 .
AddEm           proc    near
                push    ax
                mov     ax, es:2[bx]    ;Get J's value
                add     ax, es:4[bx]    ;Add in K's value
                mov     es:[bx], ax     ;Store result in I
                pop     ax
                ret
AddEm           endp</font></pre>

<p><font face="Arial" size="2">Note that you must allocate the three parameters in
contiguous memory locations. </font></p>

<p><font face="Arial" size="2">This form of parameter passing works well when passing
several parameters by reference, because you can initialize pointers to the parameters
directly within the assembler. For example, suppose you wanted to create a subroutine <code>rotate</code>
to which you pass four parameters by reference. This routine would copy the second
parameter to the first, the third to the second, the fourth to the third, and the first to
the fourth. Any easy way to accomplish this in assembly is</font></p>

<pre><font face="Courier New" size="2">; Rotate-               On entry, BX points at a parameter block in the data
;               segment that points at four far pointers. This code
;               rotates the data referenced by these pointers.

Rotate          proc    near
                push    es              ;Need to preserve these
                push    si              ; registers
                push    ax

                les     si, [bx+4]      ;Get ptr to 2nd var
                mov     ax, es:[si]     ;Get its value
                les     si, [bx]        ;Get ptr to 1st var
                xchg    ax, es:[si]     ;2nd-&gt;1st, 1st-&gt;ax
                les     si, [bx+12]     ;Get ptr to 4th var
                xchg    ax, es:[si]     ;1st-&gt;4th, 4th-&gt;ax
                les     si, [bx+8]      ;Get ptr to 3rd var
                xchg    ax, es:[si]     ;4th-&gt;3rd, 3rd-&gt;ax
                les     si, [bx+4]      ;Get ptr to 2nd var
                mov     es:[si], ax     ;3rd -&gt; 2nd

                pop     ax
                pop     si
                pop     es
                ret
Rotate          endp</font></pre>

<p><font face="Arial" size="2">To call this routine, you pass it a pointer to a group of
four far pointers in the bx register. For example, suppose you wanted to rotate the first
elements of four different arrays, the second elements of those four arrays, and the third
elements of those four arrays. You could do this with the following code:</font></p>

<pre><font face="Courier New" size="2">                lea     bx, RotateGrp1
                call    Rotate
                lea     bx, RotateGrp2
                call    Rotate
                lea     bx, RotateGrp3
                call    Rotate
                 .
                 .
                 .
RotateGrp1              dword   ary1[0], ary2[0], ary3[0], ary4[0]
RotateGrp2              dword   ary1[2], ary2[2], ary3[2], ary4[2]
RotateGrp3              dword   ary1[4], ary2[4], ary3[4], ary4[4]</font></pre>

<p><font face="Arial" size="2">Note that the pointer to the parameter block is itself a
parameter. The examples in this section pass this pointer in the registers. However, you
can pass this pointer anywhere you would pass any other reference parameter - in
registers, in global variables, on the stack, in the code stream, even in another
parameter block! Such variations on the theme, however, will be left to your own
imagination. As with any parameter, the best place to pass a pointer to a parameter block
is in the registers. This text will generally adopt that policy.</font></p>

<p><font face="Arial" size="2">Although beginning assembly language programmers rarely use
parameter blocks, they certainly have their place. Some of the IBM PC BIOS and MS-DOS
functions use this parameter passing mechanism. Parameter blocks, since you can initialize
their values during assembly (using <code>byte</code>, <code>word</code>, etc.), provide a
fast, efficient way to pass parameters to a procedure.</font></p>

<p><font face="Arial" size="2">Of course, you can pass parameters by value, reference,
value-returned, result, or by name in a parameter block. The following piece of code is a
modification of the <code>Rotate</code> procedure above where the first parameter is
passed by value (its value appears inside the parameter block), the second is passed by
reference, the third by value-returned, and the fourth by name (there is no pass by result
since <code>Rotate</code> needs to read and write all values). For simplicity, this code
uses near pointers and assumes all variables appear in the data segment:</font></p>

<pre><font face="Courier New" size="2">; Rotate-       On entry, DI points at a parameter block in the data
;               segment that points at four pointers. The first is
;               a value parameter, the second is passed by reference,
;               the third is passed by value/return, the fourth is
;               passed by name.

Rotate          proc    near
                push    si              ;Used to access ref parms
                push    ax              ;Temporary
                push    bx              ;Used by pass by name parm
                push    cx              ;Local copy of val/ret parm

                mov     si, [di+4]      ;Get a copy of val/ret parm
                mov     cx, [si]

                mov     ax, [di]        ;Get 1st (value) parm
                call    word ptr [di+6] ;Get ptr to 4th var
                xchg    ax, [bx]        ;1st-&gt;4th, 4th-&gt;ax
                xchg    ax, cx          ;4th-&gt;3rd, 3rd-&gt;ax
                mov     bx, [di+2]      ;Get adrs of 2nd (ref) parm
                xchg    ax, [bx]        ;3rd-&gt;2nd, 2nd-&gt;ax
                mov     [di], ax        ;2nd-&gt;1st

                mov     bx, [di+4]      ;Get ptr to val/ret parm
                mov     [bx], cx        ;Save val/ret parm away.

                pop     cx
                pop     bx
                pop     ax
                pop     si
                ret
Rotate          endp</font></pre>

<p><font face="Arial" size="2">A reasonable example of a call to this routine might be:</font></p>

<pre><font face="Courier New" size="2">I               word    10
J               word    15
K               word    20
RotateBlk       word    25, I, J, KThunk
                 .
                 .
                 .
                lea     di, RotateBlk
                call    Rotate
                 .
                 .
                 .
KThunk          proc    near
                lea     bx, K
                ret
KThunk          endp</font></pre>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3">11.6 Function Results</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">Functions return a result, which is nothing more than a
result parameter. In assembly language, there are very few differences between a procedure
and a function. That is probably why there aren't any &quot;<code>func</code>&quot; or
&quot;<code>endf</code>&quot; directives. Functions and procedures are usually different
in HLLs, function calls appear only in expressions, subroutine calls as statements<a HREF="#FOOTNOTE-7">[7]</a>. Assembly language doesn't distinguish between them. </font></p>

<p><font face="Arial" size="2">You can return function results in the same places you pass
and return parameters. Typically, however, a function returns only a single value (or
single data structure) as the function result. The methods and locations used to return
function results is the subject of the next three sections.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING6-123"></a>11.6.1 Returning
Function Results in a Register</font></strong></p>

<p><font face="Arial" size="2">Like parameters, the 80x86's registers are the best place
to return function results. The <code>getc</code> routine in the UCR Standard Library is a
good example of a function that returns a value in one of the CPU's registers. It reads a
character from the keyboard and returns the ASCII code for that character in the <code>al</code>
register. Generally, functions return their results in the following registers:</font></p>

<pre><font face="Courier New" size="2">Use                     First                     Last 
Bytes:                  al, ah, dl, dh, cl, ch, bl, bh 
Words:                  ax, dx, cx, si, di, bx 
Double words:           dx:ax                           On pre-80386
                        eax, edx, ecx, esi, edi, ebx    On 80386 and later.
16-bitOffsets:          bx, si, di, dx
32-bit Offsets          ebx, esi , edi, eax, ecx, edx
Segmented Pointers:     es:di, es:bx, dx:ax, es:si      Do not use DS.</font></pre>

<p><font face="Arial" size="2">Once again, this table represents general guidelines. If
you're so inclined, you could return a double word value in (<code>cl, dh, al, bh</code>).
If you're returning a function result in some registers, you shouldn't save and restore
those registers. Doing so would defeat the whole purpose of the function.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING6-135"></a>11.6.2 Returning
Function Results on the Stack</font></strong></p>

<p><font face="Arial" size="2">Another good place where you can return function results is
on the stack. The idea here is to push some dummy values onto the stack to create space
for the function result. The function, before leaving, stores its result into this
location. When the function returns to the caller, it pops everything off the stack except
this function result. Many HLLs use this technique (although most HLLs on the IBM PC
return function results in the registers). The following code sequences show how values
can be returned on the stack:</font></p>

<pre><font face="Courier New" size="2">        function PasFunc(i,j,k:integer):integer;
        begin
                PasFunc := i+j+k;
        end;

        m := PasFunc(2,n,l);
</font></pre>

<p><font face="Arial" size="2">In assembly:</font></p>

<pre><font face="Courier New" size="2">PasFunc_rtn     equ     10[bp]
PasFunc_i       equ     8[bp]
PasFunc_j       equ     6[bp]
PasFunc_k       equ     4[bp]

PasFunc         proc    near
                push    bp
                mov     bp, sp
                push    ax
                mov     ax, PasFunc_i
                add     ax, PasFunc_j
                add     ax, PasFunc_k
                mov     PasFunc_rtn, ax
                pop     ax
                pop     bp
                ret     6
PasFunc         endp</font></pre>

<p><font face="Arial" size="2">Calling sequence:</font></p>

<pre><font face="Courier New" size="2">                push    ax              ;Space for function return result
                mov     ax, 2
                push    ax
                push    n
                push    l
                call    PasFunc
                pop     ax              ;Get function return result</font></pre>

<p><font face="Arial" size="2">On an 80286 or later processor you could also use the code:</font></p>

<pre><font face="Courier New" size="2">                push    ax              ;Space for function return result
                push    2
                push    n
                push    l
                call    PasFunc
                pop     ax              ;Get function return result</font></pre>

<p><font face="Arial" size="2">Although the caller pushed eight bytes of data onto the
stack, PasFunc only removes six. The first &quot;parameter&quot; on the stack is the
function result. The function must leave this value on the stack when it returns.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING6-182"></a>11.6.3 Returning
Function Results in Memory Locations</font></strong></p>

<p><font face="Arial" size="2">Another reasonable place to return function results is in a
known memory location. You can return function values in global variables or you can
return a pointer (presumably in a register or a register pair) to a parameter block. This
process is virtually identical to passing parameters to a procedure or function in global
variables or via a parameter block. </font></p>

<p><font face="Arial" size="2">Returning parameters via a pointer to a parameter block is
an excellent way to return large data structures as function results. If a function
returns an entire array, the best way to return this array is to allocate some storage,
store the data into this area, and leave it up to the calling routine to deallocate the
storage. Most high level languages that allow you to return large data structures as
function results use this technique.</font></p>

<p><font face="Arial" size="2">Of course, there is very little difference between
returning a function result in memory and the pass by result parameter passing mechanism.
See &quot;Pass by Result&quot; for more details.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING6-186"></a>11.7 Side
    Effects</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">A side effect is any computation or operation by a
procedure that isn't the primary purpose of that procedure. For example, if you elect not
to preserve all affected registers within a procedure, the modification of those registers
is a side effect of that procedure. Side effect programming, that is, the practice of
using a procedure's side effects, is very dangerous. All too often a programmer will rely
on a side effect of a procedure. Later modifications may change the side effect,
invalidating all code relying on that side effect. This can make your programs hard to
debug and maintain. Therefore, you should avoid side effect programming. </font></p>

<p><font face="Arial" size="2">Perhaps some examples of side effect programming will help
enlighten you to the difficulties you may encounter. The following procedure zeros out an
array. For efficiency reasons, it makes the caller responsible for preserving necessary
registers. As a result, one side effect of this procedure is that the <code>bx</code> and <code>cx</code>
registers are modified. In particular, the <code>cx</code> register contains zero upon
return.</font></p>

<pre><font face="Courier New" size="2">ClrArray        proc    near
                lea     bx, array
                mov     cx, 32
ClrLoop:        mov     word ptr [bx], 0
                inc     bx
                inc     bx
                loop    ClrLoop
                ret
ClrArray        endp</font></pre>

<p><font face="Arial" size="2">If your code expects <code>cx</code> to contain zero after
the execution of this subroutine, you would be relying on a side effect of the <code>ClrArray</code>
procedure. The main purpose behind this code is zeroing out an array, not setting the <code>cx</code>
register to zero. Later, if you modify the <code>ClrArray</code> procedure to the
following, your code that depends upon <code>cx</code> containing zero would no longer
work properly:</font></p>

<pre><font face="Courier New" size="2">ClrArray        proc    near
                lea     bx, array
ClrLoop:        mov     word ptr [bx], 0
                inc     bx
                inc     bx
                cmp     bx, offset array+32
                jne     ClrLoop
                ret
ClrArray        endp</font></pre>

<p><font face="Arial" size="2">So how can you avoid the pitfalls of side effect
programming in your procedures? By carefully structuring your code and paying close
attention to exactly how your calling code and the subservient procedures interface with
one another. These rules can help you avoid problems with side effect programming: </font>

<ul>
  <li><font face="Arial" size="2">Always properly document the input and output conditions of
    a procedure. Never rely on any other entry or exit conditions other than these documented
    operations. </font></li>
  <li><font face="Arial" size="2">Partition your procedures so that they compute a single
    value or execute a single operation. Subroutines that do two or more tasks are, by
    definition, producing side effects unless every invocation of that subroutine requires all
    the computations and operations. </font></li>
  <li><font face="Arial" size="2">When updating the code in a procedure, make sure that it
    still obeys the entry and exit conditions. If not, either modify the program so that it
    does or update the documentation for that procedure to reflect the new entry and exit
    conditions. </font></li>
  <li><font face="Arial" size="2">Avoid passing information between routines in the CPU's flag
    register. Passing an error status in the carry flag is about as far as you should ever go.
    Too many instructions affect the flags and it's too easy to foul up a return sequence so
    that an important flag is modified on return. </font></li>
  <li><font face="Arial" size="2">Always save and restore all registers a procedure modifies. </font></li>
  <li><font face="Arial" size="2">Avoid passing parameters and function results in global
    variables. </font></li>
  <li><font face="Arial" size="2">Avoid passing parameters by reference (with the intent of
    modifying them for use by the calling code). </font></li>
</ul>

<p><font face="Arial" size="2">These rules, like all other rules, were meant to be broken.
Good programming practices are often sacrificed on the altar of efficiency. There is
nothing wrong with breaking these rules as often as you feel necessary. However, your code
will be difficult to debug and maintain if you violate these rules often. But such is the
price of efficiency<a HREF="#FOOTNOTE-8">[8]</a>. Until you gain enough experience to make
a judicious choice about the use of side effects in your programs, you should avoid them.
More often than not, the use of a side effect will cause more problems than it solves.</font></p>

<hr noshade size="1" color="#000000">

<p><font face="Arial" size="2"><a NAME="FOOTNOTE-7"></a><strong>[7]</strong> &quot;C&quot;
is an exception to this rule. C's procedures and functions are all called functions. PL/I
is another exception. In PL/I, they're all called procedures. </font></p>

<p><font face="Arial" size="2"><a NAME="FOOTNOTE-8"></a><strong>[8]</strong> This is not
just a snide remark. Expert programmers who have to wring the last bit of performance out
of a section of code often resort to poor programming practices in order to achieve their
goals. They are prepared, however, to deal with the problems that are often encountered in
such situations and they are a lot more careful when dealing with such code.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH11-5.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH11-5.html">Chapter Eleven</a> (Part 5)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH11-7.html">Chapter Eleven</a> (Part 7)&nbsp; </strong></font><a href="CH11-7.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Eleven: Procedures and
Functions (Part 6)<br>
27 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_11/CH11-6.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:27:22 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
