<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_11/CH11-1.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:27:03 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER ELEVEN: PROCEDURES AND FUNCTIONS (Part 1)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING1"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="../Chapter_10/CH10-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="../Chapter_10/CH10-1.html">Chapter
    Ten</a></strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH11-2.html">Chapter Eleven</a> (Part 2)&nbsp; </strong></font><a href="CH11-2.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3" bgcolor="#FFFFFF" nowrap height="10"><a NAME="HEADING1-0"></a></td>
  </tr>
  <tr>
    <td width="100%" colspan="3" bgcolor="#F0F0F0"><font face="Arial" size="4"><strong>CHAPTER
    ELEVEN:<br>
    PROCEDURES AND FUNCTIONS (Part 1)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" colspan="3" nowrap height="10"></td>
  </tr>
  <tr>
    <td width="40%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING1-4"><b>11.0 </b>-
    Chapter Overview</a> <br>
    <a HREF="#HEADING1-28"><b>11.1 </b>- Procedures</a> <br>
    <a HREF="#HEADING1-133"><b>11.2 </b>- Near and Far Procedures</a> <br>
    <a HREF="#HEADING1-144"><b>11.2.1 </b>- Forcing NEAR or FAR CALLs and Returns</a> <br>
    <a HREF="#HEADING1-163"><b>11.2.2 </b>- Nested Procedures</a> <br>
    <a HREF="#HEADING1-280"><b>11.3 </b>- Functions</a> <br>
    <a HREF="#HEADING1-282"><b>11.4 </b>- Saving the State of the Machine</a> <br>
    <a HREF="CH11-2.html#HEADING2-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH11/CH11-2.html#HEADING2-1"><b>11.5 </b>-
    Parameters</a> <br>
    <a HREF="CH11-2.html#HEADING2-23" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH11/CH11-2.html#HEADING2-23"><b>11.5.1
    </b>- Pass by Value</a> <br>
    <a HREF="CH11-2.html#HEADING2-29" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH11/CH11-2.html#HEADING2-29"><b>11.5.2
    </b>- Pass by Reference</a> <br>
    <a HREF="CH11-2.html#HEADING2-57" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH11/CH11-2.html#HEADING2-57"><b>11.5.3
    </b>- Pass by Value-Returned</a> <br>
    <a HREF="CH11-2.html#HEADING2-61" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH11/CH11-2.html#HEADING2-61"><b>11.5.4
    </b>- Pass by Result</a> <br>
    <a HREF="CH11-2.html#HEADING2-63" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH11/CH11-2.html#HEADING2-63"><b>11.5.5
    </b>- Pass by Name</a> <br>
    <a HREF="CH11-2.html#HEADING2-117" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH11/CH11-2.html#HEADING2-117"><b>11.5.6
    </b>- Pass by Lazy-Evaluation</a> <br>
    <a HREF="CH11-3.html#HEADING3-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH11/CH11-3.html#HEADING3-1"><b>11.5.7
    </b>- Passing Parameters in Registers</a> <br>
    <a HREF="CH11-3.html#HEADING3-118" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH11/CH11-3.html#HEADING3-118"><b>11.5.8
    </b>- Passing Parameters in Global Variables</a> <br>
    <a HREF="CH11-4.html#HEADING4-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH11/CH11-4.html#HEADING4-1"><b>11.5.9
    </b>- Passing Parameters on the Stack</a> <br>
    <a HREF="CH11-5.html#HEADING5-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH11/CH11-5.html#HEADING5-1"><b>11.5.10
    </b>- Passing Parameters in the Code Stream</a> <br>
    <a HREF="CH11-6.html#HEADING6-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH11/CH11-6.html#HEADING6-1"><b>11.5.11
    </b>- Passing Parameters via a Parameter Block</a> <br>
    <a HREF="CH11-6.html#HEADING6-120" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH11/CH11-6.html#HEADING6-120"><b>11.6
    </b>- Function Results</a> <br>
    <a HREF="CH11-6.html#HEADING6-123" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH11/CH11-6.html#HEADING6-123"><b>11.6.1
    </b>- Returning Function Results in a Register</a> <br>
    <a HREF="CH11-6.html#HEADING6-135" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH11/CH11-6.html#HEADING6-135"><b>11.6.2
    </b>- Returning Function Results on the Stack</a> <br>
    <a HREF="CH11-6.html#HEADING6-182" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH11/CH11-6.html#HEADING6-182"><b>11.6.3
    </b>- Returning Function Results in Memory Locations</a> <br>
    <a HREF="CH11-6.html#HEADING6-186" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH11/CH11-6.html#HEADING6-186"><b>11.7
    </b>- Side Effects</a> <br>
    <a HREF="CH11-7.html#HEADING7-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH11/CH11-7.html#HEADING7-1"><b>11.8 </b>-
    Local Variable Storage</a> <br>
    <a HREF="CH11-7.html#HEADING7-86" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH11/CH11-7.html#HEADING7-86"><b>11.9 </b>-
    Recursion</a> <br>
    <a HREF="CH11-8.html#HEADING8-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH11/CH11-8.html#HEADING8-1"><b>11.10 </b>-
    Sample Program</a> </font></td>
    <td width="20" nowrap valign="top"></td>
    <td width="60%" valign="top"><font size="1" face="Arial">Copyright 1996 by Randall Hyde
    All rights reserved. <br>
    <br>
    Duplication other than for immediate display through a browser is prohibited by U.S.
    Copyright Law. <br>
    This material is provided on-line as a beta-test of this text. It is for the personal use
    of the reader only. If you are interested in using this material as part of a course,
    please contact rhyde@cs.ucr.edu <br>
    <br>
    Supporting software and other materials are available via anonymous ftp from
    ftp.cs.ucr.edu. See the &quot;/pub/pc/ibmpcdir&quot; directory for details. You may also
    download the material from &quot;Randall Hyde's Assembly Language Page&quot; at URL:
    http://webster.ucr.edu<br>
    <br>
    Notes: <br>
    This document does not contain the laboratory exercises, programming assignments,
    exercises, or chapter summary. These portions were omitted for several reasons: either
    they wouldn't format properly, they contained hyperlinks that were too much work to
    resolve, they were under constant revision, or they were not included for security
    reasons. Such omission should have very little impact on the reader interested in learning
    this material or evaluating this document. <br>
    <br>
    This document was prepared using Harlequin's Web Maker 2.2 and Quadralay's Webworks
    Publisher. Since HTML does not support the rich formatting options available in
    Framemaker, this document is only an approximation of the actual chapter from the
    textbook. <br>
    <br>
    If you are absolutely dying to get your hands on a version other than HTML, you might
    consider having the UCR Printing a Reprographics Department run you off a copy on their
    Xerox machines. For details, please read the following EMAIL message I received from the
    Printing and Reprographics Department: </font><blockquote>
      <p><font size="1" face="Arial">Hello Again Professor Hyde,<br>
      <br>
      Dallas gave me permission to take orders for the Computer Science 13 Manuals. We would
      need to take charge card orders. The only cards we take are: Master Card, Visa, and
      Discover. They would need to send the name, numbers, expiration date, type of card, and
      authorization to charge $95.00 for the manual and shipping, also we should have their
      phone number in case the company has any trouble delivery. They can use my e-mail address
      for the orders and I will process them as soon as possible. I would assume that two weeks
      would be sufficient for printing, packages and delivery time.<br>
      <br>
      I am open to suggestions if you can think of any to make this as easy as possible.<br>
      <br>
      Thank You for your business,<br>
      Kathy Chapman, Assistant<br>
      Printing and Reprographics University of California Riverside (909) 787-4443/4444 </font></p>
    </blockquote>
    <p><font size="1" face="Arial">We are currently working on ways to publish this text in a
    form other than HTML (e.g., Postscript, PDF, Frameviewer, hard copy, etc.). This, however,
    is a low-priority project. Please do not contact Randall Hyde concerning this effort. When
    something happens, an announcement will appear on &quot;Randall Hyde's Assembly Language
    Page.&quot; Please visit this WEB site at http://webster.ucr.edu for the latest scoop.</font></p>
    <p><font size="1" face="Arial">Redesigned 10/2000 with &quot;MS FrontPage 98&quot; using
    17&quot; monitor 1024x768<br>
    (c) 2000 <a href="mail%20to_%20bircom_yanoo.html">BIRCOM Entertainment'95</a></font></td>
  </tr>
</table>
</center></div>

<hr noshade size="1" color="#000000">

<p><font face="Arial" size="2">Modular design is one of the cornerstones of structured
programming. A modular program contains blocks of code with single entry and exit points.
You can reuse well written sections of code in other programs or in other sections of an
existing program. If you reuse an existing segment of code, you needn't design, code, nor
debug that section of code since (presumably) you've already done so. Given the rising
costs of software development, modular design will become more important as time passes.</font></p>

<p><font face="Arial" size="2">The basic unit of a modular program is the module. Modules
have different meanings to different people, herein you can assume that the terms module,
subprogram, subroutine, program unit, procedure, and function are all synonymous. </font></p>

<p><font face="Arial" size="2">The procedure is the basis for a programming style. The
procedural languages include Pascal, BASIC, C++, FORTRAN, PL/I, and ALGOL. Examples of
non-procedural languages include APL, LISP, SNOBOL4 ICON, FORTH, SETL, PROLOG, and others
that are based on other programming constructs such as functional abstraction or pattern
matching. Assembly language is capable of acting as a procedural or non-procedural
language. Since you're probably much more familiar with the procedural programming
paradigm this text will stick to simulating procedural constructs in 80x86 assembly
language.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING1-4"></a>11.0 Chapter
    Overview</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">This chapter presents an introduction to procedures and
functions in assembly language. It discusses basic principles, parameter passing, function
results, local variables, and recursion. You will use most of the techniques this chapter
discusses in typical assembly language programs. The discussion of procedures and
functions continues in the next chapter; that chapter discusses advanced techniques that
you will not commonly use in assembly language programs. The sections below that have a
&quot;*&quot; prefix are essential. Those sections with a &quot;o&quot; discuss advanced
topics that you may want to put off for a while.</font></p>

<p><font face="Arial" size="2">* Procedures. </font></p>

<p><font face="Arial" size="2">* Near and far procedures. </font></p>

<p><font face="Arial" size="2">* Functions </font></p>

<p><font face="Arial" size="2">* Saving the state of the machine </font></p>

<p><font face="Arial" size="2">* Parameters </font></p>

<p><font face="Arial" size="2">* Pass by value parameters. </font></p>

<p><font face="Arial" size="2">* Pass by reference parameters. </font></p>

<p><font face="Arial" size="2">o Pass by value-returned parameters. </font></p>

<p><font face="Arial" size="2">o Pass by result parameters. </font></p>

<p><font face="Arial" size="2">o Pass by name parameters. </font></p>

<p><font face="Arial" size="2">* Passing parameters in registers. </font></p>

<p><font face="Arial" size="2">* Passing parameters in global variables. </font></p>

<p><font face="Arial" size="2">* Passing parameters on the stack. </font></p>

<p><font face="Arial" size="2">* Passing parameters in the code stream. </font></p>

<p><font face="Arial" size="2">o Passing parameters via a parameter block. </font></p>

<p><font face="Arial" size="2">* Function results. </font></p>

<p><font face="Arial" size="2">* Returning function results in a register. </font></p>

<p><font face="Arial" size="2">* Returning function results on the stack. </font></p>

<p><font face="Arial" size="2">* Returning function results in memory locations. </font></p>

<p><font face="Arial" size="2">* Side effects. </font></p>

<p><font face="Arial" size="2">o Local variable storage. </font></p>

<p><font face="Arial" size="2">o Recursion. </font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING1-28"></a>11.1
    Procedures</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">In a procedural environment, the basic unit of code is the
procedure. A procedure is a set of instructions that compute some value or take some
action (such as printing or reading a character value). The definition of a procedure is
very similar to the definition of an algorithm. A procedure is a set of rules to follow
which, if they conclude, produce some result. An algorithm is also such a sequence, but an
algorithm is guaranteed to terminate whereas a procedure offers no such guarantee. </font></p>

<p><font face="Arial" size="2">Most procedural programming languages implement procedures
using the call/return mechanism. That is, some code calls a procedure, the procedure does
its thing, and then the procedure returns to the caller. The call and return instructions
provide the 80x86's procedure invocation mechanism. The calling code calls a procedure
with the <code>call</code> instruction, the procedure returns to the caller with the <code>ret</code>
instruction. For example, the following 80x86 instruction calls the UCR Standard Library <code>sl_putcr</code>
routine<a HREF="#FOOTNOTE-1">[1]</a>: </font></p>

<pre><font face="Courier New" size="2">		call 	sl_putcr</font></pre>
<code>

<p><font face="Arial" size="2">sl_putcr</code> prints a carriage return/line feed sequence
to the video display and returns control to the instruction immediately following the <code>call
sl_putcr</code> instruction. </font></p>

<p><font face="Arial" size="2">Alas, the UCR Standard Library does not supply all the
routines you will need. Most of the time you'll have to write your own procedures. A
simple procedure may consist of nothing more than a sequence of instructions ending with a
<code>ret</code> instruction. For example, the following &quot;procedure&quot; zeros out
the 256 bytes starting at the address in the <code>bx</code> register: </font></p>

<pre><font face="Courier New" size="2">ZeroBytes:      xor     ax, ax
                mov     cx, 128
ZeroLoop:       mov     [bx], ax
                add     bx, 2
                loop    ZeroLoop
                ret</font></pre>

<p><font face="Arial" size="2">By loading the <code>bx</code> register with the address of
some block of 256 bytes and issuing a <code>call ZeroBytes </code>instruction, you can
zero out the specified block. </font></p>

<p><font face="Arial" size="2">As a general rule, you won't define your own procedures in
this manner. Instead, you should use MASM's <code>proc</code> and <code>endp</code>
assembler directives. The <code>ZeroBytes</code> routine, using the <code>proc</code> and <code>endp</code>
directives, is </font></p>

<pre><font face="Courier New" size="2">ZeroBytes       proc
                xor     ax, ax
                mov     cx, 128
ZeroLoop:       mov     [bx], ax
                add     bx, 2
                loop    ZeroLoop
                ret
ZeroBytes       endp</font></pre>

<p><font face="Arial" size="2">Keep in mind that <code>proc</code> and <code>endp</code>
are assembler directives. They do not generate any code. They're simply a mechanism to
help make your programs easier to read. To the 80x86, the last two examples are identical;
however, to a human being, latter is clearly a self-contained procedure, the other could
simply be an arbitrary set of instructions within some other procedure. Consider now the
following code: </font></p>

<pre><font face="Courier New" size="2">ZeroBytes:      xor     ax, ax
                jcxz    DoFFs
ZeroLoop:       mov     [bx], ax
                add     bx, 2
                loop    ZeroLoop
                ret

DoFFs:          mov     cx, 128
                mov     ax, 0ffffh
FFLoop:         mov     [bx], ax
                sub     bx, 2
                loop    FFLoop
                ret</font></pre>

<p><font face="Arial" size="2">Are there two procedures here or just one? In other words,
can a calling program enter this code at labels <code>ZeroBytes</code> and <code>DoFFs</code>
or just at <code>ZeroBytes</code>? The use of the <code>proc</code> and <code>endp</code>
directives can help remove this ambiguity: </font></p>

<p><font face="Arial" size="2">Treated as a single subroutine: </font></p>

<pre><font face="Courier New" size="2">ZeroBytes       proc
                xor     ax, ax
                jcxz    DoFFs
ZeroLoop:       mov     [bx], ax
                add     bx, 2
                loop    ZeroLoop
                ret

DoFFs:          mov     cx, 128
                mov     ax, 0ffffh
FFLoop:         mov     [bx], ax
                sub     bx, 2
                loop    FFLoop
                ret
ZeroBytes       endp</font></pre>

<p><font face="Arial" size="2">Treated as two separate routines: </font></p>

<pre><font face="Courier New" size="2">ZeroBytes       proc
                xor     ax, ax
                jcxz    DoFFs
ZeroLoop:       mov     [bx], ax
                add     bx, 2
                loop    ZeroLoop
                ret
ZeroBytes       endp

DoFFs           proc
                mov     cx, 128
                mov     ax, 0ffffh
FFLoop:         mov     [bx], ax
                sub     bx, 2
                loop    FFLoop
                ret
DoFFs           endp</font></pre>

<p><font face="Arial" size="2">Always keep in mind that the proc and endp directives are
logical procedure separators. The 80x86 microprocessor returns from a procedure by
executing a ret instruction, not by encountering an endp directive. The following is not
equivalent to the code above: </font></p>

<pre><font face="Courier New" size="2">ZeroBytes               proc
                xor     ax, ax
                jcxz    DoFFs
ZeroLoop:       mov     [bx], ax
                add     bx, 2
                loop    ZeroLoop
;       Note missing RET instr.
ZeroBytes       endp

DoFFs           proc
                mov     cx, 128
                mov     ax, 0ffffh
FFLoop:         mov     [bx], ax
                sub     bx, 2
                loop    FFLoop
;       Note missing RET instr.
DoFFs           endp</font></pre>

<p><font face="Arial" size="2">Without the ret instruction at the end of each procedure,
the 80x86 will fall into the next subroutine rather than return to the caller. After
executing ZeroBytes above, the 80x86 will drop through to the DoFFs subroutine (beginning
with the mov cx, 128 instruction). Once DoFFs is through, the 80x86 will continue
execution with the next executable instruction following DoFFs' endp directive. </font></p>

<pre><font face="Courier New" size="2">An 80x86 procedure takes the form:
ProcName        proc    {near|far}              ;Choose near, far, or neither.
        &lt;Procedure instructions&gt;
ProcName        endp</font></pre>

<p><font face="Arial" size="2">The <code>near</code> or <code>far</code> operand is
optional, the next section will discuss its purpose. The procedure name must be on the
both <code>proc</code> and <code>endp</code> lines. The procedure name must be unique in
the program. </font></p>

<p><font face="Arial" size="2">Every <code>proc</code> directive must have a matching <code>endp</code>
directive. Failure to match the <code>proc</code> and <code>endp</code> directives will
produce a block nesting error. </font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING1-133"></a>11.2 Near
    and Far Procedures</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">The 80x86 supports near and far subroutines. Near calls and
returns transfer control between procedures in the same code segment. Far calls and
returns pass control between different segments. The two calling and return mechanisms
push and pop different return addresses. You generally do not use a near <code>call</code>
instruction to call a far procedure or a far <code>call</code> instruction to call a near
procedure. Given this little rule, the next question is &quot;how do you control the
emission of a near or far <code>call</code> or <code>ret</code>?&quot;.</font></p>

<p><font face="Arial" size="2">Most of the time, the <code>call</code> instruction uses
the following syntax: </font></p>

<pre><font face="Courier New" size="2">                 call    ProcName</font></pre>

<p><font face="Arial" size="2">and the <code>ret</code> instruction is either<a HREF="#FOOTNOTE-2">[2]</a>: </font></p>

<pre><font face="Courier New" size="2">                ret
or              ret     disp</font></pre>

<p><font face="Arial" size="2">Unfortunately, these instructions do not tell MASM if you
are calling a near or far procedure or if you are returning from a near or far procedure.
The <code>proc</code> directive handles that chore. The <code>proc</code> directive has an
optional operand that is either <code>near</code> or <code>far</code>. <code>Near</code>
is the default if the operand field is empty<a HREF="#FOOTNOTE-3">[3]</a>. The assembler
assigns the procedure type (near or far) to the symbol. Whenever MASM assembles a <code>call</code>
instruction, it emits a near or far call depending on operand. Therefore, declaring a
symbol with <code>proc</code> or <code>proc near</code>, forces a near call. Likewise,
using <code>proc far</code>, forces a far call. </font></p>

<p><font face="Arial" size="2">Besides controlling the generation of a near or far call, <code>proc</code>'s
operand also controls <code>ret</code> code generation. If a procedure has the near
operand, then all return instructions inside that procedure will be near. MASM emits far
returns inside far procedures.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING1-144"></a>11.2.1 Forcing NEAR or
FAR CALLs and Returns</font></strong></p>

<p><font face="Arial" size="2">Once in a while you might want to override the near/far
declaration mechanism. MASM provides a mechanism that allows you to force the use of
near/far calls and returns. </font></p>

<p><font face="Arial" size="2">Use the <code>near</code> <code>ptr </code>and <code>far</code>
<code>ptr </code>operators to override the automatic assignment of a near or far <code>call</code>.
If <code>NearLbl</code> is a near label and <code>FarLbl</code> is a far label, then the
following <code>call</code> instructions generate a near and far call, respectively: </font></p>

<pre><font face="Courier New" size="2">                call    NearLbl ;Generates a NEAR call.
                call    FarLbl  ;Generates a FAR call.</font></pre>

<p><font face="Arial" size="2">Suppose you need to make a far call to <code>NearLbl</code>
or a near call to <code>FarLbl</code>. You can accomplish this using the following
instructions: </font></p>

<pre><font face="Courier New" size="2">                call    far ptr NearLbl ;Generates a FAR call.
                call    near ptr FarLbl ;Generates a NEAR call.</font></pre>

<p><font face="Arial" size="2">Calling a near procedure using a far call, or calling a far
procedure using a near call isn't something you'll normally do. If you call a near
procedure using a far call instruction, the near return will leave the cs value on the
stack. Generally, rather than: </font></p>

<pre><font face="Courier New" size="2">                call    far ptr NearProc</font></pre>

<p><font face="Arial" size="2">you should probably use the clearer code: </font></p>

<pre><font face="Courier New" size="2">                push    cs
                call    NearProc</font></pre>

<p><font face="Arial" size="2">Calling a far procedure with a near <code>call</code> is a
very dangerous operation. If you attempt such a call, the current <code>cs</code> value
must be on the stack. Remember, a far <code>ret</code> pops a segmented return address off
the stack. A near <code>call</code> instruction only pushes the offset, not the segment
portion of the return address.</font></p>

<p><font face="Arial" size="2">Starting with MASM v5.0, there are explicit instructions
you can use to force a near or far <code>ret</code>. If <code>ret</code> appears within a
procedure declared via <code>proc</code> and <code>end;</code>, MASM will automatically
generate the appropriate near or far return instruction. To accomplish this, use the <code>retn</code>
and <code>retf</code> instructions. These two instructions generate a near and far <code>ret</code>,
respectively.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING1-163"></a>11.2.2 Nested Procedures</font></strong></p>

<p><font face="Arial" size="2">MASM allows you to nest procedures. That is, one procedure
definition may be totally enclosed inside another. The following is an example of such a
pair of procedures:</font> </p>

<pre><font face="Courier New" size="2">OutsideProc     proc    near
                jmp     EndofOutside

InsideProc      proc    near
                mov     ax, 0
                ret
InsideProc      endp

EndofOutside:   call    InsideProc
                mov     bx, 0
                ret
OutsideProc     endp</font></pre>

<p><font face="Arial" size="2">Unlike some high level languages, nesting procedures in
80x86 assembly language doesn't serve any useful purpose. If you nest a procedure (as with
<code>InsideProc</code> above), you'll have to code an explicit <code>jmp</code> around
the nested procedure. Placing the nested procedure after all the code in the outside
procedure (but still between the outside <code>proc</code>/<code>endp</code> directives)
doesn't accomplish anything. Therefore, there isn't a good reason to nest procedures in
this manner. </font></p>

<p><font face="Arial" size="2">Whenever you nest one procedure within another, it must be
totally contained within the nesting procedure. That is, the <code>proc</code> and <code>endp</code>
statements for the nested procedure must lie between the <code>proc</code> and endp
directives of the outside, nesting, procedure. The following is not legal: </font></p>

<pre><font face="Courier New" size="2">OutsideProc     proc    near
                 .
                 .
                 .
InsideProc      proc    near
                 .
                 .
                 .
OutsideProc     endp
                 .
                 .
                 .
InsideProc      endp</font></pre>

<p><font face="Arial" size="2">The <code>OutsideProc</code> and <code>InsideProc</code>
procedures overlap, they are not nested. If you attempt to create a set of procedures like
this, MASM would report a &quot;block nesting error&quot;. The figure below demonstrates
this graphically:</font></p>

<p align="center"><img SRC="images/ch11a.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH11/ch11a.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="189" HEIGHT="91"> </p>

<p><font face="Arial" size="2">The only form acceptable to MASM is</font></p>

<p align="center"><img SRC="images/ch11a1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH11/ch11a1.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="189" HEIGHT="94"> </p>

<p><font face="Arial" size="2">Besides fitting inside an enclosing procedure, <code>proc/endp</code>
groups must fit entirely within a segment. Therefore the following code is illegal: </font></p>

<pre><font face="Courier New" size="2">cseg            segment
MyProc          proc    near
                ret
cseg            ends
MyProc          endp</font></pre>

<p><font face="Arial" size="2">The <code>endp</code> directive must appear before the <code>cseg
ends </code>statement since <code>MyProc</code> begins inside <code>cseg</code>.
Therefore, procedures within segments must always take the form shown below:</font></p>

<p align="center"><img SRC="images/ch11a2.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH11/ch11a2.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="351" HEIGHT="102"> </p>

<p><font face="Arial" size="2">Not only can you nest procedures inside other procedures
and segments, but you can nest segments inside other procedures and segments as well. If
you're the type who likes to simulate Pascal or C procedures in assembly language, you can
create variable declaration sections at the beginning of each procedure you create, just
like Pascal:</font> </p>

<pre><font face="Courier New" size="2">cgroup          group   cseg1, cseg2

cseg1           segment para public 'code'
cseg1           ends

cseg2           segment para public 'code'
cseg2           ends

dseg            segment para public 'data'
dseg            ends

cseg1           segment para public 'code'
                assume  cs:cgroup, ds:dseg

MainPgm         proc    near

; Data declarations for main program:

dseg            segment para public 'data'
I               word    ?
J               word    ?
dseg            ends

; Procedures that are local to the main program:

cseg2           segment para public 'code'

ZeroWords       proc     near

; Variables local to ZeroBytes:

dseg            segment para public 'data'
AXSave          word    ?
BXSave          word    ?
CXSave          word    ?
dseg            ends

; Code for the ZeroBytes procedure:

                mov     AXSave, ax
                mov     CXSave, cx
                mov     BXSave, bx
                xor     ax, ax
ZeroLoop:       mov     [bx], ax
                inc     bx
                inc     bx
                loop    ZeroLoop
                mov     ax, AXSave
                mov     bx, BXSave
                mov     cx, CXSave
                ret
ZeroWords       endp

Cseg2           ends

; The actual main program begins here:

                mov     bx, offset Array
                mov     cx, 128
                call    ZeroWords
                ret
MainPgm         endp
cseg1           ends
                end</font></pre>

<p><font face="Arial" size="2">The system will load this code into memory as shown below:</font></p>

<p align="center"><img SRC="images/ch11a3.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH11/ch11a3.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="110" HEIGHT="85"> </p>

<p><font face="Arial" size="2"><code>ZeroWords</code> follows the main program because it
belongs to a different segment (<code>cseg2</code>) than <code>MainPgm</code> (<code>cseg1</code>).
Remember, the assembler and linker combine segments with the same class name into a single
segment before loading them into memory (see Chapter Eight for more details). You can use
this feature of the assembler to &quot;pseudo-Pascalize&quot; your code in the fashion
shown above. However, you'll probably not find your programs to be any more readable than
using the straight forward non-nesting approach. </font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING1-280"></a>11.3
    Functions</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">The difference between functions and procedures in assembly
language is mainly a matter of definition. The purpose for a function is to return some
explicit value while the purpose for a procedure is to execute some action. To declare a
function in assembly language, use the <code>proc/endp</code> directives. All the rules
and techniques that apply to procedures apply to functions. This text will take another
look at functions later in this chapter in the section on function results. From here on,
procedure will mean procedure or function.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING1-282"></a>11.4
    Saving the State of the Machine</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">Take a look at this code: </font></p>

<pre><font face="Courier New" size="2">                mov     cx, 10
Loop0:          call    PrintSpaces
                putcr
                loop    Loop0
                 .
                 .
                 .
PrintSpaces     proc    near
                mov     al, ' '
                mov     cx, 40
PSLoop:         putc
                loop    PSLoop
                ret
PrintSpaces     endp</font></pre>

<p><font face="Arial" size="2">This section of code attempts to print ten lines of 40
spaces each. Unfortunately, there is a subtle bug that causes it to print 40 spaces per
line in an infinite loop. The main program uses the <code>loop</code> instruction to call <code>PrintSpaces</code>
10 times. <code>PrintSpaces</code> uses <code>cx</code> to count off the 40 spaces it
prints. <code>PrintSpaces</code> returns with <code>cx</code> containing zero. The main
program then prints a carriage return/line feed, decrements <code>cx</code>, and then
repeats because <code>cx</code> isn't zero (it will always contain 0FFFFh at this point). </font></p>

<p><font face="Arial" size="2">The problem here is that the <code>PrintSpaces</code>
subroutine doesn't preserve the <code>cx</code> register. Preserving a register means you
save it upon entry into the subroutine and restore it before leaving. Had the <code>PrintSpaces</code>
subroutine preserved the contents of the <code>cx</code> register, the program above would
have functioned properly. </font></p>

<p><font face="Arial" size="2">Use the 80x86's <code>push</code> and <code>pop</code>
instructions to preserve register values while you need to use them for something else.
Consider the following code for</font></p>

<p><font face="Courier New" size="2"><code>PrintSpaces</code>: </font></p>

<pre><font face="Courier New" size="2">PrintSpaces     proc    near
                push    ax
                push    cx
                mov     al, ' '
                mov     cx, 40
PSLoop:         putc
                loop    PSLoop
                pop     cx
                pop     ax
                ret
PrintSpaces     endp</font></pre>

<p><font face="Arial" size="2">Note that <code>PrintSpaces</code> saves and restores <code>ax</code>
and <code>cx</code> (since this procedure modifies these registers). Also, note that this
code pops the registers off the stack in the reverse order that it pushed them. The
operation of the stack imposes this ordering. </font></p>

<p><font face="Arial" size="2">Either the caller (the code containing the <code>call</code>
instruction) or the callee (the subroutine) can take responsibility for preserving the
registers. In the example above, the callee preserved the registers. The following example
shows what this code might look like if the caller preserves the registers: </font></p>

<pre><font face="Courier New" size="2">                mov     cx, 10
Loop0:          push    ax
                push    cx
                call    PrintSpaces
                pop     cx
                pop     ax
                putcr
                loop    Loop0
                 .
                 .
                 .
PrintSpaces     proc    near
                mov     al, ' '
                mov     cx, 40
PSLoop:         putc
                loop    PSLoop
                ret
PrintSpaces     endp</font></pre>

<p><font face="Arial" size="2">There are two advantages to callee preservation: space and
maintainability. If the callee preserves all affected registers, then there is only one
copy of the push and pop instructions, those the procedure contains. If the caller saves
the values in the registers, the program needs a set of push and pop instructions around
every call. Not only does this make your programs longer, it also makes them harder to
maintain. Remembering which registers to push and pop on each procedure call is not
something easily done. </font></p>

<p><font face="Arial" size="2">On the other hand, a subroutine may unnecessarily preserve
some registers if it preserves all the registers it modifies. In the examples above, the
code needn't save <code>ax</code>. Although <code>PrintSpaces</code> changes the <code>al</code>,
this won't affect the program's operation. If the caller is preserving the registers, it
doesn't have to save registers it doesn't care about: </font></p>

<pre><font face="Courier New" size="2">                mov     cx, 10
Loop0:          push    cx
                call    PrintSpaces
                pop     cx
                putcr
                loop    Loop0
                putcr
                putcr
                call    PrintSpaces

                mov     al, '*'
                mov     cx, 100
Loop1:          putc
                push    ax
                push    cx
                call    PrintSpaces
                pop     cx
                pop     ax
                putc
                putcr
                loop    Loop1
                 .
                 .
                 .
PrintSpaces     proc    near
                mov     al, ' '
                mov     cx, 40
PSLoop:         putc
                loop    PSLoop
                ret
PrintSpaces     endp</font></pre>

<p><font face="Arial" size="2">This example provides three different cases. The first loop
(<code>Loop0</code>) only preserves the <code>cx</code> register. Modifying the <code>al</code>
register won't affect the operation of this program. Immediately after the first loop,
this code calls <code>PrintSpaces</code> again. However, this code doesn't save <code>ax</code>
or <code>cx</code> because it doesn't care if <code>PrintSpaces</code> changes them. Since
the final loop (<code>Loop1</code>) uses <code>ax</code> and <code>cx</code>, it saves
them both. </font></p>

<p><font face="Arial" size="2">One big problem with having the caller preserve registers
is that your program may change. You may modify the calling code or the procedure so that
they use additional registers. Such changes, of course, may change the set of registers
that you must preserve. Worse still, if the modification is in the subroutine itself, you
will need to locate every call to the routine and verify that the subroutine does not
change any registers the calling code uses.</font></p>

<p><font face="Arial" size="2">Preserving registers isn't all there is to preserving the
environment. You can also push and pop variables and other values that a subroutine might
change. Since the 80x86 allows you to push and pop memory locations, you can easily
preserve these values as well. </font></p>

<hr noshade size="1" color="#000000">

<p><font face="Arial" size="2"><a NAME="FOOTNOTE-1"></a><strong>[1]</strong> Normally you
would use the <code>putcr</code> macro to accomplish this, but this <code>call</code>
instruction will accomplish the same thing. </font></p>

<p><font face="Arial" size="2"><a NAME="FOOTNOTE-2"></a><strong>[2]</strong> There are
also retn and retf instructions. </font></p>

<p><font face="Arial" size="2"><a NAME="FOOTNOTE-3"></a><strong>[3]</strong> Unless you
are using MASM's simplified segment directives. See the appendices for details. </font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="../Chapter_10/CH10-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="../Chapter_10/CH10-1.html">Chapter
    Ten</a></strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH11-2.html">Chapter Eleven</a> (Part 2)&nbsp; </strong></font><a href="CH11-2.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Eleven: Procedures and
Functions (Part 1)<br>
27 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_11/CH11-1.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:27:10 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
