<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_11/CH11-3.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:27:10 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER ELEVEN: PROCEDURES AND FUNCTIONS (Part 3)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING3"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH11-2.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH11-2.html">Chapter Eleven</a> (Part 2)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH11-4.html">Chapter Eleven</a> (Part 4)&nbsp; </strong></font><a href="CH11-4.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10"><a NAME="HEADING3-1"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0"><font face="Arial" size="4"><strong>CHAPTER ELEVEN:<br>
    PROCEDURES AND FUNCTIONS (Part 3)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10"></td>
  </tr>
  <tr>
    <td width="100%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING3-1"><b>11.5.7 </b>-
    Passing Parameters in Registers</a> <br>
    <a HREF="#HEADING3-118"><b>11.5.8 </b>- Passing Parameters in Global Variables</a> </font></td>
  </tr>
  <tr>
    <td width="100%" valign="top" nowrap height="20"></td>
  </tr>
</table>
</center></div>

<h3><strong><font face="Arial" size="3">11.5.7 Passing Parameters in Registers</font></strong></h3>

<p><font face="Arial" size="2">Having touched on how to pass parameters to a procedure,
the next thing to discuss is where to pass parameters. Where you pass parameters depends,
to a great extent, on the size and number of those parameters. If you are passing a small
number of bytes to a procedure, then the registers are an excellent place to pass
parameters. The registers are an ideal place to pass value parameters to a procedure. If
you are passing a single parameter to a procedure you should use the following registers
for the accompanying data types: </font></p>

<pre><font face="Courier New" size="2">Data Size       Pass in this Register
Byte:                   al 
Word:                   ax 
Double Word:            dx:ax or eax (if 80386 or better)</font></pre>

<p><font face="Arial" size="2">This is, by no means, a hard and fast rule. If you find it
more convenient to pass 16 bit values in the <code>si</code> or <code>bx</code> register,
by all means do so. However, most programmers use the registers above to pass parameters. </font></p>

<p><font face="Arial" size="2">If you are passing several parameters to a procedure in the
80x86's registers, you should probably use up the registers in the following order: </font></p>

<pre><font face="Courier New" size="2"><code>First                                    Last
        ax, dx, si, di, bx, cx </code></font></pre>

<p><font face="Arial" size="2">In general, you should avoid using <code>bp</code>
register. If you need more than six words, perhaps you should pass your values elsewhere. </font></p>

<p><font face="Arial" size="2">The UCR Standard Library package provides several good
examples of procedures that pass parameters by value in the registers. <code>Putc</code>,
which outputs an ASCII character code to the video display, expects an ASCII value in the <code>al</code>
register. Likewise, <code>puti</code> expects the value of a signed integer in the <code>ax</code>
register. As another example, consider the following <code>putsi</code> (put short
integer) routine that outputs the value in <code>al</code> as a signed integer:</font></p>

<pre><font face="Courier New" size="2">putsi           proc
                push    ax      ;Save AH's value.
                cbw             ;Sign extend AL -&gt; AX.
                puti            ;Let puti do the real work.
                pop     ax      ;Restore AH.
                ret
putsi           endp</font></pre>

<p><font face="Arial" size="2">The other four parameter passing mechanisms (pass by
reference, value-returned, result, and name) generally require that you pass a pointer to
the desired object (or to a thunk in the case of pass by name). When passing such
parameters in registers, you have to consider whether you're passing an offset or a full
segmented address. Sixteen bit offsets can be passed in any of the 80x86's general purpose
16 bit registers. <code>si</code>, <code>di</code>, and <code>bx</code> are the best place
to pass an offset since you'll probably need to load it into one of these registers anyway<a HREF="#FOOTNOTE-4">[4]</a>. You can pass 32 bit segmented addresses <code>dx:ax</code>
like other double word parameters. However, you can also pass them in <code>ds:bx</code>, <code>ds:si</code>,
<code>ds:di</code>, <code>es:bx</code>, <code>es:si</code>, or <code>es:di</code> and be
able to use them without copying into a segment register. </font></p>

<p><font face="Arial" size="2">The UCR Stdlib routine <code>puts</code>, which prints a
string to the video display, is a good example of a subroutine that uses pass by
reference. It wants the address of a string in the <code>es:di</code> register pair. It
passes the parameter in this fashion, not because it modifies the parameter, but because
strings are rather long and passing them some other way would be inefficient. As another
example, consider the following <code>strfill(str,c)</code> that copies the character <code>c</code>
(passed by value in <code>al</code>) to each character position in <code>str</code>
(passed by reference in <code>es:di</code>) up to a zero terminating byte:</font></p>

<pre><font face="Courier New" size="2">; strfill-      copies value in al to the string pointed at by es:di
;               up to a zero terminating byte.

byp             textequ &lt;byte ptr&gt;

strfill         proc
                pushf                   ;Save direction flag.
                cld                     ;To increment D with STOS.
                push    di              ;Save, because it's changed.
                jmp     sfStart

sfLoop:         stosb                   ;es:[di] := al, di := di + 1;
sfStart:        cmp     byp es:[di], 0  ;Done yet?
                jne     sfLoop

                pop     di              ;Restore di.
                popf                    ;Restore direction flag.
                ret
strfill         endp</font></pre>

<p><font face="Arial" size="2">When passing parameters by value-returned or by result to a
subroutine, you could pass in the address in a register. Inside the procedure you would
copy the value pointed at by this register to a local variable (value-returned only). Just
before the procedure returns to the caller, it could store the final result back to the
address in the register. </font></p>

<p><font face="Arial" size="2">The following code requires two parameters. The first is a
pass by value-returned parameter and the subroutine expects the address of the actual
parameter in <code>bx</code>. The second is a pass by result parameter whose address is in
<code>si</code>. This routine increments the pass by value-result parameter and stores the
previous result in the pass by result parameter:</font></p>

<pre><font face="Courier New" size="2">; CopyAndInc-   BX contains the address of a variable. This routine
;               copies that variable to the location specified in SI
;               and then increments the variable BX points at.
;               Note: AX and CX hold the local copies of these
;               parameters during execution.

CopyAndInc      proc
                push    ax              ;Preserve AX across call.
                push    cx              ;Preserve CX across call.
                mov     ax, [bx]        ;Get local copy of 1st parameter.
                mov     cx, ax          ;Store into 2nd parm's local var.
                inc     ax              ;Increment 1st parameter.
                mov     [si], cx        ;Store away pass by result parm.
                mov     [bx], ax        ;Store away pass by value/ret parm.
                pop     cx              ;Restore CX's value.
                pop     ax              ;Restore AX's value.
                ret
CopyAndInc      endp</font></pre>

<p><font face="Arial" size="2">To make the call CopyAndInc(I,J) you would use code like
the following:</font></p>

<pre><font face="Courier New" size="2">                lea     bx, I
                lea     si, J
                call    CopyAndInc</font></pre>

<p><font face="Arial" size="2">This is, of course, a trivial example whose implementation
is very inefficient. Nevertheless, it shows how to pass value-returned and result
parameters in the 80x86's registers. If you are willing to trade a little space for some
speed, there is another way to achieve the same results as pass by value-returned or pass
by result when passing parameters in registers. Consider the following implementation of <code>CopyAndInc</code>:</font></p>

<pre><font face="Courier New" size="2">CopyAndInc      proc
                mov     cx, ax  ;Make a copy of the 1st parameter,
                inc     ax      ; then increment it by one.
                ret
CopyAndInc      endp</font></pre>

<p><font face="Arial" size="2">To make the CopyAndInc(I,J) call, as before, you would use
the following 80x86 code:</font></p>

<pre><font face="Courier New" size="2">                mov     ax, I
                call    CopyAndInc
                mov     I, ax
                mov     J, cx</font></pre>

<p><font face="Arial" size="2">Note that this code does not pass any addresses at all; yet
it has the same semantics (that is, performs the same operations) as the previous version.
Both versions increment <code>I</code> and store the pre-incremented version into <code>J</code>.
Clearly the latter version is faster, although your program will be slightly larger if
there are many calls to <code>CopyAndInc</code> in your program (six or more).</font></p>

<p><font face="Arial" size="2">You can pass a parameter by name or by lazy evaluation in a
register by simply loading that register with the address of the thunk to call. Consider
the Panacea <code>PassByName</code> procedure (see &quot;Pass by Name&quot;). One
implementation of this procedure could be the following:</font></p>

<pre><font face="Courier New" size="2">;PassByName-    Expects a pass by reference parameter index
;               passed in si and a pass by name parameter, item,
;               passed in dx (the thunk returns the address in bx).

PassByName      proc
                push    ax                      ;Preserve AX across call
                mov     word ptr [si], 0        ;Index := 0;
ForLoop:        cmp     word ptr [si], 10       ;For loop ends at ten.
                jg      ForDone
                call    dx                      ;Call thunk item.
                mov     word ptr [bx], 0        ;Store zero into item.
                inc     word ptr [si]           ;Index := Index + 1;
                jmp     ForLoop

ForDone:        pop     ax                      ;Restore AX.
                ret                             ;All Done!
PassByName      endp</font></pre>

<p><font face="Arial" size="2">You might call this routine with code that looks like the
following:</font></p>

<pre><font face="Courier New" size="2">                lea     si, I
                lea     dx, Thunk_A
                call    PassByName
                 .
                 .
                 .
Thunk_A         proc
                mov     bx, I
                shl     bx, 1
                lea     bx, A[bx]
                ret
Thunk_A         endp</font></pre>

<p><font face="Arial" size="2">The advantage to this scheme, over the one presented in the
earlier section, is that you can call different thunks, not just the <code>ItemThunk</code>
routine appearing in the earlier example.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-118"></a>11.5.8 Passing
Parameters in Global Variables</font></strong></p>

<p><font face="Arial" size="2">Once you run out of registers, the only other (reasonable)
alternative you have is main memory. One of the easiest places to pass parameters is in
global variables in the data segment. The following code provides an example:</font></p>

<pre><font face="Courier New" size="2">                mov     ax, xxxx                ;Pass this parameter by value
                mov     Value1Proc1, ax
                mov     ax, offset yyyy         ;Pass this parameter by ref
                mov     word ptr Ref1Proc1, ax
                mov     ax, seg yyyy
                mov     word ptr Ref1Proc1+2, ax
                call    ThisProc
                 .
                 .
                 .
ThisProc        proc    near
                push    es
                push    ax
                push    bx
                les     bx, Ref1Proc1           ;Get address of ref parm. 
                mov     ax, Value1Proc1         ;Get value parameter
                mov     es:[bx], ax             ;Store into loc pointed at by
                pop     bx                      ; the ref parameter.
                pop     ax
                pop     es
                ret
ThisProc        endp</font></pre>

<p><font face="Arial" size="2">Passing parameters in global locations is inelegant and
inefficient. Furthermore, if you use global variables in this fashion to pass parameters,
the subroutines you write cannot use recursion (see &quot;Recursion&quot;). Fortunately,
there are better parameter passing schemes for passing data in memory so you do not need
to seriously consider this scheme.</font></p>

<hr noshade size="1" color="#000000">

<p><font face="Arial" size="2"><a NAME="FOOTNOTE-4"></a><strong>[4]</strong> This does not
apply to thunks. You may pass the address of a thunk in any 16 bit register. Of course, on
an 80386 or later processor, you can use any of the 80386's 32-bit registers to hold an
address.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH11-2.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH11-2.html">Chapter Eleven</a> (Part 2)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH11-4.html">Chapter Eleven</a> (Part 4)&nbsp; </strong></font><a href="CH11-4.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Eleven: Procedures and
Functions (Part 3)<br>
27 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_11/CH11-3.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:27:10 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
