<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_3/CH03-4.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:25:14 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER THREE: SYSTEM ORGANIZATION (Part 4)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING4"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH03-3.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH03-3.html">Chapter Three</a> (Part 3)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH03-5.html">Chapter Three</a> (Part 5) </strong></font><a href="CH03-5.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10"><a NAME="HEADING4-0"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0"><font face="Arial" size="4"><strong>CHAPTER THREE:<br>
    SYSTEM ORGANIZATION (Part 4)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10"></td>
  </tr>
  <tr>
    <td width="100%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING4-1"><b>3.3.10 </b>-
    The 886 Processor</a> <br>
    <a HREF="#HEADING4-5"><b>3.3.11 </b>- The 8286 Processor</a> </font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="20"></td>
  </tr>
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING4-1"></a>3.3.10 The
    886 Processor</font></strong></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">The 886 processor is the slowest member of the x86 family.
Timings for each instruction were discussed in the previous sections. The <code>mov </code>instruction,
for example, takes between five and twelve clock cycles to execute depending upon the
operands. The following table provides the timing for the various forms of the
instructions on the 886 processors. </font></p>
<div align="center"><center>

<table Border="1" bordercolor="#C0C0C0" cellspacing="0" cellpadding="0" width="80%">
  <caption><font face="Arial" size="2"><a NAME="4397"></a> Table 19: Execution Times for 886
  Instructions </font></caption>
  <tr>
    <th bgcolor="#F0F0F0"><font face="Arial" size="2"><a NAME="4409"></a> Instruction <img SRC="../images/arrwdbrt.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/chars/arrwdbrt.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="18" HEIGHT="13"><a NAME="4410"></a>Addressing Mode <img SRC="../images/arrwdbdn.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/chars/arrwdbdn.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="12" HEIGHT="16"></font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2"><a NAME="4412"></a> mov <a NAME="4519"></a>(both forms) </font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2"><a NAME="4414"></a> add,
    sub, cmp, and, or, </font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2"><a NAME="4416"></a> not </font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2"><a NAME="4418"></a> jmp </font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2"><a NAME="4420"></a> jxx </font></th>
  </tr>
  <tr>
    <td><font face="Arial" size="2">reg, reg </font></td>
    <td align="center"><font face="Arial" size="2">5 </font></td>
    <td align="center"><font face="Arial" size="2">7 </font></td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">reg, xxxx </font></td>
    <td align="center"><font face="Arial" size="2">6-7 </font></td>
    <td align="center"><font face="Arial" size="2">8-9 </font></td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">reg, [bx] </font></td>
    <td align="center"><font face="Arial" size="2">7-8 </font></td>
    <td align="center"><font face="Arial" size="2">9-10 </font></td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">reg, [xxxx] </font></td>
    <td align="center"><font face="Arial" size="2">8-10 </font></td>
    <td align="center"><font face="Arial" size="2">10-12 </font></td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">reg, [xxxx+bx] </font></td>
    <td align="center"><font face="Arial" size="2">10-12 </font></td>
    <td align="center"><font face="Arial" size="2">12-14 </font></td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">[bx], reg </font></td>
    <td align="center"><font face="Arial" size="2">7-8 </font></td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">[xxxx], reg </font></td>
    <td align="center"><font face="Arial" size="2">8-10 </font></td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">[xxxx+bx], reg </font></td>
    <td align="center"><font face="Arial" size="2">10-12 </font></td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">reg </font></td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
    <td align="center"><font face="Arial" size="2">6 </font></td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">[bx] </font></td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
    <td align="center"><font face="Arial" size="2">9-11 </font></td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">[xxxx] </font></td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
    <td align="center"><font face="Arial" size="2">10-13 </font></td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">[xxxx+bx] </font></td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
    <td align="center"><font face="Arial" size="2">12-15 </font></td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">xxxx </font></td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
    <td align="center"><font face="Arial" size="2">6-7 </font></td>
    <td align="center"><font face="Arial" size="2">6-8 </font></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">There are three important things to note from this. First,
longer instructions take more time to execute. Second, instructions that do not reference
memory generally execute faster; this is especially true if there are wait states
associated with memory access (the table above assumes zero wait states). Finally,
instructions using complex addressing modes run slower.<i> </i>Instructions which use
register operands are shorter, do not access memory, and do not use complex addressing
modes. This is why you should attempt to keep your variables in registers.</font></p>

<p><strong><font face="Arial" size="3">&nbsp;<a NAME="HEADING4-5"></a>3.3.11 The 8286
Processor</font></strong></p>

<p><font face="Arial" size="2">The key to improving the speed of a processor is to perform
operations in parallel. If, in the timings given for the 886, we were able to do two
operations on each clock cycle, the CPU would execute instructions twice as fast when
running at the same clock speed. However, simply deciding to execute two operations per
clock cycle is not so easy. Many steps in the execution of an instruction share functional
units in the CPU (functional units are groups of logic that perform a common operation,
e.g., the ALU and the CU). A functional unit is only capable of one operation at a time.
Therefore, you cannot do two operations that use the same functional unit concurrently
(e.g., incrementing the <code>ip</code> register and adding two values together). Another
difficulty with doing certain operations concurrently is that one operation may depend on
the other's result. For example, the last two steps of the <code>add</code> instruction
involve adding to values and then storing their sum. You cannot store the sum into a
register until after you've computed the sum. There are also some other resources the CPU
cannot share between steps in an instruction. For example, there is only one data bus; the
CPU cannot fetch an instruction opcode at the same time it is trying to store some data to
memory. The trick in designing a CPU that executes several steps in parallel is to arrange
those steps to reduce conflicts or add additional logic so the two (or more) operations
can occur simultaneously by executing in different functional units. Consider again the
steps the <code>mov reg, mem/reg/const</code> instruction requires: </font>

<ul>
  <li><font face="Arial" size="2">Fetch the instruction byte from memory. </font></li>
  <li><font face="Arial" size="2">Update the <code>ip</code> register to point at the next
    byte. </font></li>
  <li><font face="Arial" size="2">Decode the instruction to see what it does. </font></li>
  <li><font face="Arial" size="2">If required, fetch a 16-bit instruction operand from memory.
    </font></li>
  <li><font face="Arial" size="2">If required, update <code>ip</code> to point beyond the
    operand. </font></li>
  <li><font face="Arial" size="2">Compute the address of the operand, if required (i.e.,
    bx+xxxx) . </font></li>
  <li><font face="Arial" size="2">Fetch the operand. </font></li>
  <li><font face="Arial" size="2">Store the fetched value into the destination register </font></li>
</ul>

<p><font face="Arial" size="2">The first operation uses the value of the <code>ip</code>
register (so we cannot overlap incrementing ip with it) and it uses the bus to fetch the
instruction opcode from memory. Every step that follows this one depends upon the opcode
it fetches from memory, so it is unlikely we will be able to overlap the execution of this
step with any other. The second and third operations do not share any functional units,
nor does decoding an opcode depend upon the value of the <code>ip</code> register.
Therefore, we can easily modify the control unit so that it increments the <code>ip</code>
register at the same time it decodes the instruction. This will shave one cycle off the
execution of the <code>mov</code> instruction. The third and fourth operations above
(decoding and optionally fetching the 16-bit operand) do not look like they can be done in
parallel since you must decode the instruction to determine if it the CPU needs to fetch a
16-bit operand from memory. However, we could design the CPU to go ahead and fetch the
operand anyway, so that it's available if we need it. There is one problem with this idea,
though, we must have the address of the operand to fetch (the value in the <code>ip</code>
register) and if we must wait until we are done incrementing the <code>ip</code> register
before fetching this operand. If we are incrementing <code>ip</code> at the same time
we're decoding the instruction, we will have to wait until the next cycle to fetch this
operand. Since the next three steps are optional, there are several possible instruction
sequences at this point: #1 (step 4, step 5, step 6, and step 7) - e.g., mov ax, [1000+bx]
#2 (step 4, step 5, and step 7) - e.g., mov ax, [1000] #3 (step 6 and step 7) - e.g., mov
ax, [bx] #4 (step 7) - e.g., mov ax, bx In the sequences above, step seven always relies
on the previous set in the sequence. Therefore, step seven cannot execute in parallel with
any of the other steps. Step six also relies upon step four. Step five cannot execute in
parallel with step four since step four uses the value in the <code>ip</code> register,
however, step five can execute in parallel with any other step. Therefore, we can shave
one cycle off the first two sequences above as follows: #1 (step 4, step 5/6, and step 7)
#2 (step 4, step 5/7) #3 (step 6 and step 7) #4 (step 7) Of course, there is no way to
overlap the execution of steps seven and eight in the <code>mov</code> instruction since
it must surely fetch the value before storing it away. By combining these steps, we obtain
the following steps for the <code>mov</code> instruction: </font>

<ul>
  <li><font face="Arial" size="2">Fetch the instruction byte from memory. </font></li>
  <li><font face="Arial" size="2">Decode the instruction and update ip </font></li>
  <li><font face="Arial" size="2">If required, fetch a 16-bit instruction operand from memory.
    </font></li>
  <li><font face="Arial" size="2">Compute the address of the operand, if required (i.e.,
    bx+xxxx) . </font></li>
  <li><font face="Arial" size="2">Fetch the operand, if required update <code>ip</code> to
    point beyond xxxx. </font></li>
  <li><font face="Arial" size="2">Store the fetched value into the destination register. </font></li>
</ul>

<p><font face="Arial" size="2">By adding a small amount of logic to the CPU, we've shaved
one or two cycles off the execution of the <code>mov</code> instruction. This simple
optimization works with most of the other instructions as well. Another problem with the
execution of the <code>mov</code> instruction concerns opcode alignment. Consider the <code>mov
ax, [1000]</code> instruction that appears at location 100 in memory. The CPU spends one
cycle fetching the opcode and, after decoding the instruction an determining it has a
16-bit operand, it takes two additional cycles to fetch that operand from memory (because
that operand appears at an odd address - 101). The real travesty here is that the extra
clock cycle to fetch these two bytes is unnecessary, after all, the CPU fetched the L.O.
byte of the operand when it grabbed the opcode (remember, the x86 CPUs are 16-bit
processors and always fetch 16 bits from memory), why not save that byte and use only one
additional clock cycle to fetch the H.O. byte? This would shave one cycle off the
execution time when the instruction begins at an even address (so the operand falls on an
odd address). It would require only a one-byte register and a small amount of additional
logic to accomplish this, well worth the effort. While we are adding a register to buffer
up operand bytes, let's consider some additional optimizations that could use the same
logic. For example, consider what happens with that same <code>mov</code> instruction
above executes. If we fetch the opcode and L.O. operand byte on the first cycle and the
H.O. byte of the operand on the second cycle, we've actually read four bytes, not three.
That fourth byte is the opcode of the next instruction. If we could save this opcode until
the execution of the next instruction, we could shave a cycle of its execution time since
it would not have to fetch the opcode byte. Furthermore, since the instruction decoder is
idle while the CPU is executing the mov instruction, we can actually decode the next
instruction while the current instruction is executing, thereby shaving yet another cycle
off the execution of the next instruction. On the average, we will fetch this extra byte
on every other instruction. Therefore, implementing this simple scheme will allow us to
shave two cycles off about 50% of the instructions we execute. Can we do anything about
the other 50% of the instructions? The answer is yes. Note that the execution of the mov
instruction is not accessing memory on every clock cycle. For example, while storing the
data into the destination register the bus is idle. During time periods when the bus is
idle we can pre-fetch instruction opcodes and operands and save these values for executing
the next instruction. The major improvement to the 8286 over the 886 processor is the <i>prefetch
queue.</i> Whenever the CPU is not using the Bus Interface Unit (BIU), the BIU can fetch
additional bytes from the instruction stream. Whenever the CPU needs an instruction or
operand byte, it grabs the next available byte from the prefetch queue. Since the BIU
grabs two bytes at a time from memory at one shot and the CPU generally consumes fewer
than two bytes per clock cycle, any bytes the CPU would normally fetch from the
instruction stream will already be sitting in the prefetch queue. Note, however, that
we're not guaranteed that all instructions and operands will be sitting in the prefetch
queue when we need them. For example, the <code>jmp 1000</code> instruction will
invalidate the contents of the prefetch queue. If this instruction appears at location
400, 401, and 402 in memory, the prefetch queue will contain the bytes at addresses 403,
404, 405, 406, 407, etc. After loading <code>ip</code> with 1000 the bytes at addresses
403, etc., won't do us any good. So the system has to pause for a moment to fetch the
double word at address 1000 before it can go on. Another improvement we can make is to
overlap instruction decoding with the last step of the previous instruction. After the CPU
processes the operand, the next available byte in the prefetch queue is an opcode, and the
CPU can decode it in anticipation of its execution. Of course, if the current instruction
modifies the <code>ip</code> register, any time spent decoding the next instruction goes
to waste, but since this occurs in parallel with other operations, it does not slow down
the system. This sequence of optimizations to the system requires quite a few changes to
the hardware. A block diagram of the system appears below: </font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch03a22.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH03/ch03a22.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="355" HEIGHT="187"></font></p>

<p><font face="Arial" size="2">The instruction execution sequence now assumes that the
following events occur in the background: CPU Prefetch Events: </font>

<ul>
  <li><font face="Arial" size="2">If the prefetch queue is not full (generally it can hold
    between eight and thirty-two bytes, depending on the processor) and the BIU is idle on the
    current clock cycle, fetch the next word from memory at the address in <code>ip</code> at
    the beginning of the clock cycle. </font></li>
  <li><font face="Arial" size="2">If the instruction decoder is idle and the current
    instruction does not require an instruction operand, begin decoding the opcode at the
    front of the prefetch queue (if present), otherwise begin decoding the third byte in the
    prefetch queue (if present). If the desired byte is not in the prefetch queue, do not
    execute this event. </font></li>
</ul>

<p><font face="Arial" size="2">The instruction execution timings make a few optimistic
assumptions, namely that any necessary opcodes and instruction operands are already
present in the prefetch queue and that it has already decoded the current instruction
opcode. If either cause is not true, an 8286 instruction's execution will delay while the
system fetches the data from memory or decodes the instruction. The following are the
steps for each of the 8286 instructions: <code>mov reg, mem/reg/const </code></font>

<ul>
  <li><font face="Arial" size="2">If required, compute the sum of [xxxx+bx] (1 cycle, if
    required). </font></li>
  <li><font face="Arial" size="2">Fetch the source operand. Zero cycles if constant (assuming
    already in the prefetch queue), one cycle if a register, two cycles if even-aligned memory
    value, three cycles if odd-aligned memory value. </font></li>
  <li><font face="Arial" size="2">Store the result in the destination register, one cycle. </font></li>
</ul>
<code>

<p align="center"><font face="Courier New" size="2">mov mem, reg </font></code></p>

<ul>
  <li><font face="Arial" size="2">If required, compute the sum of [xxxx+bx] (1 cycle, if
    required). </font></li>
  <li><font face="Arial" size="2">Fetch the source operand (a register), one cycle. </font></li>
  <li><font face="Arial" size="2">Store into the destination operand. Two cycles if
    even-aligned memory value, three cycles if odd-aligned memory value. </font></li>
</ul>
<code>

<p align="center"><font face="Courier New" size="2">instr reg, mem/reg/const (instr = add,
sub, cmp, and, or) </font></code></p>

<ul>
  <li><font face="Arial" size="2">If required, compute the sum of [xxxx+bx] (1 cycle, if
    required). </font></li>
  <li><font face="Arial" size="2">Fetch the source operand. Zero cycles if constant (assuming
    already in the prefetch queue), one cycle if a register, two cycles if even-aligned memory
    value, three cycles if odd-aligned memory value. </font></li>
  <li><font face="Arial" size="2">Fetch the value of the first operand (a register), one
    cycle. </font></li>
  <li><font face="Arial" size="2">Compute the sum, difference, etc., as appropriate, one
    cycle. </font></li>
  <li><font face="Arial" size="2">Store the result in the destination register, one cycle. </font></li>
</ul>
<code>

<p align="center"><font face="Courier New" size="2">not mem/reg </font></code></p>

<ul>
  <li><font face="Arial" size="2">If required, compute the sum of [xxxx+bx] (1 cycle, if
    required). </font></li>
  <li><font face="Arial" size="2">Fetch the source operand. One cycle if a register, two
    cycles if even-aligned memory value, three cycles if odd-aligned memory value. </font></li>
  <li><font face="Arial" size="2">Logically not the value, one cycle. </font></li>
  <li><font face="Arial" size="2">Store the result, one cycle if a register, two cycles if
    even-aligned memory value, three cycles if odd-aligned memory value. </font></li>
</ul>
<code>

<p align="center"><font face="Courier New" size="2">jcc xxxx (conditional jump, cc=a, ae,
b, be, e, ne) </font></code></p>

<ul>
  <li><font face="Arial" size="2">Test the current condition code (less than and equal) flags,
    one cycle. </font></li>
  <li><font face="Arial" size="2">If the flag values are appropriate for the particular
    conditional branch, the CPU copies the 16-bit instruction operand into the <code>ip</code>
    register, one cycle. </font></li>
</ul>
<code>

<p align="center"><font face="Courier New" size="2">jmp xxxx </font></code></p>

<ul>
  <li><font face="Arial" size="2">The CPU copies the 16-bit instruction operand into the <code>ip</code>
    register, one cycle. </font></li>
</ul>

<p><font face="Arial" size="2">As for the 886, we will not consider the execution times of
the other x86 instructions since most of them are indeterminate. The jump instructions
look like they execute very quickly on the 8286. In fact, they may execute very slowly.
Don't forget, jumping from one location to another invalidates the contents of the
prefetch queue. So although the jmp instruction looks like it executes in one clock cycle,
it forces the CPU to flush the prefetch queue and, therefore, spend several cycles
fetching the next instruction, fetching additional operands, and decoding that
instruction. Indeed, it make be two or three instructions after the jmp instruction before
the CPU is back to the point where the prefetch queue is operating smoothly and the CPU is
decoding opcodes in parallel with the execution of the previous instruction. The has one
very important implication to your programs: if you want to write fast code, make sure to
avoid jumping around in your program as much as possible. Note that the conditional jump
instructions only invalidate the prefetch queue if they actually make the jump. If the
condition is false, they fall through to the next instruction and continue to use the
values in the prefetch queue as well as any pre-decoded instruction opcodes. Therefore, if
you can determine, while writing the program, which condition is most likely (e.g., less
than vs. not less than), you should arrange your program so that the most common case
falls through and conditional jump rather than take the branch. Instruction size (in
bytes) can also affect the performance of the prefetch queue. It never requires more than
one clock cycle to fetch a single byte instruction, but it always requires two cycles to
fetch a three-byte instruction. Therefore, if the target of a jump instruction is two
one-byte instructions, the BIU can fetch both instructions in one clock cycle and begin
decoding the second one while executing the first. If these instructions are three-byte
instructions, the CPU may not have enough time to fetch and decode the second or third
instruction by the time it finishes the first. Therefore, you should attempt to use
shorter instructions whenever possible since they will improve the performance of the
prefetch queue. The following table provides the (optimistic) execution times for the 8286
instructions:</font></p>
<div align="center"><center>

<table Border="1" bordercolor="#C0C0C0" cellspacing="0" cellpadding="0" width="80%">
  <caption><font face="Arial" size="2"><strong><a NAME="5233"></a> Table 20: Execution Times
  for 8286 Instructions </strong></font></caption>
  <tr>
    <th bgcolor="#F0F0F0" align="center"><font face="Arial" size="2"><a NAME="5245"></a>
    Instruction <img SRC="../images/arrwdbrt.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/chars/arrwdbrt.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="18" HEIGHT="13"><a NAME="5246"></a>Addressing Mode <img SRC="../images/arrwdbdn.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/chars/arrwdbdn.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="12" HEIGHT="16"></font></th>
    <th bgcolor="#F0F0F0" align="center"><font face="Arial" size="2"><a NAME="5248"></a> mov <a NAME="5249"></a>(both forms) </font></th>
    <th bgcolor="#F0F0F0" align="center"><font face="Arial" size="2"><a NAME="5251"></a> add,
    sub, cmp, and, or, </font></th>
    <th bgcolor="#F0F0F0" align="center"><font face="Arial" size="2"><a NAME="5253"></a> not </font></th>
    <th bgcolor="#F0F0F0" align="center"><font face="Arial" size="2"><a NAME="5255"></a> jmp </font></th>
    <th bgcolor="#F0F0F0" align="center"><font face="Arial" size="2"><a NAME="5257"></a> jxx </font></th>
  </tr>
  <tr>
    <td><font face="Arial" size="2">reg, reg </font></td>
    <td align="center"><font face="Arial" size="2">2 </font></td>
    <td align="center"><font face="Arial" size="2">4 </font></td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">reg, xxxx </font></td>
    <td align="center"><font face="Arial" size="2">1 </font></td>
    <td align="center"><font face="Arial" size="2">3 </font></td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">reg, [bx] </font></td>
    <td align="center"><font face="Arial" size="2">3-4 </font></td>
    <td align="center"><font face="Arial" size="2">5-6 </font></td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">reg, [xxxx] </font></td>
    <td align="center"><font face="Arial" size="2">3-4 </font></td>
    <td align="center"><font face="Arial" size="2">5-6 </font></td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">reg, [xxxx+bx] </font></td>
    <td align="center"><font face="Arial" size="2">4-5 </font></td>
    <td align="center"><font face="Arial" size="2">6-7 </font></td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">[bx], reg </font></td>
    <td align="center"><font face="Arial" size="2">3-4 </font></td>
    <td align="center"><font face="Arial" size="2">5-6 </font></td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">[xxxx], reg </font></td>
    <td align="center"><font face="Arial" size="2">3-4 </font></td>
    <td align="center"><font face="Arial" size="2">5-6 </font></td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">[xxxx+bx], reg </font></td>
    <td align="center"><font face="Arial" size="2">4-5 </font></td>
    <td align="center"><font face="Arial" size="2">6-7 </font></td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">reg </font></td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
    <td align="center"><font face="Arial" size="2">3 </font></td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">[bx] </font></td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
    <td align="center"><font face="Arial" size="2">5-7 </font></td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">[xxxx] </font></td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
    <td align="center"><font face="Arial" size="2">5-7 </font></td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">[xxxx+bx] </font></td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
    <td align="center"><font face="Arial" size="2">6-8 </font></td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">xxxx </font></td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
    <td align="center"><font face="Arial" size="2">1+pfd </font></td>
    <td align="center"><font face="Arial" size="2">2 2+pfd </font></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">Note how much faster the <code>mov </code>instruction runs
on the 8286 compared to the 886. This is because the prefetch queue allows the processor
to overlap the execution of adjacent instructions. However, this table paints an overly
rosy picture. Note the disclaimer: &quot;assuming the opcode is present in the prefetch
queue and has been decoded.&quot; Consider the following three instruction sequence: </font></p>

<pre><font face="Courier New" size="2">????:           jmp     1000
1000:           jmp     2000
2000:           mov     cx, 3000[bx]</font></pre>

<p><font face="Arial" size="2">The second and third instructions will <i>not </i>execute
as fast as the timings suggest in the table above. Whenever we modify the value of the <code>ip</code>
register the CPU flushes the prefetch queue. So the CPU cannot fetch and decode the next
instruction. Instead, it must fetch the opcode, decode it, etc., increasing the execution
time of these instructions. At this point the only improvement we've made is to execute
the &quot;update <code>ip</code>&quot; operation in parallel with another step. Usually,
including the prefetch queue improves performance. That's why Intel provides the prefetch
queue on every model of the 80x86, from the 8088 on up. On these processors, the BIU is
constantly fetching data for the prefetch queue whenever the program is not actively
reading or writing data. Prefetch queues work best when you have a wide data bus. The 8286
processor runs much faster than the 886 because it can keep the prefetch queue full.
However, consider the following instructions: </font></p>

<pre><font face="Courier New" size="2">100:            mov     ax, [1000]
105:            mov     bx, [2000]
10A:            mov     cx, [3000]</font></pre>

<p><font face="Arial" size="2">Since the <code>ax, bx,</code> and <code>cx</code>
registers are 16 bits, here's what happens (assuming the first instruction is in the
prefetch queue and decoded): </font>

<ul>
  <li><font face="Arial" size="2">Fetch the opcode byte from the prefetch queue (zero cycles)</font></li>
  <li><font face="Arial" size="2">Decode the instruction (zero cycles). </font></li>
  <li><font face="Arial" size="2">There is an operand to this instruction, so get it from the
    prefetch queue (zero cycles).</font></li>
  <li><font face="Arial" size="2">Get the value of the second operand (one cycle). Update <code>ip</code>.</font></li>
  <li><font face="Arial" size="2">Store the fetched value into the destination register (one
    cycle). Fetch two bytes from code stream. Decode the next instruction. </font></li>
</ul>

<p><font face="Arial" size="2">End of first instruction. Two bytes currently in prefetch
queue. </font>

<ul>
  <li><font face="Arial" size="2">Fetch the opcode byte from the prefetch queue (zero cycles).</font></li>
  <li><font face="Arial" size="2">Decode the instruction to see what it does (zero cycles). </font></li>
  <li><font face="Arial" size="2">If there is an operand to this instruction, get that operand
    from the prefetch queue (one clock cycle because we're still missing one byte).</font></li>
  <li><font face="Arial" size="2">Get the value of the second operand (one cycle). Update <code>ip</code>.
    </font></li>
  <li><font face="Arial" size="2">Store the fetched value into the destination register (one
    cycle). Fetch two bytes from code stream. Decode the next instruction.</font></li>
</ul>

<p><font face="Arial" size="2">End of second instruction. Three bytes currently in
prefetch queue. </font>

<ul>
  <li><font face="Arial" size="2">Fetch the opcode byte from the prefetch queue (zero cycles).</font></li>
  <li><font face="Arial" size="2">Decode the instruction (zero cycles). </font></li>
  <li><font face="Arial" size="2">If there is an operand to this instruction, get that operand
    from the prefetch queue (zero cycles).</font></li>
  <li><font face="Arial" size="2">Get the value of the second operand (one cycle). Update <code>ip</code>.
    </font></li>
  <li><font face="Arial" size="2">Store the fetched value into the destination register (one
    cycle). Fetch two bytes from code stream. Decode the next instruction.</font></li>
</ul>

<p><font face="Arial" size="2">As you can see, the second instruction requires one more
clock cycle than the other two instructions. This is because the BIU cannot fill the
prefetch queue quite as fast as the CPU executes the instructions. This problem is
exasperated when you limit the size of the prefetch queue to some number of bytes. This
problem doesn't exist on the 8286 processor, but most certainly does exist in the 80x86
processors. You'll soon see that the 80x86 processors tend to exhaust the prefetch queue
quite easily. Of course, once the prefetch queue is empty, the CPU must wait for the BIU
to fetch new opcodes from memory, slowing the program. Executing shorter instructions
helps keep the prefetch queue full. For example, the 8286 can load <i>two </i>one-byte
instructions with a single memory cycle, but it takes 1.5 clock cycles to fetch a single
three-byte instruction. Usually, it takes longer to execute those four one-byte
instructions than it does to execute the single three-byte instruction. This gives the
prefetch queue time to fill and decode new instructions. In systems with a prefetch queue,
it's possible to find eight two-byte instructions which operate faster than an equivalent
set of four four-byte instructions. The reason is that the prefetch queue has time to
refill itself with the shorter instructions. Moral of the story: <i>when programming a
processor with a prefetch queue, always use the shortest instructions possible to
accomplish a given task.</i></font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH03-3.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH03-3.html">Chapter Three</a> (Part 3)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH03-5.html">Chapter Three</a> (Part 5) </strong></font><a href="CH03-5.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Three: System Organization
(Part 4)<br>
26 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_3/CH03-4.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:25:18 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
