<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_3/CH03-3.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:25:08 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER THREE: SYSTEM ORGANIZATION (Part 3)</title>
</head>

<body topmargin="10" stylesrc="../toc.html" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING3"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH03-2.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH03-2.html">Chapter Three</a> (Part 2)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH03-4.html">Chapter Three</a> (Part 4) </strong></font><a href="CH03-4.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10" colspan="2"><a NAME="HEADING3-0"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0" colspan="2"><font face="Arial" size="4"><strong>CHAPTER
    THREE:<br>
    SYSTEM ORGANIZATION (Part 3)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10" colspan="2"></td>
  </tr>
  <tr>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING3-1"><b>3.3 </b>-
    The 886, 8286, 8486, and 8686 &quot;Hypothetical&quot; Processors</a> <br>
    <a HREF="#HEADING3-4"><b>3.3.1 </b>- CPU Registers</a> <br>
    <a HREF="#HEADING3-14"><b>3.3.2 </b>- The Arithmetic &amp; Logical Unit</a> <br>
    <a HREF="#HEADING3-20"><b>3.3.3 </b>- The Bus Interface Unit</a> <br>
    <a HREF="#HEADING3-22"><b>3.3.4 </b>- The Control Unit and Instruction Sets</a> </font></td>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING3-37"><b>3.3.5 </b>-
    The x86 Instruction Set</a> <br>
    <a HREF="#HEADING3-68"><b>3.3.6 </b>- Addressing Modes on the x86</a> <br>
    <a HREF="#HEADING3-102"><b>3.3.7 </b>- Encoding x86 Instructions</a> <br>
    <a HREF="#HEADING3-125"><b>3.3.8 </b>- Step-by-Step Instruction Execution</a> <br>
    <a HREF="#HEADING3-192"><b>3.3.9 </b>- The Differences Between the x86 Processors</a> </font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="20" colspan="2"></td>
  </tr>
  <tr>
    <td width="100%" colspan="2"><strong><font face="Arial" size="3"><a NAME="HEADING3-1"></a>3.3
    The 886, 8286, 8486, and 8686 &quot;Hypothetical&quot; Processors</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1" colspan="2"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">To understand how to improve system performance, it's time
to explore the internal operation of the CPU. Unfortunately, the processors in the 80x86
family are complex beasts. Discussing their internal operation would probably cause more
confusion than enlightenment. So we will use the 886, 8286, 8486, and 8686 processors (the
&quot;x86&quot; processors). These &quot;paper processors&quot; are extreme
simplifications of various members of the 80x86 family. They highlight the important
architectural features of the 80x86.</font></p>

<p><font face="Arial" size="2">The 886, 8286, 8486, and 8686 processors are all identical
except for the way they execute instructions. They all have the same <i>register set</i>,
and they &quot;execute&quot; the same <i>instruction set</i>. That sentence contains some
new ideas; let's attack them one at a time.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-4"></a>3.3.1 CPU Registers</font></strong></p>

<p><font face="Arial" size="2">CPU registers are <i>very </i>special memory locations
constructed from flip-flops. They are not part of main memory; the CPU implements them
on-chip. Various members of the 80x86 family have different register sizes. The 886, 8286,
8486, and 8686 (x86 from now on) CPUs have exactly four registers, all 16 bits wide. All
arithmetic and location operations occur in the CPU registers.</font></p>

<p><font face="Arial" size="2">Because the x86 processor has so few registers, we'll give
each register its own name and refer to it by that name rather than its address. The names
for the x86 registers are </font></p>

<pre><font face="Courier New" size="2">	AX	-The accumulator register
	BX	-The base address register
	CX	-The count register
	DX	-The data register</font></pre>

<p><font face="Arial" size="2">Besides the above registers, which are visible to the
programmer, the x86 processors also have an instruction pointer register which contains
the address of the next instruction to execute. There is also a flags register that holds
the result of a comparison. The flags register remembers if one value was less than, equal
to, or greater than another value. </font></p>

<p><font face="Arial" size="2">Because registers are on-chip and handled specially by the
CPU, they are much faster than memory. Accessing a memory location requires one or more
clock cycles. Accessing data in a register usually takes zero clock cycles. Therefore, you
should try to keep variables in the registers. Register sets are very small and most
registers have special purposes which limit their use as variables, but they are still an
excellent place to store temporary data. </font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-14"></a>3.3.2 The Arithmetic
&amp; Logical Unit</font></strong></p>

<p><font face="Arial" size="2">The arithmetic and logical unit (ALU) is where most of the
action takes place inside the CPU. For example, if you want to add the value five to the
AX register, the CPU: </font>

<ul>
  <li><font face="Arial" size="2">Copies the value from AX into the ALU, </font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Sends the value five to the ALU, </font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Instructs the ALU to add these two values together, </font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Moves the result back into the AX register. </font></li>
</ul>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-20"></a>3.3.3 The Bus Interface
Unit</font></strong></p>

<p><font face="Arial" size="2">The bus interface unit (BIU) is responsible for controlling
the address and data busses when accessing main memory. If a cache is present on the CPU
chip then the BIU is also responsible for accessing data in the cache.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-22"></a>3.3.4 The Control Unit
and Instruction Sets</font></strong></p>

<p><font face="Arial" size="2">A fair question to ask at this point is &quot;How exactly
does a CPU perform assigned chores?&quot; This is accomplished by giving the CPU a fixed
set of commands, or instructions, to work on. Keep in mind that CPU designers construct
these processors using logic gates to execute these instructions. To keep the number of
logic gates to a reasonably small set (tens or hundreds of thousands), CPU designers must
necessarily restrict the number and complexity of the commands the CPU recognizes. This
small set of commands is the CPU's instruction set.</font></p>

<p><font face="Arial" size="2">Programs in early (pre-Von Neumann) computer systems were
often &quot;hard-wired&quot; into the circuitry. That is, the computer's wiring determined
what problem the computer would solve. One had to rewire the circuitry in order to change
the program. A very difficult task. The next advance in computer design was the
programmable computer system, one that allowed a computer programmer to easily
&quot;rewire&quot; the computer system using a sequence of sockets and plug wires. A
computer program consisted of a set of rows of holes (sockets), each row representing one
operation during the execution of the program. The programmer could select one of several
instructions by plugging a wire into the particular socket for the desired instruction:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch03a15.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH03/ch03a15.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="273" HEIGHT="141"> </font></p>

<p><font face="Arial" size="2">Of course, a major difficulty with this scheme is that the
number of possible instructions is severely limited by the number of sockets one could
physically place on each row. However, CPU designers quickly discovered that with a small
amount of additional logic circuitry, they could reduce the number of sockets required
from n holes for n instructions to lg(n) [log base 2] holes for n instructions. They did
this by assigning a numeric code to each instruction and then encode that instruction as a
binary number using lg(n) holes:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch03a16.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH03/ch03a16.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="286" HEIGHT="116"> </font></p>

<p><font face="Arial" size="2">This addition requires eight logic functions to decode the
A, B, and C bits from the patch panel, but the extra circuitry is well worth the cost
because it reduces the number of sockets that must be repeated for each instruction.</font></p>

<p><font face="Arial" size="2">Of course, many CPU instructions are not stand-alone. For
example, the <code>move</code> instruction is a command that moves data from one location
in the computer to another (e.g., from one register to another). Therefore, the <code>move
</code>instruction requires two operands: a source operand and a destination operand. The
CPU's designer usually encodes these source and destination operands as part of the
machine instruction, certain sockets correspond to the source operand and certain sockets
correspond to the destination operand. The figure below shows one possible combination of
sockets to handle this. The <code>move</code> instruction would move data from the source
register to the destination register, the <code>add</code> instruction would add the value
of the source register to the destination register, etc.</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch03a17.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH03/ch03a17.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="304" HEIGHT="206"> </font></p>

<p><font face="Arial" size="2">One of the primary advances in computer design that the VNA
provides is the concept of a stored program. One big problem with the patch panel
programming method is that the number of program steps (machine instructions) is limited
by the number of rows of sockets available on the machine. John Von Neumann and others
recognized a relationship between the sockets on the patch panel and bits in memory; they
figured they could store the binary equivalents of a machine program in main memory and
fetch each program from memory, load it into a special decoding register that connected
directly to the instruction decoding circuitry of the CPU. </font></p>

<p><font face="Arial" size="2">The trick, of course, was to add yet more circuitry to the
CPU. This circuitry, the control unit (CU), fetches instruction codes (also known as
operation codes or opcodes) from memory and moves them to the instruction decoding
register. The control unit contains a special registers, the instruction pointer that
contains the address of an executable instruction. The control unit fetches this
instruction's code from memory and places it in the decoding register for execution. After
executing the instruction, the control unit increments the instruction pointer and fetches
the next instruction from memory for execution, and so on.</font></p>

<p><font face="Arial" size="2">When designing an instruction set, the CPU's designers
generally choose opcodes that are a multiple of eight bits long so the CPU can easily
fetch complete instructions from memory. The goal of the CPU's designer is to assign an
appropriate number of bits to the instruction class field (move, add, subtract, etc.) and
to the operand fields. Choosing more bits for the instruction field lets you have more
instructions, choosing additional bits for the operand fields lets you select a larger
number of operands (e.g., memory locations or registers). There are additional
complications. Some instructions have only one operand or, perhaps, they don't have any
operands at all. Rather than waste the bits associated with these fields, the CPU
designers often reuse these fields to encode additional opcodes, once again with some
additional circuitry. The Intel 80x86 CPU family takes this to an extreme with
instructions ranging from one to about ten bytes long. Since this is a little too
difficult to deal with at this early stage, the x86 CPUs will use a different, much
simpler, encoding scheme.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-37"></a>3.3.5 The x86 Instruction
Set</font></strong></p>

<p><font face="Arial" size="2">The x86 CPUs provide 20 basic instruction classes. Seven of
these instructions have two operands, eight of these instructions have a single operand,
and five instructions have no operands at all. The instructions are <code>mov</code> (two
forms)<code>, add, sub, cmp, and, or, not, je, jne, jb, jbe, ja, jae, jmp, brk, iret,
halt, get,</code> and <code>put</code>. The following paragraphs describe how each of
these work.</font></p>

<p><font face="Arial" size="2">The <code>mov</code> instruction is actually two
instruction classes merged into the same instruction. The two forms of the <code>mov</code>
instruction take the following forms: </font></p>

<pre><font face="Courier New" size="2">                mov     reg, reg/memory/constant
                mov     memory, reg</font></pre>

<p><font face="Arial" size="2">where <code>reg</code> is any of<code> ax, bx, cx, </code>or
<code>dx</code>; <code>constant</code> is a numeric constant (using hexadecimal notation),
and <code>memory</code> is an operand specifying a memory location. The next section
describes the possible forms the memory operand can take. The
&quot;reg/memory/constant&quot; operand tells you that this particular operand may be a
register, memory location, or a constant.</font></p>

<p><font face="Arial" size="2">The arithmetic and logical instructions take the following
forms: </font></p>

<pre><font face="Courier New" size="2">                add     reg, reg/memory/constant
                sub     reg, reg/memory/constant
                cmp     reg, reg/memory/constant
                and     reg, reg/memory/constant
                or      reg, reg/memory/constant
                not     reg/memory</font></pre>

<p><font face="Arial" size="2">The <code>add</code> instruction adds the value of the
second operand to the first (register) operand, leaving the sum in the first operand. The <code>sub</code>
instruction subtracts the value of the second operand from the first, leaving the
difference in the first operand. The <code>cmp</code> instruction compares the first
operand against the second and saves the result of this comparison for use with one of the
conditional jump instructions (described in a moment). The <code>and </code>and<code> or</code>
instructions compute the corresponding bitwise logical operation on the two operands and
store the result into the first operand. The <code>not</code> instruction inverts the bits
in the single memory or register operand.</font></p>

<p><font face="Arial" size="2">The control transfer instructions interrupt the sequential
execution of instructions in memory and transfer control to some other point in memory
either unconditionally, or after testing the result of the previous <code>cmp</code>
instruction. These instructions include the following: </font></p>

<pre><font face="Courier New" size="2">                ja      dest            -- Jump if above
                jae     dest            -- Jump if above or equal
                jb      dest            -- Jump if below
                jbe     dest            -- Jump if below or equal
                je      dest            -- Jump if equal
                jne     dest            -- Jump if not equal
                jmp     dest            -- Unconditional jump
                iret                    -- Return from an interrupt</font></pre>

<p><font face="Arial" size="2">The first six instructions in this class let you check the
result of the previous cmp instruction for greater than, greater or equal, less than, less
or equal, equality, or inequality. For example, if you compare the <code>ax</code> and <code>bx</code>
registers with the <code>cmp</code> instruction and execute the <code>ja</code>
instruction, the x86 CPU will jump to the specified destination location if <code>ax</code>
was greater than <code>bx</code>. If <code>ax</code> is not greater than <code>bx</code>,
control will fall through to the next instruction in the program. The <code>jmp</code>
instruction unconditionally transfers control to the instruction at the destination
address. The iret instruction returns control from an interrupt service routine, which we
will discuss later.</font></p>

<p><font face="Arial" size="2">The <code>get</code> and <code>put</code> instructions let
you read and write integer values. <code>Get</code> will stop and prompt the user for a
hexadecimal value and then store that value into the <code>ax</code> register. <code>Put</code>
displays (in hexadecimal) the value of the <code>ax</code> register.</font></p>

<p><font face="Arial" size="2">The remaining instructions do not require any operands,
they are <code>halt</code> and <code>brk</code>. <code>Halt</code> terminates program
execution and <code>brk </code>stops the program in a state that it can be restarted.</font></p>

<p><font face="Arial" size="2">The x86 processors require a unique opcode for every
different instruction, not just the instruction classes. Although &quot;mov ax, bx&quot;
and &quot;mov ax, cx&quot; are both in the same class, they must have different opcodes if
the CPU is to differentiate them. However, before looking at all the possible opcodes,
perhaps it would be a good idea to learn about all the possible operands for these
instructions.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-68"></a>3.3.6 Addressing Modes on
the x86</font></strong></p>

<p><font face="Arial" size="2">The x86 instructions use five different operand types:
registers, constants, and three memory addressing schemes. Each form is called an
addressing mode. The x86 processors support the register addressing mode, the immediate
addressing mode, the indirect addressing mode, the indexed addressing mode, and the direct
addressing mode. The following paragraphs explain each of these modes.</font></p>

<p><font face="Arial" size="2">Register operands are the easiest to understand. Consider
the following forms of the <code>mov </code>instruction: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, ax
                mov     ax, bx
                mov     ax, cx
                mov     ax, dx</font></pre>

<p><font face="Arial" size="2">The first instruction accomplishes absolutely nothing. It
copies the value from the <code>ax</code> register back into the <code>ax</code> register.
The remaining three instructions copy the value of <code>bx</code>, <code>cx</code> and <code>dx</code>
into <code>ax</code>. Note that the original values of <code>bx</code>, <code>cx</code>,
and <code>dx</code> remain the same. The first operand (the <i>destination</i>) is not
limited to <code>ax</code>; you can move values to any of these registers.</font></p>

<p><font face="Arial" size="2">Constants are also pretty easy to deal with. Consider the
following instructions: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, 25
                mov     bx, 195
                mov     cx, 2056
                mov     dx, 1000</font></pre>

<p><font face="Arial" size="2">These instructions are all pretty straightforward; they
load their respective registers with the specified hexadecimal constant. </font></p>

<p><font face="Arial" size="2">There are three addressing modes which deal with accessing
data in memory. These addressing modes take the following forms: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, [1000]
                mov     ax, [bx]
                mov     ax, [1000+bx]</font></pre>

<p><font face="Arial" size="2">The first instruction above uses the direct addressing mode
to load <code>ax</code> with the 16 bit value stored in memory starting at location 1000
hex. </font></p>

<p><font face="Arial" size="2">The mov ax, [bx] instruction loads <code>ax</code> from the
memory location specified by the contents of the <code>bx</code> register. This is an <i>indirect
</i>addressing mode. Rather than using the value in <code>bx</code>, this instruction
accesses to the memory location whose address appears in <code>bx</code>. Note that the
following two instructions: </font></p>

<pre><font face="Courier New" size="2">                mov     bx, 1000
                mov     ax, [bx]</font></pre>

<p><font face="Arial" size="2">are equivalent to the single instruction: </font></p>

<pre><font face="Courier New" size="2">                mov     ax, [1000]</font></pre>

<p><font face="Arial" size="2">Of course, the second sequence is preferable. However,
there are many cases where the use of indirection is faster, shorter, and better. We'll
see some examples of this when we look at the individual processors in the x86 family a
little later.</font></p>

<p><font face="Arial" size="2">The last memory addressing mode is the <i>indexed </i>addressing
mode. An example of this memory addressing mode is </font></p>

<pre><font face="Courier New" size="2">                mov     ax, [1000+bx]</font></pre>

<p><font face="Arial" size="2">This instruction adds the contents of <code>bx</code> with
1000 to produce the address of the memory value to fetch. This instruction is useful for
accessing elements of arrays, records, and other data structures.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-102"></a>3.3.7 Encoding x86
Instructions</font></strong></p>

<p><font face="Arial" size="2">Although we could arbitrarily assign opcodes to each of the
x86 instructions, keep in mind that a real CPU uses logic circuitry to decode the opcodes
and act appropriately on them. A typical CPU opcode uses a certain number of bits in the
opcode to denote the instruction class (e.g., mov, add, sub), and a certain number of bits
to encode each of the operands. Some systems (e.g., CISC, or Complex Instruction Set
Computers) encode these fields in a very complex fashion producing very compact
instructions. Other systems (e.g., RISC, or Reduced Instruction Set Computers) encode the
opcodes in a very simple fashion even if it means wasting some bits in the opcode or
limiting the number of operations. The Intel 80x86 family is definitely CISC and has one
of the most complex opcode decoding schemes ever devised. The whole purpose for the
hypothetical x86 processors is to present the concept of instruction encoding without the
attendant complexity of the 80x86 family, while still demonstrating CISC encoding.</font></p>

<p><font face="Arial" size="2">A typical x86 instruction takes the form shown below:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch03a18.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH03/ch03a18.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="453" HEIGHT="160"> </font></p>

<p><font face="Arial" size="2">The basic instruction is either one or three bytes long.
The instruction opcode consists of a single byte that contains three fields. The first
field, the H.O. three bits, defines the instruction class. This provides eight
combinations. As you may recall, there are 20 instruction classes; we cannot encode 20
instruction classes with three bits, so we'll have to pull some tricks to handle the other
classes. As you can see above, the basic opcode encodes the mov instructions (two classes,
one where the rr field specifies the destination, one where the mmm field specifies the
destination), the <code>add, sub, cmp, and,</code> and <code>or</code> instructions. There
is one additional class: special. The special instruction class provides a mechanism that
allows us to expand the number of available instruction classes, we will return to this
class shortly.</font></p>

<p><font face="Arial" size="2">To determine a particular instruction's opcode, you need
only select the appropriate bits for the iii, rr, and mmm fields. For example, to encode
the <code>mov ax, bx</code> instruction you would select iii=110 (mov reg, reg), rr=00
(ax), and mmm=001 (bx). This produces the one-byte instruction 11000001 or 0C0h.</font></p>

<p><font face="Arial" size="2">Some x86 instructions require more than one byte. For
example, the instruction <code>mov ax, [1000]</code> loads the ax register from memory
location 1000. The encoding for the opcode is 11000110 or 0C6h. However, the encoding for <code>mov
ax,[2000]</code>'s opcode is also 0C6h. Clearly these two instructions do different
things, one loads the <code>ax</code> register from memory location 1000h while the other
loads the <code>ax</code> register from memory location 2000. To encode an address for the
[xxxx] or [xxxx+bx] addressing modes, or to encode the constant for the immediate
addressing mode, you must follow the opcode with the 16-bit address or constant, with the
L.O. byte immediately following the opcode in memory and the H.O. byte after that. So the
three byte encoding for <code>mov ax, [1000]</code> would be 0C6h, 00h, 10h and the three
byte encoding for <code>mov ax, [2000]</code> would be 0C6h, 00h, 20h. </font></p>

<p><font face="Arial" size="2">The special opcode allows the x86 CPU to expand the set of
available instructions. This opcode handles several zero and one-operand instructions as
shown in the following two figures:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch03a19.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH03/ch03a19.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="453" HEIGHT="158"></font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch03a20.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH03/ch03a20.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="169" HEIGHT="157"> </font></p>

<p><font face="Arial" size="2">There are four one-operand instruction classes. The first
encoding (00) further expands the instruction set with a set of zero-operand instructions.
The second opcode is also an expansion opcode that provides all the x86 jump instructions:</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch03a21.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH03/ch03a21.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="447" HEIGHT="159"> </font></p>

<p><font face="Arial" size="2">The third opcode is the <code>not</code> instruction. This
is the bitwise logical not operation that inverts all the bits in the destination register
or memory operand. The fourth single-operand opcode is currently unassigned. Any attempt
to execute this opcode will halt the processor with an illegal instruction error. CPU
designers often reserve unassigned opcodes like this one to extend the instruction set at
a future date (as Intel did when moving from the 80286 processor to the 80386).</font></p>

<p><font face="Arial" size="2">There are seven jump instructions in the x86 instruction
set. They all take the following form: </font></p>

<pre><font face="Courier New" size="2">		jxx	address</font></pre>

<p><font face="Arial" size="2">The <code>jmp</code> instruction copies the 16-bit
immediate value (address) following the opcode into the IP register. Therefore, the CPU
will fetch the next instruction from this target address; effectively, the program
&quot;jumps&quot; from the point of the <code>jmp</code> instruction to the instruction at
the target address. </font></p>

<p><font face="Arial" size="2">The <code>jmp</code> instruction is an example of an
unconditional jump instruction. It always transfers control to the target address. The
remaining six instructions are conditional jump instructions. They test some condition and
jump if the condition is true; they fall through to the next instruction if the condition
is false. These six instructions, <code>ja, jae, jb, jbe, je,</code> and <code>jne</code>
let you test for greater than, greater than or equal, less than, less than or equal,
equality, and inequality. You would normally execute these instructions immediately after
a <code>cmp</code> instruction since it sets the less than and equality flags that the
conditional jump instructions test. Note that there are eight possible jump opcodes, but
the x86 uses only seven of them. The eighth opcode is another illegal opcode.</font></p>

<p><font face="Arial" size="2">The last group of instructions, the zero operand
instructions, appear in a figures above. Three of these instructions are illegal
instruction opcodes. The <code>brk</code> (break) instruction pauses the CPU until the
user manually restarts it. This is useful for pausing a program during execution to
observe results. The <code>iret</code> (interrupt return) instruction returns control from
an interrupt service routine. We will discuss interrupt service routines later. The <code>halt</code>
program terminates program execution. The <code>get</code> instruction reads a hexadecimal
value from the user and returns this value in the <code>ax</code> register; the <code>put</code>
instruction outputs the value in the <code>ax</code> register.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-125"></a>3.3.8 Step-by-Step
Instruction Execution</font></strong></p>

<p><font face="Arial" size="2">The x86 CPUs do <i>not </i>complete execution of an
instruction in a single clock cycle. The CPU executes several steps for each instruction.
For example, the CU issues the following commands to execute the <code>mov reg,
reg/memory/constant </code>instruction: </font>

<ul>
  <li><font face="Arial" size="2">Fetch the instruction byte from memory.</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Update the <code>ip</code> register to point at the next
    byte.</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Decode the instruction to see what it does.</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">If required, fetch a 16-bit instruction operand from memory.</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">If required, update <code>ip</code> to point beyond the
    operand.</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Compute the address of the operand, if required (i.e.,
    bx+xxxx) .</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Fetch the operand.</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Store the fetched value into the destination register </font></li>
</ul>

<p><font face="Arial" size="2">A step-by-step description may help clarify what the CPU is
doing. In the first step, the CPU fetches the instruction byte from memory. To do this, it
copies the value of the <code>ip</code> register to the address bus and reads the byte at
that address. This will take one clock cycle.</font></p>

<p><font face="Arial" size="2">After fetching the instruction byte, the CPU updates <code>ip</code>
so that it points at the next byte in the instruction stream. If the current instruction
is a multibyte instruction, <code>ip</code> will now point at the operand for the
instruction. If the current instruction is a single byte instruction, <code>ip</code>
would be left pointing at the next instruction. This takes one clock cycle.</font></p>

<p><font face="Arial" size="2">The next step is to decode the instruction to see what it
does. This will tell the CPU, among other things, if it needs to fetch additional operand
bytes from memory. This takes one clock cycle.</font></p>

<p><font face="Arial" size="2">During decoding, the CPU determines the types of operands
the instruction requires. If the instruction requires a 16 bit constant operand (i.e., if
the mmm field is 101, 110, or 111) then the CPU fetches that constant from memory. This
step may require zero, one, or two clock cycles. It requires zero cycles if there is no 16
bit operand; it requires one clock cycle if the 16 bit operand is word-aligned (that is,
begins at an even address); it requires two clock cycles if the operand is not word
aligned (that is, begins at an odd address).</font></p>

<p><font face="Arial" size="2">If the CPU fetches a 16 bit memory operand, it must
increment <code>ip</code> by two so that it points at the next byte following the operand.
This operation takes zero or one clock cycles. Zero clock cycles if there is no operand;
one if an operand is present.</font></p>

<p><font face="Arial" size="2">Next, the CPU computes the address of the memory operand.
This step is required only when the mmm field of the instruction byte is 101 or 100. If
the mmm field contains 101, then the CPU computes the sum of the <code>bx</code> register
and the 16 bit constant; this requires two cycles, one cycle to fetch <code>bx</code>'s
value, the other to computer the sum of <code>bx</code> and xxxx. If the mmm field
contains 100, then the CPU fetches the value in <code>bx</code> for the memory address,
this requires one cycle. If the mmm field does not contain 100 or 101, then this step
takes zero cycles.</font></p>

<p><font face="Arial" size="2">Fetching the operand takes zero, one, two, or three cycles
depending upon the operand itself. If the operand is a constant (mmm=111), then this step
requires zero cycles because we've already fetched this constant from memory in a previous
step. If the operand is a register (mmm = 000, 001, 010, or 011) then this step takes one
clock cycle. If this is a word aligned memory operand (mmm=100, 101, or 110) then this
step takes two clock cycles. If it is an unaligned memory operand, it takes three clock
cycles to fetch its value.</font></p>

<p><font face="Arial" size="2">The last step to the <code>mov </code>instruction is to
store the value into the destination location. Since the destination of the <code>load</code>
instruction is always a register, this operation takes a single cycle.</font></p>

<p><font face="Arial" size="2">Altogether, the <code>mov </code>instruction takes between
five and eleven cycles, depending on its operands and their alignment (starting address)
in memory.</font></p>

<p><font face="Arial" size="2">The CPU does the following for the <code>mov memory, reg </code>instruction:
</font>

<ul>
  <li><font face="Arial" size="2">Fetch the instruction byte from memory (one clock cycle).</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Update <code>ip</code> to point at the next byte (one clock
    cycle).</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Decode the instruction to see what it does (one clock
    cycle).</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">If required, fetch an operand from memory (zero cycles if
    [bx] addressing mode, one cycle if [xxxx], [xxxx+bx], or xxxx addressing mode and the
    value xxxx immediately following the opcode starts on an even address, or two clock cycles
    if the value xxxx starts at an odd address).</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">If required, update <code>ip</code> to point beyond the
    operand (zero cycles if no such operand, one clock cycle if the operand is present).</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Compute the address of the operand (zero cycles if the
    addressing mode is not [bx] or [xxxx+bx], one cycle if the addressing mode is [bx], or two
    cycles if the addressing mode is [xxxx+bx]).</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Get the value of the register to store (one clock cycle).</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Store the fetched value into the destination location (one
    cycle if a register, two cycles if a word-aligned memory operand, or three clock cycles if
    an odd-address aligned memory operand). </font></li>
</ul>

<p><font face="Arial" size="2">The timing for the last two items is different from <code>the
other mov </code>because <code>that instruction </code>can read data from memory; this
version of <code>mov</code> instruction &quot;loads&quot; its data from a register. This
instruction takes five to eleven clock cycles to execute.</font></p>

<p><font face="Arial" size="2">The <code>add, sub, cmp, and, </code>and<code> or </code>instructions
do the following: </font>

<ul>
  <li><font face="Arial" size="2">Fetch the instruction byte from memory (one clock cycle).</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Update <code>ip</code> to point at the next byte (one clock
    cycle).</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Decode the instruction (one clock cycle).</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">If required, fetch a constant operand from memory (zero
    cycles if [bx] addressing mode, one cycle if [xxxx], [xxxx+bx], or xxxx addressing mode
    and the value xxxx immediately following the opcode starts on an even address, or two
    clock cycles if the value xxxx starts at an odd address).</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">If required, update <code>ip</code> to point beyond the
    constant operand (zero or one clock cycles).</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Compute the address of the operand (zero cycles if the
    addressing mode is not [bx] or [xxxx+bx], one cycle if the addressing mode is [bx], or two
    cycles if the addressing mode is [xxxx+bx]).</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Get the value of the operand and send it to the ALU (zero
    cycles if a constant, one cycle if a register, two cycles if a word-aligned memory
    operand, or three clock cycles if an odd-address aligned memory operand).</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Fetch the value of the first operand (a register) and send
    it to the ALU (one clock cycle).</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Instruct the ALU to add, subtract, compare, logically and,
    or logically or the values (one clock cycle).</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Store the result back into the first register operand (one
    clock cycle). </font></li>
</ul>

<p><font face="Arial" size="2">These instructions require between eight and seventeen
clock cycles to execute.</font></p>

<p><font face="Arial" size="2">The not instruction is similar to the above, but may be a
little faster since it only has a single operand: </font>

<ul>
  <li><font face="Arial" size="2">Fetch the instruction byte from memory (one clock cycle).</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Update <code>ip</code> to point at the next byte (one clock
    cycle).</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Decode the instruction (one clock cycle).</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">If required, fetch a constant operand from memory (zero
    cycles if [bx] addressing mode, one cycle if [xxxx] or [xxxx+bx] addressing mode and the
    value xxxx immediately following the opcode starts on an even address, or two clock cycles
    if the value xxxx starts at an odd address).</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">If required, update <code>ip</code> to point beyond the
    constant operand (zero or one clock cycles).</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Compute the address of the operand (zero cycles if the
    addressing mode is not [bx] or [xxxx+bx], one cycle if the addressing mode is [bx], or two
    cycles if the addressing mode is [xxxx+bx]).</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Get the value of the operand and send it to the ALU (one
    cycle if a register, two cycles if a word-aligned memory operand, or three clock cycles if
    an odd-address aligned memory operand).</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Instruct the ALU to logically not the values (one clock
    cycle).</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Store the result back into the operand (one clock cycle if a
    register, two clock cycles if an even-aligned memory location, three cycles if odd-aligned
    memory location). </font></li>
</ul>

<p><font face="Arial" size="2">The <code>not</code> instruction takes six to fifteen
cycles to execute.</font></p>

<p><font face="Arial" size="2">The conditional jump instructions work as follows: </font>

<ul>
  <li><font face="Arial" size="2">Fetch the instruction byte from memory (one clock cycle).</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Update <code>ip</code> to point at the next byte (one clock
    cycle).</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Decode the instructions (one clock cycle).</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Fetch the target address operand from memory (one cycle if
    xxxx is at an even address, two clock cycles if at an odd address).</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Update <code>ip</code> to point beyond the address (one
    clock cycle).</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Test the &quot;less than&quot; and &quot;equality&quot; CPU
    flags (one cycle).</font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">If the flag values are appropriate for the particular
    conditional jump, the CPU copies the 16 bit constant into the <code>ip</code> register
    (zero cycles if no branch, one clock cycle if branch occurs). </font></li>
</ul>

<p><font face="Arial" size="2">The unconditional jump instruction is identical in
operation to the <code>mov reg, xxxx</code> instruction except the destination register is
the x86's ip register rather than <code>ax, bx, cx, </code>or <code>dx</code>.</font></p>

<p><font face="Arial" size="2">The brk, iret, <code>halt</code>, <code>put</code>, and <code>get</code>
instructions are of no interest to us here. They appear in the instruction set mainly for
programs and experiments. We can't very well give them &quot;cycle&quot; counts since they
may take an indefinite amount of time to complete their task. </font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-192"></a>3.3.9 The Differences
Between the x86 Processors</font></strong></p>

<p><font face="Arial" size="2">All the x86 processors share the same instruction set, the
same addressing modes, and execute their instructions using the same sequence of steps. So
what's the difference? Why not invent one processor rather than four?</font></p>

<p><font face="Arial" size="2">The main reason for going through this exercise is to
explain performance differences related to four hardware features: <i>pre-fetch queue</i>s,
<i>cache</i>s, <i>pipeline</i>s and <i>superscalar designs</i>. The 886 processor is an
inexpensive &quot;device&quot; which doesn't implement any of these fancy features. The
8286 processor implements the prefetch queue. The 8486 has a pre-fetch queue, a cache, and
a pipeline. The 8686 has all of the above features with superscalar operation. By studying
each of these processors you can see the benefits of each feature. </font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH03-2.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH03-2.html">Chapter Three</a> (Part 2)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH03-4.html">Chapter Three</a> (Part 4) </strong></font><a href="CH03-4.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Three: System Organization
(Part 3)<br>
26 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_3/CH03-3.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:25:14 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
