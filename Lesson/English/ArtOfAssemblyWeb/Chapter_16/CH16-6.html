<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_16/CH16-6.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:31 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER SIXTEEN: PATTERN MATCHING (Part 6)</title>
</head>

<body stylesrc="../toc.html" topmargin="10" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING6"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH16-5.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH16-5.html">Chapter Sixteen</a> (Part 5)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH16-7.html">Chapter Sixteen</a> (Part 7)&nbsp; </strong></font><a href="CH16-7.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10"><a NAME="HEADING6-1"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0"><font face="Arial" size="4"><strong>CHAPTER SIXTEEN:<br>
    PATTERN MATCHING (Part 6)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10"></td>
  </tr>
  <tr>
    <td width="100%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING6-1"><b>16.4 </b>-
    Designing Your Own Pattern Matching Routines</a> <br>
    <a HREF="#HEADING6-160"><b>16.5 </b>- Extracting Substrings from Matched Patterns</a> </font></td>
  </tr>
  <tr>
    <td width="100%" valign="top" nowrap height="20"><font face="Arial" size="2"></font></td>
  </tr>
  <tr>
    <td width="100%" valign="top"><font face="Arial" size="2"></font><strong><font face="Arial" size="3">16.4 Designing Your Own Pattern Matching Routines</font></strong><font face="Arial" size="2"></font></td>
  </tr>
  <tr>
    <td width="100%" valign="top" nowrap bgcolor="#000000" height="1"><font face="Arial" size="2"></font></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">Although the UCR Standard Library provides a wide variety
of matching functions, there is no way to anticipate the needs of all applications.
Therefore, you will probably discover that the library does not support some particular
pattern matching function you need. Fortunately, it is very easy for you to create your
own pattern matching functions to augment those available in the UCR Standard Library.
When you specify a matching function name in the pattern data structure, the match routine
calls the specified address using a far call and passing the following parameters:</font></p>

<p><font face="Arial" size="2"><code>es:di</code>- Points at the next character in the
input string. You should not look at any characters before this address. Furthermore, you
should never look beyond the end of the string (see <code>cx</code> below).</font></p>

<p><font face="Arial" size="2"><code>ds:si</code>- Contains the four byte parameter found
in the <code>matchparm</code> field.</font></p>

<p><font face="Arial" size="2"><code>cx</code>- Contains the last position, plus one, in
the input string you're allowed to look at. Note that your pattern matching routine should
not look beyond location <code>es:cx</code> or the zero terminating byte; whichever comes
first in the input string.</font></p>

<p><font face="Arial" size="2">On return from the function, <code>ax</code> must contain
the offset into the string (<code>di</code>'s value) of the last character matched plus
one, if your matching function is successful. It must also set the carry flag to denote
success. After your pattern matches, the match routine might call another matching
function (the one specified by the next pattern field) and that function begins matching
at location <code>es:ax</code>.</font></p>

<p><font face="Arial" size="2">If the pattern match fails, then you must return the
original <code>di</code> value in the <code>ax</code> register and return with the carry
flag clear. Note that your matching function must preserve all other registers.</font></p>

<p><font face="Arial" size="2">There is one very important detail you must never forget
with writing your own pattern matching routines - <code>ds</code> does not point at your
data segment, it contains the H.O. word of the <code>matchparm</code> parameter.
Therefore, if you are going to access global variables in your data segment you will need
to push <code>ds</code>, load it with the address of <code>dseg</code>, and pop <code>ds</code>
before leaving. Several examples throughout this chapter demonstrate how to do this.</font></p>

<p><font face="Arial" size="2">There are some obvious omissions from (the current version
of) the UCR Standard Library's repertoire. For example, there should probably be <code>matchtoistr</code>,
<code>matchichar</code>, and <code>matchtoichar</code> pattern functions. The following
example code demonstrates how to add a <code>matchtoistr</code> (match up to a string,
doing a case insensitive comparison) routine.</font></p>

<pre><font face="Courier New" size="2">                .xlist

                include         stdlib.a
                includelib      stdlib.lib
                matchfuncs
                .list

dseg            segment para public 'data'

TestString      byte    &quot;This is the string 'xyz' in it&quot;,cr,lf,0

TestPat         pattern {matchtoistr,xyz}
xyz             byte    &quot;XYZ&quot;,0

dseg            ends


cseg            segment para public 'code'
                assume  cs:cseg, ds:dseg

; MatchToiStr-  Matches all characters in a string up to, and including, the
;               specified parameter string. The parameter string must be
;               all upper case characters. This guy matches string using
;               a case insensitive comparison.
;
; inputs:
;               es:di-  Source string
;               ds:si-  String to match
;               cx-     Maximum match position
;
; outputs:
;               ax-     Points at first character beyond the end of the
;                       matched string if success, contains the initial DI
;                       value if failure occurs.
;               carry-  0 if failure, 1 if success.

MatchToiStr     proc    far
                pushf
                push    di
                push    si
                cld

; Check to see if we're already past the point were we're allowed
; to scan in the input string.

                cmp     di, cx
                jae     MTiSFailure

; If the pattern string is the empty string, always match.

                cmp     byte ptr ds:[si], 0
                je      MTSsuccess

; The following loop scans through the input string looking for
; the first character in the pattern string.

ScanLoop:       push    si
                lodsb                   ;Get first char of string

                dec     di
FindFirst:      inc     di              ;Move on to next (or 1st) char.
                cmp     di, cx          ;If at cx, then we've got to
                jae CantFind1st ; fail.

                mov     ah, es:[di]     ;Get input character.
                cmp     ah, 'a'         ;Convert input character to
                jb      DoCmp           ; upper case if it's a lower
                cmp     ah, 'z'         ; case character.
                ja      DoCmp
                and     ah, 5fh
DoCmp:          cmp     al, ah          ;Compare input character against
                jne     FindFirst       ; pattern string.


; At this point, we've located the first character in the input string
; that matches the first character of the pattern string. See if the
; strings are equal.

                push    di              ;Save restart point.

CmpLoop:        cmp     di, cx          ;See if we've gone beyond the
                jae     StrNotThere     ; last position allowable.
                lodsb                   ;Get next input character.
                cmp     al, 0           ;At the end of the parameter
                je      MTSsuccess2     ; string? If so, succeed.

                inc     di
                mov     ah, es:[di]     ;Get the next input character.
                cmp     ah, 'a'         ;Convert input character to
                jb      DoCmp2          ; upper case if it's a lower
                cmp     ah, 'z'         ; case character.
                ja      DoCmp2
                and     ah, 5fh
DoCmp2:         cmp     al, ah          ;Compare input character against
                je      CmpLoop
                pop     di
                pop     si
                jmp     ScanLoop

StrNotThere:    add     sp, 2           ;Remove di from stack.
CantFind1st:    add     sp, 2           ;Remove si from stack.
MTiSFailure:    pop     si
                pop     di
                mov     ax, di          ;Return failure position in AX.
                popf
                clc                     ;Return failure.
                ret

MTSSuccess2:    add     sp, 2           ;Remove DI value from stack.
MTSSuccess:     add     sp, 2           ;Remove SI value from stack.
                mov     ax, di          ;Return next position in AX.
                pop     si
                pop     di
                popf
                stc                     ;Return success.
                ret
MatchToiStr     endp

Main            proc
                mov     ax, dseg
                mov     ds, ax
                mov     es, ax
                meminit

                lesi    TestString
                ldxi    TestPat
                xor     cx, cx
                match
                jnc     NoMatch
                print
                byte    &quot;Matched&quot;,cr,lf,0
                jmp     Quit

NoMatch:        print
                byte    &quot;Did not match&quot;,cr,lf,0

Quit:           ExitPgm
Main            endp

cseg            ends

sseg            segment para stack 'stack'
stk             db      1024 dup (&quot;stack &quot;)
sseg            ends

zzzzzzseg       segment para public 'zzzzzz'
LastBytes       db      16 dup (?)
zzzzzzseg       ends
                end     Main</font></pre>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a name="HEADING6-160"></a>16.5
    Extracting Substrings from Matched Patterns</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">Often, simply determining that a string matches a given
pattern is insufficient. You may want to perform various operations that depend upon the
actual information in that string. However, the pattern matching facilities described thus
far do not provide a mechanism for testing individual components of the input string. In
this section, you will see how to extract portions of a pattern for further processing.</font></p>

<p><font face="Arial" size="2">Perhaps an example may help clarify the need to extract
portions of a string. Suppose you are writing a stock buy/sell program and you want it to
process commands described by the following regular expression:</font></p>

<pre><font face="Courier New" size="2">(buy | sell) [0-9]+ shares of (ibm | apple | hp | dec)</font></pre>

<p><font face="Arial" size="2">While it is easy to devise a Standard Library pattern that
recognizes strings of this form, calling the <code>match</code> routine would only tell
you that you have a legal buy or sell command. It does not tell you if you are to buy or
sell, who to buy or sell, or how many shares to buy or sell. Of course, you could take the
cross product of (buy | sell) with (ibm | apple | hp | dec) and generate eight different
regular expressions that uniquely determine whether you're buying or selling and whose
stock you're trading, but you can't process the integer values this way (unless you
willing to have millions of regular expressions). A better solution would be to extract
substrings from the legal pattern and process these substrings after you verify that you
have a legal buy or sell command. For example, you could extract buy or sell into one
string, the digits into another, and the company name into a third. After verifying the
syntax of the command, you could process the individual strings you've extracted. The UCR
Standard Library <code>patgrab</code> routine provides this capability for you.</font></p>

<p><font face="Arial" size="2">You normally call <code>patgrab</code> after calling <code>match</code>
and verifying that it matches the input string. <code>Patgrab</code> expects a single
parameter - a pointer to a pattern recently processed by match. <code>Patgrab</code>
creates a string on the heap consisting of the characters matched by the given pattern and
returns a pointer to this string in <code>es:di</code>. Note that <code>patgrab</code>
only returns a string associated with a single pattern data structure, not a chain of
pattern data structures. Consider the following pattern:</font></p>

<pre><font face="Courier New" size="2">PatToGrab       pattern {matchstr, str1, 0, Pat2}
Pat2            pattern {matchstr, str2}
str1            byte    &quot;Hello&quot;,0
str2            byte    &quot; there&quot;,0</font></pre>

<p><font face="Arial" size="2">Calling <code>match</code> on <code>PatToGrab</code> will
match the string &quot;Hello there&quot;. However, if after calling <code>match</code> you
call <code>patgrab</code> and pass it the address of <code>PatToGrab</code>, <code>patgrab</code>
will return a pointer to the string &quot;Hello&quot;.</font></p>

<p><font face="Arial" size="2">Of course, you might want to collect a string that is the
concatenation of several strings matched within your pattern (i.e., a portion of the
pattern list). This is where calling the <code>sl_match2</code> pattern matching function
comes in handy. Consider the following pattern:</font></p>

<pre><font face="Courier New" size="2">Numbers         pattern {sl_match2, FirstNumber}
FirstNumber     pattern {anycset, digits, 0, OtherDigs}
OtherDigs       pattern {spancset, digits}</font></pre>

<p><font face="Arial" size="2">This pattern matches the same strings as</font></p>

<pre><font face="Courier New" size="2">Numbers         pattern {anycset, digits, 0, OtherDigs}
OtherDigs       pattern {spancset, digits}</font></pre>

<p><font face="Arial" size="2">So why bother with the extra pattern that calls <code>sl_match2</code>?
Well, as it turns out the <code>sl_match2</code> matching function lets you create
parenthetical patterns. A parenthetical pattern is a pattern list that the pattern
matching routines (especially <code>patgrab</code>) treat as a single pattern. Although
the <code>match</code> routine will match the same strings regardless of which version of <code>Numbers</code>
you use, <code>patgrab</code> will produce two entirely different strings depending upon
your choice of the above patterns. If you use the latter version, <code>patgrab</code>
will only return the first digit of the number. If you use the former version (with the
call to <code>sl_match2</code>), then <code>patgrab</code> returns the entire string
matched by <code>sl_match2</code>, and that turns out to be the entire string of digits.</font></p>

<p><font face="Arial" size="2">The following sample program demonstrates how to use
parenthetical patterns to extract the pertinent information from the stock command
presented earlier. It uses parenthetical patterns for the buy/sell command, the number of
shares, and the company name.</font></p>

<pre><font face="Courier New" size="2">                .xlist
                include                 stdlib.a
                includelib              stdlib.lib
                matchfuncs
                .list

dseg            segment para public 'data'

; Variables used to hold the number of shares bought/sold, a pointer to
; a string containing the buy/sell command, and a pointer to a string
; containing the company name.

Count           word    0
CmdPtr          dword   ?
CompPtr         dword   ?

; Some test strings to try out:

Cmd1            byte    &quot;Buy 25 shares of apple stock&quot;,0
Cmd2            byte    &quot;Sell 50 shares of hp stock&quot;,0
Cmd3            byte    &quot;Buy 123 shares of dec stock&quot;,0
Cmd4            byte    &quot;Sell 15 shares of ibm stock&quot;,0
BadCmd0         byte    &quot;This is not a buy/sell command&quot;,0

; Patterns for the stock buy/sell command:
;
; StkCmd matches buy or sell and creates a parenthetical pattern
; that contains the string &quot;buy&quot; or &quot;sell&quot;.

StkCmd          pattern {sl_match2, buyPat, 0, skipspcs1}

buyPat          pattern {matchistr,buystr,sellpat}
buystr          byte    &quot;BUY&quot;,0

sellpat         pattern {matchistr,sellstr}
sellstr         byte    &quot;SELL&quot;,0

; Skip zero or more white space characters after the buy command.

skipspcs1       pattern {spancset, whitespace, 0, CountPat}

; CountPat is a parenthetical pattern that matches one or more
; digits.

CountPat        pattern {sl_match2, Numbers, 0, skipspcs2}
Numbers         pattern {anycset, digits, 0, RestOfNum}
RestOfNum       pattern {spancset, digits}

; The following patterns match &quot; shares of &quot; allowing any amount
; of white space between the words.

skipspcs2       pattern {spancset, whitespace, 0, sharesPat}

sharesPat       pattern {matchistr, sharesStr, 0, skipspcs3}
sharesStr       byte    &quot;SHARES&quot;,0

skipspcs3       pattern {spancset, whitespace, 0, ofPat}

ofPat           pattern {matchistr, ofStr, 0, skipspcs4}
ofStr           byte    &quot;OF&quot;,0

skipspcs4       pattern {spancset, whitespace, 0, CompanyPat}

; The following parenthetical pattern matches a company name.
; The patgrab-available string will contain the corporate name.

CompanyPat      pattern {sl_match2, ibmpat}

ibmpat          pattern {matchistr, ibm, applePat}
ibm             byte    &quot;IBM&quot;,0

applePat        pattern {matchistr, apple, hpPat}
apple           byte    &quot;APPLE&quot;,0

hpPat           pattern {matchistr, hp, decPat}
hp              byte    &quot;HP&quot;,0

decPat          pattern {matchistr, decstr}
decstr          byte    &quot;DEC&quot;,0

                include stdsets.a
dseg            ends

cseg            segment para public 'code'
                assume  cs:cseg, ds:dseg

; DoBuySell-    This routine processes a stock buy/sell command.
;               After matching the command, it grabs the components
;               of the command and outputs them as appropriate.
;               This routine demonstrates how to use patgrab to
;               extract substrings from a pattern string.
;
;               On entry, es:di must point at the buy/sell command
;               you want to process.

DoBuySell       proc    near
                ldxi StkCmd
                xor     cx, cx
                match
                jnc     NoMatch

                lesi    StkCmd
                patgrab
                mov     word ptr CmdPtr, di
                mov     word ptr CmdPtr+2, es

                lesi    CountPat
                patgrab
                atoi                    ;Convert digits to integer
                mov     Count, ax
                free                    ;Return storage to heap.

                lesi    CompanyPat
                patgrab
                mov     word ptr CompPtr, di
                mov     word ptr CompPtr+2, es

                printf
                byte    &quot;Stock command: %^s\n&quot;
                byte    &quot;Number of shares: %d\n&quot;
                byte    &quot;Company to trade: %^s\n\n&quot;,0
                dword   CmdPtr, Count, CompPtr

                les     di, CmdPtr
                free
                les     di, CompPtr
                free
                ret

NoMatch:                print
                byte    &quot;Illegal buy/sell command&quot;,cr,lf,0
                ret
DoBuySell       endp


Main            proc
                mov     ax, dseg
                mov     ds, ax
                mov     es, ax

                meminit

                lesi    Cmd1
                call    DoBuySell
                lesi    Cmd2
                call    DoBuySell
                lesi    Cmd3
                call    DoBuySell
                lesi    Cmd4
                call    DoBuySell
                lesi    BadCmd0
                call    DoBuySell

Quit:           ExitPgm
Main            endp

cseg            ends

sseg            segment para stack 'stack'
stk             db      1024 dup (&quot;stack &quot;)
sseg            ends

zzzzzzseg       segment para public 'zzzzzz'
LastBytes       db      16 dup (?)
zzzzzzseg       ends
                end     Main


Sample program output:
Stock command: Buy
Number of shares: 25
Company to trade: apple

Stock command: Sell
Number of shares: 50
Company to trade: hp

Stock command: Buy
Number of shares: 123
Company to trade: dec

Stock command: Sell
Number of shares: 15
Company to trade: ibm

Illegal buy/sell command</font></pre>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH16-5.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH16-5.html">Chapter Sixteen</a> (Part 5)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH16-7.html">Chapter Sixteen</a> (Part 7)&nbsp; </strong></font><a href="CH16-7.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Sixteen: Pattern Matching
(Part 6)<br>
29 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_16/CH16-6.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:31 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
