<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_16/CH16-5.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:31 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER SIXTEEN: PATTERN MATCHING (Part 5)</title>
</head>

<body stylesrc="../toc.html" topmargin="10" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING5"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH16-4.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH16-4.html">Chapter Sixteen</a> (Part 4)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH16-6.html">Chapter Sixteen</a> (Part 6)&nbsp; </strong></font><a href="CH16-6.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10" colspan="2"><a NAME="HEADING5-1"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0" colspan="2"><font face="Arial" size="4"><strong>CHAPTER
    SIXTEEN:<br>
    PATTERN MATCHING (Part 5)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10" colspan="2"></td>
  </tr>
  <tr>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING5-1"><b>16.2 </b>-
    The UCR Standard Library Pattern Matching Routines</a> <br>
    <a HREF="#HEADING5-29"><b>16.3 </b>- The Standard Library Pattern Matching Functions</a> <br>
    <a HREF="#HEADING5-32"><b>16.3.1 </b>- Spancset</a> <br>
    <a HREF="#HEADING5-44"><b>16.3.2 </b>- Brkcset</a> <br>
    <a HREF="#HEADING5-59"><b>16.3.3 </b>- Anycset</a> <br>
    <a HREF="#HEADING5-75"><b>16.3.4 </b>- Notanycset</a> <br>
    <a HREF="#HEADING5-90"><b>16.3.5 </b>- MatchStr</a> <br>
    <a HREF="#HEADING5-105"><b>16.3.6 </b>- MatchiStr</a> <br>
    <a HREF="#HEADING5-120"><b>16.3.7 </b>- MatchToStr</a> <br>
    <a HREF="#HEADING5-135"><b>16.3.8 </b>- MatchChar</a> <br>
    <a HREF="#HEADING5-150"><b>16.3.9 </b>- MatchToChar</a> </font></td>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING5-164"><b>16.3.10
    </b>- MatchChars</a> <br>
    <a HREF="#HEADING5-179"><b>16.3.11 </b>- MatchToPat</a> <br>
    <a HREF="#HEADING5-197"><b>16.3.12 </b>- EOS</a> <br>
    <a HREF="#HEADING5-213"><b>16.3.13 </b>- ARB</a> <br>
    <a HREF="#HEADING5-230"><b>16.3.14 </b>- ARBNUM</a> <br>
    <a HREF="#HEADING5-249"><b>16.3.15 </b>- Skip</a> <br>
    <a HREF="#HEADING5-267"><b>16.3.16 </b>- Pos</a> <br>
    <a HREF="#HEADING5-283"><b>16.3.17 </b>- RPos</a> <br>
    <a HREF="#HEADING5-299"><b>16.3.18 </b>- GotoPos</a> <br>
    <a HREF="#HEADING5-316"><b>16.3.19 </b>- RGotoPos</a> <br>
    <a HREF="#HEADING5-332"><b>16.3.20 </b>- SL_Match2</a> </font></td>
  </tr>
  <tr>
    <td width="100%" valign="top" colspan="2" nowrap height="20"></td>
  </tr>
  <tr>
    <td width="100%" valign="top" colspan="2"><strong><font face="Arial" size="3">16.2 The UCR
    Standard Library Pattern Matching Routines</font></strong></td>
  </tr>
  <tr>
    <td width="100%" valign="top" colspan="2" nowrap height="1" bgcolor="#000000"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">The UCR Standard Library provides a very sophisticated set
of pattern matching routines. They are patterned after the pattern matching facilities of
SNOBOL4, support CFGs, and provide fully automatic backtracking, as necessary.
Furthermore, by writing only five assembly language statements, you can match simple or
complex patterns.</font></p>

<p><font face="Arial" size="2">There is very little assembly language code to worry about
when using the Standard Library's pattern matching routines because most of the work
occurs in the data segment. To use the pattern matching routines, you first construct a
pattern data structure in the data segment. You then pass the address of this pattern and
the string you wish to test to the Standard Library <code>match</code> routine. The <code>match</code>
routine returns failure or success depending on the state of the comparison. This isn't
quite as easy as it sounds, though; learning how to construct the pattern data structure
is almost like learning a new programming language. Fortunately, if you've followed the
discussion on context free languages, learning this new &quot;language&quot; is a breeze.</font></p>

<p><font face="Arial" size="2">The Standard Library pattern data structure takes the
following form:</font></p>

<pre><font face="Courier New" size="2">Pattern         struct
MatchFunction   dword   ?
MatchParm       dword   ?
MatchAlt        dword   ?
NextPattern     dword   ?
EndPattern      word    ?
StartPattern    word    ?
StrSeg          word    ?
Pattern         ends</font></pre>

<p><font face="Arial" size="2">The <code>MatchFunction</code> field contains the address
of a routine to call to perform some sort of comparison. The success or failure of this
function determines whether the pattern matches the input string. For example, the UCR
Standard Library provides a <code>MatchStr</code> function that compares the next n
characters of the input string against some other character string.</font></p>

<p><font face="Arial" size="2">The <code>MatchParm</code> field contains the address or
value of a parameter (if appropriate) for the <code>MatchFunction</code> routine. For
example, if the <code>MatchFunction</code> routine is <code>MatchStr</code>, then the <code>MatchParm</code>
field contains the address of the string to compare the input characters against.
Likewise, the <code>MatchChar</code> routine compares the next input character in the
string against the L.O. byte of the <code>MatchParm</code> field. Some matching functions
do not require any parameters, they will ignore any value you assign to <code>MatchParm</code>
field. By convention, most programmers store a zero in unused fields of the <code>Pattern</code>
structure.</font></p>

<p><font face="Arial" size="2">The <code>MatchAlt</code> field contains either zero (NULL)
or the address of some other pattern data structure. If the current pattern matches the
input characters, the pattern matching routines ignore this field. However, if the current
pattern fails to match the input string, then the pattern matching routines will attempt
to match the pattern whose address appears in this field. If this alternate pattern
returns success, then the pattern matching routine returns success to the caller,
otherwise it returns failure. If the <code>MatchAlt</code> field contains NULL, then the
pattern matching routine immediately fails if the main pattern does not match. </font></p>

<p><font face="Arial" size="2">The <code>Pattern</code> data structure only matches one
item. For example, it might match a single character, a single string, or a character from
a set of characters. A real world pattern will probably contain several small patterns
concatenated together, e.g., the pattern for a Pascal identifier consists of a single
character from the set of alphabetic characters followed by one or more characters from
the set [a-zA-Z0-9_]. The <code>NextPattern</code> field lets you create a composite
pattern as the concatenation of two individual patterns. For such a composite pattern to
return success, the current pattern must match and then the pattern specified by the <code>NextPattern</code>
field must also match. Note that you can chain as many patterns together as you please
using this field.</font></p>

<p><font face="Arial" size="2">The last three fields, <code>EndPattern</code>, <code>StartPattern</code>,
and <code>StrSeg</code> are for the internal use of the pattern matching routine. You
should not modify or examine these fields.</font></p>

<p><font face="Arial" size="2">Once you create a pattern, it is very easy to test a string
to see if it matches that pattern. The calling sequence for the UCR Standard Library <code>match</code>
routine is</font></p>

<pre><font face="Arial" size="2">                lesi    &lt;&lt; Input string to match »
                ldxi    &lt;&lt; Pattern to match string against »
                mov     cx, 0
                match
                jc      Success</font></pre>

<p><font face="Arial" size="2">The Standard Library <code>match</code> routine expects a
pointer to the input string in the <code>es:di</code> registers; it expects a pointer to
the pattern you want to match in the <code>dx:si </code>register pair. The <code>cx</code>
register should contain the length of the string you want to test. If <code>cx</code>
contains zero, the match routine will test the entire input string. If <code>cx</code>
contains a nonzero value, the match routine will only test the first <code>cx</code>
characters in the string. Note that the end of the string (the zero terminating byte) must
not appear in the string before the position specified in <code>cx</code>. For most
applications, loading <code>cx</code> with zero before calling match is the most
appropriate operation.</font></p>

<p><font face="Arial" size="2">On return from the <code>match</code> routine, the carry
flag denotes success or failure. If the carry flag is set, the pattern matches the string;
if the carry flag is clear, the pattern does not match the string. Unlike the examples
given in earlier sections, the <code>match</code> routine does not modify the <code>di</code>
register, even if the match succeeds. Instead, it returns the failure/success position in
the <code>ax</code> register. The is the position of the first character after the match
if <code>match</code> succeeds, it is the position of the first unmatched character if <code>match</code>
fails.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING5-29"></a>16.3 The
    Standard Library Pattern Matching Functions</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">The UCR Standard Library provides about 20 built-in pattern
matching functions. These functions are based on the pattern matching facilities provided
by the SNOBOL4 programming language, so they are very powerful indeed! You will probably
discover that these routines solve all your pattern matching need, although it is easy to
write your own pattern matching routines if an appropriate one is not available. The
following subsections describe each of these pattern matching routines in detail.</font></p>

<p><font face="Arial" size="2">There are two things you should note if you're using the
Standard Library's SHELL.ASM file when creating programs that use pattern matching and
character sets. First, there is a line at the very beginning of the SHELL.ASM file that
contains the statement &quot;matchfuncs&quot;. This line is currently a comment because it
contains a semicolon in column one. If you are going to be using the pattern matching
facilities of the UCR Standard Library, you need to uncomment this line by deleting the
semicolon in column one. If you are going to be using the character set facilities of the
UCR Standard Library (very common when using the pattern matching facilities), you may
want to uncomment the line containing &quot;include stdsets.a&quot; in the data segment.
The &quot;stdsets.a&quot; file includes several common character sets, including
alphabetics, digits, alphanumerics, whitespace, and so on. </font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-32"></a>16.3.1 Spancset</font></strong></p>

<p><font face="Arial" size="2">The <code>spancset</code> routine skips over all characters
belonging to a character set. This routine will match zero or more characters in the
specified set and, therefore, always succeeds. The <code>MatchParm</code> field of the
pattern data structure must point at a UCR Standard Library character set variable. </font></p>

<p><font face="Arial" size="2">Example:</font></p>

<pre><font face="Courier New" size="2">SkipAlphas      pattern {spancset, alpha}
                 .
                 .
                 .
                lesi    StringWAlphas
                ldxi    SkipAlphas
                xor     cx, cx
                match</font></pre>

<h3><strong><font face="Arial" size="3"><a name="HEADING5-44"></a>16.3.2 Brkcset</font></strong></h3>
<code>

<p><font face="Arial" size="2">Brkcset</code> is the dual to <code>spancset</code> - it
matches zero or more characters in the input string which are not members of a specified
character set. Another way of viewing <code>brkcset</code> is that it will match all
characters in the input string up to a character in the specified character set (or to the
end of the string). The <code>matchparm</code> field contains the address of the character
set to match.</font></p>

<p><font face="Arial" size="2">Example:</font></p>

<pre><font face="Courier New" size="2">DoDigits        pattern {brkcset, digits, 0, DoDigits2}
DoDigits2       pattern {spancset, digits}
                 .
                 .
                 .
                lesi    StringWDigits
                ldxi    DoDigits
                xor     cx, cx
                match
                jnc     NoDigits</font></pre>

<p><font face="Arial" size="2">The code above matches any string that contains a string of
one or more digits somewhere in the string.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-59"></a>16.3.3 Anycset</font></strong></p>
<code>

<p><font face="Arial" size="2">Anycset</code> matches a single character in the input
string from a set of characters. The <code>matchparm</code> field contains the address of
a character set variable. If the next character in the input string is a member of this
set, <code>anycset</code> set accepts the string and skips over than character. If the
next input character is not a member of that set, <code>anycset</code> returns failure.</font></p>

<p><font face="Arial" size="2">Example:</font></p>

<pre><font face="Courier New" size="2">DoID            pattern {anycset, alpha, 0, DoID2}
DoID2           pattern {spancset, alphanum}
                 .
                 .
                 .
                lesi    StringWID
                ldxi    DoID
                xor     cx, cx
                match
                jnc     NoID</font></pre>

<p><font face="Arial" size="2">This code segment checks the string <code>StringWID</code>
to see if it begins with an identifier specified by the regular expression
[a-zA-Z][a-zA-Z0-9]*. The first subpattern with <code>anycset</code> makes sure there is
an alphabetic character at the beginning of the string (<code>alpha</code> is the
stdsets.a set variable that has all the alphabetic characters as members). If the string
does not begin with an alphabetic, the <code>DoID</code> pattern fails. The second
subpattern, <code>DoID2</code>, skips over any following alphanumeric characters using the
spancset matching function. Note that <code>spancset</code> always succeeds.</font></p>

<p><font face="Arial" size="2">The above code does not simply match a string that is an
identifier; it matches strings that begin with a valid identifier. For example, it would
match &quot;ThisIsAnID&quot; as well as &quot;ThisIsAnID+SoIsThis - 5&quot;. If you only
want to match a single identifier and nothing else, you must explicitly check for the end
of string in your pattern.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-75"></a>16.3.4 Notanycset</font></strong></p>
<code>

<p><font face="Arial" size="2">Notanycset</code> provides the complement to <code>anycset</code>
- it matches a single character in the input string that is not a member of a character
set. The <code>matchparm</code> field, as usual, contains the address of the character set
whose members must not appear as the next character in the input string. If <code>notanycset</code>
successfully matches a character (that is, the next input character is not in the
designated character set), the function skips the character and returns success; otherwise
it returns failure.</font></p>

<p><font face="Arial" size="2">Example:</font></p>

<pre><font face="Courier New" size="2">DoSpecial       pattern {notanycset, digits, 0, DoSpecial2}
DoSpecial2      pattern {spancset, alphanum}
                 .
                 .
                 .
                lesi    StringWSpecial
                ldxi    DoSpecial
                xor     cx, cx
                match
                jnc     NoSpecial</font></pre>

<p><font face="Arial" size="2">This code is similar to the <code>DoID</code> pattern in
the previous example. It matches a string containing any character except a digit and then
matches a string of alphanumeric characters.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-90"></a>16.3.5 MatchStr</font></strong></p>
<code>

<p><font face="Arial" size="2">Matchstr</code> compares the next set of input characters
against a character string. The <code>matchparm</code> field contains the address of a
zero terminated string to compare against. If <code>matchstr</code> succeeds, it returns
the carry set and skips over the characters it matched; if it fails, it tries the
alternate matching function or returns failure if there is no alternate.</font></p>

<p><font face="Arial" size="2">Example:</font></p>

<pre><font face="Courier New" size="2">DoString        pattern {matchstr, MyStr}
MyStr           byte    &quot;Match this!&quot;,0
                 .
                 .
                 .
                lesi    String
                ldxi    DoString
                xor     cx, cx
                match
                jnc     NotMatchThis</font></pre>

<p><font face="Arial" size="2">This sample code matches any string that begins with the
characters &quot;Match This!&quot;</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-105"></a>16.3.6 MatchiStr</font></strong></p>
<code>

<p><font face="Arial" size="2">Matchistr</code> is like <code>matchstr</code> insofar as
it compares the next several characters against a zero terminated string value. However, <code>matchistr</code>
does a case insensitive comparison. During the comparison it converts the characters in
the input string to upper case before comparing them to the characters that the matchparm
field points at. Therefore, the string pointed at by the <code>matchparm</code> field must
contain uppercase wherever alphabetics appear. If the <code>matchparm</code> string
contains any lower case characters, the <code>matchistr</code> function will always fail.</font></p>

<p><font face="Arial" size="2">Example:</font></p>

<pre><font face="Courier New" size="2">DoString        pattern {matchistr, MyStr}
MyStr           byte    &quot;MATCH THIS!&quot;,0
                 .
                 .
                 .
                lesi    String
                ldxi    DoString
                xor     cx, cx
                match
                jnc     NotMatchThis</font></pre>

<p><font face="Arial" size="2">This example is identical to the one in the previous
section except it will match the characters &quot;match this!&quot; using any combination
of upper and lower case characters.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-120"></a>16.3.7 MatchToStr</font></strong></p>
<code>

<p><font face="Arial" size="2">Matchtostr</code> matches all characters in an input string
up to and including the characters specified by the <code>matchparm</code> parameter. This
routine succeeds if the specified string appears somewhere in the input string, it fails
if the string does not appear in the input string. This pattern function is quite useful
for locating a substring and ignoring everything that came before the substring.</font></p>

<p><font face="Arial" size="2">Example:</font></p>

<pre><font face="Courier New" size="2">DoString        pattern {matchtostr, MyStr}
MyStr           byte    &quot;Match this!&quot;,0
                 .
                 .
                 .
                lesi    String
                ldxi    DoString
                xor     cx, cx
                match
                jnc     NotMatchThis</font></pre>

<p><font face="Arial" size="2">Like the previous two examples, this code segment matches
the string &quot;Match this!&quot; However, it does not require that the input string (<code>String</code>)
begin with &quot;Match this!&quot; Instead, it only requires that &quot;Match this!&quot;
appear somewhere in the string.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-135"></a>16.3.8 MatchChar</font></strong></p>

<p><font face="Arial" size="2">The <code>matchchar</code> function matches a single
character. The <code>matchparm</code> field's L.O. byte contains the character you want to
match. If the next character in the input string is that character, then this function
succeeds, otherwise it fails.</font></p>

<p><font face="Arial" size="2">Example:</font></p>

<pre><font face="Courier New" size="2">DoSpace         pattern {matchchar, ' '}
                 .
                 .
                 .
                lesi    String
                ldxi    DoSpace
                xor     cx, cx
                match
                jnc     NoSpace</font></pre>

<p><font face="Arial" size="2">This code segment matches any string that begins with a
space. Keep in mind that the <code>match</code> routine only checks the prefix of a
string. If you wanted to see if the string contained only a space (rather than a string
that begins with a space), you would need to explicitly check for an end of string after
the space. Of course, it would be far more efficient to use <code>strcmp</code> rather
than <code>match</code> for this purpose!</font></p>

<p><font face="Arial" size="2">Note that unlike <code>matchstr</code>, you encode the
character you want to match directly into the <code>matchparm</code> field. This lets you
specify the character you want to test directly in the pattern definition.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-150"></a>16.3.9 MatchToChar</font></strong></p>

<p><font face="Arial" size="2">Like <code>matchtostr</code>, <code>matchtochar</code>
matches all characters up to and including a character you specify. This is similar to <code>brkcset</code>
except you don't have to create a character set containing a single member and <code>brkcset</code>
skips up to but not including the specified character(s). <code>Matchtochar</code> fails
if it cannot find the specified character in the input string.</font></p>

<p><font face="Arial" size="2">Example:</font></p>

<pre><font face="Courier New" size="2">DoToSpace       pattern {matchtochar, ' '}
                 .
                 .
                 .
                lesi    String
                ldxi    DoSpace
                xor     cx, cx
                match
                jnc     NoSpace</font></pre>

<p><font face="Arial" size="2">This call to <code>match</code> will fail if there are no
spaces left in the input string. If there are, the call to <code>matchtochar</code> will
skip over all characters up to, and including, the first space. This is a useful pattern
for skipping over words in a string.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-164"></a>16.3.10 MatchChars</font></strong></p>
<code>

<p><font face="Arial" size="2">Matchchars</code> skips zero or more occurrences of a singe
character in an input string. It is similar to <code>spancset</code> except you can
specify a single character rather than an entire character set with a single member. Like <code>matchchar</code>,
<code>matchchars</code> expects a single character in the L.O. byte of the <code>matchparm</code>
field. Since this routine matches zero or more occurrences of that character, it always
succeeds.</font></p>

<p><font face="Arial" size="2">Example:</font></p>

<pre><font face="Courier New" size="2">Skip2NextWord   pattern {matchtochar, ' ', 0, SkipSpcs}
SkipSpcs        pattern {matchchars, ' '}
                 .
                 .
                 .
                lesi    String
                ldxi    Skip2NextWord
                xor     cx, cx
                match
                jnc     NoWord</font></pre>

<p><font face="Arial" size="2">The code segment skips to the beginning of the next word in
a string. It fails if there are no additional words in the string (i.e., the string
contains no spaces).</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-179"></a>16.3.11 MatchToPat</font></strong></p>
<code>

<p><font face="Arial" size="2">Matchtopat</code> matches all characters in a string up to
and including the substring matched by some other pattern. This is one of the two
facilities the UCR Standard Library pattern matching routines provide to allow the
implementation of nonterminal function calls. This matching function succeeds if it finds
a string matching the specified pattern somewhere on the line. If it succeeds, it skips
the characters through the last character matched by the pattern parameter. As you would
expect, the <code>matchparm</code> field contains the address of the pattern to match.</font></p>

<p><font face="Arial" size="2">Example:</font></p>

<pre><font face="Courier New" size="2">; Assume there is a pattern &quot;expression&quot; that matches arithmetic
; expressions. The following pattern determines if there is such an
; expression on the line followed by a semicolon.

FindExp         pattern {matchtopat, expression, 0, MatchSemi}
MatchSemi       pattern {matchchar, ';'}
                 .
                 .
                 .
                lesi    String
                ldxi    FindExp
                xor     cx, cx
                match
                jnc     NoExp</font></pre>

<h3><strong><font face="Arial" size="3"><a name="HEADING5-197"></a>16.3.12 EOS</font></strong></h3>

<p><font face="Arial" size="2">The <code>EOS</code> pattern matches the end of a string.
This pattern, which must obviously appear at the end of a pattern list if it appears at
all, checks for the zero terminating byte. Since the Standard Library routines only match
prefixes, you should stick this pattern at the end of a list if you want to ensure that a
pattern exactly matches a string with no left over characters at the end. <code>EOS</code>
succeeds if it matches the zero terminating byte, it fails otherwise.</font></p>

<p><font face="Arial" size="2">Example:</font></p>

<pre><font face="Courier New" size="2">SkipNumber      pattern {anycset, digits, 0, SkipDigits}
SkipDigits      pattern {spancset, digits, 0, EOSPat}
EOSPat          pattern {EOS}
                 .
                 .
                 .
                lesi    String
                ldxi    SkipNumber
                xor     cx, cx
                match
                jnc     NoNumber</font></pre>

<p><font face="Arial" size="2">The <code>SkipNumber</code> pattern matches strings that
contain only decimal digits (from the start of the match to the end of the string). Note
that <code>EOS</code> requires no parameters, not even a matchparm parameter.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-213"></a>16.3.13 ARB</font></strong></p>
<code>

<p><font face="Arial" size="2">ARB</code> matches any number of arbitrary characters. This
pattern matching function is equivalent to <img SRC="../images/capsigma.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/capsigma.gif" WIDTH="13" HEIGHT="13">*. Note that <code>ARB</code>
is a very inefficient routine to use. It works by assuming it can match all remaining
characters in the string and then tries to match the pattern specified by the <code>nextpattern</code>
field. If the <code>nextpattern</code> item fails, <code>ARB</code> backs up one character
and tries matching <code>nextpattern</code> again. This continues until the pattern
specified by <code>nextpattern</code> succeeds or <code>ARB</code> backs up to its initial
starting position. <code>ARB</code> succeeds if the pattern specified by <code>nextpattern</code>
succeeds, it fails if it backs up to its initial starting position. </font></p>

<p><font face="Arial" size="2">Given the enormous amount of backtracking that can occur
with <code>ARB</code> (especially on long strings), you should try to avoid using this
pattern if at all possible. The <code>matchtostr</code>, <code>matchtochar</code>, and <code>matchtopat</code>
functions accomplish much of what <code>ARB</code> accomplishes, but they work forward
rather than backward in the source string and may be more efficient. <code>ARB</code> is
useful mainly if you're sure the following pattern appears late in the string you're
matching or if the string you want to match occurs several times and you want to match the
last occurrence (<code>matchtostr</code>, <code>matchtochar</code>, and <code>matchtopat</code>
always match the first occurrence they find).</font></p>

<p><font face="Arial" size="2">Example:</font></p>

<pre><font face="Courier New" size="2">SkipNumber      pattern {ARB,0,0,SkipDigit}
SkipDigit       pattern {anycset, digits, 0, SkipDigits}
SkipDigits      pattern {spancset, digits}
                 .
                 .
                 .
                lesi    String
                ldxi    SkipNumber
                xor     cx, cx
                match
                jnc     NoNumber</font></pre>

<p><font face="Arial" size="2">This code example matches the last number that appears on
an input line. Note that <code>ARB</code> does not use the <code>matchparm</code> field,
so you should set it to zero by default.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-230"></a>16.3.14 ARBNUM</font></strong></p>
<code>

<p><font face="Arial" size="2">ARBNUM</code> matches an arbitrary number (zero or more) of
patterns that occur in the input string. If <em>R</em> represents some nonterminal number
(pattern matching function), then <code>ARBNUM</code>(<em>R</em> ) is equivalent to the
production <code>ARBNUM </code><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"><em>R ARBNUM </em>|
<img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11">. </font></p>

<p><font face="Arial" size="2">The <code>matchparm</code> field contains the address of
the pattern that <code>ARBNUM</code> attempts to match. </font></p>

<p><font face="Arial" size="2">Example:</font></p>

<pre><font face="Courier New" size="2">SkipNumbers     pattern {ARBNUM, SkipNumber}
SkipNumber      pattern {anycset, digits, 0, SkipDigits}
SkipDigits      pattern {spancset, digits, 0, EndDigits}
EndDigits       pattern {matchchars, ' ', EndString}
EndString       pattern {EOS}
                 .
                 .
                 .
                lesi    String
                ldxi    SkipNumbers
                xor     cx, cx
                match
                jnc     IllegalNumbers</font></pre>

<p><font face="Arial" size="2">This code accepts the input string if it consists of a
sequence of zero or more numbers separated by spaces and terminated with the <code>EOS</code>
pattern. Note the use of the <code>matchalt</code> field in the <code>EndDigits</code>
pattern to select <code>EOS</code> rather than a space for the last number in the string.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-249"></a>16.3.15 Skip</font></strong></p>
<code>

<p><font face="Arial" size="2">Skip</code> matches n arbitrary characters in the input
string. The <code>matchparm</code> field is an integer value containing the number of
characters to skip. Although the <code>matchparm</code> field is a double word, this
routine limits the number of characters you can skip to 16 bits (65,535 characters); that
is, n is the L.O. word of the <code>matchparm</code> field. This should prove sufficient
for most needs.</font></p>

<p><font face="Arial" size="2"><code>Skip</code> succeeds if there are at least n
characters left in the input string; it fails if there are fewer than n characters left in
the input string.</font></p>

<p><font face="Arial" size="2">Example:</font></p>

<pre><font face="Courier New" size="2">Skip1st6        pattern {skip, 6, 0, SkipNumber}
SkipNumber      pattern {anycset, digits, 0, SkipDigits}
SkipDigits      pattern {spancset, digits, 0, EndDigits}
EndDigits       pattern {EOS}
                 .
                 .
                 .
                lesi    String
                ldxi    Skip1st6
                xor     cx, cx
                match
                jnc     IllegalItem</font></pre>

<p><font face="Arial" size="2">This example matches a string containing six arbitrary
characters followed by one or more decimal digits and a zero terminating byte.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-267"></a>16.3.16 Pos</font></strong></p>
<code>

<p><font face="Arial" size="2">Pos</code> succeeds if the matching functions are currently
at the nth character in the string, where n is the value in the L.O. word of the <code>matchparm</code>
field. <code>Pos</code> fails if the matching functions are not currently at position n in
the string. Unlike the pattern matching functions you've seen so far, <code>pos</code>
does not consume any input characters. Note that the string starts out at position zero.
So when you use the <code>pos</code> function, it succeeds if you've matched n characters
at that point.</font></p>

<p><font face="Arial" size="2">Example:</font></p>

<pre><font face="Courier New" size="2">SkipNumber      pattern {anycset, digits, 0, SkipDigits}
SkipDigits      pattern {spancset, digits, 0, EndDigits}
EndDigits       pattern {pos, 4}
                 .
                 .
                 .
                lesi    String
                ldxi    SkipNumber
                xor     cx, cx
                match
                jnc     IllegalItem</font></pre>

<p><font face="Arial" size="2">This code matches a string that begins with exactly 4
decimal digits.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-283"></a>16.3.17 RPos</font></strong></p>
<code>

<p><font face="Arial" size="2">Rpos</code> works quite a bit like the <code>pos</code>
function except it succeeds if the current position is n character positions from the end
of the string. Like <code>pos</code>, n is the L.O. 16 bits of the <code>matchparm</code>
field. Also like <code>pos</code>, <code>rpos</code> does not consume any input
characters.</font></p>

<p><font face="Arial" size="2">Example:</font></p>

<pre><font face="Courier New" size="2">SkipNumber      pattern {anycset, digits, 0, SkipDigits}
SkipDigits      pattern {spancset, digits, 0, EndDigits}
EndDigits       pattern {rpos, 4}
                 .
                 .
                 .
                lesi    String
                ldxi    SkipNumber
                xor     cx, cx
                match
                jnc     IllegalItem</font></pre>

<p><font face="Arial" size="2">This code matches any string that is all decimal digits
except for the last four characters of the string. The string must be at least five
characters long for the above pattern match to succeed.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-299"></a>16.3.18 GotoPos</font></strong></p>
<code>

<p><font face="Arial" size="2">Gotopos</code> skips over any characters in the string
until it reaches character position n in the string. This function fails if the pattern is
already beyond position n in the string. The L.O. word of the <code>matchparm</code> field
contains the value for n. </font></p>

<p><font face="Arial" size="2">Example:</font></p>

<pre><font face="Courier New" size="2">SkipNumber      pattern {gotopos, 10, 0, MatchNmbr}
MatchNmbr       pattern {anycset, digits, 0, SkipDigits}
SkipDigits      pattern {spancset, digits, 0, EndDigits}
EndDigits       pattern {rpos, 4}
                 .
                 .
                 .
                lesi    String
                ldxi    SkipNumber
                xor     cx, cx
                match
                jnc     IllegalItem</font></pre>

<p><font face="Arial" size="2">This example code skips to position 10 in the string and
attempts to match a string of digits starting with the 11th character. This pattern
succeeds if the there are four characters remaining in the string after processing all the
digits.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-316"></a>16.3.19 RGotoPos</font></strong></p>
<code>

<p><font face="Arial" size="2">Rgotopos</code> works like <code>gotopos</code> except it
goes to the position specified from the end of the string. <code>Rgotopos</code> fails if
the matching routines are already beyond position n from the end of the string. As with <code>gotopos</code>,
the L.O. word of the <code>matchparm</code> field contains the value for n.</font></p>

<p><font face="Arial" size="2">Example:</font></p>

<pre><font face="Courier New" size="2">SkipNumber      pattern {rgotopos, 10, 0, MatchNmbr}
MatchNmbr       pattern {anycset, digits, 0, SkipDigits}
SkipDigits      pattern {spancset, digits}
                 .
                 .
                 .
                lesi    String
                ldxi    SkipNumber
                xor     cx, cx
                match
                jnc     IllegalItem</font></pre>

<p><font face="Arial" size="2">This example skips to ten characters from the end of the
string and then attempts to match one or digits starting at that point. It fails if there
aren't at least 11 characters in the string or the last 10 characters don't begin with a
string of one or more digits.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING5-332"></a>16.3.20 SL_Match2</font></strong></p>

<p><font face="Arial" size="2">The <code>sl_match2</code> routine is nothing more than a
recursive call to match. The <code>matchparm</code> field contains the address of pattern
to match. This is quite useful for simulating parenthesis around a pattern in a pattern
expression. As far as matching strings are concerned, <code>pattern1</code> and <code>pattern2</code>,
below, are equivalent:</font></p>

<pre><font face="Courier New" size="2">Pattern2		pattern	{sl_match2, Pattern1}
Pattern1		pattern	{matchchar, 'a'}</font></pre>

<p><font face="Arial" size="2">The only difference between invoking a pattern directly and
invoking it with <code>sl_match2</code> is that <code>sl_match2</code> tweaks some
internal variables to keep track of matching positions within the input string. Later, you
can extract the character string matched by <code>sl_match2</code> using the <code>patgrab</code>
routine. </font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH16-4.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH16-4.html">Chapter Sixteen</a> (Part 4)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH16-6.html">Chapter Sixteen</a> (Part 6)&nbsp; </strong></font><a href="CH16-6.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Sixteen: Pattern Matching
(Part 5)<br>
29 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_16/CH16-5.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:31 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
