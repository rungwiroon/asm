<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_16/CH16-2.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:07 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER SIXTEEN: PATTERN MATCHING (Part 2)</title>
</head>

<body stylesrc="../toc.html" topmargin="10" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING2"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH16-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH16-1.html">Chapter Sixteen</a> (Part 1)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH16-3.html">Chapter Sixteen</a> (Part 3)&nbsp; </strong></font><a href="CH16-3.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10"><a NAME="HEADING2-1"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0"><font face="Arial" size="4"><strong>CHAPTER SIXTEEN:<br>
    PATTERN MATCHING (Part 2)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10"></td>
  </tr>
  <tr>
    <td width="100%"><font face="Arial" size="2"><a HREF="#HEADING2-1"><b>16.1.2.2 </b>-
    Nondeterministic Finite State Automata (NFAs)</a> <br>
    <a HREF="#HEADING2-12"><b>16.1.2.3 </b>- Converting Regular Expressions to NFAs</a> <br>
    <a HREF="#HEADING2-26"><b>16.1.2.4 </b>- Converting an NFA to Assembly Language</a></font></td>
  </tr>
</table>
</center></div>

<h3><strong><font face="Arial" size="3">16.1.2.2 Nondeterministic Finite State Automata
(NFAs)</font></strong></h3>

<p><font face="Arial" size="2">An NFA is a directed graph with state numbers associated
with each node and characters or character strings associated with each edge of the graph.
A distinguished state, the starting state, determines where the machine begins attempting
to match an input string. With the machine in the starting state, it compares input
characters against the characters or strings on each edge of the graph. If a set of input
characters matches one of the edges, the machine can change states from the node at the
start of the edge (the tail) to the state at the end of the edge (the head).</font></p>

<p><font face="Arial" size="2">Certain other states, known as final or accepting states,
are usually present as well. If a machine winds up in a final state after exhausting all
the input characters, then that machine accepts or matches that string. If the machine
exhausts the input and winds up in a state that is not a final state, then that machine
rejects the string. Figure 16.1 shows an example NFA for the floating point RE presented
earlier. </font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch16a4.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/ch16a4.gif" WIDTH="460" HEIGHT="196"> </font></p>

<p><font face="Arial" size="2">By convention, we'll always assume that the starting state
is state zero. We will denote final states (there may be more than one) by using a double
circle for the state (state eight is the final state above).</font></p>

<p><font face="Arial" size="2">An NFA always begins with an input string in the starting
state (state zero). On each edge coming out of a state there is either <img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11">, a single
character, or a character string. To help unclutter the NFA diagrams, we will allow
expressions of the form &quot; xxx | yyy | zzz | &quot; where xxx, yyy, and zzz are <img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11">, a single
character, or a character string. This corresponds to multiple edges from one state to the
other with a single item on each edge. In the example above, </font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch16a5.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/ch16a5.gif" WIDTH="92" HEIGHT="25"> </font></p>

<p><font face="Arial" size="2">is equivalent to </font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch16a6.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/ch16a6.gif" WIDTH="92" HEIGHT="63"> </font></p>

<p><font face="Arial" size="2">Likewise, we will allow sets of characters, specified by a
string of the form x-y, to denote the expression x | x+1 | x+2 | ... | y.</font></p>

<p><font face="Arial" size="2">Note that an NFA accepts a string if there is some path
from the starting state to an accepting state that exhausts the input string. There may be
multiple paths from the starting state to various final states. Furthermore, there may be
some particular path from the starting state to a non-accepting state that exhausts the
input string. This does not necessarily mean the NFA rejects that string; if there is some
other path from the starting state to an accepting state, then the NFA accepts the string.
An NFA rejects a string only if there are no paths from the starting state to an accepting
state that exhaust the string.</font></p>

<p><font face="Arial" size="2">Passing through an accepting state does not cause the NFA
to accept a string. You must wind up in a final state and exhaust the input string.</font></p>

<p><font face="Arial" size="2">To process an input string with an NFA, begin at the
starting state. The edges leading out of the starting state will have a character, a
string, or <img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11">associated
with them. If you choose to move from one state to another along an edge with a single
character, then remove that character from the input string and move to the new state
along the edge traversed by that character. Likewise, if you choose to move along an edge
with a character string, remove that character string from the input string and switch to
the new state. If there is an edge with the empty string, <img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11">, then you may
elect to move to the new state given by that edge without removing any characters from the
input string. </font></p>

<p><font face="Arial" size="2">Consider the string &quot;1.25e2&quot; and the NFA in
Figure 16.1. From the starting state we can move to state one using the <img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11">string (there
is no leading plus or minus, so <img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11">is our only
option). From state one we can move to state two by matching the &quot;1&quot; in our
input string with the set 0-9; this eats the &quot;1&quot; in our input string leaving
&quot;.25e2&quot;. In state two we move to state three and eat the period from the input
string, leaving &quot;25e2&quot;. State three loops on itself with numeric input
characters, so we eat the &quot;2&quot; and &quot;5&quot; characters at the beginning of
our input string and wind up back in state three with a new input string of
&quot;e2&quot;. The next input character is &quot;e&quot;, but there is no edge coming out
of state three with an &quot;e&quot; on it; there is, however, an <img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11">-edge, so we
can use that to move to state four. This move does not change the input string. In state
four we can move to state five on an &quot;e&quot; character. This eats the &quot;e&quot;
and leaves us with an input string of &quot;2&quot;. Since this is not a plus or minus
character, we have to move from state five to state six on the <img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11">edge. Movement
from state six to state seven eats the last character in our string. Since the string is
empty (and, in particular, it does not contain any digits), state seven cannot loop back
on itself. We are currently in state seven (which is not a final state) and our input
string is exhausted. However, we can move to state eight (the accepting state) since the
transition between states seven and eight is an <img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11">edge. Since we
are in a final state and we've exhausted the input string, This NFA accepts the input
string.</font></p>

<p><strong><font face="Arial" size="3">&nbsp;<a NAME="HEADING2-12"></a>16.1.2.3 Converting
Regular Expressions to NFAs</font></strong></p>

<p><font face="Arial" size="2">If you have a regular expression and you want to build a
machine that recognizes strings in the regular language specified by that expression, you
will need to convert the RE to and NFA. It turns out to be very easy to convert a regular
expression to an NFA. To do so, just apply the following rules: </font>

<ul>
  <li><font face="Arial" size="2">The NFA representing regular language denoted by the regular
    expression <img SRC="../images/emptyset.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/emptyset.gif" WIDTH="16" HEIGHT="13">(the empty
    set) is a single, non-accepting state. </font></li>
  <li><p align="left"><font face="Arial" size="2">If a regular expression contains an <img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11">, a single
    character, or a string, create two states and draw an arc between them with <img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11">, the single
    character, or the string as the label. For example, the RE &quot;a&quot; is converted to
    an NFA as</font></p>
  </li>
</ul>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch16a7.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/ch16a7.gif" WIDTH="92" HEIGHT="22"> </font></p>

<p align="center"><font face="Arial" size="2">Let the symbol</font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch16a8.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/ch16a8.gif" WIDTH="54" HEIGHT="16"></font></p>

<menu>
  <li><p align="left"><font face="Arial" size="2">denote an NFA which recognizes some regular
    language specified by some regular expression <em>r, s, </em>or <em>t.</em> If a regular
    expression takes the form <em>rs</em> then the corresponding NFA is</font></p>
  </li>
</menu>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch16a9.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/ch16a9.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="214" HEIGHT="17"></font></p>

<menu>
  <li><font face="Arial" size="2">If a regular expression takes the form <em>r</em> | <em>s</em>,
    then the corresponding NFA is</font></li>
</menu>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch16a10.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/ch16a10.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="213" HEIGHT="52"></font></p>

<menu>
  <li><p align="left"><font face="Arial" size="2">If a regular expression takes the form <em>r*</em>
    then the corresponding NFA is</font></p>
  </li>
</menu>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch16a11.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/ch16a11.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="82" HEIGHT="58"></font></p>

<p><font face="Arial" size="2">All of the other forms of regular expressions are easily
synthesized from these, therefore, converting those other forms of regular expressions to
NFAs is a simple two-step process, convert the RE to one of these forms, and then convert
this form to the NFA. For example, to convert <em>r</em>+ to an NFA, you would first
convert <em>r</em>+ to <em>rr</em>*. This produces the NFA: </font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch16a12.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/ch16a12.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="172" HEIGHT="58"> </font></p>

<p><font face="Arial" size="2">The following example converts the regular expression for
an integer constant to an NFA. The first step is to create an NFA for the regular
expression (+ | - | <img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11">). The
complete construction becomes </font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch16a13.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/ch16a13.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="236" HEIGHT="75"> </font></p>

<p><font face="Arial" size="2">Although we can obviously optimize this to </font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch16a14.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/ch16a14.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="92" HEIGHT="25"> </font></p>

<p><font face="Arial" size="2">The next step is to handle the [0-9]+ regular expression;
after some minor optimization, this becomes the NFA </font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch16a15.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/ch16a15.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="82" HEIGHT="65"> </font></p>

<p><font face="Arial" size="2">Now we simply concatenate the results to produce: </font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch16a16.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/ch16a16.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="212" HEIGHT="65"> </font></p>

<p><font face="Arial" size="2">All we need now are starting and final states. The starting
state is always the first state of the NFA created by the conversion of the leftmost item
in the regular expression. The final state is always the last state of the NFA created by
the conversion of the rightmost item in the regular expression. Therefore, the complete
regular expression for integer constants (after optimizing out the middle edge above,
which serves no purpose) is </font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch16a17.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/ch16a17.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="154" HEIGHT="65"> </font></p>

<p><strong><font face="Arial" size="3"><a NAME="382"></a><a NAME="HEADING2-26"></a>16.1.2.4
Converting an NFA to Assembly Language</font></strong></p>

<p><font face="Arial" size="2">There is only one major problem with converting an NFA to
an appropriate matching function - NFAs are nondeterministic. If you're in some state and
you've got some input character, say &quot;a&quot;, there is no guarantee that the NFA
will tell you what to do next. For example, there is no requirement that edges coming out
of a state have unique labels. You could have two or more edges coming out of a state, all
leading to different states on the single character &quot;a&quot;. If an NFA accepts a
string, it only guarantees that there is some path that leads to an accepting state, there
is no guarantee that this path will be easy to find.</font></p>

<p><font face="Arial" size="2">The primary technique you will use to resolve the
nondeterministic behavior of an NFA is backtracking. A function that attempts to match a
pattern using an NFA begins in the starting state and tries to match the first
character(s) of the input string against the edges leaving the starting state. If there is
only one match, the code must follow that edge. However, if there are two possible edges
to follow, then the code must arbitrarily choose one of them and remember the others as
well as the current point in the input string. Later, if it turns out the algorithm
guessed an incorrect edge to follow, it can return back and try one of the other
alternatives (i.e., it backtracks and tries a different path). If the algorithm exhausts
all alternatives without winding up in a final state (with an empty input string), then
the NFA does not accept the string.</font></p>

<p><font face="Arial" size="2">Probably the easiest way to implement backtracking is via
procedure calls. Let us assume that a matching procedure returns the carry flag set if it
succeeds (i.e., accepts a string) and returns the carry flag clear if it fails (i.e.,
rejects a string). If an NFA offers multiple choices, you could implement that portion of
the NFA as follows: </font></p>

<p align="center"><img SRC="images/ch16a18.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/ch16a18.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="207" HEIGHT="64"> </p>

<pre><font face="Courier New" size="2">AltRST          proc    near
                push    ax              ;The purpose of these two instructions
                mov     ax, di          ; is to preserve di in case of failure.
                call    r
                jc      Success
                mov     di, ax          ;Restore di (it may be modified by r).
                call    s
                jc      Success
                mov     di, ax          ;Restore di (it may be modified by s).
                call    t
Success:        pop     ax              ;Restore ax.
                ret
AltRST          endp</font></pre>

<p><font face="Arial" size="2">If the <code>r</code> matching procedure succeeds, there is
no need to try <code>s</code> and <code>t</code>. On the other hand, if <code>r</code>
fails, then we need to try <code>s</code>. Likewise, if <code>r</code> and <code>s</code>
both fail, we need to try <code>t</code>. <code>AltRST</code> will fail only if <code>r</code>,
<code>s</code>, and <code>t</code> all fail. This code assumes that <code>es:di</code>
points at the input string to match. On return, <code>es:di</code> points at the next
available character in the string after a match or it points at some arbitrary point if
the match fails. This code assumes that <code>r</code>, <code>s</code>, and <code>t</code>
all preserve the <code>ax</code> register, so it preserves a pointer to the current point
in the input string in <code>ax</code> in the event <code>r</code> or <code>s</code> fail.</font></p>

<p><font face="Arial" size="2">To handle the individual NFA associated with simple regular
expressions (i.e., matching <img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11">or a single
character) is not hard at all. Suppose the matching function r matches the regular
expression (+ | - | <img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11">). The
complete procedure for r is </font></p>

<pre><font face="Courier New" size="2">r               proc    near
                cmp     byte ptr es:[di], '+'
                je      r_matched
                cmp     byte ptr es:[di], '-'
                jne     r_nomatch
r_matched:      inc     di
r_nomatch:      stc
                ret
r               endp</font></pre>

<p><font face="Arial" size="2">Note that there is no explicit test for <img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11">. If <img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11">is one of the
alternatives, the function attempts to match one of the other alternatives first. If none
of the other alternatives succeed, then the matching function will succeed anyway,
although it does not consume any input characters (which is why the above code skips over
the <code>inc di</code> instruction if it does not match &quot;+&quot; or &quot;-&quot;).
Therefore, any matching function that has <img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11">as an
alternative will always succeed. </font></p>

<p><font face="Arial" size="2">Of course, not all matching functions succeed in every
case. Suppose the <code>s</code> matching function accepts a single decimal digit. the
code for <code>s</code> might be the following:</font></p>

<pre><font face="Courier New" size="2">s               proc    near
                cmp     byte ptr es:[di], '0'
                jb      s_fails
                cmp     byte ptr es:[di], '9'
                ja      s_fails
                inc     di
                stc
                ret

s_fails:        clc
                ret
s               endp</font></pre>

<p><font face="Arial" size="2">If an NFA takes the form: </font></p>

<p align="center"><img SRC="images/ch16a19.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/ch16a19.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="214" HEIGHT="17"> </p>

<p><font face="Arial" size="2">Where <code>x</code> is any arbitrary character or string
or <img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11">, the
corresponding assembly code for this procedure would be </font></p>

<pre><font face="Courier New" size="2">ConcatRxS       proc    near
                call    r
                jnc     CRxS_Fail       ;If no r, we won't succeed

; Note, if x=e then simply delete the following three statements.
; If x is a string rather than a single character, put the the additional
; code to match all the characters in the string.

                cmp     byte ptr es:[di], 'x'
                jne     CRxS_Fail
                inc     di

                call    s
                jnc     CRxS_Fail
                stc                     ;Success!
                ret

CRxS_Fail:      clc
                ret
ConcatRxS       endp</font></pre>

<p><font face="Arial" size="2">If the regular expression is of the form r* and the
corresponding NFA is of the form </font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch16a20.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/ch16a20.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="82" HEIGHT="58"> </font></p>

<p><font face="Arial" size="2">Then the corresponding 80x86 assembly code can look
something like the following:</font></p>

<pre><font face="Courier New" size="2">RStar           proc    near
                call    r
                jc      RStar
                stc
                ret
RStar           endp</font></pre>

<p><font face="Arial" size="2">Regular expressions based on the Kleene star always succeed
since they allow zero or more occurrences. That is why this code always returns with the
carry flag set.</font></p>

<p><font face="Arial" size="2">The Kleene Plus operation is only slightly more complex,
the corresponding (slightly optimized) assembly code is</font></p>

<pre><font face="Courier New" size="2">RPlus           proc    near
                call    r
                jnc     RPlus_Fail
RPlusLp:        call    r
                jc      RPlusLp
                stc
                ret

RPlus_Fail:     clc
                ret
RPlus           endp</font></pre>

<p><font face="Arial" size="2">Note how this routine fails if there isn't at least one
occurrence of <code>r</code>.</font></p>

<p><font face="Arial" size="2">A major problem with backtracking is that it is potentially
inefficient. It is very easy to create a regular expression that, when converted to an NFA
and assembly code, generates considerable backtracking on certain input strings. This is
further exacerbated by the fact that matching routines, if written as described above, are
generally very short; so short, in fact, that the procedure calls and returns make up a
significant portion of the execution time. Therefore, pattern matching in this fashion,
although easy, can be slower than it has to be.</font></p>

<p><font face="Arial" size="2">This is just a taste of how you would convert REs to NFAs
to assembly language. We will not go into further detail in this chapter; not because this
stuff isn't interesting to know, but because you will rarely use these techniques in a
real program. If you need high performance pattern matching you would not use
nondeterministic techniques like these. If you want the ease of programming offered by the
conversion of an NFA to assembly language, you still would not use this technique.
Instead, the UCR Standard Library provides very powerful pattern matching facilities
(which exceed the capabilities of NFAs), so you would use those instead; but more on that
a little later.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH16-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH16-1.html">Chapter Sixteen</a> (Part 1)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH16-3.html">Chapter Sixteen</a> (Part 3)&nbsp; </strong></font><a href="CH16-3.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Sixteen: Pattern Matching
(Part 2)<br>
29 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_16/CH16-2.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:25 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
