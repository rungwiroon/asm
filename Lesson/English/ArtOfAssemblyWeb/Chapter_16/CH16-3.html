<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_16/CH16-3.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:25 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER SIXTEEN: PATTERN MATCHING (Part 3)</title>
</head>

<body stylesrc="../toc.html" topmargin="10" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING3"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH16-2.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH16-2.html">Chapter Sixteen</a> (Part 2)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH16-4.html">Chapter Sixteen</a> (Part 4)&nbsp; </strong></font><a href="CH16-4.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10"><a NAME="HEADING3-1"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0"><font face="Arial" size="4"><strong>CHAPTER SIXTEEN:<br>
    PATTERN MATCHING (Part 3)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10"></td>
  </tr>
  <tr>
    <td width="100%"><font face="Arial" size="2"><a HREF="#HEADING3-1"><b>16.1.2.5 </b>-
    Deterministic Finite State Automata (DFAs)</a> <br>
    <a HREF="#HEADING3-48"><b>16.1.2.6 </b>- Converting a DFA to Assembly Language</a> </font></td>
  </tr>
</table>
</center></div>

<h3><font face="Arial" size="3">16.1.2.5 Deterministic Finite State Automata (DFAs)</font></h3>

<p><font face="Arial" size="2">Nondeterministic finite state automata, when converted to
actual program code, may suffer from performance problems because of the backtracking that
occurs when matching a string. Deterministic finite state automata solve this problem by
comparing different strings in parallel. Whereas, in the worst case, an NFA may require n
comparisons, where n is the sum of the lengths of all the strings the NFA recognizes, a
DFA requires only m comparisons (worst case), where m is the length of the longest string
the DFA recognizes.</font></p>

<p><font face="Arial" size="2">For example, suppose you have an NFA that matches the
following regular expression (the set of 80x86 real-mode mnemonics that begin with an
&quot;A&quot;):</font></p>

<pre><font face="Arial" size="2">( AAA | AAD | AAM | AAS | ADC | ADD | AND )</font></pre>

<p><font face="Arial" size="2">A typical implementation as an NFA might look like the
following:</font></p>

<pre><font face="Courier New" size="2">MatchAMnem      proc    near
                strcmpl
                byte    &quot;AAA&quot;,0
                je      matched
                strcmpl
                byte    &quot;AAD&quot;,0
                je      matched
                strcmpl
                byte    &quot;AAM&quot;,0
                je      matched
                strcmpl
                byte    &quot;AAS&quot;,0
                je      matched
                strcmpl
                byte    &quot;ADC&quot;,0
                je      matched
                strcmpl
                byte    &quot;ADD&quot;,0
                je      matched
                strcmpl
                byte    &quot;AND&quot;,0
                je      matched
                clc
                ret

matched:        add     di, 3
                stc
                ret
MatchAMnem      endp</font></pre>

<p><font face="Arial" size="2">If you pass this NFA a string that it doesn't match, e.g.,
&quot;AAND&quot;, it must perform seven string comparisons, which works out to about 18
character comparisons (plus all the overhead of calling <code>strcmpl</code>). In fact, a
DFA can determine that it does not match this character string by comparing only three
characters.</font></p>

<p><font face="Arial" size="2">A DFA is a special form of an NFA with two restrictions.
First, there must be <em>exactly</em> one edge coming out of each node for each of the
possible input characters; this implies that there must be one edge for each possible
input symbol <em>and</em> you may not have two edges with the same input symbol. Second,
you cannot move from one state to another on the empty string, <img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11">. A DFA is
deterministic because at each state the next input symbol determines the next state you
will enter. Since each input symbol has an edge associated with it, there is never a case
where a DFA &quot;jams&quot; because you cannot leave the state on that input symbol.
Similarly, the new state you enter is never ambiguous because there is only one edge
leaving any particular state with the current input symbol on it. Figure16.2 shows the DFA
that handles integer constants described by the regular expression </font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch16a21.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/ch16a21.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="460" HEIGHT="186"> </font></p>

<p><font face="Arial" size="2">(+ | - | <img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11">) [0-9]+ </font></p>

<p><font face="Arial" size="2">Note than an expression of the form &quot;<img SRC="../images/capsigma.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/capsigma.gif" WIDTH="13" HEIGHT="13"> -
[0-9]&quot; means <em>any character except a digit</em>; that is, the <em>complement</em>
of the set [0-9]. </font></p>

<p><font face="Arial" size="2">State three is a failure state. It is not an accepting
state and once the DFA enters a failure state, it is stuck there (i.e., it will consume
all additional characters in the input string without leaving the failure state). Once you
enter a failure state, the DFA has already rejected the input string. Of course, this is
not the only way to reject a string; the DFA above, for example, rejects the empty string
(since that leaves you in state zero) and it rejects a string containing only a
&quot;+&quot; or a &quot;-&quot; character.</font></p>

<p><font face="Arial" size="2">DFAs generally contain more states than a comparable NFA.
To help keep the size of a DFA under control, we will allow a few shortcuts that, in no
way, affect the operation of a DFA. First, we will remove the restriction that there be an
edge associated with each possible input symbol leaving every state. Most of the edges
leaving a particular state lead to the failure state. Therefore, our first simplification
will be to allow DFAs to drop the edges that lead to a failure state. If a input symbol is
not represented on an outgoing edge from some state, we will assume that it leads to a
failure state. The above DFA with this simplification appears in Figure 16.2. </font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch16a22.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/ch16a22.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="460" HEIGHT="89"> </font></p>

<p><font face="Arial" size="2">A second shortcut, that is actually present in the two
examples above, is to allow sets of characters (or the alternation symbol, &quot;|&quot;)
to associate several characters with a single edge. Finally, we will also allow strings
attached to an edge. This is a shorthand notation for a list of states which recognize
each successive character, i.e., the following two DFAs are equivalent: </font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch16a23.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/ch16a23.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="92" HEIGHT="24"> </font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch16a24.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/ch16a24.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="234" HEIGHT="23"> </font></p>

<p><font face="Arial" size="2">Returning to the regular expression that recognizes 80x86
real-mode mnemonics beginning with an &quot;A&quot;, we can construct a DFA that
recognizes such strings as shown in Figure 16.4. </font></p>

<p align="center"><font face="Arial" size="2"><img SRC="images/ch16a25.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/ch16a25.gif" NATURALSIZEFLAG="3" ALIGN="bottom" WIDTH="460" HEIGHT="169"> </font></p>

<p><font face="Arial" size="2">If you trace through this DFA by hand on several accepting
and rejecting strings, you will discover than it requires no more than six character
comparisons to determine whether the DFA should accept or reject an input string.</font></p>

<p><font face="Arial" size="2">Although we are not going to discuss the specifics here, it
turns out that regular expressions, NFAs, and DFAs are all equivalent. That is, you can
convert anyone of these to the others. In particular, you can always convert an NFA to a
DFA. Although the conversion isn't totally trivial, especially if you want an optimized
DFA, it is always possible to do so. Converting between all these forms is beginning to
leave the scope of this text. If you are interested in the details, any text on formal
languages or automata theory will fill you in.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING3-48"></a>16.1.2.6 Converting a DFA
to Assembly Language</font></strong></p>

<p><font face="Arial" size="2">It is relatively straightforward to convert a DFA to a
sequence of assembly instructions. For example, the assembly code for the DFA that accepts
the A-mnemonics in the previous section is</font></p>

<pre><font face="Courier New" size="2">DFA_A_Mnem      proc    near
                cmp     byte ptr es:[di], 'A'
                jne     Fail
                cmp     byte ptr es:[di+1], 'A'
                je      DoAA
                cmp     byte ptr es:[di+1], 'D'
                je      DoAD
                cmp     byte ptr es:[di+1], 'N'
                je      DoAN
Fail:           clc
                ret

DoAN:           cmp     byte ptr es:[di+2], 'D'
                jne     Fail
Succeed:        add     di, 3
                stc
                ret

DoAD:           cmp     byte ptr es:[di+2], 'D'
                je      Succeed
                cmp     byte ptr es:[di+2], 'C'
                je      Succeed
                clc                             ;Return Failure
                ret

DoAA:           cmp     byte ptr es:[di+2], 'A'
                je      Succeed
                cmp     byte ptr es:[di+2], 'D'
                je      Succeed
                cmp     byte ptr es:[di+2], 'M'
                je      Succeed
                cmp     byte ptr es:[di+2], 'S'
                je      Succeed
                clc
                ret
DFA_A_Mnem      endp</font></pre>

<p><font face="Arial" size="2">Although this scheme works and is considerably more
efficient than the coding scheme for NFAs, writing this code can be tedious, especially
when converting a large DFA to assembly code. There is a technique that makes converting
DFAs to assembly code almost trivial, although it can consume quite a bit of space - to
use state machines. A simple state machine is a two dimensional array. The columns are
indexed by the possible characters in the input string and the rows are indexed by state
number (i.e., the states in the DFA). Each element of the array is a new state number. The
algorithm to match a given string using a state machine is trivial, it is</font></p>

<pre><font face="Courier New" size="2">state := 0;
while (another input character ) do begin

	ch := next input character ;
	state := StateTable [state][ch];

end;
if (state in FinalStates) then accept
else reject;</font></pre>

<p><font face="Arial" size="2"><code>FinalStates</code> is a set of accepting states. If
the current state number is in this set after the algorithm exhausts the characters in the
string, then the state machine accepts the string, otherwise it rejects the string.</font></p>

<p><font face="Arial" size="2">The following state table corresponds to the DFA for the
&quot;A&quot; mnemonics appearing in the previous section:</font></p>
<div align="center"><center>

<table BORDER="1" bordercolor="#C0C0C0" width="30%" cellspacing="0" cellpadding="0">
  <caption><font face="Arial" size="2"><strong>State Machine for 80x86 &quot;A&quot;
  Instructions DFA</strong></font></caption>
  <tr>
    <th align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">State</font></strong></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">A</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">C</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">D</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">M</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">N</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">S</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">Else</font></th>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">0</font></strong></td>
    <td align="center"><font face="Arial" size="2">1</font></td>
    <td align="center"><font face="Arial" size="2">F</font></td>
    <td align="center"><font face="Arial" size="2">F</font></td>
    <td align="center"><font face="Arial" size="2">F</font></td>
    <td align="center"><font face="Arial" size="2">F</font></td>
    <td align="center"><font face="Arial" size="2">F</font></td>
    <td align="center"><font face="Arial" size="2">F</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">1</font></strong></td>
    <td align="center"><font face="Arial" size="2">3</font></td>
    <td align="center"><font face="Arial" size="2">F</font></td>
    <td align="center"><font face="Arial" size="2">4</font></td>
    <td align="center"><font face="Arial" size="2">F</font></td>
    <td align="center"><font face="Arial" size="2">2</font></td>
    <td align="center"><font face="Arial" size="2">F</font></td>
    <td align="center"><font face="Arial" size="2">F</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">2</font></strong></td>
    <td align="center"><font face="Arial" size="2">F</font></td>
    <td align="center"><font face="Arial" size="2">F</font></td>
    <td align="center"><font face="Arial" size="2">5</font></td>
    <td align="center"><font face="Arial" size="2">F</font></td>
    <td align="center"><font face="Arial" size="2">F</font></td>
    <td align="center"><font face="Arial" size="2">F</font></td>
    <td align="center"><font face="Arial" size="2">F</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">3</font></strong></td>
    <td align="center"><font face="Arial" size="2">5</font></td>
    <td align="center"><font face="Arial" size="2">F</font></td>
    <td align="center"><font face="Arial" size="2">5</font></td>
    <td align="center"><font face="Arial" size="2">5</font></td>
    <td align="center"><font face="Arial" size="2">F</font></td>
    <td align="center"><font face="Arial" size="2">5</font></td>
    <td align="center"><font face="Arial" size="2">F</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">4</font></strong></td>
    <td align="center"><font face="Arial" size="2">F</font></td>
    <td align="center"><font face="Arial" size="2">5</font></td>
    <td align="center"><font face="Arial" size="2">5</font></td>
    <td align="center"><font face="Arial" size="2">F</font></td>
    <td align="center"><font face="Arial" size="2">F</font></td>
    <td align="center"><font face="Arial" size="2">F</font></td>
    <td align="center"><font face="Arial" size="2">F</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">5</font></strong></td>
    <td align="center"><font face="Arial" size="2">F</font></td>
    <td align="center"><font face="Arial" size="2">F</font></td>
    <td align="center"><font face="Arial" size="2">F</font></td>
    <td align="center"><font face="Arial" size="2">F</font></td>
    <td align="center"><font face="Arial" size="2">F</font></td>
    <td align="center"><font face="Arial" size="2">F</font></td>
    <td align="center"><font face="Arial" size="2">F</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">F</font></strong></td>
    <td align="center"><font face="Arial" size="2">F</font></td>
    <td align="center"><font face="Arial" size="2">F</font></td>
    <td align="center"><font face="Arial" size="2">F</font></td>
    <td align="center"><font face="Arial" size="2">F</font></td>
    <td align="center"><font face="Arial" size="2">F</font></td>
    <td align="center"><font face="Arial" size="2">F</font></td>
    <td align="center"><font face="Arial" size="2">F</font></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">State five is the only accepting state.</font></p>

<p><font face="Arial" size="2">There is one major drawback to using this table driven
scheme - the table will be quite large. This is not apparent in the table above because
the column labelled &quot;Else&quot; hides considerable detail. In a true state table, you
will need one column for each possible input character. since there are 256 possible input
characters (or at least 128 if you're willing to stick to seven bit ASCII), the table
above will have 256 columns. With only one byte per element, this works out to about 2K
for this small state machine. Larger state machines could generate very large tables. </font></p>

<p><font face="Arial" size="2">One way to reduce the size of the table at a (very) slight
loss in execution speed is to classify the characters before using them as an index into a
state table. By using a single 256-byte lookup table, it is easy to reduce the state
machine to the table above. Consider the 256 byte lookup table that contains:</font> 

<ul>
  <li><font face="Arial" size="2">A one at positions Base+&quot;a&quot; and
    Base+&quot;A&quot;, </font></li>
  <li><font face="Arial" size="2">A two at locations Base+&quot;c&quot; and
    Base+&quot;C&quot;, </font></li>
  <li><font face="Arial" size="2">A three at locations Base+&quot;d&quot; and
    Base+&quot;D&quot;, </font></li>
  <li><font face="Arial" size="2">A four at locations Base+&quot;m&quot; and
    Base+&quot;M&quot;, </font></li>
  <li><font face="Arial" size="2">A five at locations Base+&quot;n&quot; and
    Base+&quot;N&quot;, </font></li>
  <li><font face="Arial" size="2">A six at locations Base+&quot;s&quot; and
    Base+&quot;S&quot;, and </font></li>
  <li><font face="Arial" size="2">A zero everywhere else.</font></li>
</ul>

<p><font face="Arial" size="2">Now we can modify the above table to produce: </font></p>
<div align="center"><center>

<table BORDER="1" bordercolor="#C0C0C0" width="30%" cellspacing="0" cellpadding="0">
  <caption><font face="Arial" size="2"><strong>Classified State Machine Table for 80x86
  &quot;A&quot; Instructions DFA</strong></font></caption>
  <tr>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">State</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">0</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">1</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">2</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">3</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">4</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">5</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">6</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">7</font></th>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">0</font></strong></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">1</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">1</font></strong></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">3</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">4</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">2</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">2</font></strong></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">5</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">3</font></strong></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">5</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">5</font></td>
    <td align="center"><font face="Arial" size="2">5</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">5</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">4</font></strong></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">5</font></td>
    <td align="center"><font face="Arial" size="2">5</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">5</font></strong></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">6</font></strong></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">The table above contains an extra column, &quot;7&quot;,
that we will not use. The reason for adding the extra column is to make it easy to index
into this two dimensional array (since the extra column lets us multiply the state number
by eight rather than seven).</font></p>

<p><font face="Arial" size="2">Assuming Classify is the name of the lookup table, the
following 80386 code recognizes the strings specified by this DFA:</font></p>

<pre><font face="Courier New" size="2">DFA2_A_Mnem     proc
                push    ebx                     ;Ptr to Classify.
                push    eax                     ;Current character.
                push    ecx                     ;Current state.
                xor     eax, eax                ;EAX := 0
                mov     ebx, eax                ;EBX := 0
                mov     ecx, eax                ;ECX (state) := 0
                lea     bx, Classify
WhileNotEOS:    mov     al, es:[di]             ;Get next input char.
                cmp     al, 0                   ;At end of string?
                je      AtEOS
                xlat                            ;Classify character.
                mov     cl, State_Tbl[eax+ecx*8] ;Get new state #.
                inc     di                      ;Move on to next char.
                jmp     WhileNotEOS

AtEOS:          cmp     cl, 5                   ;In accepting state?
                stc                             ;Assume acceptance.
                je      Accept
                clc
Accept:         pop     ecx
                pop     eax
                pop     ebx
                ret
DFA2_A_Mnem     endp</font></pre>

<p><font face="Arial" size="2">The nice thing about this DFA (the DFA is the combination
of the classification table, the state table, and the above code) is that it is very easy
to modify. To handle any other state machine (with eight or fewer character
classifications) you need only modify the <code>Classification</code> array, the <code>State_Tbl</code>
array, the <code>lea bx, Classify</code> statement and the statements at label <code>AtEOS</code>
that determine if the machine is in a final state. The assembly code does not get more
complex as the DFA grows in size. The State_Tbl array will get larger as you add more
states, but this does not affect the assembly code.</font></p>

<p><font face="Arial" size="2">Of course, the assembly code above does assume there are
exactly eight columns in the matrix. It is easy to generalize this code by inserting an
appropriate <code>imul</code> instruction to multiply by the size of the array. For
example, had we gone with seven columns rather than eight, the code above would be</font></p>

<pre><font face="Courier New" size="2">DFA2_A_Mnem     proc
                push    ebx                     ;Ptr to Classify.
                push    eax                     ;Current character.
                push    ecx                     ;Current state.
                xor     eax, eax                ;EAX := 0
                mov     ebx, eax                ;EBX := 0
                mov     ecx, eax                ;ECX (state) := 0
                lea     bx, Classify
WhileNotEOS:    mov     al, es:[di]             ;Get next input char.
                cmp     al, 0                   ;At end of string?
                je      AtEOS
                xlat                            ;Classify character.
                imul    cx, 7
                movzx   ecx, State_Tbl[eax+ecx] ;Get new state #.
                inc     di                      ;Move on to next char.
                jmp     WhileNotEOS

AtEOS:          cmp     cl, 5                   ;In accepting state?
                stc                             ;Assume acceptance.
                je      Accept
                clc
Accept:         pop     ecx
                pop     eax
                pop     ebx
                ret
DFA2_A_Mnem     endp</font></pre>

<p><font face="Arial" size="2">Although using a state table in this manner simplifies the
assembly coding, it does suffer from two drawbacks. First, as mentioned earlier, it is
slower. This technique has to execute all the statements in the while loop for each
character it matches; and those instructions are not particularly fast ones, either. The
second drawback is that you've got to create the state table for the state machine; that
process is tedious and error prone. </font></p>

<p><font face="Arial" size="2">If you need the absolute highest performance, you can use
the state machine techniques described in Chapter Ten. The trick here is to represent each
state with a short segment of code and its own one dimensional state table. Each entry in
the table is the target address of the segment of code representing the next state. The
following is an example of our &quot;A Mnemonic&quot; state machine written in this
fashion. The only difference is that the zero byte is classified to value seven (zero
marks the end of the string, we will use this to determine when we encounter the end of
the string). The corresponding state table would be: </font></p>
<div align="center"><center>

<table BORDER="1" bordercolor="#C0C0C0" width="30%" cellspacing="0" cellpadding="0">
  <caption><font face="Arial" size="2"><strong>Another State Machine Table for 80x86
  &quot;A&quot; Instructions DFA</strong></font></caption>
  <tr>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">State</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">0</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">1</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">2</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">3</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">4</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">5</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">6</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">7</font></th>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">0</font></strong></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">1</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">1</font></strong></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">3</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">4</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">2</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">2</font></strong></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">5</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">3</font></strong></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">5</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">5</font></td>
    <td align="center"><font face="Arial" size="2">5</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">5</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">4</font></strong></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">5</font></td>
    <td align="center"><font face="Arial" size="2">5</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">5</font></strong></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">5</font></td>
  </tr>
  <tr>
    <td align="center" bgcolor="#F0F0F0"><strong><font face="Arial" size="2">6</font></strong></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
    <td align="center"><font face="Arial" size="2">6</font></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">The 80x86 code is</font></p>

<pre><font face="Courier New" size="2">DFA3_A_Mnem     proc
                push    ebx
                push    eax
                push    ecx
                xor     eax, eax

                lea     ebx, Classify
State0:         mov     al, es:[di]
                xlat
                inc     di
                jmp     cseg:State0Tbl[eax*2]

State0Tbl       word    State6, State1, State6, State6
                word    State6, State6, State6, State6

State1:         mov     al, es:[di]
                xlat
                inc     di
                jmp     cseg:State1Tbl[eax*2]

State1Tbl       word    State6, State3, State6, State4
                word    State6, State2, State6, State6

State2:         mov     al, es:[di]
                xlat
                inc     di
                jmp     cseg:State2Tbl[eax*2]

State2Tbl       word    State6, State6, State6, State5
                word    State6, State6, State6, State6

State3:         mov     al, es:[di]
                xlat
                inc     di
                jmp     cseg:State3Tbl[eax*2]

State3Tbl       word    State6, State5, State6, State5
                word    State5, State6, State5, State6

State4:         mov     al, es:[di]
                xlat
                inc     di
                jmp     cseg:State4Tbl[eax*2]

State4Tbl       word    State6, State6, State5, State5
                word    State6, State6, State6, State6

State5:         mov     al, es:[di]
                cmp     al, 0
                jne     State6
                stc
                pop     ecx
                pop     eax
                pop     ebx
                ret

State6:         clc
                pop     ecx
                pop     eax
                pop     ebx
                ret</font></pre>

<p><font face="Arial" size="2">There are two important features you should note about this
code. First, it only executes four instructions per character comparison (fewer, on the
average, than the other techniques). Second, the instant the DFA detects failure it stops
processing the input characters. The other table driven DFA techniques blindly process the
entire string, even after it is obvious that the machine is locked in a failure state.</font></p>

<p><font face="Arial" size="2">Also note that this code treats the accepting and failure
states a little differently than the generic state table code. This code recognizes the
fact that once we're in state five it will either succeed (if EOS is the next character)
or fail. Likewise, in state six this code knows better than to try searching any farther. </font></p>

<p><font face="Arial" size="2">Of course, this technique is not as easy to modify for
different DFAs as a simple state table version, but it is quite a bit faster. If you're
looking for speed, this is a good way to code a DFA.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH16-2.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH16-2.html">Chapter Sixteen</a> (Part 2)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH16-4.html">Chapter Sixteen</a> (Part 4)&nbsp; </strong></font><a href="CH16-4.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Sixteen: Pattern Matching
(Part 3)<br>
29 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_16/CH16-3.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:29 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
