<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_16/CH16-12.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:31 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER SIXTEEN: PATTERN MATCHING (Part 12)</title>
</head>

<body stylesrc="../toc.html" topmargin="10" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING12"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH16-11.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH16-11.html">Chapter Sixteen</a> (Part 11)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="../Chapter_17/CH17-1.html">Chapter Seventeen</a>
    &nbsp; </strong></font><a href="../Chapter_17/CH17-1.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10"><a NAME="HEADING12-1"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0"><font face="Arial" size="4"><strong>CHAPTER SIXTEEN:<br>
    PATTERN MATCHING (Part 12)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10"></td>
  </tr>
  <tr>
    <td width="100%" valign="top"><dl>
      <p><font face="Arial" size="2"><a HREF="#HEADING12-1"><b>16.8.5 </b>- The
      &quot;MADVENTURE&quot; Game</a> </font></p>
    </dl>
    </td>
  </tr>
</table>
</center></div>

<h3><strong><font face="Arial" size="3">16.8.5 The &quot;MADVENTURE&quot; Game</font></strong></h3>

<p><font face="Arial" size="2">Computer games are a perfect example of programs that often
use pattern matching. One class of computer games in general, the adventure game, is a
perfect example of games that use pattern matching. An adventure style game excepts
English-like commands from the user, parses these commands, and acts upon them. In this
section we will develop an adventure game shell. That is, it will be a reasonably
functional adventure style game, capable of accepting and processing user commands. All
you need do is supply a story line and a few additional details to develop a fully
functioning adventure class game.</font></p>

<p><font face="Arial" size="2">An adventure game usually consists of some sort of maze
through which the player moves. The program processes commands like go north or go right
to move the player through the maze. Each move can deposit the player in a new room of the
game. Generally, each room or area contains objects the player can interact with. This
could be reward objects such as items of value or it could be an antagonistic object like
a monster or enemy player.</font></p>

<p><font face="Arial" size="2">Usually, an adventure game is a puzzle of some sort. The
player finds clues and picks up useful object in one part of the maze to solve problems in
other parts of the maze. For example, a player could pick up a key in one room that opens
a chest in another; then the player could find an object in the chest that is useful
elsewhere in the maze. The purpose of the game is to solve all the interlocking puzzles
and maximize one's score (however that is done). This text will not dwell upon the
subtleties of game design; that is a subject for a different text. Instead, we'll look at
the tools and data structures required to implement the game design.</font></p>

<p><font face="Arial" size="2">The Madventure game's use of pattern matching is quite
different from the previous examples appearing in this chapter. In the examples up to this
point, the matching routines specifically checked the validity of an input string;
Madventure does not do this. Instead, it uses the pattern matching routines to simply
determine if certain key words appear on a line input by the user. The program handles the
actual parsing (determining if the command is syntactically correct). To understand how
the Madventure game does this, it would help if we took a look at how to play the
Madventure game.</font></p>

<p><font face="Arial" size="2">The Madventure prompts the user to enter a command. Unlike
the original adventure game that required commands like &quot;GO NORTH&quot; (with no
other characters other than spaces as part of the command), Madventure allows you to write
whole sentences and then it attempts to pick out the key words from those sentences. For
example, Madventure accepts the &quot;GO NORTH&quot; command; however, it also accepts
commands like &quot;North is the direction I want to go&quot; and &quot;I want to go in
the north direction.&quot; Madventure doesn't really care as long as it can find
&quot;GO&quot; and &quot;NORTH&quot; somewhere on the command line. This is a little more
flexible that the original Adventure game structure. Of course, this scheme isn't
infallible, it will treat commands like &quot;I absolutely, positively, do NOT want to go
anywhere near the north direction&quot; as a &quot;GO NORTH&quot; command. Oh well, the
user almost always types just &quot;GO NORTH&quot; anyway.</font></p>

<p><font face="Arial" size="2">A Madventure command usually consists of a noun keyword and
a verb keyword. The Madventure recognizes six verbs and fourteen nouns. The verbs are </font></p>

<pre><font face="Courier New" size="2"><em>verbs</em> <img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"> go | get | drop | inventory | quit | help</font></pre>

<p><font face="Arial" size="2">The nouns are </font></p>

<p><font face="Courier New" size="2"><em>nouns</em> <img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"> north |
south | east | west | lime | beer | card | sign | program | homework | money | form |
coupon</font></p>

<p><font face="Arial" size="2">Obviously, Madventure does not allow all combinations of
verbs and nouns. Indeed, the following patterns are the only legal ones: </font></p>

<p><font face="Courier New" size="2"><em>LegalCmds</em> <img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"> go <em>direction</em>
| get <em>item</em> | drop <em>item </em>| inventory | quit | help</font></p>

<p><font face="Courier New" size="2"><em>direction</em> <img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"> north |
south | east | west</font></p>

<p><font face="Courier New" size="2"><em>item</em> <img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"> lime | beer
| card | sign | program | homework | money | form | coupon</font></p>

<p><font face="Arial" size="2">However, the pattern does not enforce this grammar. It just
locates a noun and a verb on the line and, if found, sets the <code>noun</code> and <code>verb</code>
variables to appropriate values to denote the keywords it finds. By letting the main
program handle the parsing, the program is somewhat more flexible. </font></p>

<p><font face="Arial" size="2">There are two main patterns in the Madventure program: <code>NounPat</code>
and <code>VerbPat</code>. These patterns match words (nouns or verbs) using a regular
expression like the following: </font></p>
<div align="center"><center>

<pre><font face="Courier New" size="2">(ARB* ` ` | <img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11">) word (` ` | EOS)</font></pre>
</center></div>

<p><font face="Arial" size="2">This regular expression matches a word that appears at the
beginning of a sentence, at the end of a sentence, anywhere in the middle of a sentence,
or a sentence consisting of a single word. Madventure uses a macro (<code>MatchNoun</code>
or <code>MatchVerb</code>) to create an expression for each noun and verb in the above
expression.</font></p>

<p><font face="Arial" size="2">To get an idea of how Madvent processes words, consider the
following <code>VerbPat</code> pattern: </font></p>

<pre><font face="Courier New" size="2">VerbPat         pattern         {sl_match2, MatchGo}
                MatchVerb       MatchGO, MatchGet, &quot;GO&quot;, 1
                MatchVerb       MatchGet, MatchDrop, &quot;GET&quot;, 2
                MatchVerb       MatchDrop, MatchInv, &quot;DROP&quot;, 3
                MatchVerb       MatchInv, MatchQuit, &quot;INVENTORY&quot;, 4
                MatchVerb       MatchQuit, MatchHelp, &quot;QUIT&quot;, 5
                MatchVerb       MatchHelp, 0, &quot;HELP&quot;, 6</font></pre>

<p><font face="Arial" size="2">The <code>MatchVerb</code> macro expects four parameters.
The first is an arbitrary pattern name; the second is a link to the next pattern in the
list; the third is the string to match, and the fourth is a number that the matching
routines will store into the <code>verb</code> variable if that string matches (by
default, the <code>verb</code> variable contains zero). It is very easy to add new verbs
to this list. For example, if you wanted to allow &quot;run&quot; and &quot;walk&quot; as
synonyms for the &quot;go&quot; verb, you would just add two patterns to this list: </font></p>

<pre><font face="Courier New" size="2">VerbPat         pattern         {sl_match2, MatchGo}
                MatchVerb       MatchGO, MatchGet, &quot;GO&quot;, 1
                MatchVerb       MatchGet, MatchDrop, &quot;GET&quot;, 2
                MatchVerb       MatchDrop, MatchInv, &quot;DROP&quot;, 3
                MatchVerb       MatchInv, MatchQuit, &quot;INVENTORY&quot;, 4
                MatchVerb       MatchQuit, MatchHelp, &quot;QUIT&quot;, 5
                MatchVerb       MatchHelp, MatchRun, &quot;HELP&quot;, 6
                MatchVerb       MatchRun, MatchWalk, &quot;RUN&quot;, 1
                MatchVerb       MatchWalk, 0, &quot;WALK&quot;, 1</font></pre>

<p><font face="Arial" size="2">There are only two things to consider when adding new
verbs: first, don't forget that the next field of the last verb should contain zero;
second, the current version of Madventure only allows up to seven verbs. If you want to
add more you will need to make a slight modification to the main program (more on that,
later). Of course, if you only want to create synonyms, as we've done here, you simply
reuse existing verb values so there is no need to modify the main program.</font></p>

<p><font face="Arial" size="2">When you call the <code>match</code> routine and pass it
the address of the <code>VerbPat</code> pattern, it scans through the input string looking
for the first verb. If it finds that verb (&quot;GO&quot;) it sets the <code>verb</code>
variable to the corresponding verb value at the end of the pattern. If <code>match</code>
cannot find the first verb, it tries the second. If that fails, it tries the third, and so
on. If <code>match</code> cannot find any of the verbs in the input string, it does not
modify the <code>verb</code> variable (which contains zero). If there are two or more of
the above verbs on the input line, match will locate the first verb in the verb list
above. This may not be the first verb appearing on the line. For example, if you say
&quot;Let's get the money and go north&quot; the match routine will match the
&quot;go&quot; verb, not the &quot;get&quot; verb. By the same token, the <code>NounPat</code>
pattern would match the north noun, not the money noun. So this command would be identical
to &quot;GO NORTH.&quot;</font></p>

<p><font face="Arial" size="2">The MatchNoun is almost identical to the MatchVerb macro;
there is, however, one difference - the MatchNoun macro has an extra parameter which is
the name of the data structure representing the given object (if there is one). Basically,
all the nouns (in this version of Madventure) except NORTH, SOUTH, EAST, and WEST have
some sort of data structure associated with them.</font></p>

<p><font face="Arial" size="2">The maze in Madventure consists of nine rooms defined by
the data structure: </font></p>

<pre><font face="Courier New" size="2">Room            struct
north           word    ?
south           word    ?
west            word    ?
east            word    ?
ItemList        word    MaxWeight dup (?)
Description     word    ?
Room            ends</font></pre>

<p><font face="Arial" size="2">The <code>north</code>, <code>south</code>, <code>west</code>,
and <code>east</code> fields contain near pointers to other rooms. The program uses the <code>CurRoom</code>
variable to keep track of the player's current position in the maze. When the player
issues a &quot;GO&quot; command of some sort, Madventure copies the appropriate value from
the <code>north</code>, <code>south</code>, <code>west</code>, or <code>east</code> field
to the <code>CurRoom</code> variable, effectively changing the room the user is in. If one
of these pointers is NULL, then the user cannot move in that direction. </font></p>

<p><font face="Arial" size="2">The direction pointers are independent of one another. If
you issue the command &quot;GO NORTH&quot; and then issue the command &quot;GO SOUTH&quot;
upon arriving in the new room, there is no guarantee that you will wind up in the original
room. The <code>south</code> field of the second room may not point at the room that led
you there. Indeed, there are several cases in the Madventure game where this occurs.</font></p>

<p><font face="Arial" size="2">The <code>ItemList</code> array contains a list of near
pointers to objects that could be in the room. In the current version of this game, the
objects are all the nouns except north, south, east, and west. The player can carry these
objects from room to room (indeed, that is the major purpose of this game). Up to <code>MaxWeight</code>
objects can appear in the room (MaxWeight is an assembly time constant that is currently
four; so there are a maximum of four items in any one given room). If an entry in the <code>ItemList</code>
is non-NULL, then it is a pointer to an <code>Item</code> object. There may be zero to <code>MaxWeight</code>
objects in a room. </font></p>

<p><font face="Arial" size="2">The <code>Description</code> field contains a pointer to a
zero terminated string that describes the room. The program prints this string each time
through the command loop to keep the player oriented.</font></p>

<p><font face="Arial" size="2">The second major data type in Madventure is the <code>Item</code>
structure. This structure takes the form: </font></p>

<pre><font face="Courier New" size="2">Item            struct
Value           word    ?
Weight          word    ?
Key             word    ?
ShortDesc       word    ?
LongDesc        word    ?
WinDesc         word    ?
Item            ends</font></pre>

<p><font face="Arial" size="2">The <code>Value</code> field contains an integer value
awarded to the player when the player drops this object in the appropriate room. This is
how the user scores points. </font></p>

<p><font face="Arial" size="2">The <code>Weight</code> field usually contains one or two
and determines how much this object &quot;weighs.&quot; The user can only carry around <code>MaxWeight</code>
units of weight at any one given time. Each time the user picks up an object, the weight
of that object is added to the user's total weight. When the user drops an object,
Madventure subtracts the object's weight from the total.</font></p>

<p><font face="Arial" size="2">The <code>Key</code> field contains a pointer to a room
associated with the object. When the user drops the object in the <code>Key</code> room,
the user is awarded the points in the <code>Value</code> field and the object disappears
from the game. If the user drops the object in some other room, the object stays in that
room until the user picks it up again.</font></p>

<p><font face="Arial" size="2">The <code>ShortDesc</code>, <code>LongDesc</code>, and <code>WinDesc</code>
fields contain pointers to zero terminated strings. Madventure prints the <code>ShortDesc</code>
string in response to an INVENTORY command. It prints the <code>LongDesc</code> string
when describing a room's contents. It prints the <code>WinDesc</code> string when the user
drops the object in its <code>Key</code> room and the object disappears from the game.</font></p>

<p><font face="Arial" size="2">The Madventure main program is deceptively simple. Most of
the logic is hidden in the pattern matching routines and in the parsing routine. We've
already discussed the pattern matching code; the only important thing to remember is that
it initializes the noun and verb variables with a value uniquely identifying each noun and
verb. The main program's logic uses these two values as an index into a two dimensional
table that takes the following form:</font></p>
<div align="center"><center>

<table BORDER="1" bordercolor="#C0C0C0" width="60%" cellspacing="0" cellpadding="0">
  <caption><font face="Arial" size="2"><strong>Madventure Noun/Verb Table</strong></font></caption>
  <tr>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">&nbsp;</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">No Verb</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">GO</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">GET</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">DROP</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">Inventory</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">Quit</font></th>
    <th align="center" bgcolor="#F0F0F0"><font face="Arial" size="2">Help</font></th>
  </tr>
  <tr>
    <td><font face="Arial" size="2">No Noun</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">Inventory</font></td>
    <td align="center"><font face="Arial" size="2">Quit</font></td>
    <td align="center"><font face="Arial" size="2">Help</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">North</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">Do North</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">South</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">Do South</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">East</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">Do East</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">West</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">Do West</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">Lime</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">Get Item</font></td>
    <td align="center"><font face="Arial" size="2">Drop Item</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">Beer</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">Get Item</font></td>
    <td align="center"><font face="Arial" size="2">Drop Item</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">Card</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">Get Item</font></td>
    <td align="center"><font face="Arial" size="2">Drop Item</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">Sign</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">Get Item</font></td>
    <td align="center"><font face="Arial" size="2">Drop Item</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">Program</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">Get Item</font></td>
    <td align="center"><font face="Arial" size="2">Drop Item</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">Homework</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">Get Item</font></td>
    <td align="center"><font face="Arial" size="2">Drop Item</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">Money</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">Get Item</font></td>
    <td align="center"><font face="Arial" size="2">Drop Item</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">Form</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">Get Item</font></td>
    <td align="center"><font face="Arial" size="2">Drop Item</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
  </tr>
  <tr>
    <td><font face="Arial" size="2">Coupon</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">Get Item</font></td>
    <td align="center"><font face="Arial" size="2">Drop Item</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
    <td align="center"><font face="Arial" size="2">-</font></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">The empty entries in this table correspond to illegal
commands. The other entries are addresses of code within the main program that handles the
given command.</font></p>

<p><font face="Arial" size="2">To add more nouns (objects) to the game, you need only
extend the NounPat pattern and add additional rows to the table (of course, you may need
to add code to handle the new objects if they are not easily handled by the routines
above). To add new verbs you need only extended the VerbPat pattern and add new columns to
this table.</font></p>

<p><font face="Arial" size="2">Other than the goodies mentioned above, the rest of the
program utilizes techniques appearing throughout this and previous chapters. The only real
surprising thing about this program is that you can implement a fairly complex program
with so few lines of code. But such is the advantage of using pattern matching techniques
in your assembly language programs. </font></p>

<pre><font face="Courier New" size="2">; MADVENT.ASM
;
; This is a &quot;shell&quot; of an adventure game that you can use to create
; your own adventure style games.

                .xlist
                .286
                include         stdlib.a
                includelib      stdlib.lib
                matchfuncs
                .list

dseg            segment         para public 'data'

; Equates:

NULL            equ     0
MaxWeight       equ     4       ;Max weight user can carry at one time.


; The &quot;ROOM&quot; data structure defines a room, or area, where a player can
; go. The NORTH, SOUTH, EAST, and WEST fields contain the address of
; the rooms to the north, south, east, and west of the room. The game
; transfers control to the room whose address appears in these fields
; when the player supplies a GO NORTH, GO SOUTH, etc., command.
;
; The ITEMLIST field contains a list of pointers to objects appearing
; in this room. In this game, the user can pick up and drop these
; objects (if there are any present).
;
; The DESCRIPTION field contains a (near) address of a short description
; of the current room/area.

Room            struct
north           word    ?       ;Near pointers to other structures where
south           word    ?       ; we will wind up on the GO NORTH, GO SOUTH,
west            word    ?       ; etc., commands.
east            word    ?

ItemList        word    MaxWeight dup (?)

Description     word    ?       ;Description of room.
Room            ends


; The ITEM data structure describes the objects that may appear
; within a room (in the ITEMLIST above). The VALUE field contains
; the number of points this object is worth if the user drops it
; off in the proper room (i.e, solves the puzzle). The WEIGHT
; field provides the weight of this object. The user can only
; carry four units of weight at a time. This field is usually
; one, but may be more for larger objects. The KEY field is the
; address of the room where this object must be dropped to solve
; the problem. The SHORTDESC field is a pointer to a string that
; the program prints when the user executes an INVENTORY command.
; LONGDESC is a pointer to a string the program prints when des-
; cribing the contents of a room. The WINDESC field is a pointer
; to a string that the program prints when the user solves the
; appropriate puzzle.

Item            struct
Value           word    ?
Weight          word    ?
Key             word    ?
ShortDesc       word    ?
LongDesc        word    ?
WinDesc         word    ?
Item            ends


; State variables for the player:

CurRoom         word    Room1            ;Room the player is in.
ItemsOnHand     word    MaxWeight dup (?) ;Items the player carries.
CurWeight       word    0                ;Weight of items carried.
CurScore        word    15               ;Player's current score.
TotalCounter    word    9                ;Items left to place.
Noun            word    0                ;Current noun value.
Verb            word    0                ;Current verb value.
NounPtr         word    0                ;Ptr to current noun item.


; Input buffer for commands

InputLine       byte    128 dup (?)

; The following macros generate a pattern which will match a single word
; which appears anywhere on a line. In particular, they match a word
; at the beginning of a line, somewhere in the middle of the line, or
; at the end of a line. This program defines a word as any sequence
; of character surrounded by spaces or the beginning or end of a line.
;
; MatchNoun/Verb matches lines defined by the regular expression:
;
;       (ARB* ' ' | e) string (' ' | EOS)

MatchNoun       macro   Name, next, WordString, ItemVal, ItemPtr
                local   WS1, WS2, WS3, WS4
                local   WS5, WS6, WordStr

Name            Pattern {sl_match2, WS1, next}
WS1             Pattern {MatchStr, WordStr, WS2, WS5}
WS2             Pattern {arb,0,0,WS3}
WS3             Pattern {Matchchar, ' ',0, WS4}
WS4             Pattern {MatchStr, WordStr, 0, WS5}
WS5             Pattern {SetNoun,ItemVal,0,WS6}
WS6             Pattern {SetPtr, ItemPtr,0,MatchEOS}
WordStr         byte    WordString
                byte    0
                endm


MatchVerb       macro   Name, next, WordString, ItemVal
                local   WS1, WS2, WS3, WS4
                local   WS5, WordStr

Name            Pattern {sl_match2, WS1, next}
WS1             Pattern {MatchStr, WordStr, WS2, WS5}
WS2             Pattern {arb,0,0,WS3}
WS3             Pattern {Matchchar, ' ',0, WS4}
WS4             Pattern {MatchStr, WordStr, 0, WS5}
WS5             Pattern {SetVerb,ItemVal,0,MatchEOS}
WordStr         byte    WordString
                byte    0
                endm




; Generic patterns which most of the patterns use:

MatchEOS        Pattern {EOS,0,MatchSpc}
MatchSpc        Pattern {MatchChar,' '}


; Here are the list of nouns allowed in this program.

NounPat         pattern         {sl_match2, MatchNorth}

                MatchNoun       MatchNorth, MatchSouth, &quot;NORTH&quot;, 1, 0
                MatchNoun       MatchSouth, MatchEast, &quot;SOUTH&quot;, 2, 0
                MatchNoun       MatchEast, MatchWest, &quot;EAST&quot;, 3, 0
                MatchNoun       MatchWest, MatchLime, &quot;WEST&quot;, 4, 0
                MatchNoun       MatchLime, MatchBeer, &quot;LIME&quot;, 5, Item3
                MatchNoun       MatchBeer, MatchCard, &quot;BEER&quot;, 6, Item9
                MatchNoun       MatchCard, MatchSign, &quot;CARD&quot;, 7, Item2
                MatchNoun       MatchSign, MatchPgm, &quot;SIGN&quot;, 8, Item1
                MatchNoun       MatchPgm, MatchHW, &quot;PROGRAM&quot;, 9, Item7
                MatchNoun       MatchHW, MatchMoney, &quot;HOMEWORK&quot;, 10, Item4
                MatchNoun       MatchMoney, MatchForm, &quot;MONEY&quot;, 11, Item5
                MatchNoun       MatchForm, MatchCoupon, &quot;FORM&quot;, 12, Item6
                MatchNoun       MatchCoupon, 0, &quot;COUPON&quot;, 13, Item8


; Here is the list of allowable verbs.

VerbPat         pattern         {sl_match2, MatchGo}

                MatchVerb       MatchGO, MatchGet, &quot;GO&quot;, 1
                MatchVerb       MatchGet, MatchDrop, &quot;GET&quot;, 2
                MatchVerb       MatchDrop, MatchInv, &quot;DROP&quot;, 3
                MatchVerb       MatchInv, MatchQuit, &quot;INVENTORY&quot;, 4
                MatchVerb       MatchQuit, MatchHelp, &quot;QUIT&quot;, 5
                MatchVerb       MatchHelp, 0, &quot;HELP&quot;, 6

; Data structures for the &quot;maze&quot;.

Room1           room    {Room1, Room5, Room4, Room2,
                         {Item1,0,0,0},
                         Room1Desc}

Room1Desc       byte    &quot;at the Commons&quot;,0

Item1           item    {10,2,Room3,GS1,GS2,GS3}
GS1             byte    &quot;a big sign&quot;,0
GS2             byte    &quot;a big sign made of styrofoam with funny &quot;
                byte    &quot;letters on it.&quot;,0
GS3             byte    &quot;The ETA PI Fraternity thanks you for return&quot;
                byte    &quot;ing their sign, they&quot;,cr,lf
                byte    &quot;make you an honorary life member, as long as &quot;
                byte    &quot;you continue to pay&quot;,cr,lf
                byte    &quot;your $30 monthly dues, that is.&quot;,0

Room2           room    {NULL, Room5, Room1, Room3,
                         {Item2,0,0,0},
                         Room2Desc}

Room2Desc       byte    'at the &quot;C&quot; on the hill above campus',0

Item2           item    {10,1,Room1,LC1,LC2,LC3}
LC1             byte    &quot;a lunch card&quot;,0
LC2             byte    &quot;a lunch card which someone must have &quot;
                byte    &quot;accidentally dropped here.&quot;, 0
LC3             byte    &quot;You get a big meal at the Commons cafeteria&quot;
                byte    cr,lf
                byte    &quot;It would be a good idea to go visit the &quot;
                byte    &quot;student health center&quot;,cr,lf
                byte    &quot;at this time.&quot;,0

Room3           room    {NULL, Room6, Room2, Room2,
                         {Item3,0,0,0},
                         Room3Desc}

Room3Desc       byte    &quot;at ETA PI Frat House&quot;,0

Item3           item    {10,2,Room2,BL1,BL2,BL3}
BL1             byte    &quot;a bag of lime&quot;,0
BL2             byte    &quot;a bag of baseball field lime which someone &quot;
                byte    &quot;is obviously saving for&quot;,cr,lf
                byte    &quot;a special occasion.&quot;,0
BL3             byte    &quot;You spread the lime out forming a big '++' &quot;
                byte    &quot;after the 'C'&quot;,cr,lf
                byte    &quot;Your friends in Computer Science hold you &quot;
                byte    &quot;in total awe.&quot;,0

Room4           room    {Room1, Room7, Room7, Room5,
                         {Item4,0,0,0},
                         Room4Desc}

Room4Desc       byte    &quot;in Dr. John Smith's Office&quot;,0

Item4           item    {10,1,Room7,HW1,HW2,HW3}
HW1             byte    &quot;a homework assignment&quot;,0
HW2             byte    &quot;a homework assignment which appears to &quot;
                byte    &quot;to contain assembly language&quot;,0
HW3             byte    &quot;The grader notes that your homework &quot;
                byte    &quot;assignment looks quite&quot;,cr,lf
                byte    &quot;similar to someone else's assignment &quot;
                byte    &quot;in the class and reports you&quot;,cr,lf
                byte    &quot;to the instructor.&quot;,0

Room5           room    {Room1, Room9, Room7, Room2,
                        {Item5,0,0,0},
                         Room5Desc}

Room5Desc       byte    &quot;in the computer lab&quot;,0

Item5           item    {10,1,Room9,M1,M2,M3}
M1              byte    &quot;some money&quot;,0
M2              byte    &quot;several dollars in an envelope in the &quot;
                byte    &quot;trashcan&quot;,0
M3              byte    &quot;The waitress thanks you for your &quot;
                byte    &quot;generous tip and gets you&quot;,cr,lf
                byte    &quot;another pitcher of beer. &quot;
                byte    &quot;Then she asks for your ID.&quot;,cr,lf
                byte    &quot;You are at least 21 aren't you?&quot;,0

Room6           room    {Room3, Room9, Room5, NULL,
                         {Item6,0,0,0},
                         Room6Desc}

Room6Desc       byte    &quot;at the campus book store&quot;,0

Item6           item    {10,1,Room8,AD1,AD2,AD3}
AD1             byte    &quot;an add/drop/change form&quot;,0
AD2             byte    &quot;an add/drop/change form filled out for &quot;
                byte    &quot;assembly to get a letter grade&quot;,0
AD3             byte    &quot;You got the form in just in time. &quot;
                byte    &quot;It would have been a shame to&quot;,cr,lf
                byte    &quot;have had to retake assembly because &quot;
                byte    &quot;you didn't realize you needed to &quot;,cr,lf
                byte    &quot;get a letter grade in the course.&quot;,0

Room7           room    {Room1, Room7, Room4, Room8,
                         {Item7,0,0,0},
                         Room7Desc}

Room7Desc       byte    &quot;in the assembly lecture&quot;,0

Item7           item    {10,1,Room5,AP1,AP2,AP3}
AP1             byte    &quot;an assembly language program&quot;,0
AP2             byte    &quot;an assembly language program due in &quot;
                byte    &quot;the assemblylanguage class.&quot;,0
AP3             byte    &quot;The sample program the instructor gave &quot;
                byte    &quot;you provided all the information&quot;,cr,lf
                byte    &quot;you needed to complete your assignment. &quot;
                byte    &quot;You finish your work and&quot;,cr,lf
                byte    &quot;head to the local pub to celebrate.&quot;
                byte    cr,lf,0

Room8           room    {Room5, Room6, Room7, Room9,
                         {Item8,0,0,0},
                         Room8Desc}

Room8Desc       byte     &quot;at the Registrar's office&quot;,0

Item8           item    {10,1,Room6,C1,C2,C3}
C1              byte    &quot;a coupon&quot;,0
C2              byte    &quot;a coupon good for a free text book&quot;,0
C3              byte    'You get a free copy of &quot;Cliff Notes for '
                byte    'The Art of Assembly',cr,lf
                byte    'Language Programming&quot; Alas, it does not '
                byte    &quot;provide all the&quot;,cr,lf
                byte    &quot;information you need for the class, so you &quot;
                byte    &quot;sell it back during&quot;,cr,lf
                byte    &quot;the book buy-back period.&quot;,0



Room9           room    {Room6, Room9, Room8, Room3,
                         {Item9,0,0,0},
                         Room9Desc}

Room9Desc       byte    &quot;at The Pub&quot;,0
Item9           item    {10,2,Room4,B1,B2,B3}
B1              byte    &quot;a pitcher of beer&quot;,0
B2              byte    &quot;an ice cold pitcher of imported beer&quot;,0
B3              byte    &quot;Dr. Smith thanks you profusely for your &quot;
                byte    &quot;good taste in brews.&quot;,cr,lf
                byte    &quot;He then invites you to the pub for a &quot;
                byte    &quot;round of pool and&quot;,cr,lf
                byte    &quot;some heavy duty hob-nobbing, &quot;
                byte    &quot;CS Department style.&quot;,0

dseg            ends


cseg            segment         para public 'code'
                assume          ds:dseg


; SetNoun-      Copies the value in SI (the matchparm parameter) to the
;               NOUN variable.

SetNoun         proc    far
                push    ds
                mov     ax, dseg
                mov     ds, ax
                mov     Noun, si
                mov     ax, di
                stc
                pop     ds
                ret
SetNoun         endp


; SetVerb-      Copies the value in SI (the matchparm parameter) to the
;               VERB variable.

SetVerb         proc    far
                push    ds
                mov     ax, dseg
                mov     ds, ax
                mov     Verb, si
                mov     ax, di
                stc
                pop     ds
                ret
SetVerb         endp

; SetPtr-       Copies the value in SI (the matchparm parameter) to the
;               NOUNPTR variable.

SetPtr          proc    far
                push    ds
                mov     ax, dseg
                mov     ds, ax
                mov     NounPtr, si
                mov     ax, di
                stc
                pop     ds
                ret
SetPtr          endp

; CheckPresence-
;               BX points at an item. DI points at an item list. This
;               routine checks to see if that item is present in the
;               item list. Returns Carry set if item was found,
;               clear if not found.

CheckPresence   proc

; MaxWeight is an assembly-time adjustable constant that determines
; how many objects the user can carry, or can be in a room, at one
; time. The following repeat macro emits &quot;MaxWeight&quot; compare and
; branch sequences to test each item pointed at by DS:DI.

ItemCnt         =       0
                repeat  MaxWeight
                cmp     bx, [di+ItemCnt]
                je      GotIt

ItemCnt         =       ItemCnt+2
                endm

                clc
                ret

GotIt:          stc
                ret
CheckPresence   endp

; RemoveItem-   BX contains a pointer to an item. DI contains a pointer
;               to an item list which contains that item. This routine
;               searches the item list and removes that item from the
;               list. To remove an item from the list, we need only
;               store a zero (NULL) over the top of its pointer entry
;               in the list.

RemoveItem      proc

; Once again, we use the repeat macro to automatically generate a chain
; of compare, branch, and remove code sequences for each possible item
; in the list.

ItemCnt         =       0
                repeat  MaxWeight
                local   NotThisOne
                cmp     bx, [di+ItemCnt]
                jne     NotThisOne
                mov     word ptr [di+ItemCnt], NULL
                ret
NotThisOne:
ItemCnt         =       ItemCnt+2
                endm

                ret
RemoveItem      endp


; InsertItem-   BX contains a pointer to an item, DI contains a pointer to
;               and item list. This routine searches through the list for
;               the first empty spot and copies the value in BX to that point.
;               It returns the carry set if it succeeds. It returns the
;               carry clear if there are no empty spots available.

InsertItem      proc

ItemCnt         =       0
                repeat  MaxWeight
                local   NotThisOne
                cmp     word ptr [di+ItemCnt], 0
                jne     NotThisOne
                mov     [di+ItemCnt], bx
                stc
                ret
NotThisOne:
ItemCnt         =       ItemCnt+2
                endm

                clc
                ret
InsertItem      endp

; LongDesc- Long description of an item.
; DI points at an item - print the long description of it.

LongDesc        proc
                push    di
                test    di, di
                jz      NoDescription
                mov     di, [di].item.LongDesc
                puts
                putcr
NoDescription:  pop     di
                ret
LongDesc        endp


; ShortDesc- Print the short description of an object.
; DI points at an item (possibly NULL). Print the short description for it.

ShortDesc       proc
                push    di
                test    di, di
                jz      NoDescription
                mov     di, [di].item.ShortDesc
                puts
                putcr
NoDescription:  pop     di
                ret
ShortDesc       endp

; Describe:     &quot;CurRoom&quot; points at the current room. Describe it and its
;               contents.

Describe        proc
                push    es
                push    bx
                push    di
                mov     di, ds
                mov     es, di

                mov     bx, CurRoom
                mov     di, [bx].room.Description
                print
                byte    &quot;You are currently &quot;,0
                puts
                putcr
                print
                byte    &quot;Here you find the following:&quot;,cr,lf,0

; For each possible item in the room, print out the long description
; of that item. The repeat macro generates a code sequence for each
; possible item that could be in this room.

ItemCnt         =       0
                repeat  MaxWeight
                mov     di, [bx].room.ItemList[ItemCnt]
                call    LongDesc

ItemCnt         =       ItemCnt+2
                endm


                pop     di
                pop     bx
                pop     es
                ret
Describe        endp


; Here is the main program, that actually plays the game.

Main            proc
                mov     ax, dseg
                mov     ds, ax
                mov     es, ax
                meminit

                print
                byte    cr,lf,lf,lf,lf,lf
                byte    &quot;Welcome to &quot;,'&quot;MADVENTURE&quot;',cr,lf
                byte    'If you need help, type the command &quot;HELP&quot;'
                byte    cr,lf,0

RoomLoop:       dec     CurScore                ;One point for each move.
                jnz     NotOverYet

; If they made too many moves without dropping anything properly, boot them
; out of the game.

                print
                byte    &quot;WHOA! You lost! You get to join the legions of &quot;
                byte    &quot;the totally lame&quot;,cr,lf
                byte    'who have failed at &quot;MADVENTURE&quot;',cr,lf,0
                jmp     Quit

; Okay, tell 'em where they are and get a new command from them.

NotOverYet:     putcr
                call    Describe
                print
                byte    cr,lf
                byte    &quot;Command: &quot;,0
                lesi    InputLine
                gets
                strupr                  ;Ignore case by converting to U.C.

; Okay, process the command. Note that we don't actually check to see
; if there is a properly formed sentence. Instead, we just look to see
; if any important keywords are on the line. If they are, the pattern
; matching routines load the appropriate values into the noun and verb
; variables (nouns: north=1, south=2, east=3, west=4, lime=5, beer=6,
; card=7, sign=8, program=9, homework=10, money=11, form=12, coupon=13;
; verbs: go=1, get=2, drop=3, inventory=4, quit=5, help=6).
;
; This code uses the noun and verb variables as indexes into a two
; dimensional array whose elements contain the address of the code
; to process the given command. If a given command does not make
; any sense (e.g., &quot;go coupon&quot;) the entry in the table points at the
; bad command code.

                mov     Noun, 0
                mov     Verb, 0
                mov     NounPtr, 0

                ldxi    VerbPat
                xor     cx, cx
                match

                lesi    InputLine
                ldxi    NounPat
                xor     cx, cx
                match

; Okay, index into the command table and jump to the appropriate
; handler. Note that we will cheat and use a 14x8 array. There
; are really only seven verbs, not eight. But using eight makes
; things easier since it is easier to multiply by eight than seven.

                mov     si, CurRoom     ;The commands expect this here.

                mov     bx, Noun
                shl     bx, 3           ;Multiply by eight.
                add     bx, Verb
                shl     bx, 1           ;Multiply by two - word table.
                jmp     cseg:jmptbl[bx]

; The following table contains the noun x verb cross product.
; The verb values (in each row) are the following:
;
;       NONE    GO      GET      DROP   INVNTRY QUIT    HELP    unused
;        0       1       2        3      4       5       6       7
;
; There is one row for each noun (plus row zero, corresponding to no
; noun found on line).

jmptbl          word    Bad             ;No noun, no verb
                word    Bad             ;No noun, GO
                word    Bad             ;No noun, GET
                word    Bad             ;No noun, DROP
                word    DoInventory     ;No noun, INVENTORY
                word    QuitGame        ;No noun, QUIT
                word    DoHelp          ;No noun, HELP
                word    Bad             ;N/A

NorthCmds       word    Bad, GoNorth, Bad, Bad, Bad, Bad, Bad, Bad
SouthCmds       word    Bad, GoSouth, Bad, Bad, Bad, Bad, Bad, Bad
EastCmds        word    Bad, GoEast, Bad, Bad, Bad, Bad, Bad, Bad
WestCmds        word    Bad, GoWest, Bad, Bad, Bad, Bad, Bad, Bad
LimeCmds        word    Bad, Bad, GetItem, DropItem, Bad, Bad, Bad, Bad
BeerCmds        word    Bad, Bad, GetItem, DropItem, Bad, Bad, Bad, Bad
CardCmds        word    Bad, Bad, GetItem, DropItem, Bad, Bad, Bad, Bad
SignCmds        word    Bad, Bad, GetItem, DropItem, Bad, Bad, Bad, Bad
ProgramCmds     word    Bad, Bad, GetItem, DropItem, Bad, Bad, Bad, Bad
HomeworkCmds    word    Bad, Bad, GetItem, DropItem, Bad, Bad, Bad, Bad
MoneyCmds       word    Bad, Bad, GetItem, DropItem, Bad, Bad, Bad, Bad
FormCmds        word    Bad, Bad, GetItem, DropItem, Bad, Bad, Bad, Bad
CouponCmds      word    Bad, Bad, GetItem, DropItem, Bad, Bad, Bad, Bad

; If the user enters a command we don't know how to process, print an
; appropriate error message down here.

Bad:            printf
                byte    &quot;I'm sorry, I don't understand how to '%s'\n&quot;,0
                dword   InputLine
                jmp     NotOverYet


; Handle the movement commands here.
; Movements are easy, all we've got to do is fetch the NORTH, SOUTH,
; EAST, or WEST pointer from the current room's data structure and
; set the current room to that address. The only catch is that some
; moves are not legal. Such moves have a NULL (zero) in the direction
; field. A quick check for this case handles illegal moves.

GoNorth:        mov     si, [si].room.North
                jmp     MoveMe

GoSouth:        mov     si, [si].room.South
                jmp     MoveMe

GoEast:         mov     si, [si].room.East
                jmp     MoveMe

GoWest:         mov     si, [si].room.West
MoveMe:         test    si, si                  ;See if move allowed.
                jnz     SetCurRoom
                printf
                byte    &quot;Sorry, you cannot go in this direction.&quot;
                byte    cr, lf, 0
                jmp     RoomLoop

SetCurRoom:     mov     CurRoom, si             ;Move to new room.
                jmp     RoomLoop

; Handle the GetItem command down here. At this time the user
; has entered GET and some noun that the player can pick up.
; First, we will make sure that item is in this room.
; Then we will check to make sure that picking up this object
; won't overload the player. If these two conditions are met,
; we'll transfer the object from the room to the player.

GetItem:        mov     bx, NounPtr             ;Ptr to item user wants.
                mov     si, CurRoom
                lea     di, [si].room.ItemList  ;Ptr to item list in di.
                call    CheckPresence           ;See if in room.
                jc      GotTheItem
                printf
                byte    &quot;Sorry, that item is not available here.&quot;
                byte    cr, lf, 0
                jmp     RoomLoop

; Okay, see if picking up this object will overload the player.

GotTheItem:     mov     ax, [bx].Item.Weight
                add     ax, CurWeight
                cmp     ax, MaxWeight
                jbe     WeightOkay
                printf
                byte    &quot;Sorry, you are already carrying too many items &quot;
                byte    &quot;to safely carry\nthat object\n&quot;,0
                jmp     RoomLoop

; Okay, everything's cool, transfer the object from the room to the user.

WeightOkay:     mov     CurWeight, ax           ;Save new weight.
                call    RemoveItem              ;Remove item from room.
                lea     di, ItemsOnHand         ;Ptr to player's list.
                call    InsertItem
                jmp     RoomLoop


; Handle dropped objects down here.

DropItem:       lea     di, ItemsOnHand         ;See if the user has
                mov     bx, NounPtr             ; this item on hand.
                call    CheckPresence
                jc      CanDropIt1
                printf
                byte    &quot;You are not currently holding that item\n&quot;,0
                jmp     RoomLoop

; Okay, let's see if this is the magic room where this item is
; supposed to be dropped. If so, award the user some points for
; properly figuring this out.

CanDropIt1:     mov     ax, [bx].item.key
                cmp     ax, CurRoom
                jne     JustDropIt

; Okay, success! Print the winning message for this object.

                mov     di, [bx].item.WinDesc
                puts
                putcr

; Award the user some points.

                mov     ax, [bx].item.value
                add     CurScore, ax

; Since the user dropped it, they can carry more things now.

                mov     ax, [bx].item.Weight
                sub     CurWeight, ax

; Okay, take this from the user's list.

                lea     di, ItemsOnHand
                call    RemoveItem

; Keep track of how may objects the user has successfully dropped.
; When this counter hits zero, the game is over.

                dec     TotalCounter
                jnz     RoomLoop

                printf
                byte    &quot;Well, you've found where everything goes &quot;
                byte    &quot;and your score is %d.\n&quot;
                byte    &quot;You might want to play again and see if &quot;
                byte    &quot;you can get a better score.\n&quot;,0
                dword   CurScore
                jmp     Quit

; If this isn't the room where this object belongs, just drop the thing
; off. If this object won't fit in this room, ignore the drop command.

JustDropIt:     mov     di, CurRoom
                lea     di, [di].room.ItemList
                call    InsertItem
                jc      DroppedItem
                printf
                byte    &quot;There is insufficient room to leave &quot;
                byte    &quot;that item here.\n&quot;,0
                jmp     RoomLoop

; If they can drop it, do so. Don't forget we've just unburdened the
; user so we need to deduct the weight of this object from what the
; user is currently carrying.

DroppedItem:    lea     di, ItemsOnHand
                call    RemoveItem
                mov     ax, [bx].item.Weight
                sub     CurWeight, ax
                jmp     RoomLoop

; If the user enters the INVENTORY command, print out the objects on hand

DoInventory:    printf
                byte    &quot;You currently have the following items in your &quot;
                byte    &quot;possession:&quot;,cr,lf,0
                mov     di, ItemsOnHand[0]
                call    ShortDesc
                mov     di, ItemsOnHand[2]
                call    ShortDesc
                mov     di, ItemsOnHand[4]
                call    ShortDesc
                mov     di, ItemsOnHand[6]
                call    ShortDesc
                printf
                byte    &quot;\nCurrent score: %d\n&quot;
                byte    &quot;Carrying ability: %d/4\n\n&quot;,0
                dword   CurScore,CurWeight
                inc     CurScore                ;This command is free.
                jmp     RoomLoop


; If the user requests help, provide it here.

DoHelp:         printf
                byte    &quot;List of commands:&quot;,cr,lf,lf
                byte    &quot;GO {NORTH, EAST, WEST, SOUTH}&quot;,cr,lf
                byte    &quot;{GET, DROP} {LIME, BEER, CARD, SIGN, PROGRAM, &quot;
                byte    &quot;HOMEWORK, MONEY, FORM, COUPON}&quot;,cr,lf
                byte    &quot;SHOW INVENTORY&quot;,cr,lf
                byte    &quot;QUIT GAME&quot;,cr,lf
                byte    &quot;HELP ME&quot;,cr,lf,lf
                byte    &quot;Each command costs you one point.&quot;,cr,lf
                byte    &quot;You accumulate points by picking up objects and &quot;
                byte    &quot;dropping them in their&quot;,cr,lf
                byte    &quot; appropriate locations.&quot;,cr,lf
                byte    &quot;If you drop an item in its proper location, it &quot;
                byte    &quot;disappears from the game.&quot;,cr,lf
                byte    &quot;The game is over if your score drops to zero or &quot;
                byte    &quot;you properly place&quot;,cr,lf
                byte    &quot; all items.&quot;,cr,lf
                byte    0
                jmp     RoomLoop


; If they quit prematurely, let 'em know what a wimp they are!

QuitGame:       printf
                byte    &quot;So long, your score is %d and there are &quot;
                byte    &quot;still %d objects unplaced\n&quot;,0
                dword   CurScore, TotalCounter

Quit:           ExitPgm                 ;DOS macro to quit program.
Main            endp
cseg            ends

sseg            segment para stack 'stack'
stk             db      1024 dup (&quot;stack &quot;)
sseg            ends

zzzzzzseg       segment para public 'zzzzzz'
LastBytes       db      16 dup (?)
zzzzzzseg       ends
                end     Main</font></pre>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH16-11.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH16-11.html">Chapter Sixteen</a> (Part 11)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="../Chapter_17/CH17-1.html">Chapter Seventeen</a>
    &nbsp; </strong></font><a href="../Chapter_17/CH17-1.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Sixteen: Pattern Matching
(Part 12)<br>
29 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_16/CH16-12.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:31 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
