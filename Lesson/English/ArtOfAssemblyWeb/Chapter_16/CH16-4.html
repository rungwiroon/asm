<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_16/CH16-4.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:29 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER SIXTEEN: PATTERN MATCHING (Part 4)</title>
</head>

<body stylesrc="../toc.html" topmargin="10" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING4"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH16-3.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH16-3.html">Chapter Sixteen</a> (Part 3)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH16-5.html">Chapter Sixteen</a> (Part 5)&nbsp; </strong></font><a href="CH16-5.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10" colspan="2"><a NAME="HEADING4-1"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0" colspan="2"><font face="Arial" size="4"><strong>CHAPTER
    SIXTEEN:<br>
    PATTERN MATCHING (Part 4)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10" colspan="2"></td>
  </tr>
  <tr>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING4-1"><b>16.1.3 </b>-
    Context Free Languages</a> <br>
    <a HREF="#HEADING4-78"><b>16.1.4 </b>- Eliminating Left Recursion and Left Factoring CFGs</a>
    <br>
    <a HREF="#HEADING4-137"><b>16.1.5 </b>- Converting REs to CFGs</a> </font></td>
    <td width="50%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING4-152"><b>16.1.6
    </b>- Converting CFGs to Assembly Language</a> <br>
    <a HREF="#HEADING4-548"><b>16.1.7 </b>- Some Final Comments on CFGs</a> <br>
    <a HREF="#HEADING4-552"><b>16.1.8 </b>- Beyond Context Free Languages</a></font></td>
  </tr>
</table>
</center></div>

<h3><strong><font face="Arial" size="3">16.1.3 Context Free Languages</font></strong></h3>

<p><font face="Arial" size="2">Context free languages provide a superset of the regular
languages - if you can specify a class of patterns with a regular expression, you can
express the same language using a context free grammar. In addition, you can specify many
languages that are not regular using context free grammars (CFGs).</font></p>

<p><font face="Arial" size="2">Examples of languages that are context free, but not
regular, include the set of all strings representing common arithmetic expressions, legal
Pascal or C source files, and MASM macros. Context free languages are characterized by
balance and nesting. For example, arithmetic expression have balanced sets of parenthesis.
High level language statements like <code>repeat</code>...<code>until</code> allow nesting
and are always balanced (e.g., for every <code>repeat</code> there is a corresponding <code>until</code>
statement later in the source file).</font></p>

<p><font face="Arial" size="2">There is only a slight extension to the regular languages
to handle context free languages - function calls. In a regular expression, we only allow
the objects we want to match and the specific RE operators like &quot;|&quot;,
&quot;*&quot;, concatenation, and so on. To extend regular languages to context free
languages, we need only add recursive function calls to regular expressions. Although it
would be simple to create a syntax allowing function calls within a regular expression,
computer scientists use a different notation altogether for context free languages - a
context free grammar.</font></p>

<p><font face="Arial" size="2">A context free grammar contains two types of symbols: <em>terminal
symbols</em> and <em>nonterminal symbols</em>. Terminal symbols are the individual
characters and strings that the context free grammar matches plus the empty string, <img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11">. Context free
grammars use nonterminal symbols for function calls and definitions. In our context free
grammars we will use italic characters to denote nonterminal symbols and standard
characters to denote terminal symbols. </font></p>

<p><font face="Arial" size="2">To match this string, we begin by calling the starting
symbol function, <em>expression</em>, using the function <em>expression </em><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"><em>expression
</em>+ <em>factor. </em>The first plus sign suggests that the <em>expression</em> term
must match &quot;7&quot; and the <em>factor</em> term must match &quot;5*(2+1)&quot;. Now
we need to match our input string with the pattern <em>expression </em>+ <em>factor.</em></font></p>

<p><font face="Arial" size="2">To do this, we call the <em>expression</em> function once
again, this time using the <em>expression </em><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"><em>factor</em>
production. This give us the <em>reduction</em>: </font></p>

<p><font face="Arial" size="2"><em>expression </em><img SRC="../images/arrwdbrt-1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwdbrt.gif" WIDTH="18" HEIGHT="13"><em>expression
</em>+ <em>factor</em> <img SRC="../images/arrwdbrt-1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwdbrt.gif" WIDTH="18" HEIGHT="13"><em>factor </em>+
<em>factor </em></font></p>

<p><font face="Arial" size="2">The <img SRC="../images/arrwdbrt-1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwdbrt.gif" WIDTH="18" HEIGHT="13">symbol
denotes the application of a nonterminal function call (a reduction). </font></p>

<p><font face="Arial" size="2">Next, we call the factor function, using the production <em>factor
</em><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"><em>term </em>to
yield the reduction: </font></p>

<p><font face="Arial" size="2"><em>expression </em><img SRC="../images/arrwdbrt-1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwdbrt.gif" WIDTH="18" HEIGHT="13"><em>expression
</em>+ <em>factor</em> <img SRC="../images/arrwdbrt-1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwdbrt.gif" WIDTH="18" HEIGHT="13"><em>factor </em>+
<em>factor </em><img SRC="../images/arrwdbrt-1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwdbrt.gif" WIDTH="18" HEIGHT="13"><em>term </em>+
<em>factor </em></font></p>

<p><font face="Arial" size="2">Continuing, we call the <em>term</em> function to produce
the reduction: </font></p>

<p><font face="Arial" size="2"><em>expression </em><img SRC="../images/arrwdbrt-1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwdbrt.gif" WIDTH="18" HEIGHT="13"><em>expression
</em>+ <em>factor</em> <img SRC="../images/arrwdbrt-1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwdbrt.gif" WIDTH="18" HEIGHT="13"><em>factor </em>+
<em>factor </em><img SRC="../images/arrwdbrt-1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwdbrt.gif" WIDTH="18" HEIGHT="13"><em>term </em>+
<em>factor </em><img SRC="../images/arrwdbrt-1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwdbrt.gif" WIDTH="18" HEIGHT="13"><em>IntegerConstant
</em>+ <em>factor </em></font></p>

<p><font face="Arial" size="2">Next, we call the <em>IntegerConstant</em> function to
yield: </font></p>

<p><font face="Arial" size="2"><em>expression </em><img SRC="../images/arrwdbrt-1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwdbrt.gif" WIDTH="18" HEIGHT="13"><em>expression
</em>+ <em>factor</em> <img SRC="../images/arrwdbrt-1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwdbrt.gif" WIDTH="18" HEIGHT="13"><em>factor </em>+
<em>factor </em><img SRC="../images/arrwdbrt-1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwdbrt.gif" WIDTH="18" HEIGHT="13"><em>term </em>+
<em>factor </em><img SRC="../images/arrwdbrt-1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwdbrt.gif" WIDTH="18" HEIGHT="13"><em>IntegerConstant
</em>+ <em>factor </em><img SRC="../images/arrwdbrt-1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwdbrt.gif" WIDTH="18" HEIGHT="13"><em>7 </em>+ <em>factor
</em></font></p>

<p><font face="Arial" size="2">At this point, the first two symbols of our generated
string match the first two characters of the input string, so we can remove them from the
input and concentrate on the items that follow. In succession, we call the <em>factor</em>
function to produce the reduction <em>7 </em>+ <em>factor </em>* <em>term </em>and then we
call <em>factor, term</em>, and <em>IntegerConstant</em> to yield <em>7 </em>+ <em>5 </em>*
<em>term</em>. In a similar fashion, we can reduce the term to &quot;( <em>expression </em>)&quot;
and reduce expression to &quot;2+1&quot;. The complete <em>derivation</em> for this string
is </font></p>

<pre><font face="Arial" size="2"><em>expression	</em><img SRC="../images/arrwdbrt-1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwdbrt.gif" WIDTH="18" HEIGHT="13"> <em>expression </em>+ <em>factor</em> </font></pre>

<pre><font face="Arial" size="2">		<img SRC="../images/arrwdbrt-1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwdbrt.gif" WIDTH="18" HEIGHT="13"> <em>factor </em>+ <em>factor </em></font></pre>

<pre><font face="Arial" size="2">		<img SRC="../images/arrwdbrt-1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwdbrt.gif" WIDTH="18" HEIGHT="13"> <em>term </em>+ <em>factor </em></font></pre>

<pre><font face="Arial" size="2">		<img SRC="../images/arrwdbrt-1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwdbrt.gif" WIDTH="18" HEIGHT="13"> <em>IntegerConstant </em>+ <em>factor </em></font></pre>

<pre><font face="Arial" size="2">		<img SRC="../images/arrwdbrt-1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwdbrt.gif" WIDTH="18" HEIGHT="13"> <em>7 </em>+ <em>factor</em> </font></pre>

<pre><font face="Arial" size="2">		<img SRC="../images/arrwdbrt-1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwdbrt.gif" WIDTH="18" HEIGHT="13"> <em>7 </em>+ <em>factor * term</em> </font></pre>

<pre><font face="Arial" size="2">		<img SRC="../images/arrwdbrt-1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwdbrt.gif" WIDTH="18" HEIGHT="13"> <em>7 </em>+ <em>term * term</em> </font></pre>

<pre><font face="Arial" size="2">		<img SRC="../images/arrwdbrt-1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwdbrt.gif" WIDTH="18" HEIGHT="13"> <em>7 </em>+ <em>IntegerConstant * term</em> </font></pre>

<pre><font face="Arial" size="2">		<img SRC="../images/arrwdbrt-1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwdbrt.gif" WIDTH="18" HEIGHT="13"> <em>7 </em>+ <em>5 * term</em> </font></pre>

<pre><font face="Arial" size="2">		<img SRC="../images/arrwdbrt-1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwdbrt.gif" WIDTH="18" HEIGHT="13"> <em>7 </em>+ <em>5 * </em>( <em>expression</em> ) </font></pre>

<pre><font face="Arial" size="2">		<img SRC="../images/arrwdbrt-1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwdbrt.gif" WIDTH="18" HEIGHT="13"> <em>7 </em>+ <em>5 * </em>( <em>expression</em> + <em>factor</em> ) </font></pre>

<pre><font face="Arial" size="2">		<img SRC="../images/arrwdbrt-1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwdbrt.gif" WIDTH="18" HEIGHT="13"> <em>7 </em>+ <em>5 * </em>( <em>factor</em> + <em>factor</em> ) </font></pre>

<pre><font face="Arial" size="2">		<img SRC="../images/arrwdbrt-1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwdbrt.gif" WIDTH="18" HEIGHT="13"> <em>7 </em>+ <em>5 * </em>( <em>IntegerConstant</em> + <em>factor</em> ) </font></pre>

<pre><font face="Arial" size="2">		<img SRC="../images/arrwdbrt-1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwdbrt.gif" WIDTH="18" HEIGHT="13"> <em>7 </em>+ <em>5 * </em>( <em>2</em> + <em>factor</em> ) </font></pre>

<pre><font face="Arial" size="2">		<img SRC="../images/arrwdbrt-1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwdbrt.gif" WIDTH="18" HEIGHT="13"> <em>7 </em>+ <em>5 * </em>( <em>2</em> + <em>term</em> ) </font></pre>

<pre><font face="Arial" size="2">		<img SRC="../images/arrwdbrt-1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwdbrt.gif" WIDTH="18" HEIGHT="13"> <em>7 </em>+ <em>5 * </em>( <em>2</em> + <em>IntegerConstant</em> ) </font></pre>

<pre><font face="Arial" size="2">		<img SRC="../images/arrwdbrt-1.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwdbrt.gif" WIDTH="18" HEIGHT="13"> <em>7 </em>+ <em>5 * </em>( <em>2</em> + <em>1</em> )</font></pre>

<p><font face="Arial" size="2">The final reduction completes the derivation of our input
string, so the string 7+5*(2+1) is in the language specified by the context free grammar. </font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING4-78"></a>16.1.4 Eliminating Left
Recursion and Left Factoring CFGs</font></strong></p>

<p><font face="Arial" size="2">In the next section we will discuss how to convert a CFG to
an assembly language program. However, the technique we are going to use to do this
conversion will require that we modify certain grammars before converting them. The
arithmetic expression grammar in the previous section is a good example of such a grammar
- one that is left recursive.</font></p>

<p><font face="Arial" size="2">Left recursive grammars pose a problem for us because the
way we will typically convert a production to assembly code is to call a function
corresponding to a nonterminal and compare against the terminal symbols. However, we will
run into trouble if we attempt to convert a production like the following using this
technique:</font></p>

<pre><font face="Arial" size="2"><em>expression </em><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"> <em>expression </em>+ <em>factor</em></font></pre>

<p><font face="Arial" size="2">Such a conversion would yield some assembly code that looks
roughly like the following:</font></p>

<pre><font face="Courier New" size="2">expression      proc    near
                call    expression
                jnc     fail
                cmp     byte ptr es:[di], '+'
                jne     fail
                inc     di
                call    factor
                jnc     fail
                stc
                ret
Fail:           clc
                ret
expression      endp</font></pre>

<p><font face="Arial" size="2">The obvious problem with this code is that it will generate
an infinite loop. Upon entering the <code>expression</code> function this code immediately
calls <code>expression</code> recursively, which immediately calls <code>expression</code>
recursively, which immediately calls <code>expression</code> recursively, ... Clearly, we
need to resolve this problem if we are going to write any real code to match this
production.</font></p>

<p><font face="Arial" size="2">The trick to resolving left recursion is to note that if
there is a production that suffers from left recursion, there must be some production with
the same left hand side that is not left recursive. All we need do is rewrite the left
recursive call in terms of the production that does not have any left recursion. This
sound like a difficult task, but it's actually quite easy. </font></p>

<p><font face="Arial" size="2">To see how to eliminate left recursion, let Xi and Yj
represent any set of terminal symbols or nonterminal symbols that do not have a right hand
side beginning with the nonterminal A. If you have some productions of the form:</font></p>

<pre><font face="Courier New" size="2"><em>A </em><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"> <em>AX1</em> | <em>AX2</em> |  | <em>AXn</em> | <em>Y1</em> | <em>Y2</em> |  | <em>Ym</em> </font></pre>

<p><font face="Arial" size="2">You will be able to translate this to an equivalent grammar
without left recursion by replacing each term of the form <code>A </code><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"><code>Yi</code>
by <code>A </code><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"><code>Yi</code>
<em>A </em>and each term of the form <code>A </code><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"><code>AXi</code>
by <code>A' </code><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"><code>Xi A' |
</code><img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11">. For example,
consider three of the productions from the arithmetic grammar: </font></p>

<pre><font face="Courier New" size="2"><em>expression </em><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"> <em>expression </em>+ <em>factor</em></font></pre>

<pre><font face="Courier New" size="2"><em>expression </em><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"> <em>expression </em>- <em>factor</em></font></pre>

<pre><font face="Courier New" size="2"><em>expression </em><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"> <em>factor</em></font></pre>

<p><font face="Arial" size="2">In this example <code>A</code> corresponds to <em>expression</em>,
<code>X1</code> corresponds to &quot;+ <em>factor</em> &quot;, <code>X2</code> corresponds
to &quot;- <em>factor</em> &quot;, and <code>Y1</code> corresponds to &quot;<em>factor </em>&quot;.
The equivalent grammar without left recursion is </font></p>

<pre><font face="Courier New" size="2"><em>expression </em><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"> <em>factor E'</em></font></pre>

<pre><font face="Courier New" size="2"><em>E' </em><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"><em> </em>- <em>factor E'</em></font></pre>

<pre><font face="Courier New" size="2"><em>E' </em><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"> + <em>factor E'</em></font></pre>

<pre><font face="Courier New" size="2"><em>E' </em><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"> <img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11"></font></pre>

<p><font face="Arial" size="2">The complete arithmetic grammar, with left recursion
removed, is </font></p>

<pre><font face="Courier New" size="2"><em>expression </em><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"> <em>factor E'</em></font></pre>

<pre><font face="Courier New" size="2"><em>E' </em><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"><em> </em>+ <em>factor E' </em>| <em> </em>- <em>factor E' </em>|<em>  </em><img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11"></font></pre>

<pre><font face="Courier New" size="2"><em>factor </em><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"> <em>term F'</em></font></pre>

<pre><font face="Courier New" size="2"><em>F' </em><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"><em> </em>* <em>term F' </em>| <em> </em>/ <em>term F' </em>|<em>  </em><img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11"></font></pre>

<pre><font face="Courier New" size="2"><em>term </em><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"> <em>IntegerConstant  </em>|  ( <em>expression</em> )</font></pre>

<pre><font face="Courier New" size="2"><em>IntegerConstant </em><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"> <em>digit  </em>|  <em>digit</em> <em>IntegerConstant</em></font></pre>

<pre><font face="Courier New" size="2"><em>digit </em><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"> 0<em>  </em>|  1<em>  </em>|  2<em>  </em>|  3<em>  </em>|  <em>4  </em>|  5<em>  </em>|  6<em>  </em>|  7<em>  </em>|  8<em>  </em>|  9</font></pre>

<p><font face="Arial" size="2">Another useful transformation on a grammar is to left
factor the grammar. This can reduce the need for backtracking, improving the performance
of your pattern matching code. Consider the following CFG fragment: </font></p>

<pre><font face="Courier New" size="2"><em>stmt </em><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"> if <em>expression </em>then <em>stmt </em>endif</font></pre>

<pre><font face="Courier New" size="2"><em>stmt </em><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"> if <em>expression </em>then <em>stmt </em>else <em>stmt </em>endif</font></pre>

<p><font face="Arial" size="2">These two productions begin with the same set of symbols.
Either production will match all the characters in an <code>if</code> statement up to the
point the matching algorithm encounters the first <code>else</code> or <code>endif</code>.
If the matching algorithm processes the first statement up to the point of the <code>endif</code>
terminal symbol and encounters the <code>else</code> terminal symbol instead, it must
backtrack all the way to the <code>if</code> symbol and start over. This can be terribly
inefficient because of the recursive call to <code>stmt</code> (imagine a 10,000 line
program that has a single if statement around the entire 10,000 lines, a compiler using
this pattern matching technique would have to recompile the entire program from scratch if
it used backtracking in this fashion). However, by left factoring the grammar before
converting it to program code, you can eliminate the need for backtracking. </font></p>

<p><font face="Arial" size="2">To left factor a grammar, you collect all productions that
have the same left hand side and begin with the same symbols on the right hand side. In
the two productions above, the common symbols are &quot;if <em>expression</em> then <em>stmt</em>
&quot;. You combine the common strings into a single production and then append a new
nonterminal symbol to the end of this new production, e.g., </font></p>

<pre><font face="Courier New" size="2"><em>stmt </em><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"> if <em>expression </em>then <em>stmt NewNonTerm</em></font></pre>

<p><font face="Arial" size="2">Finally, you create a new set of productions using this new
nonterminal for each of the suffixes to the common production: </font></p>

<pre><font face="Courier New" size="2"><em>NewNonTerm </em><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"> endif | else <em>stmt</em> endif</font></pre>

<p><font face="Arial" size="2">This eliminates backtracking because the matching algorithm
can process the <code>if</code>, the <code>expression</code>, the <code>then</code>, and
the <code>stmt</code> before it has to choose between <code>endif</code> and <code>else</code>.
</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING4-137"></a>16.1.5 Converting REs to
CFGs</font></strong></p>

<p><font face="Arial" size="2">Since the context free languages are a superset of the
regular languages, it should come as no surprise that it is possible to convert regular
expressions to context free grammars. Indeed, this is a very easy process involving only a
few intuitive rules.</font></p>

<p><font face="Arial" size="2">1) If a regular expression simply consists of a sequence of
characters, xyz, you can easily create a production for this regular expression of the
form <em>P </em><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15">xyz. This
applies equally to the empty string, <img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11">. </font></p>

<p><font face="Arial" size="2">2) If <em>r</em> and <em>s</em> are two regular expression
that you've converted to CFG productions <em>R </em>and <em>S</em> , and you have a
regular expression <em>rs</em> that you want to convert to a production, simply create a
new production of the form <em>T </em><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"><em>R S</em>.
</font></p>

<p><font face="Arial" size="2">3) If <em>r</em> and <em>s</em> are two regular expression
that you've converted to CFG productions <em>R </em>and <em>S</em> , and you have a
regular expression <em>r | s</em> that you want to convert to a production, simply create
a new production of the form <em>T </em><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"><em>R | S</em>.
</font></p>

<p><font face="Arial" size="2">4) If <em>r </em>is a regular expression that you've
converted to a production, <em>R</em>, and you want to create a production for <em>r*</em>,
simply use the production <em>RStar </em><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"><em>R RStar </em>|
<img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11">. </font></p>

<p><font face="Arial" size="2">5) If <em>r </em>is a regular expression that you've
converted to a production, <em>R</em>, and you want to create a production for <em>r+</em>,
simply use the production <em>RPlus </em><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"><em>R RPlus </em>|
<em>R</em>. </font></p>

<p><font face="Arial" size="2">6) For regular expressions there are operations with
various precedences. Regular expressions also allow parenthesis to override the default
precedence. This notion of precedence does not carry over into CFGs. Instead, you must
encode the precedence directly into the grammar. For example, to encode <em>R S*</em> you
would probably use productions of the form: </font></p>

<pre><font face="Courier New" size="2">		<code>T  </code><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"><code> R   SStar</code></font></pre>

<pre><font face="Courier New" size="2">		SStar <img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"> <em>S SStar</em> | <img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11"></font></pre>

<p><font face="Arial" size="2">Likewise, to handle a grammar of the form (<em>RS</em> )*
you could use productions of the form: </font></p>

<pre><font face="Courier New" size="2">		<code>T  </code><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"><code> R S   T  | </code><img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11"></font></pre>

<pre><font face="Courier New" size="2">		<em>RS</em> <code> </code><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"><code> </code><em>R   S</em></font></pre>

<h3><strong><font face="Arial" size="3"><a name="HEADING4-152"></a>16.1.6 Converting CFGs
to Assembly Language</font></strong></h3>

<p><font face="Arial" size="2">If you have removed left recursion and you've left factored
a grammar, it is very easy to convert such a grammar to an assembly language program that
recognizes strings in the context free language. </font></p>

<p><font face="Arial" size="2">The first convention we will adopt is that <code>es:di</code>
always points at the start of the string we want to match. The second convention we will
adopt is to create a function for each nonterminal. This function returns success (carry
set) if it matches an associated subpattern, it returns failure (carry clear) otherwise.
If it succeeds, it leaves <code>di</code> pointing at the next character is the staring
after the matched pattern; if it fails, it preserves the value in <code>di</code> across
the function call. </font></p>

<p><font face="Arial" size="2">To convert a set of productions to their corresponding
assembly code, we need to be able to handle four things: terminal symbols, nonterminal
symbols, alternation, and the empty string. First, we will consider simple functions
(nonterminals) which do not have multiple productions (i.e., alternation).</font></p>

<p><font face="Arial" size="2">If a production takes the form <code>T </code><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"><img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11">and there are
no other productions associated with <em>T</em>, then this production always succeeds. The
corresponding assembly code is simply: </font></p>

<p><font face="Courier New" size="2">T
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc
&nbsp;&nbsp;&nbsp; near<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stc<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret<br>
T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endp</font></p>

<p><font face="Arial" size="2">Of course, there is no real need to ever call T and test
the returned result since we know it will always succeed. On the other hand, if T is a
stub that you intend to fill in later, you should call T.</font></p>

<p><font face="Arial" size="2">If a production takes the form <code>T </code><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15">xyz, where
xyz is a string of one or more terminal symbols, then the function returns success if the
next several input characters match xyz, it returns failure otherwise. Remember, if the
prefix of the input string matches xyz, then the matching function must advance <code>di</code>
beyond these characters. If the first characters of the input string does not match xyz,
it must preserve <code>di</code>. The following routines demonstrate two cases, where xyz
is a single character and where xyz is a string of characters: </font></p>

<pre><font face="Courier New" size="2">T1              proc    near
                cmp     byte ptr es:[di], 'x'   ;Single char.
                je      Success
                clc                             ;Return Failure.
                ret

Success:        inc     di                      ;Skip matched char.
                stc                             ;Return success.
                ret
T1              endp


T2              proc    near
                call    MatchPrefix
                byte    'xyz',0
                ret
T2              endp</font></pre>
<code>

<p><font face="Arial" size="2">MatchPrefix</code> is a routine that matches the prefix of
the string pointed at by es:di against the string following the call in the code stream.
It returns the carry set and adjusts <code>di</code> if the string in the code stream is a
prefix of the input string, it returns the carry flag clear and preserves <code>di</code>
if the literal string is not a prefix of the input. The <code>MatchPrefix</code> code
follows:</font></p>

<pre><font face="Courier New" size="2">MatchPrefix     proc    far             ;Must be far!
                push    bp
                mov     bp, sp
                push    ax
                push    ds
                push    si
                push    di

                lds     si, 2[bp]       ;Get the return address.
CmpLoop:        mov     al, ds:[si]     ;Get string to match.
                cmp     al, 0           ;If at end of prefix,
                je      Success         ; we succeed.
                cmp     al, es:[di]     ;See if it matches prefix,
                jne     Failure         ; if not, immediately fail.
                inc     si
                inc     di
                jmp     CmpLoop

Success:        add     sp, 2           ;Don't restore di.
                inc     si              ;Skip zero terminating byte.
                mov     2[bp], si       ;Save as return address.
                pop     si
                pop     ds
                pop     ax
                pop     bp
                stc                     ;Return success.
                ret

Failure:        inc     si              ;Need to skip to zero byte.
                cmp     byte ptr ds:[si], 0
                jne     Failure
                inc     si
                mov     2[bp], si       ;Save as return address.

                pop     di
                pop     si
                pop     ds
                pop     ax
                pop     bp
                clc                     ;Return failure.
                ret
MatchPrefix     endp</font></pre>

<p><font face="Arial" size="2">If a production takes the form <code>T </code><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"><em>R</em>,
where <em>R </em>is a nonterminal, then the <em>T</em> function calls <em>R</em> and
returns whatever status <em>R</em> returns, e.g., </font></p>

<pre><font face="Courier New" size="2">T		proc	near
		call	R
		ret
T		endp</font></pre>

<p><font face="Arial" size="2">If the right hand side of a production contains a string of
terminal and nonterminal symbols, the corresponding assembly code checks each item in
turn. If any check fails, then the function returns failure. If all items succeed, then
the function returns success. For example, if you have a production of the form <code>T </code><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"><em>R</em>
abc <em>S </em>you could implement this in assembly language as </font></p>

<pre><font face="Courier New" size="2">T               proc    near
                push    di              ;If we fail, must preserve di.
                call    R
                jnc     Failure
                call    MatchPrefix
                byte    &quot;abc&quot;,0
                jnc     Failure
                call    S
                jnc     Failure
                add     sp, 2           ;Don't preserve di if we succeed.
                stc
                ret

Failure:        pop     di
                clc
                ret
T               endp</font></pre>

<p><font face="Arial" size="2">Note how this code preserves di if it fails, but does not
preserve di if it succeeds.</font></p>

<p><font face="Arial" size="2">If you have multiple productions with the same left hand
side (i.e., alternation), then writing an appropriate matching function for the
productions is only slightly more complex than the single production case. If you have
multiple productions associated with a single nonterminal on the left hand side, then
create a sequence of code to match each of the individual productions. To combine them
into a single matching function, simply write the function so that it succeeds if any one
of these code sequences succeeds. If one of the productions is of the form T <img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15">e, then test
the other conditions first. If none of them could be selected, the function succeeds. For
example, consider the productions: </font></p>

<pre><font face="Courier New" size="2"><em>E' </em><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"><em> </em>+ <em>factor E' </em>| <em> </em>- <em>factor E' </em>|<em>  </em><img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11"></font></pre>

<p><font face="Arial" size="2">This translates to the following assembly code:</font></p>

<pre><font face="Courier New" size="2">EPrime          proc    near
                push    di
                cmp     byte ptr es:[di], '+'
                jne     TryMinus
                inc     di
                call    factor
                jnc     EP_Failed
                call    EPrime
                jnc     EP_Failed
Success:        add     sp, 2
                stc
                ret

TryMinus:       cmp     byte ptr es:[di], '-'
                jne     EP_Failed
                inc     di
                call    factor
                jnc     EP_Failed
                call    EPrime
                jnc     EP_Failed
                add     sp, 2
                stc
                ret

EP_Failed:      pop     di
                stc                     ;Succeed because of E' -&gt; e
                ret
EPrime          endp</font></pre>

<p><font face="Arial" size="2">This routine always succeeds because it has the production <em>E'
</em><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"><img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11">. This is why
the <code>stc</code> instruction appears after the <code>EP_Failed</code> label. </font></p>

<p><font face="Arial" size="2">To invoke a pattern matching function, simply load es:di
with the address of the string you want to test and call the pattern matching function. On
return, the carry flag will contain one if the pattern matches the string up to the point
returned in di. If you want to see if the entire string matches the pattern, simply check
to see if <code>es:di</code> is pointing at a zero byte when you get back from the
function call. If you want to see if a string belongs to a context free language, you
should call the function associated with the starting symbol for the given context free
grammar.</font></p>

<p><font face="Arial" size="2">The following program implements the arithmetic grammar
we've been using as examples throughout the past several sections. The complete
implementation is</font></p>

<pre><font face="Courier New" size="2">; ARITH.ASM
;
; A simple recursive descent parser for arithmetic strings.

                .xlist
                include         stdlib.a
                includelib      stdlib.lib
                .list


dseg            segment para public 'data'

; Grammar for simple arithmetic grammar (supports +, -, *, /):
;
; E -&gt; FE'
; E' -&gt; + F E' | - F E' | &lt;empty string&gt;
; F -&gt; TF'
; F' -&gt; * T F' | / T F' | &lt;empty string&gt;
; T -&gt; G | (E)
; G -&gt; H | H G
; H -&gt; 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
;


InputLine       byte    128 dup (0)

dseg            ends

cseg            segment para public 'code'
                assume  cs:cseg, ds:dseg

; Matching functions for the grammar.
; These functions return the carry flag set if they match their
; respective item. They return the carry flag clear if they fail.
; If they fail, they preserve di. If they succeed, di points to
; the first character after the match.


; E -&gt; FE'

E               proc    near
                push    di
                call    F               ;See if F, then E', succeeds.
                jnc     E_Failed
                call    EPrime
                jnc     E_Failed
                add     sp, 2           ;Success, don't restore di.
                stc
                ret

E_Failed:       pop     di              ;Failure, must restore di.
                clc
                ret
E               endp



; E' -&gt; + F E' | - F E' | e

EPrime          proc    near
                push    di

; Try + F E' here

                cmp     byte ptr es:[di], '+'
                jne     TryMinus
                inc     di
                call    F
                jnc     EP_Failed
                call    EPrime
                jnc     EP_Failed
Success:        add     sp, 2
                stc
                ret

; Try  - F E' here.

TryMinus:       cmp     byte ptr es:[di], '-'
                jne     Success
                inc     di
                call    F
                jnc     EP_Failed
                call    EPrime
                jnc     EP_Failed
                add     sp, 2
                stc
                ret

; If none of the above succeed, return success anyway because we have
; a production of the form E' -&gt; e.

EP_Failed:      pop     di
                stc
                ret
EPrime          endp



; F -&gt; TF'

F               proc    near
                push    di
                call    T
                jnc     F_Failed
                call    FPrime
                jnc     F_Failed
                add     sp, 2           ;Success, don't restore di.
                stc
                ret

F_Failed:       pop     di
                clc
                ret
F               endp




; F -&gt; * T F' | / T F' | e

FPrime          proc    near
                push    di
                cmp     byte ptr es:[di], '*'   ;Start with &quot;*&quot;?
                jne     TryDiv
                inc     di                      ;Skip the &quot;*&quot;.
                call    T
                jnc     FP_Failed
                call    FPrime
                jnc     FP_Failed
Success:        add     sp, 2
                stc
                ret

; Try F -&gt; / T F' here

TryDiv:         cmp     byte ptr es:[di], '/'   ;Start with &quot;/&quot;?
                jne     Success                 ;Succeed anyway.
                inc     di                      ;Skip the &quot;/&quot;.
                call    T
                jnc     FP_Failed
                call    FPrime
                jnc     FP_Failed
                add     sp, 2
                stc
                ret

; If the above both fail, return success anyway because we've got
; a production of the form F -&gt; e

FP_Failed:      pop     di
                stc
                ret
FPrime          endp


; T -&gt; G | (E)

T               proc    near

; Try T -&gt; G here.

                call    G
                jnc     TryParens
                ret

; Try T -&gt; (E) here.

TryParens:      push    di                      ;Preserve if we fail.
                cmp     byte ptr es:[di], '('   ;Start with &quot;(&quot;?
                jne     T_Failed                ;Fail if no.
                inc     di                      ;Skip &quot;(&quot; char.
                call    E
                jnc     T_Failed
                cmp     byte ptr es:[di], ')'   ;End with &quot;)&quot;?
                jne     T_Failed                ;Fail if no.
                inc     di                      ;Skip &quot;)&quot;
                add     sp, 2                   ;Don't restore di,
                stc                             ; we've succeeded.
                ret

T_Failed:       pop     di
                clc
                ret
T               endp


; The following is a free-form translation of
;
; G -&gt; H | H G
; H -&gt; 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
;
; This routine checks to see if there is at least one digit. It fails if there
; isn't at least one digit; it succeeds and skips over all digits if there are
; one or more digits.

G               proc    near
                cmp     byte ptr es:[di], '0'   ;Check for at least
                jb      G_Failed                ; one digit.
                cmp     byte ptr es:[di], '9'
                ja      G_Failed

DigitLoop:      inc     di                      ;Skip any remaining
                cmp     byte ptr es:[di], '0'   ; digits found.
                jb      G_Succeeds
                cmp     byte ptr es:[di], '9'
                jbe     DigitLoop
G_Succeeds:     stc
                ret

G_Failed:       clc                             ;Fail if no digits
                ret                             ; at all.
G               endp


; This main program tests the matching functions above and demonstrates
; how to call the matching functions.

Main            proc
                mov     ax, seg dseg            ;Set up the segment registers
                mov     ds, ax
                mov     es, ax

                printf
                byte    &quot;Enter an arithmetic expression: &quot;,0
                lesi    InputLine
                gets
                call    E
                jnc     BadExp

; Good so far, but are we at the end of the string?

                cmp     byte ptr es:[di], 0
                jne     BadExp

; Okay, it truly is a good expression at this point.

                printf
                byte    &quot;'%s' is a valid expression&quot;,cr,lf,0
                dword   InputLine
                jmp     Quit

BadExp:         printf
                byte    &quot;'%s' is an invalid arithmetic expression&quot;,cr,lf,0
                dword   InputLine

Quit:           ExitPgm
Main            endp

cseg            ends

sseg            segment para stack 'stack'
stk             byte    1024 dup (&quot;stack &quot;)
sseg            ends

zzzzzzseg       segment para public 'zzzzzz'
LastBytes       byte    16 dup (?)
zzzzzzseg       ends
                end     Main</font></pre>

<h3><strong><font face="Arial" size="3"><a name="HEADING4-548"></a>16.1.7 Some Final
Comments on CFGs</font></strong></h3>

<p><font face="Arial" size="2">The techniques presented in this chapter for converting
CFGs to assembly code do not work for all CFGs. They only work for a (large) subset of the
CFGs known as LL(1) grammars. The code that these techniques produce is a recursive
descent predictive parser. Although the set of context free languages recognizable by an
LL(1) grammar is a subset of the context free languages, it is a very large subset and you
shouldn't run into too many difficulties using this technique. </font></p>

<p><font face="Arial" size="2">One important feature of predictive parsers is that they do
not require any backtracking. If you are willing to live with the inefficiencies
associated with backtracking, it is easy to extended a recursive descent parser to handle
any CFG. Note that when you use backtracking, the predictive adjective goes away, you wind
up with a nondeterministic system rather than a deterministic system (predictive and
deterministic are very close in meaning in this case).</font></p>

<p><font face="Arial" size="2">There are other CFG systems as well as LL(1). The so-called
operator precedence and LR(k) CFGs are two examples. For more information about parsing
and grammars, consult a good text on formal language theory or compiler construction (see
the bibliography).</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING4-552"></a>16.1.8 Beyond Context
Free Languages</font></strong></p>

<p><font face="Arial" size="2">Although most patterns you will probably want to process
will be regular or context free, there may be times when you need to recognize certain
types of patterns that are beyond these two (e.g., context sensitive languages). As it
turns out, the finite state automata are the simplest machines; the pushdown automata
(that recognize context free languages) are the next step up. After pushdown automata, the
next step up in power is the Turing machine. However, Turing machines are equivalent in
power to the 80x86, so matching patterns recognized by Turing machines is no different
than writing a normal program.</font></p>

<p><font face="Arial" size="2">The key to writing functions that recognize patterns that
are not context free is to maintain information in variables and use the variables to
decide which of several productions you want to use at any one given time. This technique
introduces context sensitivity. Such techniques are very useful in artificial intelligence
programs (like natural language processing) where ambiguity resolution depends on past
knowledge or the current context of a pattern matching operation. However, the uses for
such types of pattern matching quickly go beyond the scope of a text on assembly language
programming, so we will let some other text continue this discussion.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH16-3.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH16-3.html">Chapter Sixteen</a> (Part 3)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH16-5.html">Chapter Sixteen</a> (Part 5)&nbsp; </strong></font><a href="CH16-5.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Sixteen: Pattern Matching
(Part 4)<br>
29 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_16/CH16-4.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:31 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
