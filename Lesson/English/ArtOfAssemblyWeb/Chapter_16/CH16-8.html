<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_16/CH16-8.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:31 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER SIXTEEN: PATTERN MATCHING (Part 8)</title>
</head>

<body stylesrc="../toc.html" topmargin="10" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING8"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH16-7.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH16-7.html">Chapter Sixteen</a> (Part 7)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH16-9.html">Chapter Sixteen</a> (Part 9)&nbsp; </strong></font><a href="CH16-9.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#FFFFFF" nowrap height="10"><a NAME="HEADING8-1"></a></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#F0F0F0"><font face="Arial" size="4"><strong>CHAPTER SIXTEEN:<br>
    PATTERN MATCHING (Part 8)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" nowrap height="10"></td>
  </tr>
  <tr>
    <td width="100%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING8-1"><b>16.8 </b>-
    Some Sample Pattern Matching Applications</a> <br>
    <a HREF="#HEADING8-3"><b>16.8.1 </b>- Converting Written Numbers to Integers</a> </font></td>
  </tr>
  <tr>
    <td width="100%" valign="top" nowrap height="20"></td>
  </tr>
  <tr>
    <td width="100%" valign="top"><strong><font face="Arial" size="3">16.8 Some Sample Pattern
    Matching Applications</font></strong></td>
  </tr>
  <tr>
    <td width="100%" valign="top" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">The best way to learn how to convert a pattern matching
problem to the respective pattern matching algorithms is by example. The following
sections provide several examples of some small pattern matching problems and their
solutions. </font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING8-3"></a>16.8.1 Converting Written
Numbers to Integers</font></strong></p>

<p><font face="Arial" size="2">One interesting pattern matching problem is to convert
written (English) numbers to their integer equivalents. For example, take the string
&quot;one hundred ninety-two&quot; and convert it to the integer 192. Although written
numbers represent a pattern quite a bit more complex than the ones we've seen thus far, a
little study will show that it is easy to decompose such strings.</font></p>

<p><font face="Arial" size="2">The first thing we will need to do is enumerate the English
words we will need to process written numbers. This includes the following words:</font></p>

<p><font face="Arial" size="2">zero, one, two, three, four, five, six, seven, eight, nine,
ten, eleven twelve, thirteen, fourteen, fifteen, sixteen, seventeen, eighteen, nineteen,
twenty, thirty, forty, fifty sixty, seventy, eighty, ninety, hundred, and thousand.</font></p>

<p><font face="Arial" size="2">With this set of words we can build all the values between
zero and 65,535 (the values we can represent in a 16 bit integer.</font></p>

<p><font face="Arial" size="2">Next, we've got to decide how to put these words together
to form all the values between zero and 65,535. The first thing to note is that zero only
occurs by itself, it is never part of another number. So our first production takes the
form:</font></p>

<pre><font face="Courier New" size="2"><em>Number</em> <img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15">  zero | <em>NonZero</em></font></pre>

<p><font face="Arial" size="2">The next thing to note is that certain values <em>may</em>
occur in pairs, denoting addition. For example, eighty-five denotes the sum of eighty plus
five. Also note that certain other pairs denote multiplication. If you have a statement
like &quot;two hundred&quot; or &quot;fifteen hundred&quot; the &quot;hundred&quot; word
says <em>multiply the preceding value by 100</em>. The multiplicative words,
&quot;hundred&quot; and &quot;thousand&quot; , are also additive. Any value following
these terms is added in to the total; e.g., &quot;one hundred five&quot; means 1*100+5. By
combining the appropriate rules, we obtain the following grammar </font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="10%" nowrap><em><font face="Courier New" size="2">NonZero</font></em></td>
    <td width="30" nowrap align="center"><font face="Courier New" size="2"><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"></font></td>
    <td width="90%"><font face="Courier New" size="2"><em>Thousands</em> <em>Maybe100s </em>| <em>Hundreds</em></font></td>
  </tr>
  <tr>
    <td width="10%" nowrap><em><font face="Courier New" size="2">Thousands</font></em></td>
    <td width="30" nowrap align="center"><font face="Courier New" size="2"><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"></font></td>
    <td width="90%"><font face="Courier New" size="2"><em>Under100 </em>thousand</font></td>
  </tr>
  <tr>
    <td width="10%" nowrap><em><font face="Courier New" size="2">Maybe100s</font></em></td>
    <td width="30" nowrap align="center"><font face="Courier New" size="2"><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"></font></td>
    <td width="90%"><font face="Courier New" size="2"><em>Hundreds</em> | <img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11"></font></td>
  </tr>
  <tr>
    <td width="10%" nowrap><em><font face="Courier New" size="2">Hundreds</font></em></td>
    <td width="30" nowrap align="center"><font face="Courier New" size="2"><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"></font></td>
    <td width="90%"><font face="Courier New" size="2"><em>Under100</em> hundred <em>After100 </em>|
    <em>Under100</em></font></td>
  </tr>
  <tr>
    <td width="10%" nowrap><em><font face="Courier New" size="2">After100</font></em></td>
    <td width="30" nowrap align="center"><font face="Courier New" size="2"><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"></font></td>
    <td width="90%"><font face="Courier New" size="2"><em>Under100</em> | <img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11"></font></td>
  </tr>
  <tr>
    <td width="10%" nowrap><em><font face="Courier New" size="2">Under100</font></em></td>
    <td width="30" nowrap align="center"><font face="Courier New" size="2"><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"></font></td>
    <td width="90%"><font face="Courier New" size="2"><em>Tens</em> <em>Maybe1s</em>| <em>Teens
    </em>| <em>ones</em></font></td>
  </tr>
  <tr>
    <td width="10%" nowrap><em><font face="Courier New" size="2">Maybe1s</font></em></td>
    <td width="30" nowrap align="center"><font face="Courier New" size="2"><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"></font></td>
    <td width="90%"><font face="Courier New" size="2"><em>Ones </em>| <img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11"></font></td>
  </tr>
  <tr>
    <td width="10%" nowrap><em><font face="Courier New" size="2">ones</font></em></td>
    <td width="30" nowrap align="center"><font face="Courier New" size="2"><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"></font></td>
    <td width="90%"><font face="Courier New" size="2">one | two | three | four | five | six |
    seven | eight | nine</font></td>
  </tr>
  <tr>
    <td width="10%" nowrap><em><font face="Courier New" size="2">teens</font></em></td>
    <td width="30" nowrap align="center"><font face="Courier New" size="2"><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"></font></td>
    <td width="90%"><font face="Courier New" size="2">ten | eleven | twelve | thirteen |
    fourteen | fifteen | sixteen | seventeen | eighteen | nineteen</font></td>
  </tr>
  <tr>
    <td width="10%" nowrap><em><font face="Courier New" size="2">tens</font></em></td>
    <td width="30" nowrap align="center"><font face="Courier New" size="2"><img SRC="../images/arrwrite.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/arrwrite.gif" WIDTH="18" HEIGHT="15"></font></td>
    <td width="90%"><font face="Courier New" size="2">twenty | thirty | forty | fifty | sixty
    | seventy | eighty | ninety</font></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">The final step is to add semantic actions to actually
convert the strings matched by this grammar to integer values. The basic idea is to
initialize an accumulator value to zero. Whenever you encounter one of the strings that
ones, teens, or tens matches, you add the corresponding value to the accumulator. If you
encounter the hundred or thousand strings, you multiply the accumulator by the appropriate
factor. The complete program to do the conversion follows:</font></p>

<pre><font face="Courier New" size="2">; Numbers.asm
;
; This program converts written English numbers in the range &quot;zero&quot;
; to &quot;sixty five thousand five hundred thirty five&quot; to the corresponding
; integer value.

                .xlist
                include         stdlib.a
                includelib      stdlib.lib
                matchfuncs
                .list


dseg            segment para public 'data'

Value           word    0                       ;Store results here.
HundredsVal     word    0
ThousandsVal    word    0


Str0            byte    &quot;twenty one&quot;,0
Str1            byte    &quot;nineteen hundred thirty-five&quot;,0
Str2            byte    &quot;thirty three thousand two hundred nineteen&quot;,0
Str3            byte    &quot;three&quot;,0
Str4            byte    &quot;fourteen&quot;,0
Str5            byte    &quot;fifty two&quot;,0
Str6            byte    &quot;seven hundred&quot;,0
Str7            byte    &quot;two thousand seven&quot;,0
Str8            byte    &quot;four thousand ninety six&quot;,0
Str9            byte    &quot;five hundred twelve&quot;,0
Str10           byte    &quot;twenty three thousand two hundred ninety-five&quot;,0
Str11           byte    &quot;seventy-five hundred&quot;,0
Str12           byte    &quot;sixty-five thousand&quot;,0
Str13           byte    &quot;one thousand&quot;,0


; The following grammar is what we use to process the numbers.
; Semantic actions appear in the braces.
;
; Note: begin by initializing Value, HundredsVal, and ThousandsVal to zero.
;
; N             -&gt; separators zero
;               | N4
;
; N4            -&gt; do1000s maybe100s
;               | do100s
;
; Maybe100s     -&gt; do100s
;               | &lt;empty string&gt;
;
; do1000s       -&gt; Under100 &quot;THOUSAND&quot; separators
;                               {ThousandsVal := Value*1000}
;
; do100s        -&gt; Under100 &quot;HUNDRED&quot;
;                       {HundredsVal := Value*100} After100
;               | Under100
;
; After100      -&gt; {Value := 0} Under100
;               | {Value := 0} &lt;empty string&gt;
;
; Under100              -&gt; {Value := 0} try20 try1s
;               | {Value := 0} doTeens
;               | {Value := 0} do1s
;
; try1s         -&gt; do1s | &lt;empty string&gt;
;
; try20         -&gt; &quot;TWENTY&quot; {Value := Value + 20}
;               | &quot;THIRTY&quot; {Value := Value + 30}
;               | ...
;               | &quot;NINETY&quot; {Value := Value + 90}
;
; doTeens               -&gt; &quot;TEN&quot;        {Value := Value + 10}
;               | &quot;ELEVEN&quot;      {Value := Value + 11}
;               | ...
;               | &quot;NINETEEN&quot;    {Value := Value + 19}
;
; do1s          -&gt; &quot;ONE&quot;        {Value := Value + 1}
;               | &quot;TWO&quot; {Value := Value + 2}
;               | ...
;               | &quot;NINE&quot;        {Value := Value + 9}


separators      pattern {anycset, delimiters, 0, delim2}
delim2          pattern {spancset, delimiters}
doSuccess       pattern {succeed}
AtLast          pattern {sl_match2, separators, AtEOS, AtEOS}
AtEOS           pattern {EOS}


N               pattern {sl_match2, separators, N2, N2}
N2              pattern {matchistr, zero, N3, AtLast}
zero            byte    &quot;ZERO&quot;,0

N3              pattern {sl_match2, N4, 0, AtLast}
N4              pattern {sl_match2, do1000s, do100s, Maybe100s}
Maybe100s       pattern {sl_match2, do100s, AtLast, AtLast}

do1000s         pattern {sl_match2, Under100, 0, do1000s2}
do1000s2        pattern {matchistr, str1000, 0, do1000s3}
do1000s3        pattern {sl_match2, separators, do1000s4, do1000s5}
do1000s4        pattern {EOS, 0, 0, do1000s5}
do1000s5        pattern {Get1000s}
str1000         byte    &quot;THOUSAND&quot;,0

do100s          pattern {sl_match2, do100s1, Under100, After100}
do100s1         pattern {sl_match2, Under100, 0, do100s2}
do100s2         pattern {matchistr, str100, 0, do100s3}
do100s3         pattern {sl_match2, separators, do100s4, do100s5}
do100s4         pattern {EOS, 0, 0, do100s5}
do100s5         pattern {Get100s}
str100          byte    &quot;HUNDRED&quot;,0

After100        pattern {SetVal, 0, 0, After100a}
After100a       pattern {sl_match2, Under100, doSuccess}

Under100        pattern {SetVal, 0, 0, Under100a}
Under100a       pattern {sl_match2, try20, Under100b, Do1orE}
Under100b       pattern {sl_match2, doTeens, do1s}

Do1orE          pattern {sl_match2, do1s, doSuccess, 0}



NumPat          macro   lbl, next, Constant, string
                local   try, SkipSpcs, val, str, tryEOS
lbl             pattern {sl_match2, try, next}
try             pattern {matchistr, str, 0, SkipSpcs}
SkipSpcs                pattern {sl_match2, separators, tryEOS, val}
tryEOS          pattern {EOS, 0, 0, val}
val             pattern {AddVal, Constant}
str             byte    string
                byte    0
                endm

                NumPat  doTeens, try11, 10, &quot;TEN&quot;
                NumPat  try11, try12, 11, &quot;ELEVEN&quot;
                NumPat  try12, try13, 12, &quot;TWELVE&quot;
                NumPat  try13, try14, 13, &quot;THIRTEEN&quot;
                NumPat  try14, try15, 14, &quot;FOURTEEN&quot;
                NumPat  try15, try16, 15, &quot;FIFTEEN&quot;
                NumPat  try16, try17, 16, &quot;SIXTEEN&quot;
                NumPat  try17, try18, 17, &quot;SEVENTEEN&quot;
                NumPat  try18, try19, 18, &quot;EIGHTEEN&quot;
                NumPat  try19, 0, 19, &quot;NINETEEN&quot;

                NumPat  do1s, try2, 1, &quot;ONE&quot;
                NumPat  try2, try3, 2, &quot;TWO&quot;
                NumPat  try3, try4, 3, &quot;THREE&quot;
                NumPat  try4, try5, 4, &quot;FOUR&quot;
                NumPat  try5, try6, 5, &quot;FIVE&quot;
                NumPat  try6, try7, 6, &quot;SIX&quot;
                NumPat  try7, try8, 7, &quot;SEVEN&quot;
                NumPat  try8, try9, 8, &quot;EIGHT&quot;
                NumPat  try9, 0, 9, &quot;NINE&quot;

                NumPat  try20, try30, 20, &quot;TWENTY&quot;
                NumPat  try30, try40, 30, &quot;THIRTY&quot;
                NumPat  try40, try50, 40, &quot;FORTY&quot;
                NumPat  try50, try60, 50, &quot;FIFTY&quot;
                NumPat  try60, try70, 60, &quot;SIXTY&quot;
                NumPat  try70, try80, 70, &quot;SEVENTY&quot;
                NumPat  try80, try90, 80, &quot;EIGHTY&quot;
                NumPat  try90, 0, 90, &quot;NINETY&quot;

                include stdsets.a

dseg            ends



cseg            segment para public 'code'
                assume  cs:cseg, ds:dseg


; Semantic actions for our grammar:
;
;
;
; Get1000s-     We've just processed the value one..nine, grab it from
;               the value variable, multiply it by 1000, and store it
;               into thousandsval.

Get1000s        proc    far
                push    ds
                push    dx
                mov     ax, dseg
                mov     ds, ax

                mov     ax, 1000
                mul     Value
                mov     ThousandsVal, ax
                mov     Value, 0

                pop     dx
                mov     ax, di                  ;Required by sl_match.
                pop     ds
                stc                             ;Always return success.
                ret
Get1000s        endp


; Get100s-      We've just processed the value one..nine, grab it from
;               the value variable, multiply it by 100, and store it
;               into hundredsval.

Get100s         proc    far
                push    ds
                push    dx
                mov     ax, dseg
                mov     ds, ax

                mov     ax, 100
                mul     Value
                mov     HundredsVal, ax
                mov     Value, 0

                pop     dx
                mov     ax, di                  ;Required by sl_match.
                pop     ds
                stc                             ;Always return success.
                ret
Get100s         endp


; SetVal-       This routine sets Value to whatever is in si

SetVal          proc    far
                push    ds
                mov     ax, dseg
                mov     ds, ax
                mov     Value, si
                mov     ax, di
                pop     ds
                stc
                ret
SetVal          endp

; AddVal-       This routine sets adds whatever is in si to Value

AddVal          proc    far
                push    ds
                mov     ax, dseg
                mov     ds, ax
                add     Value, si
                mov     ax, di
                pop     ds
                stc
                ret
AddVal          endp


; Succeed matches the empty string. In other words, it matches anything
; and always returns success without eating any characters from the input
; string.

Succeed         proc    far
                mov     ax, di
                stc
                ret
Succeed         endp


; This subroutine expects a pointer to a string containing the English
; version of an integer number. It converts this to an integer and
; prints the result.

ConvertNumber   proc    near
                mov     value, 0
                mov     HundredsVal, 0
                mov     ThousandsVal, 0

                ldxi    N
                xor     cx, cx
                match
                jnc     NoMatch
                mov     al, &quot;'&quot;
                putc
                puts
                print
                byte    &quot;' = &quot;, 0
                mov     ax, ThousandsVal
                add     ax, HundredsVal
                add     ax, Value
                putu
                putcr
                jmp     Done

NoMatch:        print
                byte    &quot;Illegal number&quot;,cr,lf,0

Done:           ret
ConvertNumber   endp



Main            proc
                mov     ax, dseg
                mov     ds, ax
                mov     es, ax

                meminit                         ;Init memory manager.

; Union in a &quot;-&quot; to the delimiters set because numbers can have
; dashes in them.

                lesi    delimiters
                mov     al, '-'
                addchar

; Some calls to test the ConvertNumber routine and the conversion process.

                lesi    Str0
                call    ConvertNumber
                lesi    Str1
                call    ConvertNumber
                lesi    Str2
                call    ConvertNumber
                lesi    Str3
                call    ConvertNumber
                lesi    Str4
                call    ConvertNumber
                lesi    Str5
                call    ConvertNumber
                lesi    Str6
                call    ConvertNumber
                lesi    Str7
                call    ConvertNumber
                lesi    Str8
                call    ConvertNumber
                lesi    Str9
                call    ConvertNumber
                lesi    Str10
                call    ConvertNumber
                lesi    Str11
                call    ConvertNumber
                lesi    Str12
                call    ConvertNumber
                lesi    Str13
                call    ConvertNumber


Quit:           ExitPgm
Main            endp

cseg            ends

sseg            segment para stack 'stack'
stk             db      1024 dup (&quot;stack &quot;)
sseg            ends

zzzzzzseg       segment para public 'zzzzzz'
LastBytes       db      16 dup (?)
zzzzzzseg       ends
                end     Main</font></pre>

<p><font face="Arial" size="2">Sample output:</font></p>

<pre><font face="Courier New" size="2">'twenty one' = 21
'nineteen hundred thirty-five' = 1935
'thirty three thousand two hundred nineteen' = 33219
'three' = 3
'fourteen' = 14
'fifty two' = 52
'seven hundred' = 700
'two thousand seven' = 2007
'four thousand ninety six' = 4096
'five hundred twelve' = 512
'twenty three thousand two hundred ninety-five' = 23295
'seventy-five hundred' = 7500
'sixty-five thousand' = 65000
'one thousand' = 1000</font></pre>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="CH16-7.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="CH16-7.html">Chapter Sixteen</a> (Part 7)</strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH16-9.html">Chapter Sixteen</a> (Part 9)&nbsp; </strong></font><a href="CH16-9.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Sixteen: Pattern Matching
(Part 8)<br>
29 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_16/CH16-8.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:31 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
