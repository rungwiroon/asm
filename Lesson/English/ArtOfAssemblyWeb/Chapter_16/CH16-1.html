<html>
<!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->


<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_16/CH16-1.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:01 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="pragma" content="no-cache">
<title>CHAPTER SIXTEEN: PATTERN MATCHING (Part 1)</title>
</head>

<body stylesrc="../toc.html" topmargin="10" bgcolor="#FFFFFF" text="#000000" link="#008000" vlink="#000000">
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3"><p align="right"><a name="top"></a><font size="1" face="Arial">The Art of<br>
    </font><font face="Arial Black" size="1">ASSEMBLY LANGUAGE PROGRAMMING</font></td>
  </tr>
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"><a NAME="HEADING1"></a></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="../Chapter_15/CH15-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="../Chapter_15/CH15-1.html">Chapter
    Fifteen</a></strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH16-2.html">Chapter Sixteen</a> (Part 2)&nbsp; </strong></font><a href="CH16-2.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" colspan="3" bgcolor="#FFFFFF" nowrap height="10"><a NAME="HEADING1-0"></a></td>
  </tr>
  <tr>
    <td width="100%" colspan="3" bgcolor="#F0F0F0"><font face="Arial" size="4"><strong>CHAPTER
    SIXTEEN:<br>
    PATTERN MATCHING (Part 1)</strong></font></td>
  </tr>
  <tr>
    <td width="100%" colspan="3" nowrap height="10"></td>
  </tr>
  <tr>
    <td width="40%" valign="top"><font face="Arial" size="2"><a HREF="#HEADING1-2"><b>16.1 </b>-
    An Introduction to Formal Language (Automata) Theory</a> <br>
    <a HREF="#HEADING1-4"><b>16.1.1 </b>- Machines vs. Languages</a> <br>
    <a HREF="#HEADING1-27"><b>16.1.2 </b>- Regular Languages</a> <br>
    <a HREF="#HEADING1-29"><b>16.1.2.1 </b>- Regular Expressions</a> <br>
    <a HREF="CH16-2.html#HEADING2-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-2.html#HEADING2-1"><b>16.1.2.2
    </b>- Nondeterministic Finite State Automata (NFAs)</a> <br>
    <a HREF="CH16-2.html#HEADING2-12" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-2.html#HEADING2-12"><b>16.1.2.3
    </b>- Converting Regular Expressions to NFAs</a> <br>
    <a HREF="CH16-2.html#HEADING2-26" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-2.html#HEADING2-26"><b>16.1.2.4
    </b>- Converting an NFA to Assembly Language</a> <br>
    <a HREF="CH16-3.html#HEADING3-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-3.html#HEADING3-1"><b>16.1.2.5
    </b>- Deterministic Finite State Automata (DFAs)</a> <br>
    <a HREF="CH16-3.html#HEADING3-48" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-3.html#HEADING3-48"><b>16.1.2.6
    </b>- Converting a DFA to Assembly Language</a> <br>
    <a HREF="CH16-4.html#HEADING4-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-4.html#HEADING4-1"><b>16.1.3
    </b>- Context Free Languages</a> <br>
    <a HREF="CH16-4.html#HEADING4-78" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-4.html#HEADING4-78"><b>16.1.4
    </b>- Eliminating Left Recursion and Left Factoring CFGs</a> <br>
    <a HREF="CH16-4.html#HEADING4-137" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-4.html#HEADING4-137"><b>16.1.5
    </b>- Converting REs to CFGs</a> <br>
    <a HREF="CH16-4.html#HEADING4-152" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-4.html#HEADING4-152"><b>16.1.6
    </b>- Converting CFGs to Assembly Language</a> <br>
    <a HREF="CH16-4.html#HEADING4-548" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-4.html#HEADING4-548"><b>16.1.7
    </b>- Some Final Comments on CFGs</a> <br>
    <a HREF="CH16-4.html#HEADING4-552" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-4.html#HEADING4-552"><b>16.1.8
    </b>- Beyond Context Free Languages</a> <br>
    <a HREF="CH16-5.html#HEADING5-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-5.html#HEADING5-1"><b>16.2 </b>-
    The UCR Standard Library Pattern Matching Routines</a> <br>
    <a HREF="CH16-5.html#HEADING5-29" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-5.html#HEADING5-29"><b>16.3 </b>-
    The Standard Library Pattern Matching Functions</a> <br>
    <a HREF="CH16-5.html#HEADING5-32" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-5.html#HEADING5-32"><b>16.3.1
    </b>- Spancset</a> <br>
    <a HREF="CH16-5.html#HEADING5-44" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-5.html#HEADING5-44"><b>16.3.2
    </b>- Brkcset</a> <br>
    <a HREF="CH16-5.html#HEADING5-59" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-5.html#HEADING5-59"><b>16.3.3
    </b>- Anycset</a> <br>
    <a HREF="CH16-5.html#HEADING5-75" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-5.html#HEADING5-75"><b>16.3.4
    </b>- Notanycset</a> <br>
    <a HREF="CH16-5.html#HEADING5-90" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-5.html#HEADING5-90"><b>16.3.5
    </b>- MatchStr</a> <br>
    <a HREF="CH16-5.html#HEADING5-105" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-5.html#HEADING5-105"><b>16.3.6
    </b>- MatchiStr</a> <br>
    <a HREF="CH16-5.html#HEADING5-120" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-5.html#HEADING5-120"><b>16.3.7
    </b>- MatchToStr</a> <br>
    <a HREF="CH16-5.html#HEADING5-135" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-5.html#HEADING5-135"><b>16.3.8
    </b>- MatchChar</a> <br>
    <a HREF="CH16-5.html#HEADING5-150" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-5.html#HEADING5-150"><b>16.3.9
    </b>- MatchToChar</a> <br>
    <a HREF="CH16-5.html#HEADING5-164" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-5.html#HEADING5-164"><b>16.3.10
    </b>- MatchChars</a> <br>
    <a HREF="CH16-5.html#HEADING5-179" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-5.html#HEADING5-179"><b>16.3.11
    </b>- MatchToPat</a> <br>
    <a HREF="CH16-5.html#HEADING5-197" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-5.html#HEADING5-197"><b>16.3.12
    </b>- EOS</a> <br>
    <a HREF="CH16-5.html#HEADING5-213" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-5.html#HEADING5-213"><b>16.3.13
    </b>- ARB</a> <br>
    <a HREF="CH16-5.html#HEADING5-230" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-5.html#HEADING5-230"><b>16.3.14
    </b>- ARBNUM</a> <br>
    <a HREF="CH16-5.html#HEADING5-249" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-5.html#HEADING5-249"><b>16.3.15
    </b>- Skip</a> <br>
    <a HREF="CH16-5.html#HEADING5-267" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-5.html#HEADING5-267"><b>16.3.16
    </b>- Pos</a> <br>
    <a HREF="CH16-5.html#HEADING5-283" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-5.html#HEADING5-283"><b>16.3.17
    </b>- RPos</a> <br>
    <a HREF="CH16-5.html#HEADING5-299" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-5.html#HEADING5-299"><b>16.3.18
    </b>- GotoPos</a> <br>
    <a HREF="CH16-5.html#HEADING5-316" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-5.html#HEADING5-316"><b>16.3.19
    </b>- RGotoPos</a> <br>
    <a HREF="CH16-5.html#HEADING5-332" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-5.html#HEADING5-332"><b>16.3.20
    </b>- SL_Match2</a> <br>
    <a HREF="CH16-6.html#HEADING6-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-6.html#HEADING6-1"><b>16.4 </b>-
    Designing Your Own Pattern Matching Routines</a> <br>
    <a HREF="CH16-6.html#HEADING6-160" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-6.html#HEADING6-160"><b>16.5
    </b>- Extracting Substrings from Matched Patterns</a> <br>
    <a HREF="CH16-7.html#HEADING7-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-7.html#HEADING7-1"><b>16.6 </b>-
    Semantic Rules and Actions</a> <br>
    <a HREF="CH16-7.html#HEADING7-239" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-7.html#HEADING7-239"><b>16.7
    </b>- Constructing Patterns for the MATCH Routine</a> <br>
    <a HREF="CH16-8.html#HEADING8-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-8.html#HEADING8-1"><b>16.8 </b>-
    Some Sample Pattern Matching Applications</a> <br>
    <a HREF="CH16-8.html#HEADING8-3" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-8.html#HEADING8-3"><b>16.8.1
    </b>- Converting Written Numbers to Integers</a> <br>
    <a HREF="CH16-9.html#HEADING9-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-9.html#HEADING9-1"><b>16.8.2
    </b>- Processing Dates</a> <br>
    <a HREF="CH16-10.html#HEADING10-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-10.html#HEADING10-1"><b>16.8.3
    </b>- Evaluating Arithmetic Expressions</a> <br>
    <a HREF="CH16-11.html#HEADING11-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-11.html#HEADING11-1"><b>16.8.4
    </b>- A Tiny Assembler </a><br>
    <a HREF="CH16-12.html#HEADING12-1" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/CH16-12.html#HEADING12-1"><b>16.8.5
    </b>- The &quot;MADVENTURE&quot; Game</a> <br>
    <b>16.9 </b>- Laboratory Exercises <br>
    <b>16.9.1 </b>- Checking for Stack Overflow (Infinite Loops) <br>
    <b>16.9.2 </b>- Printing Diagnostic Messages from a Pattern </font></td>
    <td width="20" nowrap valign="top"></td>
    <td width="60%" valign="top"><font size="1" face="Arial">Copyright 1996 by Randall Hyde
    All rights reserved. <br>
    <br>
    Duplication other than for immediate display through a browser is prohibited by U.S.
    Copyright Law. <br>
    This material is provided on-line as a beta-test of this text. It is for the personal use
    of the reader only. If you are interested in using this material as part of a course,
    please contact rhyde@cs.ucr.edu <br>
    <br>
    Supporting software and other materials are available via anonymous ftp from
    ftp.cs.ucr.edu. See the &quot;/pub/pc/ibmpcdir&quot; directory for details. You may also
    download the material from &quot;Randall Hyde's Assembly Language Page&quot; at URL:
    http://webster.ucr.edu<br>
    <br>
    Notes: <br>
    This document does not contain the laboratory exercises, programming assignments,
    exercises, or chapter summary. These portions were omitted for several reasons: either
    they wouldn't format properly, they contained hyperlinks that were too much work to
    resolve, they were under constant revision, or they were not included for security
    reasons. Such omission should have very little impact on the reader interested in learning
    this material or evaluating this document. <br>
    <br>
    This document was prepared using Harlequin's Web Maker 2.2 and Quadralay's Webworks
    Publisher. Since HTML does not support the rich formatting options available in
    Framemaker, this document is only an approximation of the actual chapter from the
    textbook. <br>
    <br>
    If you are absolutely dying to get your hands on a version other than HTML, you might
    consider having the UCR Printing a Reprographics Department run you off a copy on their
    Xerox machines. For details, please read the following EMAIL message I received from the
    Printing and Reprographics Department: </font><blockquote>
      <p><font size="1" face="Arial">Hello Again Professor Hyde,<br>
      <br>
      Dallas gave me permission to take orders for the Computer Science 13 Manuals. We would
      need to take charge card orders. The only cards we take are: Master Card, Visa, and
      Discover. They would need to send the name, numbers, expiration date, type of card, and
      authorization to charge $95.00 for the manual and shipping, also we should have their
      phone number in case the company has any trouble delivery. They can use my e-mail address
      for the orders and I will process them as soon as possible. I would assume that two weeks
      would be sufficient for printing, packages and delivery time.<br>
      <br>
      I am open to suggestions if you can think of any to make this as easy as possible.<br>
      <br>
      Thank You for your business,<br>
      Kathy Chapman, Assistant<br>
      Printing and Reprographics University of California Riverside (909) 787-4443/4444 </font></p>
    </blockquote>
    <p><font size="1" face="Arial">We are currently working on ways to publish this text in a
    form other than HTML (e.g., Postscript, PDF, Frameviewer, hard copy, etc.). This, however,
    is a low-priority project. Please do not contact Randall Hyde concerning this effort. When
    something happens, an announcement will appear on &quot;Randall Hyde's Assembly Language
    Page.&quot; Please visit this WEB site at http://webster.ucr.edu for the latest scoop.</font></p>
    <p><font size="1" face="Arial">Redesigned 10/2000 with &quot;MS FrontPage 98&quot; using
    17&quot; monitor 1024x768<br>
    (c) 2000 <a href="mail%20to_%20bircom_yanoo.html">BIRCOM Entertainment'95</a></font></td>
  </tr>
</table>
</center></div>

<hr noshade size="1" color="#000000">

<p><font face="Arial" size="2">The last chapter covered character strings and various
operations on those strings. A very typical program reads a sequence of strings from the
user and compares the strings to see if they match. For example, DOS' COMMAND.COM program
reads command lines from the user and compares the strings the user types to fixed strings
like &quot;COPY&quot;, &quot;DEL&quot;, &quot;RENAME&quot;, and so on. Such commands are
easy to parse because the set of allowable commands is finite and fixed. Sometimes,
however, the strings you want to test for are not fixed; instead, they belong to a
(possibly infinite) set of different strings. For example, if you execute the DOS command
&quot;DEL *.BAK&quot;, MS-DOS does not attempt to delete a file named &quot;*.BAK&quot;.
Instead, it deletes all files which match the generic pattern &quot;*.BAK&quot;. This, of
course, is any file which contains four or more characters and ends with &quot;.BAK&quot;.
In the MS-DOS world, a string containing characters like &quot;*&quot; and &quot;?&quot;
are called wildcards; wildcard characters simply provide a way to specify different names
via patterns. DOS' wildcard characters are very limited forms of what are known as regular
expressions; regular expressions are very limited forms of patterns in general. This
chapter describes how to create patterns that match a variety of character strings and
write pattern matching routines to see if a particular string matches a given pattern.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%"><strong><font face="Arial" size="3"><a NAME="HEADING1-2"></a>16.1 An
    Introduction to Formal Language (Automata) Theory</font></strong></td>
  </tr>
  <tr>
    <td width="100%" nowrap bgcolor="#000000" height="1"></td>
  </tr>
</table>
</center></div>

<p><font face="Arial" size="2">Pattern matching, despite its low-key coverage, is a very
important topic in computer science. Indeed, pattern matching is the main programming
paradigm in several programming languages like Prolog, SNOBOL4, and Icon. Several programs
you use all the time employ pattern matching as a major part of their work. MASM, for
example, uses pattern matching to determine if symbols are correctly formed, expressions
are proper, and so on. Compilers for high level languages like Pascal and C also make
heavy use of pattern matching to parse source files to determine if they are syntactically
correct. Surprisingly enough, an important statement known as Church's Hypothesis suggests
that any computable function can be programmed as a pattern matching problem. Of course,
there is no guarantee that the solution would be efficient (they usually are not), but you
could arrive at a correct solution. You probably wouldn't need to know about Turing
machines (the subject of Church's hypothesis) if you're interested in writing, say, an
accounts receivable package. However, there many situations where you may want to
introduce the ability to match some generic patterns; so understanding some of the theory
of pattern matching is important. This area of computer science goes by the stuffy names
of formal language theory and automata theory. Courses in these subjects are often less
than popular because they involve a lot of proofs, mathematics, and, well, theory.
However, the concepts behind the proofs are quite simple and very useful. In this chapter
we will not bother trying to prove everything about pattern matching. Instead, we will
accept the fact that this stuff really works and just apply it. Nonetheless, we do have to
discuss some of the results from automata theory, so without further ado...</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING1-4"></a>16.1.1 Machines vs.
Languages</font></strong></p>

<p><font face="Arial" size="2">You will find references to the term &quot;machine&quot;
throughout automata theory literature. This term does not refer to some particular
computer on which a program executes. Instead, this is usually some function that reads a
string of symbols as input and produces one of two outputs: match or failure. A typical
machine (or automaton ) divides all possible strings into two sets - those strings that it
accepts (or matches) and those string that it rejects. The language accepted by this
machine is the set of all strings that the machine accepts. Note that this language could
be infinite, finite, or the empty set (i.e., the machine rejects all input strings). Note
that an infinite language does not suggest that the machine accepts all strings. It is
quite possible for the machine to accept an infinite number of strings and reject an even
greater number of strings. For example, it would be very easy to design a function which
accepts all strings whose length is an even multiple of three. This function accepts an
infinite number of strings (since there are an infinite number of strings whose length is
a multiple of three) yet it rejects twice as many strings as it accepts. This is a very
easy function to write. Consider the following 80x86 program that accepts all strings of
length three (we'll assume that the carriage return character terminates a string):</font></p>

<pre><font face="Courier New" size="2">MatchLen3       proc    near
                getc                    ;Get character #1.
                cmp     al, cr          ;Zero chars if EOLN.
                je      Accept
                getc                    ;Get character #2.
                cmp     al, cr
                je      Failure
                getc                    ;Get character #3.
                cmp     al, cr
                jne     MatchLen3
Failure:        mov     ax, 0           ;Return zero to denote failure.
                ret

Accept:         mov     ax, 1           ;Return one to denote success.
                ret
MatchLen3       endp</font></pre>

<p><font face="Arial" size="2">By tracing through this code, you should be able to easily
convince yourself that it returns one in <code>ax</code> if it succeeds (reads a string
whose length is a multiple of three) and zero otherwise.</font></p>

<p><font face="Arial" size="2">Machines are inherently recognizers. The machine itself is
the embodiment of a pattern. It recognizes any input string which matches the built-in
pattern. Therefore, a codification of these automatons is the basic job of the programmer
who wants tomatch some patterns.</font></p>

<p><font face="Arial" size="2">There are many different classes of machines and the
languages they recognize. From simple to complex, the major classifications are
deterministic finite state automata (which are equivalent to nondeterministic finite state
automata ), deterministic push down automata, nondeterministic push down automata, and
Turing machines. Each successive machine in this list provides a superset of the
capabilities of the machines appearing before it. The only reason we don't use Turing
machines for everything is because they are more complex to program than, say, a
deterministic finite state automaton. If you can match the pattern you want using a
deterministic finite state automaton, you'll probably want to code it that way rather than
as a Turing machine.</font></p>

<p><font face="Arial" size="2">Each class of machine has a class of languages associated
with it. Deterministic and nondeterministic finite state automata recognize the regular
languages. Nondeterministic push down automata recognize the context free languages.
Turing machines can recognize all recognizable languages. We will discuss each of these
sets of languages, and their properties, in turn.</font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING1-27"></a>16.1.2 Regular Languages</font></strong></p>

<p><font face="Arial" size="2">The regular languages are the least complex of the
languages described in the previous section. That does not mean they are less useful; in
fact, patterns based on regular expression are probably more common than any other. </font></p>

<p><strong><font face="Arial" size="3"><a NAME="HEADING1-29"></a>16.1.2.1 Regular
Expressions</font></strong></p>

<p><font face="Arial" size="2">The most compact way to specify the strings that belong to
a regular language is with a regular expression. We shall define, recursively, a regular
expression with the following rules:</font> 

<ul>
  <li><font face="Arial" size="2">&lt;empty set&gt; (the empty set) is a regular language and
    denotes the empty set. </font></li>
  <li><font face="Arial" size="2"><img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11">is a regular
    expression. It denotes the set of languages containing only the empty string: {<img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" ALIGN="bottom" border="0" WIDTH="11" HEIGHT="11">}. </font></li>
  <li><font face="Arial" size="2">Any single symbol, <em>a</em>, is a regular expression (we
    will use lower case characters to denote arbitrary symbols). This single symbol matches
    exactly one character in the input string, that character must be equal to the single
    symbol in the regular expression. For example, the pattern &quot;m&quot; matches a single
    &quot;m&quot; character in the input string. </font></li>
</ul>

<p><font face="Arial" size="2">Note that &lt;empty set&gt; and <img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" ALIGN="bottom" WIDTH="11" HEIGHT="11">are
not the same. The empty set is a regular language that does not accept <em>any</em>
strings, including strings of length zero. If a regular language is denoted by {<img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" ALIGN="bottom" WIDTH="11" HEIGHT="11">},
then it accepts exactly one string, the string of length zero. This latter regular
language accepts something, the former does not. </font></p>

<p><font face="Arial" size="2">The three rules above provide our <em>basis</em> for a
recursive definition. Now we will define regular expressions recursively. In the following
definitions, assume that <em>r</em>, <em>s</em>, and <em>t</em> are any valid regular
expressions. </font>

<ul>
  <li><font face="Arial" size="2">Concatenation. If <em>r</em> and <em>s</em> are regular
    expressions, so is <em>rs</em>. The regular expression <em>rs</em> matches any string that
    begins with a string matched by <em>r</em> and ends with a string matched by <em>s</em>. </font></li>
  <li><font face="Arial" size="2">Alternation/Union. If <em>r</em> and <em>s</em> are regular
    expressions, so is <em>r</em> | <em>s</em> (read this as <em>r</em> <strong>or</strong> <em>s</em>
    ) This is equivalent to <em>r</em> <img SRC="../images/union.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/union.gif" ALIGN="bottom" WIDTH="14" HEIGHT="13"><em>s,
    </em>(read as <em>r</em> union <em>s </em>). This regular expression matches any string
    that <em>r</em> or <em>s</em> matches. </font></li>
  <li><font face="Arial" size="2">Intersection. If <em>r</em> and <em>s</em> are regular
    expressions, so is <em>r </em><img SRC="../images/intrsect.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/intrsect.gif" WIDTH="14" HEIGHT="11"><em>s</em>.
    This is the set of all strings that both <em>r</em> <strong>and </strong><em>s</em> match.
    </font></li>
  <li><font face="Arial" size="2">Kleene Star. If <em>r</em> is a regular expression, so is <em>r</em>*.
    This regular expression matches zero or more occurrences of <em>r</em>. That is, it
    matches <img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" ALIGN="bottom" WIDTH="11" HEIGHT="11">,
    <em>r</em>, <em>rr</em>, <em>rrr</em>, <em>rrrr</em>, ... </font></li>
  <li><font face="Arial" size="2">Difference. If <em>r </em>and <em>s</em> are regular
    expressions, so is <em>r-s</em>. This denotes the set of strings matched by <em>r</em>
    that are not also matched by <em>s.</em> </font></li>
  <li><font face="Arial" size="2">Precedence. If <em>r</em> is a regular expression, so is (<em>r</em>
    ). This matches any string matched by <em>r</em> alone. The normal algebraic associative
    and distributive laws apply here, so (<em>r</em> | <em>s</em> )<em> t</em> is equivalent
    to <em>rt</em> | <em>st</em>. </font></li>
</ul>

<p><font face="Arial" size="2">These operators following the normal associative and
distributive laws and exhibit the following precedences:</font></p>

<pre><font face="Courier New" size="2">Highest:		(r)
		Kleene Star
		Concatentation
		Intersection
		Difference
Lowest:		Alternation/Union</font></pre>

<p><font face="Arial" size="2">Examples:</font></p>

<pre><font face="Courier New" size="2">	(r | s) t = rt | st

	rs* = r(s*)

	r <img SRC="../images/union.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/union.gif" ALIGN="bottom" WIDTH="14" HEIGHT="13"> t - s = r <img SRC="../images/union.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/union.gif" ALIGN="bottom" WIDTH="14" HEIGHT="13"> (t - s)

	r <img SRC="../images/intrsect.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/intrsect.gif" WIDTH="14" HEIGHT="11"> t - s = (r <img SRC="../images/intrsect.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/intrsect.gif" WIDTH="14" HEIGHT="11"> t) - s</font></pre>

<p><font face="Arial" size="2">Generally, we'll use parenthesis to avoid any ambiguity</font></p>

<p><font face="Arial" size="2">Although this definition is sufficient for an automata
theory class, there are some practical aspects to this definition that leave a little to
be desired. For example, to define a regular expression that matches a single alphabetic
character, you would need to create something like (a | b | c | ... | y | z ). Quite a lot
of typing for such a trivial character set. Therefore, we shall add some notation to make
it easier to specify regular expressions.</font> 

<ul>
  <li><font face="Arial" size="2">Character Sets. Any set of characters surrounded by
    brackets, e.g., [abcdefg] is a regular expression and matches a single character from that
    set. You can specify ranges of characters using a dash, i.e., &quot;[a-z]&quot; denotes
    the set of lower case characters and this regular expression matches a single lower case
    character. </font></li>
</ul>

<ul>
  <li><font face="Arial" size="2">Kleene Plus. If r is a regular expression, so is r+. This
    regular expression matches one or more occurrences of r. That is, it matches r, rr, rrr,
    rrrr, ... The precedence of the Kleene Plus is the same as for the Kleene Star. Note that
    r+ = rr*. </font></li>
</ul>

<ul>
  <li><font face="Arial" size="2"><img SRC="../images/capsigma.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/capsigma.gif" WIDTH="13" HEIGHT="13"> represents
    any single character from the allowable character set. <img SRC="../images/capsigma.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/capsigma.gif" WIDTH="13" HEIGHT="13">* represents
    the set of all possible strings. The regular expression <img SRC="../images/capsigma.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/capsigma.gif" WIDTH="13" HEIGHT="13">*-<em>r</em>
    is the <em>complement</em> of <em>r</em> - that is, the set of all strings that <em>r</em>
    does not match. </font></li>
</ul>

<p><font face="Arial" size="2">With the notational baggage out of the way, it's time to
discuss how to actually use regular expressions as pattern matching specifications. The
following examples should give a suitable introduction.</font></p>

<p><font face="Arial" size="2">Identifiers: Most programming languages like Pascal or
C/C++ specify legal forms for identifiers using a regular expression. Expressed in English
terms, the specification is something like &quot;An identifier must begin with an
alphabetic character and is followed by zero or more alphanumeric or underscore
characters.&quot; Using the regular expression (RE) syntax described in this section, an
identifier is</font></p>

<p><font face="Arial" size="2">[a-zA-Z][a-zA-Z0-9_]*</font></p>

<p><font face="Arial" size="2">Integer Consts: A regular expression for integer constants
is relatively easy to design. An integer constant consists of an optional plus or minus
followed by one or more digits. The RE is </font></p>

<p><font face="Arial" size="2">(+ | - | <img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11">) [0-9]+ </font></p>

<p><font face="Arial" size="2">Note the use of the empty string (<img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" ALIGN="bottom" WIDTH="11" HEIGHT="11">)
to make the plus or minus optional. </font></p>

<p><font face="Arial" size="2">Real Consts: Real constants are a bit more complex, but
still easy to specify using REs. Our definition matches that for a real constant appearing
in a Pascal program - an optional plus or minus, following by one or more digits;
optionally followed by a decimal point and zero or more digits; optionally followed by an
&quot;e&quot; or an &quot;E&quot; with an optional sign and one or more digits: </font></p>

<p><font face="Arial" size="2">(+ | - | <img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11">) [0-9]+ (
&quot;.&quot; [0-9]* | <img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" ALIGN="bottom" WIDTH="11" HEIGHT="11">)
(((e | E) (+ | - | <img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11">) [0-9]+) | <img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" WIDTH="11" HEIGHT="11">) </font></p>

<p><font face="Arial" size="2">Since this RE is relatively complex, we should dissect it
piece by piece. The first parenthetical term gives us the optional sign. One or more
digits are mandatory before the decimal point, the second term provides this. The third
term allows an optional decimal point followed by zero or more digits. The last term
provides for an optional exponent consisting of &quot;e&quot; or &quot;E&quot; followed by
an optional sign and one or more digits. </font></p>

<p><font face="Arial" size="2">Reserved Words: It is very easy to provide a regular
expression that matches a set of reserved words. For example, if you want to create a
regular expression that matches MASM's reserved words, you could use an RE similar to the
following: </font></p>

<p><font face="Arial" size="2">( mov | add | and | | mul ) </font></p>

<p><font face="Arial" size="2">Even: The regular expression ( <img SRC="../images/capsigma.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/capsigma.gif" ALIGN="bottom" WIDTH="13" HEIGHT="13"><img SRC="../images/capsigma.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/capsigma.gif" ALIGN="bottom" WIDTH="13" HEIGHT="13">)* matches all strings whose length is a multiple of two. </font></p>

<p><font face="Arial" size="2">Sentences: The regular expression: </font></p>

<p><font face="Arial" size="2">(<img SRC="../images/capsigma.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/capsigma.gif" ALIGN="bottom" WIDTH="13" HEIGHT="13">* &quot; &quot;* )* run ( &quot; &quot;+ ( <img SRC="../images/capsigma.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/capsigma.gif" ALIGN="bottom" WIDTH="13" HEIGHT="13">* &quot; &quot;+ | <img SRC="../images/epsilon.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/epsilon.gif" ALIGN="bottom" WIDTH="11" HEIGHT="11">))
fast (&quot; &quot; <img SRC="../images/capsigma.gif" tppabs="http://webster.cs.ucr.edu/asm/ArtofAssembly/CH16/chars/capsigma.gif" WIDTH="13" HEIGHT="13">* )* </font></p>

<p><font face="Arial" size="2">matches all strings that contain the separate words
&quot;run&quot; followed by &quot;fast&quot; somewhere on the line. This matches strings
like &quot;I want to run very fast&quot; and &quot;run as fast as you can&quot; as well as
&quot;run fast.&quot; </font></p>

<p><font face="Arial" size="2">While REs are convenient for specifying the pattern you
want to recognize, they are not particularly useful for creating programs (i.e.,
&quot;machines&quot;) that actually recognize such patterns. Instead, you should first
convert an RE to a <em>nondeterministic finite state automaton</em>, or NFA. It is very
easy to convert an NFA into an 80x86 assembly language program; however, such programs are
rarely efficient as they might be. If efficiency is a big concern, you can convert the NFA
into a <em>deterministic finite state automaton </em>(DFA) that is also easy to convert to
80x86 assembly code, but the conversion is usually far more efficient.</font></p>
<div align="center"><center>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" valign="middle" align="center" nowrap bgcolor="#000000" height="1" colspan="3"></td>
  </tr>
  <tr>
    <td width="34%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="left"><a href="../Chapter_15/CH15-1.html"><img src="../images/WB00823_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a><font face="Arial" size="2"><strong> <a href="../Chapter_15/CH15-1.html">Chapter
    Fifteen</a></strong></font></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><a href="../toc.html"><font face="Arial" size="2"><strong>Table of Content</strong></font></a></td>
    <td width="33%" valign="middle" align="center" bgcolor="#FFFFFF" nowrap><p align="right"><font face="Arial" size="2"><strong><a href="CH16-2.html">Chapter Sixteen</a> (Part 2)&nbsp; </strong></font><a href="CH16-2.html"><img src="../images/WB00827_.GIF" align="absmiddle" border="0" WIDTH="12" HEIGHT="24"></a></td>
  </tr>
</table>
</center></div>

<p align="right"><font face="Arial" size="2"><strong>Chapter Sixteen: Pattern Matching
(Part 1)<br>
29 SEP 1996</strong></font></p>
</body>

<!-- Mirrored from www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_16/CH16-1.html by HTTrack Website Copier/3.x [XR&CO'2008], Fri, 05 Dec 2008 15:28:07 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
